

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="概述Hello, React :-)React 是用于构建用户界面的 JavaScript 库，React 核心只关注视图，不断优化算法，改进性能，提高开发和交互体验。 React 迭代稳定，重视兼容和过渡，在国内外，尤其是南方，都有相当多的公司在使用 React。 渐进式的思想同样表现在 React 的学习曲线上，能够与传统的 Web 技术共存，灵活的 JSX 语法等都会让 React 上手很快">
<meta property="og:type" content="article">
<meta property="og:title" content="前端通关手册-React">
<meta property="og:url" content="http://example.com/2023/01/28/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="概述Hello, React :-)React 是用于构建用户界面的 JavaScript 库，React 核心只关注视图，不断优化算法，改进性能，提高开发和交互体验。 React 迭代稳定，重视兼容和过渡，在国内外，尤其是南方，都有相当多的公司在使用 React。 渐进式的思想同样表现在 React 的学习曲线上，能够与传统的 Web 技术共存，灵活的 JSX 语法等都会让 React 上手很快">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/12/31/PA1GoNTluzsaipH.jpg">
<meta property="article:published_time" content="2023-01-28T07:30:59.000Z">
<meta property="article:modified_time" content="2023-01-29T02:48:52.562Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="React">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2022/12/31/PA1GoNTluzsaipH.jpg">
  
  
  
  <title>前端通关手册-React - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://s2.loli.net/2022/12/31/PA1GoNTluzsaipH.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="前端通关手册-React"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-28 15:30" pubdate>
          2023年1月28日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          43k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          359 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">前端通关手册-React</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h3 id="Hello-React"><a href="#Hello-React" class="headerlink" title="Hello, React :-)"></a>Hello, React :-)</h3><p>React 是用于构建用户界面的 JavaScript 库，React 核心只关注视图，不断优化算法，改进性能，提高开发和交互体验。</p>
<p>React 迭代稳定，重视兼容和过渡，在国内外，尤其是南方，都有相当多的公司在使用 React。</p>
<p>渐进式的思想同样表现在 React 的学习曲线上，能够与传统的 Web 技术共存，灵活的 JSX 语法等都会让 React 上手很快， 而庞大生态赋予了 React 更强能力的同时，也让开发者感叹花费了更多时间在社区里遨游。</p>
<h3 id="React-应用"><a href="#React-应用" class="headerlink" title="React 应用"></a>React 应用</h3><p>React 在前端开发领域应用广泛，使用 React 可以构建 Web，插件，单页应用，App，小程序，桌面端，服务端等，微服务，Serverless，低代码，虚拟现实等都有 React 的用武之地。</p>
<h3 id="React-面试注意事项"><a href="#React-面试注意事项" class="headerlink" title="React 面试注意事项"></a>React 面试注意事项</h3><p>React 面试题可以分为以下 4 个方面</p>
<ul>
<li>基础：ES5+ 作用域，class，箭头函数，this 指向，异步编程，高阶函数的循环等常问</li>
<li>会用：state，副作用，Hook，加载渲染过程，路由、测试、调试、TS、Redux 等常问</li>
<li>原理：Virtual DOM，Diff 算法，设计组件，优化性能，原理和实现等高级岗位、大厂常问</li>
<li>项目：项目结构，技术栈，工具链，解决问题，担任角色，亮点等常问，也是面试问题来源</li>
</ul>
<p>新手最好先熟练 ES5+ 的使用，再上手 React 时，可以边阅读边写代码，适当练习若干项目，再看原来生涩的表述，会有亲切的画面感。带着项目去看面试题，联想练习或工作中遇到的实际问题，加上自己的理解，你的回答一定可以比手册总结得更自然，更能得到面试官的肯定。</p>
<h3 id="对比-React-和-Vue-？"><a href="#对比-React-和-Vue-？" class="headerlink" title="对比 React 和 Vue ？"></a>对比 React 和 Vue ？</h3><p>相同点</p>
<ul>
<li>支持 Virtual DOM</li>
<li>支持响应式和组件化的视图组件</li>
<li>核心库、路由和状态管理分离</li>
<li>支持 JSX，移动端都支持原生渲染</li>
</ul>
<p>不同点</p>
<ul>
<li><p>预编译</p>
<ul>
<li>React 可以通过 Prepack 优化 JavaScript 源代码，在编译时执行原本在运行时的计算过程，通过简单的赋值序列提高 JavaScript 代码的执行效率，消除中间计算过程及分配对象操作。缓存 JavaScript 解析结果，优化效果最佳</li>
<li>Vue 可以静态分析 template，构造 AST 树，通过 PatchFlags 标记节点变化类型</li>
</ul>
</li>
<li><p>渲染</p>
<ul>
<li>React 通过 shouldComponentUpdate &#x2F; setState，使用 PureCompoent 等对比前后状态和属性，手动决定是否渲染来优化</li>
<li>Vue 推荐模板语法，自动追踪组件依赖，精确渲染状态改变的组件</li>
</ul>
</li>
<li><p>事件处理</p>
<ul>
<li><p>React</p>
<ul>
<li>React 17前，事件委托到 document，之后委托到 根节点</li>
<li>所有事件被合并为合成事件并兼容不同浏览器</li>
<li>事件处理函数中的 this 需要手动绑定或使用箭头函数声明</li>
</ul>
</li>
<li><p>Vue</p>
<ul>
<li><p>原生事件</p>
</li>
<li><p>this 自动绑定执行上下文</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="什么是-React"><a href="#什么是-React" class="headerlink" title="什么是 React ?"></a>什么是 React ?</h3><p>React 是用于构建用户界面的 JavaScript 库</p>
<ul>
<li>声明式编写 UI，代码可靠，便于调试</li>
<li>组件化开发，组件逻辑使用 JavaScript 编写而非模板，遵循单向数据流和数据绑定，状态与 DOM 分离</li>
<li>一次学习，随处编写，使用 Virtual DOM，支持 浏览器、Node 服务器等多种渲染方式 和 React Native 开发原生应用</li>
</ul>
<h3 id="对比-React-和-Angular"><a href="#对比-React-和-Angular" class="headerlink" title="对比 React 和 Angular ?"></a>对比 React 和 Angular ?</h3><ul>
<li>核心功能<ul>
<li>React 核心库只提供构建 UI 组件的方法，其他功能通过社区提供</li>
<li>Angular 集成了 路由、异步请求、表单、模块化 CSS 等功能</li>
</ul>
</li>
<li>组件<ul>
<li>React 组件推荐使用 JSX，可以一个文件包含 HTML、CSS 和 JS，也可以分开</li>
<li>Angular 组件 HTML、CSS 和 TS 分别是一个文件</li>
</ul>
</li>
<li>DOM<ul>
<li>React 基于 Virtual DOM，组件会被编译成 JS 对象，数据更改时通过 Diff 算法更新</li>
<li>Angular 基于 Incremental DOM，组件会被编译成指令，数据更改时就地更新。没有使用规定指令的组件可以被 Tree Shaking</li>
</ul>
</li>
<li>数据绑定<ul>
<li>React 单向数据绑定，声明状态，更新视图</li>
<li>Angular 双向数据绑定，数据改变，更新视图</li>
</ul>
</li>
<li>全局状态管理<ul>
<li>Angualr 可以用 Service 依赖注入实现</li>
<li>React 可以用全局对象或 Redux 实现</li>
</ul>
</li>
<li>上手成本<ul>
<li>React 推荐了解 JSX，是库，可以渐进式使用</li>
<li>Angluar 需要了解 TypeScript，Rxjs，OOP 和装饰器等，是框架，推荐独立使用</li>
</ul>
</li>
</ul>
<h3 id="你认为-React-的缺点是什么？"><a href="#你认为-React-的缺点是什么？" class="headerlink" title="你认为 React 的缺点是什么？"></a>你认为 React 的缺点是什么？</h3><ul>
<li>React 核心是 UI 库，路由，状态管理等由社区维护。细粒度需求和问题依赖社区解决</li>
<li>React 概念和约束较少，容易上手并与现有项目整合。代码风格和项目结构容易产生差别</li>
<li>React JSX 灵活性高，预编译时可以做的优化相对其他 HTML 分离的库有限</li>
<li>React setState 提供基于队列异步更新，手动优化渲染流程，需要关注业务之外的逻辑</li>
<li>React17 以前基于事件委托的合成事件，表现和使用与原生事件存在差异</li>
</ul>
<h3 id="什么是声明式编程？"><a href="#什么是声明式编程？" class="headerlink" title="什么是声明式编程？"></a>什么是声明式编程？</h3><ul>
<li>声明式编程是一种编程范式，描述目标，而不是流程</li>
<li>通过函数、推理规则或者重写规则，来描述变量间关系</li>
<li>通过编译器采用固定算法，使得这些关系产生结果</li>
</ul>
<h3 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h3><ul>
<li>函数式编程是一种编程范式，它是声明式编程的子集</li>
<li>避免使用状态、异变对象，最小化副作用</li>
<li>基于 lambda 演算，函数可以作为入参和出参</li>
</ul>
<h3 id="MVC-和-MVVM-的区别是？"><a href="#MVC-和-MVVM-的区别是？" class="headerlink" title="MVC 和 MVVM 的区别是？"></a>MVC 和 MVVM 的区别是？</h3><p>相同点</p>
<ul>
<li>目的相同：分离模型 Model 和视图 View</li>
</ul>
<p>不同点</p>
<ul>
<li>MVC<ul>
<li>构成：模型 Model - 视图 View - 控制器 Controller</li>
<li>分为主动 MVC 和 被动 MVC<ul>
<li>主动 MVC：视图订阅数据更新</li>
<li>被动 MVC：控制器操作视图</li>
</ul>
</li>
<li>渲染<ul>
<li>后端返回 HTML，利于 SEO</li>
<li>后端返回数据，前端使用模板引擎或操作 DOM</li>
</ul>
</li>
</ul>
</li>
<li>MVVM<ul>
<li>构成：模型 Model - 视图 View - 视图模型 ViewModel</li>
<li>ViewModel 单向或双向数据绑定 View 和 Model 层，实现自动同步</li>
<li>渲染<ul>
<li>后端减少关心视图，前端 SSR 利于 SEO</li>
<li>前端减少操作 DOM</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何组织-React-项目文件结构？"><a href="#如何组织-React-项目文件结构？" class="headerlink" title="如何组织 React 项目文件结构？"></a>如何组织 React 项目文件结构？</h3><p>React 建议</p>
<ul>
<li>项目目录嵌套最多3到4个层级</li>
<li>不要过度思考</li>
<li>没有官方推荐的组织方式，常见组织方式包括<ul>
<li>按功能和路由组织：相同功能或路由的 CSS、JS 和 测试文件放入同一目录</li>
<li>按文件类型组织：组件、页面、API、状态管理、静态文件分类存放</li>
</ul>
</li>
</ul>
<h3 id="如何组织-React-项目文件结构？-1"><a href="#如何组织-React-项目文件结构？-1" class="headerlink" title="如何组织 React 项目文件结构？"></a>如何组织 React 项目文件结构？</h3><p>React 建议</p>
<ul>
<li>项目目录嵌套最多3到4个层级</li>
<li>不要过度思考</li>
<li>没有官方推荐的组织方式，常见组织方式包括<ul>
<li>按功能和路由组织：相同功能或路由的 CSS、JS 和 测试文件放入同一目录</li>
<li>按文件类型组织：组件、页面、API、状态管理、静态文件分类存放</li>
</ul>
</li>
</ul>
<h3 id="React-18-都有哪些新特性？"><a href="#React-18-都有哪些新特性？" class="headerlink" title="React 18 都有哪些新特性？"></a>React 18 都有哪些新特性？</h3><ul>
<li>新的 Root API：ReactDom.creatRoot<ul>
<li>React 17 及之前版本<ul>
<li>通过 ReactDom.render 将应用渲染到页面的根元素</li>
<li>有限的自动批量处理<ul>
<li>如在浏览器事件触发多个状态更改，自动批量更新</li>
<li>而在异步函数中多个状态更改，不会批量更新</li>
</ul>
</li>
</ul>
</li>
<li>React 18<ul>
<li>可选通过 ReactDom.creatRoot 将应用渲染到页面的根元素</li>
<li>确保安全的前提下<ul>
<li>如对于每个用户触发的事件，在下一个事件前完成渲染</li>
<li>尽可能地多应用自动批量处理，包括异步函数中的多个状态更新</li>
</ul>
</li>
<li>可选 ReactDom.flushSync 退出批量更新</li>
</ul>
</li>
</ul>
</li>
<li>SSR 支持 React.lazy 和 React.Suspense<ul>
<li>React 17 及之前版本<ul>
<li>React.lazy() 和 React.Suspense 尚未在 ReactDOMServer 中支持</li>
</ul>
</li>
<li>React 18<ul>
<li>全新的 SSR 架构内置支持 React.lazy() 和 React.Suspense</li>
</ul>
</li>
</ul>
</li>
<li>startTransition<br>* React 17 及以前版本<br>* 所有更新都被紧急渲染<br>* 使用 <code>setTimeout</code> 和 防抖等方式，避免频繁更新<br>* React 18<br>* 所有渲染分为紧急和非紧急<br>* 非紧急渲染使用 <code>startTransition</code> 包裹<br>* 非紧急渲染的延迟时间由设备决定<br>* 非紧急渲染可中断，不会影响响应用户输入、动画等紧急渲染</li>
</ul>
<h3 id="什么是-JSX-？"><a href="#什么是-JSX-？" class="headerlink" title="什么是 JSX ？"></a>什么是 JSX ？</h3><ul>
<li><p>JSX 是 JavaScript 的语法扩展，生成 React 元素</p>
</li>
<li><p>JSX 是</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(component, props, ...children)<br></code></pre></td></tr></table></figure>

<p>函数的语法糖</p>
<ul>
<li>React 17 RC 开始，由编辑器自动引入 <code>import &#123; jsx &#125; from &#39;react/jsx-runtime&#39;</code></li>
</ul>
</li>
<li><p>JSX 支持 HTML 模板语法 和 表达式，支持条件和循环渲染，支持点语法和展开运算符</p>
</li>
<li><p>JSX 转义所有输入内容，防止注入攻击</p>
</li>
<li><p>JSX 忽略渲染 <code>false</code>，<code>null</code>，<code>undefined</code>，<code>true</code> 子元素</p>
</li>
</ul>
<h3 id="为什么推荐在-React-中使用-JSX-？"><a href="#为什么推荐在-React-中使用-JSX-？" class="headerlink" title="为什么推荐在 React 中使用 JSX ？"></a>为什么推荐在 React 中使用 JSX ？</h3><ul>
<li>React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合<ul>
<li>UI 中绑定处理事件</li>
<li>状态更新时通知 UI</li>
<li>UI 中展示数据</li>
</ul>
</li>
<li>React 将标记和逻辑共同存放在组件，实现关注点分离</li>
<li>React 不强制要求使用 JSX，但 JSX 与 UI 一起有视觉辅助作用</li>
<li>React 通过 JSX 可以显示更多有用错误和警告消息</li>
</ul>
<h3 id="为什么-JSX-可以有效降低-XSS-风险？"><a href="#为什么-JSX-可以有效降低-XSS-风险？" class="headerlink" title="为什么 JSX 可以有效降低 XSS 风险？"></a>为什么 JSX 可以有效降低 XSS 风险？</h3><ul>
<li>React DOM 在渲染所有输入内容前，默认会将它们转义成字符串，有效降低 XSS 风险</li>
<li>可以通过<code>dangerouslySetInnerHTML = &#123;&#123; __html: HTML &#125;&#125;</code>来显示转义前的内容</li>
</ul>
<h3 id="如何在-JSX-中条件渲染？"><a href="#如何在-JSX-中条件渲染？" class="headerlink" title="如何在 JSX 中条件渲染？"></a>如何在 JSX 中条件渲染？</h3><ul>
<li><p>if &#x2F; else 语句</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">if</span> (condition) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span></span><br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>三元运算符</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> condition ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span></span> : <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>逻辑运算符</p>
</li>
<li><p>plain</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> condition &amp;&amp; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>条件渲染组件</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx">render () &#123;<br>	<span class="hljs-keyword">const</span> <span class="hljs-title function_">Condition</span> = props =&gt; &#123;<br>		<span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">If</span>, children &#125; = props<br>		<span class="hljs-keyword">return</span> <span class="hljs-title class_">If</span> &amp;&amp; children<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Condition</span> <span class="hljs-attr">If</span>=<span class="hljs-string">&#123;true&#125;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Condition</span>&gt;</span></span><br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="如何在-JSX-中循环控制？"><a href="#如何在-JSX-中循环控制？" class="headerlink" title="如何在 JSX 中循环控制？"></a>如何在 JSX 中循环控制？</h3><ul>
<li>map 将数组每一项转成 UI，flatMap filter 等能返回数组的循环方法也被支持</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">const</span> &#123; data &#125; = props<br>	<span class="hljs-keyword">return</span> data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用 javaScript 的循环（for &#x2F; while &#x2F; do while），将结果存储到变量，将变量代入 JSX</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">const</span> &#123; data &#125; = props<br>	<span class="hljs-keyword">const</span> datas = <span class="hljs-title class_">Array</span>(data.<span class="hljs-property">length</span>)<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-property">length</span>; i++) &#123;<br>		<span class="hljs-keyword">const</span> item = data[i]<br>		datas[i] = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span><br>	&#125;<br>	<span class="hljs-keyword">return</span> datas<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用 lodash 等第三方库或自定义可以返回数组的方法，以 lodash 为例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">const</span> &#123; data &#125; = props<br>	<span class="hljs-keyword">return</span> _.<span class="hljs-title function_">times</span>(data.<span class="hljs-property">length</span>, <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;data[i].id&#125;</span>&gt;</span>&#123;data[i].text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="为什么-JSX-中-class-变成了-className"><a href="#为什么-JSX-中-class-变成了-className" class="headerlink" title="为什么 JSX 中 class 变成了 className ?"></a>为什么 JSX 中 class 变成了 className ?</h3><ul>
<li>JSX 语法上更接近 JavaScript 而不是 HTML<ul>
<li>HTML 属性值通常为字符串</li>
<li>HTML DOM 对象属性值可以是任意数据类型</li>
</ul>
</li>
<li>JSX 的 className 更接近 HTML DOM 对象的属性，并且支持属性拓展运算符</li>
<li>JSX 通过匹配闭合标签提升可读性，而不是代替 HTML<ul>
<li>JSX 与 HTML 需要转换，直接使用 class 也无法避免其它转换工作</li>
</ul>
</li>
</ul>
<h3 id="什么是-React-组件？"><a href="#什么是-React-组件？" class="headerlink" title="什么是 React 组件？"></a>什么是 React 组件？</h3><ul>
<li>React 组件允许用户将 UI 拆分成独立可复用的代码片段，并对每个片段进行独立构思</li>
<li>React 组件从概念上类似于 JavaScript 函数</li>
<li>React 组件接受任意的入参 Props，返回用于描述页面展示内容的 React 元素</li>
</ul>
<h3 id="React-组件分成哪几类？"><a href="#React-组件分成哪几类？" class="headerlink" title="React 组件分成哪几类？"></a>React 组件分成哪几类？</h3><ul>
<li>按定义分类<ul>
<li>类组件，使用 ES6 的 class 定义，维护 state，有生命周期</li>
<li>函数组件，使用普通函数定义，可以通过 hooks 维护状态和副作用</li>
</ul>
</li>
<li>按状态分<ul>
<li>有状态组件，组件返回结果，受时间、空间或上下文影响</li>
<li>无状态组件，通常是纯展示 UI 组件，容易复用</li>
</ul>
</li>
<li>按定位分<ul>
<li>展示型组件，接收 props，负责 UI 展示</li>
<li>容器组件，管理 states，负责数据获取和组件间通信，多用于状态提升</li>
</ul>
</li>
<li>按 React 内置类型分类<ul>
<li>有状态组件<ul>
<li>ClassComponent，由 class 创建</li>
<li>ContextProvider，由 createContext 创建</li>
</ul>
</li>
<li>无状态组件<ul>
<li>IndeterminateComponent，FunctionCompoent 挂载前的初始类型</li>
<li>FunctionComponent，即函数组件</li>
<li>ForwardRef，由 React.forwardRef 创建，接收 ref 并转发给子组件</li>
<li>MemoComponent，由 React.memo 创建，条件渲染子组件</li>
<li>SimpleMemoCompoent，由 React.memo 创建且不指定条件</li>
</ul>
</li>
<li>FiberNode<ul>
<li>HostRoot，由 ReactDOM.render 创建</li>
<li>HostPortal，由 React.createPortal 创建，多用于模态框</li>
<li>HostComponent，对应元素节点</li>
<li>HostText，对应文本节点</li>
</ul>
</li>
<li>内置类型<ul>
<li>Fragment，分组子列表，无需向 DOM 添加额外节点，可用短语法 &lt;&gt;</li>
<li>Profiler，测量 React 应用多久渲染一次以及渲染一次的“代价”</li>
<li>StrictMode，严格模式，用来突出显示应用程序中潜在问题的工具</li>
<li>Suspense，等待目标代码加载，并且可以指定一个加载界面，在用户等待时显示</li>
<li>PureCompoent，浅层对比 prop 和 state 实现了 shouldComponentUpdate</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="类组件和函数组件的区别是？"><a href="#类组件和函数组件的区别是？" class="headerlink" title="类组件和函数组件的区别是？"></a>类组件和函数组件的区别是？</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">类组件</th>
<th align="left">函数组件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">回调钩子</td>
<td align="left">生命周期</td>
<td align="left">useEffect &#x2F; useLayoutEffect</td>
</tr>
<tr>
<td align="left">this</td>
<td align="left">有，事件处理函数需绑定 this</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">state</td>
<td align="left">有，this.setState 更新</td>
<td align="left">无，useState &#x2F; useReducer 引入</td>
</tr>
<tr>
<td align="left">实例化</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">现代浏览器中，闭包和类的原始性能只有在极端场景才会有明显差别</td>
<td align="left">使用 Hooks 某些情况更加高效,避免了 class 需要的额外成本，如创建类实例和在构造函数绑定事件处理器的成本,符合语言习惯的代码不需要很深的组件库嵌套</td>
</tr>
</tbody></table>
<h3 id="受控组件和非受控组件的区别是？"><a href="#受控组件和非受控组件的区别是？" class="headerlink" title="受控组件和非受控组件的区别是？"></a>受控组件和非受控组件的区别是？</h3><h4 id="面试高频指数：★-★-★-★-☆"><a href="#面试高频指数：★-★-★-★-☆" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul>
<li>受控组件<ul>
<li>React 的 state 是表单元素的“唯一数据源”，控制用户输入过程中表单发生的操作</li>
<li>表单元素的 value 跟随 state 变化，默认值由 defaultValue 设置</li>
<li>表单元素需要被 React 组件包裹</li>
<li>每种数据变化都需要编写事件处理函数</li>
<li>不支持 value 只读的表单元素，如 <code>&lt;input type=&quot;file&quot; /&gt;</code> 的 value 由用户设置</li>
</ul>
</li>
<li>非受控组件<ul>
<li>表单数据交由 DOM 节点处理</li>
<li>使用 <code>ref</code> 从 DOM 节点获取表单数据</li>
<li>表单元素无需被 React 组件包裹</li>
<li>只关心业务需要的数据变化，减少代码量</li>
<li>集成 React 和 非 React 代码，不推荐使用</li>
</ul>
</li>
</ul>
<h3 id="什么是高阶组件？"><a href="#什么是高阶组件？" class="headerlink" title="什么是高阶组件？"></a>什么是高阶组件？</h3><ul>
<li>高阶组件是参数为组件，返回值为新组件的函数，某种角度上就是高阶函数</li>
<li>高阶组件是 React 中复用组件逻辑的一种高级技巧</li>
<li>高阶组件不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式</li>
</ul>
<h3 id="什么是-Pure-Components-？"><a href="#什么是-Pure-Components-？" class="headerlink" title="什么是 Pure Components ？"></a>什么是 Pure Components ？</h3><p>React.PureComponent 与 React.Component 相似，区别是</p>
<ul>
<li>React.Component 并未实现 shouldComponentUpdate</li>
<li>React.PureComponent 以浅层对比 prop 和 state 方式实现了 shouldComponentUpdate<ul>
<li>React.PureComponent 无法检查对象的深层差别</li>
<li>prop 和 state 使用深层数据结构时<ul>
<li>调用 <code>forceUpdate()</code> 来确保组件正确更新</li>
<li>使用 <code>immutable 对象</code> 加速嵌套数据的比较</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="展示组件和容器组件的区别是？"><a href="#展示组件和容器组件的区别是？" class="headerlink" title="展示组件和容器组件的区别是？"></a>展示组件和容器组件的区别是？</h3><p>React 组件按照用途可以分为展示组件和容器组件</p>
<p>React 推荐所有新组件，无论是展示组件，还是容器组件，都采用函数组件 + Hook 方式编写</p>
<ul>
<li>展示组件<ul>
<li>关心页面 UI，有自己的 HTML 标签和样式</li>
<li>如果有状态，仅与 UI 相关。与其他组件、store 无关</li>
<li>不关心数据源，通过 props 获取数据，并执行回调</li>
</ul>
</li>
<li>容器组件<ul>
<li>关心功能实现，无自己的 HTML 标签和样式</li>
<li>有状态。包含请求数据源等副作用。状态提升时，维护多个子组件的状态</li>
<li>可以由第三方库生成，如 React Redux 的 <code>connect()</code> 和 Relay 的 <code>createFragmentContainer</code></li>
</ul>
</li>
</ul>
<p>React 分离展示组件和容器组件的优势</p>
<ul>
<li>关注点分离，便于维护</li>
<li>提高展示组件的复用度，便于调整 UI</li>
<li>便于通过如 this.props.children 传递组件本身，减少相同 props 层层传递</li>
</ul>
<h3 id="如何劫持-React-组件提高组件复用度？"><a href="#如何劫持-React-组件提高组件复用度？" class="headerlink" title="如何劫持 React 组件提高组件复用度？"></a>如何劫持 React 组件提高组件复用度？</h3><p>劫持 React 组件又被称为渲染劫持</p>
<p>将已有组件包装，注入新属性和功能，输出高阶组件，来实现组件复用</p>
<p>劫持需要遵守高阶组件的约定</p>
<ul>
<li>不要改变原始组件，仅组合组件</li>
<li>保持组件的接口与已有组件相似，透传与自身无关的 props 给已有组件</li>
<li>最大化可组合性，确保函数签名类型一致，输入函数，返回函数，输入组件，返回组件</li>
<li>包装显示名称便于调试，如 <code>withSubscription(CommentList)</code></li>
</ul>
<h3 id="如何设计一个-React-组件？"><a href="#如何设计一个-React-组件？" class="headerlink" title="如何设计一个 React 组件？"></a>如何设计一个 React 组件？</h3><ul>
<li>根据数据源和原型和 UI 稿，了解数据结构和 UI 视图</li>
<li>划分组件层级<ul>
<li>根据单一功能原则分离 UI 与数据源的结构一一对应</li>
<li>明确组件的包含关系</li>
</ul>
</li>
<li>构建静态版本<ul>
<li>将静态数据通过 props 父组件到子组件单向传递</li>
<li>构建应用<ul>
<li>简单应用，自上而下，从高层组件到低层组件构建</li>
<li>大型应用，自下而上，从低层组件到高层组件构建，同时为低层组件编写测试</li>
</ul>
</li>
<li>确定 UI state 最小且完整表示<ul>
<li>排除通过 props 传递来的数据</li>
<li>排除不随时间变化的数据</li>
<li>排除可以由其他 state 或 props 计算得出的数据</li>
</ul>
</li>
<li>确定 state 放置位置<ul>
<li>找出根据 state 渲染的所有组件</li>
<li>找出这些组件的共同上级组件</li>
<li>state 应该放置在共同上级组件或者更高层级的组件中</li>
</ul>
</li>
<li>添加反向数据流<ul>
<li>state 只能由拥有它们的组件更改</li>
<li>在该组件添加修改 state 的回调函数</li>
<li>将该回调函数通过 props 传递给子组件，在子组件中，如事件处理函数中调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="React-组件与-Web-Components-共存的最佳实践是？"><a href="#React-组件与-Web-Components-共存的最佳实践是？" class="headerlink" title="React 组件与 Web Components 共存的最佳实践是？"></a>React 组件与 Web Components 共存的最佳实践是？</h3><ul>
<li>访问 Web Components 的命令式 API：使用 <code>ref</code>与 DOM 节点进行交互</li>
<li>引入第三方 Web Components：编写 React 组件包装该 Web Components</li>
<li>Web Components 触发事件：React 组件中手动添加事件处理器来处理事件</li>
</ul>
<h3 id="什么是-React-的状态？"><a href="#什么是-React-的状态？" class="headerlink" title="什么是 React 的状态？"></a>什么是 React 的状态？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆"><a href="#面试高频指数：★-☆-☆-☆-☆" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li>React 的状态 state 是一个对象<ul>
<li>类组件中，状态通过 this.state 创建，通过 this.setState 合并更改，异步更新</li>
<li>React Hook 中，状态通过 this.useState 或 this.useReducer 使用</li>
</ul>
</li>
<li>React 将组件看做状态机，状态改变触发渲染</li>
<li>React 建议减少有状态的组件，提高组件复用度，利于维护<ul>
<li>只将无法从 props 传递，无法从其他数据计算，并且随时间可能变化的数据作为 state</li>
<li>多个组件 state 的数据源相同，应将状态提升到父组件或容器组件</li>
<li>避免使用 context，仅在 React 的状态管理无法满足需求时使用 Redux</li>
</ul>
</li>
</ul>
<h3 id="什么是-React-的状态提升？"><a href="#什么是-React-的状态提升？" class="headerlink" title="什么是 React 的状态提升？"></a>什么是 React 的状态提升？</h3><ul>
<li>React 中，任何可变数据应当只有一个相对应的唯一“数据源”</li>
<li>多个组件反映相同的变化数据时，共享状态提升到最近的共同父组件<ul>
<li>state 应首先添加到需要渲染数据的组件</li>
<li>其他组件也需要这个 state，将它提升至这些组件的最近共同父组件</li>
</ul>
</li>
<li>state 只能由拥有它们的组件修改，bug 排查范围被大大缩减</li>
</ul>
<h3 id="状态和属性的区别是什么？"><a href="#状态和属性的区别是什么？" class="headerlink" title="状态和属性的区别是什么？"></a>状态和属性的区别是什么？</h3><p>相同点</p>
<ul>
<li>state 和 props 都是原生的 JavaScript 对象</li>
<li>state 和 props 的变化都会触发生命周期、useEffect &#x2F; useLayoutEffect、和渲染</li>
<li>state 和 props 相同，渲染结果相同</li>
<li>state 和 props 都可以在组件内部设置默认值</li>
</ul>
<p>不同点</p>
<ul>
<li>获取<ul>
<li>state 由当前组件声明</li>
<li>props 由父组件传入</li>
</ul>
</li>
<li>更新<ul>
<li>state<ul>
<li>由所在组件通过 useState &#x2F; useReducer 或 setState 方法更新</li>
<li>由子组件通过 state 所在组件传入的回调函数间接更新</li>
</ul>
</li>
<li>props 不允许修改</li>
</ul>
</li>
<li>数据<ul>
<li>state 通常存储可变数据，避免多层嵌套或使用不可变对象便于优化渲染</li>
<li>props 除数据外，还多用于回调函数，组件 ( children )，路由 ( history ) 的传递</li>
</ul>
</li>
</ul>
<h3 id="如何创建动态的状态名称？"><a href="#如何创建动态的状态名称？" class="headerlink" title="如何创建动态的状态名称？"></a>如何创建动态的状态名称？</h3><ul>
<li>状态是一个 JavaScript 对象，状态名称即对象的属性名称</li>
<li>从 ECMAScript 2015 开始，对象初始化语法开始支持计算属性名。在 [] 放入表达式，计算结果当做属性名。例如</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> h = &#123;&#125;<br><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span><br>h[i + <span class="hljs-number">1</span>] = i <span class="hljs-comment">// h = &#123;&#x27;1&#x27;: 0&#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>计算属性名支持对象字面量，例：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; i &#125; = props <span class="hljs-comment">// props = &#123; i : 0 &#125;</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>	[i + <span class="hljs-number">1</span>] : i<br>&#125; <span class="hljs-comment">// this.state = &#123; &#x27;1&#x27; : 0 &#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="setState-支持哪些用法？"><a href="#setState-支持哪些用法？" class="headerlink" title="setState 支持哪些用法？"></a>setState 支持哪些用法？</h3><h4 id="面试高频指数：★-★-☆-☆-☆"><a href="#面试高频指数：★-★-☆-☆-☆" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>setState(updater, [callback])<ul>
<li>updater 函数带有形式参数，基于 state 和 props 构建新对象表示变化</li>
<li>(state, props) &#x3D;&gt; stateChange，适合后续状态取决于当前状态的情况</li>
</ul>
</li>
<li>setState(stateChange[, callback])<ul>
<li>stateChange 为传入对象，会浅层合并到新的 state</li>
<li>同一周期内，后调用的 setState 会覆盖先调用的 setState</li>
</ul>
</li>
<li>setState 的第二参数为可选回调函数<ul>
<li>回调函数将在 setState 完成合并并重新渲染组件后执行</li>
<li>React 官方推荐使用 componentDidUpdate() 生命周期代替 setState 的回调函数</li>
</ul>
</li>
</ul>
<h3 id="setState-和-replaceState-的区别是？"><a href="#setState-和-replaceState-的区别是？" class="headerlink" title="setState 和 replaceState 的区别是？"></a>setState 和 replaceState 的区别是？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-1"><a href="#面试高频指数：★-☆-☆-☆-☆-1" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li>setState 会合并当前状态与之前状态</li>
<li>replaceState 会丢弃之前状态，用新状态替代</li>
<li>replaceState 等同于先在 setState 中将状态设置为 false &#x2F; null，再设置新状态</li>
</ul>
<h3 id="如何优化-setState，减少不必要更新？"><a href="#如何优化-setState，减少不必要更新？" class="headerlink" title="如何优化 setState，减少不必要更新？"></a>如何优化 setState，减少不必要更新？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-1"><a href="#面试高频指数：★-★-☆-☆-☆-1" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>通过 setState(updater, [callback]) 的用法，第一参数使用带有形式参数的函数</li>
<li>通过 updater 函数 (state, props) &#x3D;&gt; stateChange 的第一参数，接受原来的 state 状态值</li>
<li>对比新旧状态值<ul>
<li>相同，返回 null，不渲染</li>
<li>不同，返回新状态值，触发异步合并渲染</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">getData = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>	<span class="hljs-keyword">const</span> &#123; time &#125; = data<br>	<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;<br>		<span class="hljs-keyword">return</span> state.<span class="hljs-property">time</span> === time ?  <span class="hljs-literal">null</span> : &#123; time &#125;<br>	&#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="当-State-值为-Object-时，如何优化？"><a href="#当-State-值为-Object-时，如何优化？" class="headerlink" title="当 State 值为 Object 时，如何优化？"></a>当 State 值为 Object 时，如何优化？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-2"><a href="#面试高频指数：★-★-☆-☆-☆-2" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>避免使用 Object 作为 State 值，使用 PureComponent 的浅比较的自动优化失效</li>
<li>必要使用 Object 作为 State 值<ul>
<li>避免嵌套过多层级</li>
<li>设置更新 state 的前置条件或使用 shouldComponent 手动优化</li>
</ul>
</li>
<li>已经使用 Object 作为 State 值，并且嵌套层级过多<ul>
<li>拆分 State 到子组件</li>
<li>使用不可变对象 Immutable，只要 State 更新，返回对象新引用，重新渲染修改节点</li>
</ul>
</li>
</ul>
<h3 id="什么是-React-的属性？"><a href="#什么是-React-的属性？" class="headerlink" title="什么是 React 的属性？"></a>什么是 React 的属性？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-2"><a href="#面试高频指数：★-☆-☆-☆-☆-2" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li>属性是组件的入参，用法同 HTML 自定义属性，可将任意类型数据从父组件传给子组件</li>
<li>属性的改变可以触发组件的生命周期流程和渲染</li>
<li>建议从组件自身的角度，不依赖于调用中间的上下文命名 Props</li>
<li>属性具有只读性，所有 React 组件必须像纯函数一样保护它们的 props 不被更改</li>
<li>请避免使用匿名函数作为属性值，避免引起重复渲染</li>
<li>具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑</li>
</ul>
<h3 id="为什么不能直接修改属性？"><a href="#为什么不能直接修改属性？" class="headerlink" title="为什么不能直接修改属性？"></a>为什么不能直接修改属性？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-3"><a href="#面试高频指数：★-☆-☆-☆-☆-3" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li>React 是“单向”数据流，数据通过 props 传递</li>
<li>从 state 派生数据或 UI 只能影响“低于”它们的组件，设计简单高效，便于调试</li>
<li>所有 React 组件必须像纯函数一样保护它们的 props 不被更改，保证组件没有副作用</li>
</ul>
<h3 id="通过属性传递组件本身的方法有哪些？"><a href="#通过属性传递组件本身的方法有哪些？" class="headerlink" title="通过属性传递组件本身的方法有哪些？"></a>通过属性传递组件本身的方法有哪些？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-3"><a href="#面试高频指数：★-★-☆-☆-☆-3" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>props.children<ul>
<li>子组件可以获取父组件开始标签和结束标签之间的内容</li>
</ul>
</li>
<li>render props<ul>
<li>向子组件传入函数，返回组件需要渲染什么内容</li>
<li>直接在父组件的标签之间，调用函数返回组件</li>
<li>避免使用匿名函数返回组件，避免重复渲染</li>
</ul>
</li>
</ul>
<h3 id="使用-key-属性有哪些注意事项？"><a href="#使用-key-属性有哪些注意事项？" class="headerlink" title="使用 key 属性有哪些注意事项？"></a>使用 key 属性有哪些注意事项？</h3><h4 id="面试高频指数：★-★-★-☆-☆"><a href="#面试高频指数：★-★-★-☆-☆" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul>
<li>key 用来帮助 React 识别哪些元素改变</li>
<li>key 在数组列表及兄弟节点之间必须唯一</li>
<li>不建议使用索引作为 key 值，如果不显示指定 key 值，默认使用索引作为 key 值</li>
<li>key 只有放在就近的数组上下文中才有意义</li>
<li>key 不会传递给子组件，需要使用 key 属性的值，需使用其他属性显式传递</li>
</ul>
<h3 id="如何在-React-中进行静态类型检查？"><a href="#如何在-React-中进行静态类型检查？" class="headerlink" title="如何在 React 中进行静态类型检查？"></a>如何在 React 中进行静态类型检查？</h3><h4 id="面试高频指数：★-★-★-☆-☆-1"><a href="#面试高频指数：★-★-★-☆-☆-1" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul>
<li>React.PropTypes 或 prop-types 库<ul>
<li>提供一系列验证器，确保组件接收到的数据类型有效</li>
<li>PropTypes 仅在开发模下进行检查并在控制台显示警告</li>
<li>通过特定的 defaultProps 属性来定义 props 的默认值</li>
</ul>
</li>
<li>Flow<ul>
<li>Flow 是一个针对 JavaScript 代码的静态类型检测器</li>
<li>Facebook 开发，经常与 React 一起使用</li>
<li>Flow 通过特殊类型语法为变量、函数以及 React 组件提供注解</li>
<li>Flow 添加方法<ul>
<li>将 Flow 添加到项目依赖</li>
<li>确保编译后的代码已经去除 Flow 语法</li>
<li>添加类型注解并且运行 Flow 来检查</li>
</ul>
</li>
</ul>
</li>
<li>TypeScript<ul>
<li>TypeScript 是微软开发的编程语言，它是 JavaScript 的类型超集，包含独立编译器</li>
<li>类型语言，构建时可以发现 bug 和错误</li>
<li>TypeScript 添加方法<ul>
<li>将 TypeScript 添加到项目依赖</li>
<li>配置 TypeScript 编译选项</li>
<li>使用正确的文件扩展名，React 的 JSX 使用<code>.tsx</code>作为扩展名</li>
<li>为已经使用的库添加定义，现实其他包的错误和提示</li>
</ul>
</li>
</ul>
</li>
<li>新语法和工具链<ul>
<li>Reason，由 Facebook 开发，经过实战验证的 OCaml 语言</li>
<li>Kotlin，由 JetBrains 开发的静态类型语言</li>
</ul>
</li>
</ul>
<h3 id="如何限制某个属性是必须的？"><a href="#如何限制某个属性是必须的？" class="headerlink" title="如何限制某个属性是必须的？"></a>如何限制某个属性是必须的？</h3><p>React 中，可以在任何 PropTypes 属性后加上 isRequired，声明该属性必须</p>
<ul>
<li>当必须属性没有被提供值时，控制台打印警告信息</li>
<li>表示该属性必须，而不限制属性类型，可以使用 PropTypes.any.isRequired</li>
<li>表示必须包含一个元素，可以使用 PropTypes.element.isRequired</li>
</ul>
<h3 id="如何设置属性的默认值？"><a href="#如何设置属性的默认值？" class="headerlink" title="如何设置属性的默认值？"></a>如何设置属性的默认值？</h3><h4 id="面试高频指数：★-★-★-☆-☆-2"><a href="#面试高频指数：★-★-★-☆-☆-2" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>React 中，通过特定 defaultProps 属性来定义 props 默认值</p>
<ul>
<li>设置类组件或函数组件的静态属性 defaultProps</li>
<li>类组件，参考 proposal-class-fields 提案，在 class 内声明静态属性 defaultProps</li>
<li>当传入属性值为 undefined 时，使用属性的默认值</li>
</ul>
<h3 id="React-是否支持-HTML-属性？"><a href="#React-是否支持-HTML-属性？" class="headerlink" title="React 是否支持 HTML 属性？"></a>React 是否支持 HTML 属性？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-4"><a href="#面试高频指数：★-★-☆-☆-☆-4" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>React16 中，任何标准和自定义的 DOM 属性都是完全支持</li>
<li>React 为 DOM 提供了一套以 JavaScript 为中心的 API<ul>
<li>标准 DOM 属性采用小驼峰命名</li>
<li>自定义属性全部小写</li>
</ul>
</li>
<li>React 与 HTML 之间部分属性存在差异<ul>
<li>checked<ul>
<li>受控组件 checked</li>
<li>非受控组件用 defaultChecked 设置组件首次挂载时是否被选中</li>
</ul>
</li>
<li>classNmae<ul>
<li>用于指定 DOM 节点和 SVG 元素的 class</li>
<li>React 中，使用 Web Components，使用 class 属性代替</li>
</ul>
</li>
<li>dangerouslySetInnerHTML<ul>
<li>React 为浏览器 DOM 提供 innerHTML 的替换方案</li>
<li>需要向该属性传入 key 为 __html 的对象，用来警示跨站脚本（XSS）攻击风险</li>
</ul>
</li>
<li>htmlFor<ul>
<li>for 是 JavaScript 关键字</li>
<li>React 元素使用 htmlFor 代替</li>
</ul>
</li>
<li>onChange<ul>
<li>onChange 事件与预期行为一致：表单字段变化时，事件都会被触发</li>
<li>与浏览器已有的默认行为不一致：<ul>
<li>用户更改 <code>&lt;input&gt;</code>,<code>&lt;select&gt;</code> 和 <code>&lt;textarea&gt;</code> 元素的值并提交更改时 <code>change</code> 事件在这些元素上触发</li>
<li>与 <code>input</code> 事件不一样，<code>change</code> 事件不是每次元素的 <code>value</code> 改变时都会被触发</li>
</ul>
</li>
<li>React 依靠该事件实时处理用户输入</li>
</ul>
</li>
<li>selected<ul>
<li>将 <code>&lt;option&gt;</code> 标记为已选中状态，请在 <code>select</code> 的 <code>value</code> 中引用该选项的值</li>
</ul>
</li>
<li>style<ul>
<li>接受小驼峰命名属性的 JavaScript 对象，而不是 CSS 字符串</li>
<li>与 JavaScript 属性一致，同时会更高效，且能预防跨站脚本（XSS）的安全漏洞</li>
<li>样式不会自动补齐浏览器私有前缀，除 <code>ms</code> 外，浏览器引擎前缀都应以大写字母开头</li>
<li>React 自动添加 “px” 后缀到内联样式为数字的属性<ul>
<li>本来没有单位的属性 <code>zoom</code>,<code>order</code>,<code>flex</code> 不会转换像素字符串</li>
<li>需使用 “px” 以外单位，请将值设为数字与所需单位组成的字符串</li>
</ul>
</li>
</ul>
</li>
<li>suppressContentEditableWaring<ul>
<li>禁止拥有子节点的元素比标记为 contentEditable 时 React 发出警告</li>
</ul>
</li>
<li>suprressHydrationWarning<ul>
<li>禁止 React 服务端渲染与客户端渲染不同内容时发出警告</li>
<li>只会对元素一级深度有效，应急方案使用，不过过度使用</li>
</ul>
</li>
<li>value<ul>
<li><code>&lt;input&gt;</code>,<code>&lt;select&gt;</code>,<code>&lt;textarea&gt;</code> 组件支持 <code>value</code> 属性</li>
<li>非受控组件使用 <code>dafaultValue</code> 属性设置组件第一次挂载时的 <code>value</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="React-是否支持自定义属性？"><a href="#React-是否支持自定义属性？" class="headerlink" title="React 是否支持自定义属性？"></a>React 是否支持自定义属性？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-5"><a href="#面试高频指数：★-★-☆-☆-☆-5" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>React 16 前会忽略未知的 DOM 属性。JSX 属性 React 无法识别，将被跳过</li>
<li>React 16 中任何未知的属性都会在 DOM 显示，适用于<ul>
<li>非标准属性</li>
<li>尝试实验中的 DOM 接口</li>
<li>集成第三方库或 Web Components</li>
</ul>
</li>
</ul>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><h3 id="React-父子组件通信有哪些方法？"><a href="#React-父子组件通信有哪些方法？" class="headerlink" title="React 父子组件通信有哪些方法？"></a>React 父子组件通信有哪些方法？</h3><h4 id="面试高频指数：★-★-★-★-★"><a href="#面试高频指数：★-★-★-★-★" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><ul>
<li>props<ul>
<li>父组件将需要传递的数据，更改 state 的方法或组件本身通过 props 传递给子组件</li>
<li>子组件通过 props 传来的回调函数向父组件传递数据或更改状态</li>
</ul>
</li>
<li>refs<ul>
<li>适合在典型数据流之外强制修改子组件的场景，例如<ul>
<li>管理焦点，文本选择或媒体播放</li>
<li>触发强制动画</li>
<li>集成第三方 DOM 库</li>
</ul>
</li>
<li>DOM refs 打破组件封装，ref 转发更改开发者预期<ul>
<li>应避免过度使用，用声明式实现和状态提升代替</li>
<li>一定要使用时，建议添加注释和说明</li>
</ul>
</li>
<li>被修改的子组件可以是 React 组件实例或 DOM 元素</li>
<li>包含向子组件添加 ref、回调 refs 和 ref 转发三种方式</li>
</ul>
</li>
<li>context<ul>
<li>适合在组件之间共享如地区偏好，主题等数据，避免逐层传递 props</li>
<li>存在 context 的 value 更新，内部所有消费组件都重新渲染问题</li>
<li>过度使用组件的状态与上下文相关，复用度降低</li>
</ul>
</li>
<li>事件订阅发布<ul>
<li>实现并使用 Event Bus<ul>
<li>在需要数据的组件监听自定义事件，并传入改变状态更新组件的回调函数</li>
<li>在获取数据的组件触发自定义事件，并传入数据，执行回调函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Eventbus</span> &#123;<br>	<span class="hljs-title function_">constructor</span> () &#123;<br>		<span class="hljs-variable language_">this</span>.<span class="hljs-property">fns</span> = []<br>	&#125;<br>	emit (type, ...args) &#123;<br>		<span class="hljs-keyword">const</span> fns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">fns</span>[type]<br>		<span class="hljs-keyword">if</span> (fns) fns.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args))<br>	&#125;<br>	addListener (type, fn) &#123;<br>		<span class="hljs-keyword">const</span> fns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">fns</span>[type]<br>		fns ? fns.<span class="hljs-title function_">push</span>(fn) : (<span class="hljs-variable language_">this</span>.<span class="hljs-property">fns</span>[type] = [fn])<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>使用 Node.js 的 events<br></code></pre></td></tr></table></figure>

<ul>
<li>使用状态管理，举例说明特点<ul>
<li>Redux<ul>
<li>单一数据源 store</li>
<li>state 只能通过 action 更改</li>
<li>使用 reducer 纯函数返回新 state 来更改 state</li>
</ul>
</li>
<li>Recoil<ul>
<li>任意地方灵活共享 state，并保持高性能</li>
<li>高效可靠地根据变化的 state 进行计算</li>
<li>支持持久化日志</li>
<li>支持 undo</li>
</ul>
</li>
<li>hox<ul>
<li>只有一个 API</li>
<li>使用 custom Hooks 定义 model</li>
<li>支持 TS</li>
<li>支持多数据源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="为什么-React-是单向数据流？"><a href="#为什么-React-是单向数据流？" class="headerlink" title="为什么 React 是单向数据流？"></a>为什么 React 是单向数据流？</h3><h4 id="面试高频指数：★-★-★-☆-☆-3"><a href="#面试高频指数：★-★-★-☆-☆-3" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul>
<li>React 组件不关心其他组件是否有状态和类型<ul>
<li>父组件可以把它的 state 作为 props 向下传递它的子组件中</li>
<li>子组件通过 props 接收父组件的数据，不关心数据来源于父组件的 state 或 props</li>
</ul>
</li>
<li>React 中这种自上而下的数据传递被称为单向数据流<ul>
<li>状态 state 总是所属于特定的组件</li>
<li>状态 state 派生的任何数据和 UI 只能影响树中“低于”它们的组件</li>
</ul>
</li>
<li>单向数据流单向绑定无关，对比双向绑定<ul>
<li>坏处：需要绑定更多“样板”代码</li>
<li>好处：排除和隔离 bug 所需的工作量将会减少<ul>
<li>状态 state 只有其所在组件自身可修改</li>
<li>Bug 可以使用 React 开发者工具来检查问题组件的 props</li>
<li>按照组件树结构逐级向上搜寻，直到定位到负责更新 state 的组件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="什么是-Context-？"><a href="#什么是-Context-？" class="headerlink" title="什么是 Context ？"></a>什么是 Context ？</h3><h4 id="面试高频指数：★-★-★-★-☆-1"><a href="#面试高频指数：★-★-★-★-☆-1" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul>
<li>Context 提供了一种无需为每层组件手动添加 props，能在组件树间进行数据传递的方法</li>
<li>Context 设计目的是共享或缓存组件树的全局数据，如用户认证，地区偏好，主题和语言</li>
<li>Context 应用场景是不同层级组件访问同样数据，副作用是降低组件的复用性</li>
<li>Context API<ul>
<li>React.createContext 创建 Context 对象，订阅该对象的组件从组件树中离自身最近的匹配的 Provider 中读取当前的 context 值</li>
<li>Context.Provider 接收 value 属性，当其发生变化时，内部所有消费组件都会重新渲染，忽略 shouldComponentUpdate 函数</li>
<li>Class.contextType 订阅单一 context，在任何生命周期中，使用 this.context 访问</li>
<li>Context.Consumer<ul>
<li>在函数式组件中订阅 context 的变更</li>
<li>需要一个函数作为子元素。函数接收当前 context 值，并返回一个 React 节点<ul>
<li>context 值由最近的 Provider 提供</li>
<li>没有 Provider 时等同于 createContext() 的 defaultValue</li>
</ul>
</li>
</ul>
</li>
<li>Context.displayName 指定组件在 DevToools 中显示的名称</li>
</ul>
</li>
</ul>
<h3 id="什么是-ContextType"><a href="#什么是-ContextType" class="headerlink" title="什么是 ContextType ?"></a>什么是 ContextType ?</h3><h4 id="面试高频指数：★-★-★-☆-☆-4"><a href="#面试高频指数：★-★-★-☆-☆-4" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ol>
<li>ContextType 用于订阅单一的 context</li>
</ol>
<ul>
<li><p>设置 class.contextType 为 React.createContext() 创建的 context 对象</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(defaultValue)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewClass</span> extend <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> &#123;<br>	<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>		<span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span><br>	&#125;<br>&#125;<br><span class="hljs-title class_">NewClass</span>.<span class="hljs-property">contextType</span> = <span class="hljs-title class_">MyContext</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>类组件参考 proposal-class-fields 提案</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> MyContext = React.createContext(defaultValue)<br><span class="hljs-keyword">class</span> <span class="hljs-title">NewClass</span> <span class="hljs-title">extend</span> <span class="hljs-title">React.Component</span> &#123;<br>	<span class="hljs-keyword">static</span> contextType = <span class="hljs-function">MyContext</span><br><span class="hljs-function">	<span class="hljs-title">render</span>()</span> &#123;<br>		<span class="hljs-keyword">const</span> <span class="hljs-keyword">value</span> = <span class="hljs-keyword">this</span>.context<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>在 React 组件中，使用 this.context 访问通过 contextType 指定的 Context</li>
</ol>
<h3 id="如何优化-Context-？"><a href="#如何优化-Context-？" class="headerlink" title="如何优化 Context ？"></a>如何优化 Context ？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-6"><a href="#面试高频指数：★-★-☆-☆-☆-6" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>为什么要优化 Context ?</li>
</ul>
<p>Context 的 value 更新，它内部所有消费组件都会重新渲染，并且不受制于 shouldComponentUpdate 函数</p>
<ul>
<li>优化 Context 的方法<ul>
<li>避免使用对象字面量作为 value</li>
</ul>
</li>
</ul>
<p>context 使用参考标识（reference identity) 来决定渲染时机，当 Provider 接收 value 为对象字面量时，每次 value 都会被赋值新对象，建议将 value 状态提升到父节点的 state 里</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>拆分 Context<br></code></pre></td></tr></table></figure>

<p>将原来同一个 Context 频繁变化的值拆分出来，分别放入不同的 Context</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>记忆化<br></code></pre></td></tr></table></figure>

<p>使用 React.memo 或 useMemo 包裹组件，指定需要比较的值，只有值变化时重新渲染</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>使用 createContext 的第二参数，不稳定，不推荐<br></code></pre></td></tr></table></figure>

<p>createContext 为函数，两个形参分别为更新前后值，接收 Number 类型作为返回值</p>
<p>在订阅 context 变化的组件上，使用 unstable_observedBits 设置重新渲染组件的条件</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Consumer</span>, <span class="hljs-title class_">Provider</span> &#125; = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>, <span class="hljs-function">(<span class="hljs-params">prev, next</span>) =&gt;</span> &#123;<br>	<span class="hljs-keyword">if</span> (prev.<span class="hljs-property">value1</span> !== next.<span class="hljs-property">value1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>	<span class="hljs-keyword">if</span> (prev.<span class="hljs-property">value2</span> !== next.<span class="hljs-property">value2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span><br>&#125;)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Consumer1</span> =&gt; &#123; <span class="hljs-comment">// 只有当 value1 变化重新渲染</span><br>	<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Consumer</span> <span class="hljs-attr">unstable_observedBits</span>=<span class="hljs-string">&#123;1&#125;</span> <span class="hljs-attr">children</span>=<span class="hljs-string">&#123;value</span> =&gt;</span> (</span><br><span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/&gt;</span></span><br>)&#125;<br>/&gt;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Consumer2</span> =&gt; &#123;<span class="hljs-comment">// 只有当 value2 变化重新渲染</span><br><span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Consumer</span> <span class="hljs-attr">unstable_oberverdBits</span>=<span class="hljs-string">&#123;10&#125;</span> <span class="hljs-attr">children</span>=<span class="hljs-string">&#123;value</span> =&gt;</span> (</span><br><span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/&gt;</span></span><br>)&#125;<br>/&gt;<br>&#125;<br>* 使用第三方库<br>    * use-context-selector<br>        * 使用 createContext 创建支持 useContextSelector 的特殊 context<br>        * 使用 useContextSelector 选择 context 某个值，当且仅当该值变化时，重新渲染<br>    * <span class="hljs-title class_">React</span> <span class="hljs-title class_">Tracke</span><br></code></pre></td></tr></table></figure>

<h3 id="什么是-Ref-转发？"><a href="#什么是-Ref-转发？" class="headerlink" title="什么是 Ref 转发？"></a>什么是 Ref 转发？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-7"><a href="#面试高频指数：★-★-☆-☆-☆-7" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li><p>Ref 转发可以将</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">ref</span><br></code></pre></td></tr></table></figure>

<p>传递到子组件</p>
<ul>
<li>由 <code>React.forwardRef</code> 实现</li>
<li>向 <code>ref</code> 传入回调函数，函数第一参数是 React 组件实例或 HTML DOM 元素</li>
</ul>
</li>
<li><p>Ref 转发适合应用场景</p>
<ul>
<li>转发表单组件的 ref 到 DOM 节点，便于访问 DOM 节点，来管理焦点、选中或动画</li>
<li>在高阶组件内，转发外层组件的 ref 到 被包裹的组件</li>
</ul>
</li>
<li><p>Ref 转发更改了组件默认的 ref 指向，对组件使用者不可见，不建议使用</p>
<ul>
<li>不兼容之前同时使用组件和 ref 的应用</li>
<li>对组件使用者，ref 结果可能不符合直观预期</li>
</ul>
</li>
<li><p>由</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>forwardRef<br></code></pre></td></tr></table></figure>

<p>实现 Ref 转发，可以使用函数决定 ref 转发组件显示的内容</p>
<ul>
<li>设置传入 <code>React.forwardRef</code> 函数名称，例如</li>
</ul>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const newComponent = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>forward<span class="hljs-constructor">Ref(<span class="hljs-params">function</span> <span class="hljs-params">myName</span>(<span class="hljs-params">props</span>, <span class="hljs-params">ref</span>)</span> &#123;<br>	return &lt;innerComponent &#123;...props&#125; forwardedRef=&#123;<span class="hljs-built_in">ref</span>&#125; /&gt;<br>&#125;)<br><span class="hljs-comment">// DevTools DisplayName: ForwardRef(myName)</span><span class="hljs-operator"></span><br><span class="hljs-operator">* </span>设置函数的 displayName 来包含被包裹组件的名称<br></code></pre></td></tr></table></figure>

<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> my<span class="hljs-constructor">Name(<span class="hljs-params">props</span>, <span class="hljs-params">ref</span>)</span> &#123;<br>	return &lt;innerComponent &#123;...props&#125; forwardedRef=&#123;<span class="hljs-built_in">ref</span>&#125;<br>&#125;<br>myName.displayName = &#x27;myDisplayName&#x27;<br>const newComponent = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>forward<span class="hljs-constructor">Ref(<span class="hljs-params">myName</span>)</span><br><span class="hljs-comment">// DevTools DisplayName: ForwardRef(myDisplayName)</span><br></code></pre></td></tr></table></figure>

<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><h3 id="React-返回空对象有哪些方法？"><a href="#React-返回空对象有哪些方法？" class="headerlink" title="React 返回空对象有哪些方法？"></a>React 返回空对象有哪些方法？</h3><ul>
<li>false &#x2F; true &#x2F; null &#x2F; undefined 将被忽略，不被渲染</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> / <span class="hljs-literal">true</span> / <span class="hljs-literal">null</span> /<span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>React.Fragment &#x2F; &lt;&gt;</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span> /&gt;</span></span> <span class="hljs-regexp">/ &lt;/</span>&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="如何优化不必要的渲染？"><a href="#如何优化不必要的渲染？" class="headerlink" title="如何优化不必要的渲染？"></a>如何优化不必要的渲染？</h3><h4 id="面试高频指数：★-★-★-★-★-1"><a href="#面试高频指数：★-★-★-★-★-1" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><ul>
<li><p>优化状态 state</p>
<ul>
<li>避免使用多层嵌套对象作为 state，降低比较效率，提高比较难度<ul>
<li>如果超过3层，建议继续拆分组件，将每一层状态放置在更内层的组件中</li>
</ul>
</li>
<li>状态提升和隔离<ul>
<li>多个组件需要反映相同的变化数据，共享状态提升到最近的共同父组件</li>
<li>仅影响组件本身的状态隔离放置在组件内部<ul>
<li>状态管理库可以使用 Recoil，其使用 Atom 更灵活地管理状态</li>
</ul>
</li>
</ul>
</li>
<li>合并状态更新，分离计算和渲染<ul>
<li>出于性能考虑，React 可能会把多个 setState 调用合并成一个调用</li>
<li>如果状态更新后，需要根据新状态计算或判断，再更新状态<ul>
<li>那么更新计算前的状态引发的渲染很可能不必要</li>
<li>分离计算逻辑，先计算状态的最终值，直接更新状态到最终值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>优化属性 props</p>
<ul>
<li>除高阶组件等需保持接口一致的场景外，props 保持简单，仅与组件单一职责关联</li>
<li>避免使用多层嵌套对象作为 props，降低比较效率，提高比较难度</li>
<li>组件只关心自身相关的 props<ul>
<li>例如标识单选、复选的选中状态、列表的激活项<ul>
<li>为每一项添加是否选中，是否激活标识优于额外添加选中项，激活项列表属性</li>
</ul>
</li>
</ul>
</li>
<li>避免在 render 等渲染函数中重复创建对象和函数，先赋值到变量再引用<ul>
<li>避免使用对象字面量作为 props，每次 render 创建新对象，相应子组件重复渲染</li>
<li>避免使用匿名函数作为 props，每次 render 创建新函数，相应子组件重复渲染</li>
</ul>
</li>
</ul>
</li>
<li><p>先比较再更新</p>
<ul>
<li>类组件<ul>
<li>使用 PureComponent 执行一层浅比较 props 或 state，值变化时渲染</li>
<li>使用 shouldComponentUpdate 函数<ul>
<li>手动比较前后 props 或 state，返回 true 渲染，false 不渲染</li>
<li>若 state 为对象，使用不可变对象，简化并加速比较</li>
</ul>
</li>
</ul>
</li>
<li>函数式组件<ul>
<li>使用 React.memo 比较 props 再渲染组件<ul>
<li>不使用第二参数时，一层浅比较 props，变化时渲染</li>
<li>使用第二参数时，手动比较前后的 props，返回 false 渲染，true 不渲染</li>
</ul>
</li>
<li>使用 useMemo 指定依赖，细粒度渲染组件<ul>
<li>使用第二参数，传入依赖数组，当数组中的值发生变化时，更新返回值</li>
<li>通常包裹函数式组件的返回值，指定依赖的 props 或 state 的具体值</li>
<li>包裹任意需要复杂计算的函数，指定依赖的变量。能在同一组件中部分和多次使用</li>
</ul>
</li>
<li>使用 useCallback 避免函数重复创建引起渲染<ul>
<li>当函数式组件重新更新时，内部声明的函数可能会被重复创建<ul>
<li>将这些函数作为 props 传入的子组件会重复渲染</li>
<li>使用 useCallback 包裹函数，传入空数组，总是返回相同函数来避免重复创建引起的渲染</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>减少嵌套</p>
<ul>
<li>减少不必要的根组件<ul>
<li>返回一个组件列表数组</li>
<li>使用内置组件文档碎片<code>React.Fragement</code>或其缩写<code>&lt;&gt;</code></li>
</ul>
</li>
<li>谨慎使用 CSS-in-JS 方案<ul>
<li>Class + 样式表方案的渲染性能和 CSS 本身的复用度总体优于内联方案</li>
<li>避免仅为书写内联样式而频繁地创建嵌套组件</li>
</ul>
</li>
</ul>
</li>
<li><p>惰性渲染</p>
<ul>
<li><p>key 唯一</p>
<ul>
<li>使用唯一标识作为 key，而不是 索引，让 React 精确判断变化，复用不变元素</li>
</ul>
</li>
<li><p>条件渲染</p>
<ul>
<li>使用 <code>if</code>&#x2F;<code>else</code> 三元运算符或逻辑运算符，仅在条件满足时，渲染组件</li>
<li>渲染列表时，当条件不满足时，返回 null 或空组件，保留组件位置</li>
</ul>
</li>
<li><p>防抖和节流</p>
<ul>
<li><p>使用 <code>window.requestAnimationFrame</code> 或定时器构建防抖或节流函数</p>
</li>
<li><p>使用 <code>MutationObserver</code> 代替定时器</p>
</li>
<li><p>使用</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Intersection</span> Observer<br></code></pre></td></tr></table></figure>

<p>代替</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">window</span>.scroll<br></code></pre></td></tr></table></figure>

<ul>
<li>懒加载图片<ul>
<li>只渲染可视区域的图片</li>
</ul>
</li>
<li>懒加载 DOM<ul>
<li>只渲染可视区域的 DOM，如虚拟列表，商品详情<ul>
<li>虚拟列表库可以使用 react-virtualized 及其更新 react-window</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>异步路由</p>
</li>
</ul>
</li>
<li><p>优化 Context，减少 value 更新，内部所有消费组件的重新渲染</p>
<ul>
<li>拆分 Context<ul>
<li>将原属于同一 Context 的值拆分到不同的 Context</li>
</ul>
</li>
<li>记忆化<ul>
<li>使用 React.memo 或 useMemo 包裹组件，指定需要比较的值，只有值变化时重新渲染</li>
</ul>
</li>
<li>使用 createContext 的第二参数，不稳定，不推荐<ul>
<li>createContext 为函数，两个形参分别为更新前后值，接收 Number 类型作为返回值</li>
<li>在订阅 context 变化的组件上，使用 unstable_observedBits 设置重新渲染组件的条件</li>
</ul>
</li>
<li>使用第三方库<ul>
<li>use-context-selector</li>
<li>React Tracke</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="React-如何渲染-HTML-，有什么风险？"><a href="#React-如何渲染-HTML-，有什么风险？" class="headerlink" title="React 如何渲染 HTML ，有什么风险？"></a>React 如何渲染 HTML ，有什么风险？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-4"><a href="#面试高频指数：★-☆-☆-☆-☆-4" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li><p><code>dangerouslySetInnerHTML</code> 是 React 为浏览器 DOM 提供 <code>innerHTML</code> 的替换方案</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">newComponent</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">&#123;&#123;__html:</span> &#x27;&lt;<span class="hljs-attr">b</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>&#x27;&#125;&#125; /&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>代码直接设置 HTML 存在风险，很容易无意中使用户暴露于跨站脚本（XSS）攻击</li>
<li>React 设计此替换方案，通过名称警示开发者</li>
</ul>
<h3 id="React-为什么要引入基于-Fiber-协调器的异步渲染？"><a href="#React-为什么要引入基于-Fiber-协调器的异步渲染？" class="headerlink" title="React 为什么要引入基于 Fiber 协调器的异步渲染？"></a>React 为什么要引入基于 Fiber 协调器的异步渲染？</h3><h4 id="面试高频指数：★-★-★-☆-☆-5"><a href="#面试高频指数：★-★-★-☆-☆-5" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul>
<li>在经典渲染模式下，React 一旦开始渲染一次更新，不能中断包括创建新 DOM 节点和运行组件中代码在内的工作，这种渲染方法为“阻塞渲染”</li>
<li>渲染阻塞响应用户输入和动画，使用防抖牺牲一定的响应即时性，使用节流降低更新频率，都不能提供最佳用户体验。</li>
<li>React 提供 Concurrent 模式，将人机交互研究的结果整合到真实 UI 中<ul>
<li>渲染可中断</li>
<li>有意的加载顺序<ul>
<li>React 可以在旧屏幕桑多停留一段时间，跳过不够好的加载状态，直接展示新屏幕</li>
</ul>
</li>
<li>并发，使用启发式方法决定更新紧急性，同时更新多个状态<ul>
<li>对于 CPU 密集型更新，例如创建新 DOM 节点和运行组件中代码，任意一个更急迫更新可以中断已经开始的渲染</li>
<li>对于 IO 密集型更新，例如从网络加载代码或数据，在全部数据到达前在内存中渲染，跳过令人不愉快的空白加载状态</li>
<li>对于超出屏幕显示的更新，延迟它的相关逻辑</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="什么是-React-Fiber"><a href="#什么是-React-Fiber" class="headerlink" title="什么是 React Fiber ?"></a>什么是 React Fiber ?</h3><h4 id="面试高频指数：★-★-☆-☆-☆-8"><a href="#面试高频指数：★-★-☆-☆-☆-8" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li><p>React 组件是数据的函数 <code>v = f(d)</code></p>
</li>
<li><p>计算机通过调用栈跟踪程序执行</p>
<ul>
<li>函数执行，栈会添加新堆栈结构，代表函数执行的事务</li>
<li>太多事务同时执行，会导致动画掉帧，用户输入无法及时响应</li>
<li>现代浏览器提供 API<ul>
<li><code>requestIdleCallback</code> 调度一个低优先级函数在空闲阶段执行</li>
<li><code>requestAnimationFrame</code> 调度一个高优先级函数在下一个动画帧执行</li>
</ul>
</li>
<li>需要自定义调用栈行为，来使用这些 API 优化 UI 渲染</li>
</ul>
</li>
<li><p>React Fiber 是专门为 React 组件实现的堆栈重构</p>
<ul>
<li><p>堆栈结构可以保存在内存中，手动调度和操作</p>
</li>
<li><p>单个 fiber 是虚拟的堆栈结构，对应一个组件实例</p>
<ul>
<li><p>包含组件及其输入、输出信息的 JavaScript 对象</p>
<ul>
<li><pre><code class="hljs">type
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>   <br><br>  是执行会被堆栈结构跟踪的函数<br><br>  - 复合函数、组件类 class 或字符串<br><br>- `key` 决定协调算法 Fiber 是否可重用<br><br>- ```<br>  child<br></code></pre></td></tr></table></figure>

 

指向

- 类组件 class 的 `render` 方法返回值
- 函数组件 的`return` 返回值
</code></pre>
</li>
<li><pre><code class="hljs">sibling
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>   <br><br>  指向<br><br><span class="hljs-bullet">  -</span> 类组件 class 或函数组件返回数组，其中包含多个子节点的情况<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">`return`</span> 返回父 fiber<br><br><span class="hljs-bullet">-</span> 属性，即函数参数，以下两者相等，则 fiber 可复用<br><br><span class="hljs-bullet">  -</span> <span class="hljs-code">`pendingProps`</span> fiber 开始时设置<br><span class="hljs-bullet">  -</span> <span class="hljs-code">`memoizedProps`</span> fiber 结束时设置<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```</span><br><span class="hljs-code">  pengdingWorkProiority</span><br></code></pre></td></tr></table></figure>

 

事务优先级数字

- 0 表示 `NoWork`
- 数字越大，优先级越低
- 调度器使用该字段搜索下一个要执行的事务
</code></pre>
</li>
<li><p>&#96;&#96;&#96;<br>alternate</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  - `flush` 渲染输出结果到屏幕<br>  - `work-in-progress` 进行中的 fiber 代表未返回堆栈结构的 fiber<br><br>- ```<br>  output<br></code></pre></td></tr></table></figure>

<ul>
<li><code>host component</code> 是 React 应用的叶子节点，浏览器环境是小写 HTML 标签</li>
<li>每个 fiber 输出结果由宿主组件创建，向上传递到整个树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="React-Fiber-异步渲染分为哪几个阶段，对应生命周期是什么？"><a href="#React-Fiber-异步渲染分为哪几个阶段，对应生命周期是什么？" class="headerlink" title="React Fiber 异步渲染分为哪几个阶段，对应生命周期是什么？"></a>React Fiber 异步渲染分为哪几个阶段，对应生命周期是什么？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-9"><a href="#面试高频指数：★-★-☆-☆-☆-9" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>不同于 Stack renconciler，Fiber reconciler 过程分为两个阶段：</p>
<ul>
<li><p>render &#x2F; reconciliation 可中断阶段</p>
<ul>
<li><p>以 Fiber tree 为蓝本，每个 Fiber 为工作单元，自顶向下构造 workInProgress Tree</p>
<ul>
<li><p>判断节点是否需要更新</p>
<ul>
<li><p>需要更新，标记当前节点</p>
<ul>
<li><p>更新当前节点状态和属性</p>
</li>
<li><p>调用</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">shouldComponentUpdate</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>返回</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ture</span><br></code></pre></td></tr></table></figure>

<p>需要更新</p>
<ul>
<li><p>调用</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">render</span><br></code></pre></td></tr></table></figure>

<ul>
<li>返回子节点，并创建对应 <code>fiber</code></li>
<li>无子节点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>当前工作单元结束，返回副作用列表</p>
</li>
<li><p>检查 fiber 的 sibiling 或 child</p>
<ul>
<li>存在，作为下一个工作单元<ul>
<li>检查剩余可用时间<ul>
<li>有，立即开始下一个工作单元</li>
<li>无，等待下一次主线程空闲，开始下一个工作单元，通过 <code>requestIdleCallback</code> 实现</li>
</ul>
</li>
</ul>
</li>
<li>没有下一个工作单元，本阶段结束，进入 <code>pendingCommit</code> 状态</li>
</ul>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/react-interview/nafqor/">∨∧Page 2</a></p>
</li>
<li><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/"><img src="/../imgs/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/logo-dark-cn.c42314a8.svg+xml" srcset="/img/loading.gif" lazyload alt="logo"></a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/">学习</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problemset/all/">题库</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/">讨论</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/">竞赛</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/company/">求职</a></li>
<li>商店</li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">-</a></p>
</li>
<li><p><img src="/../imgs/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/avatar_1645205761.webp" srcset="/img/loading.gif" lazyload alt="img"><img src="/../imgs/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/plus-light.594ca211.svg+xml" srcset="/img/loading.gif" lazyload alt="img"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/detail/react-interview/">返回</a></p>
</li>
<li></li>
</ul>
</li>
<li><p>commit 不可中断阶段</p>
<ul>
<li>执行副作用列表<ul>
<li>更新 DOM 树，更新 ref 指向</li>
<li>调用组件的生命周期函数或 useEffect 声明的钩子</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对应生命周期</p>
<ul>
<li>render &#x2F; reconciliation<ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpate</li>
<li>componentWillUpdate</li>
</ul>
</li>
<li>commit<ul>
<li>componentDidMount</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ul>
</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="React-组件有哪些生命周期方法？"><a href="#React-组件有哪些生命周期方法？" class="headerlink" title="React 组件有哪些生命周期方法？"></a>React 组件有哪些生命周期方法？</h3><h4 id="面试高频指数：★-★-★-☆-☆-6"><a href="#面试高频指数：★-★-★-☆-☆-6" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>React 每个组件都包含“生命周期”方法</p>
<p>开发者可以重写这些方法，便于在运行过程中特定阶段执行这些方法</p>
<ul>
<li>constructor(props)<ul>
<li>React 组件挂载之前调用</li>
<li>用于初始化 state 和 方法绑定，例如绑定事件处理函数的 this</li>
</ul>
</li>
<li>static getDerivedStateFromProps(props, state)<ul>
<li>React 组件调用 render 方法前，初始挂载及后续更新都会被调用</li>
<li>用于返回一个对象来更新 state，返回 null 不更新任何内容</li>
<li>每次渲染都会触发，包括父组件重新渲染以及组件本身调用 setState</li>
<li>以下场景不使用 getDerivedStateFromProps<ul>
<li>执行副作用应用 componentDidUpdate</li>
<li>prop 更改时重新计算某些数据，请使用 memoization helper 代替</li>
<li>prop 更改时“重置”某些 state<ul>
<li>请考虑使组件完全受控或使用 key 使组件完全不受控 代替</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>shouldComponentUpdate(nextProps, nextState)<ul>
<li>props 或 state 发生变化时，渲染执行之前被调用</li>
<li>首次渲染及 forceUpdate() 调用，React 参考返回 true &#x2F; false，决定是否重新渲染</li>
</ul>
</li>
<li>render()<ul>
<li>class 组件中唯一必须实现的方法，纯函数，每次调用应返回相同结果</li>
<li>当 render 被调用时，它会检查 this.props 和 this.state 变化，并返回<ul>
<li>React 元素：通过 JSX 创建</li>
<li>数组或 fragements：使得 render 方法可以返回多个元素</li>
<li>Portals：可以渲染子节点到不同 DOM 子树</li>
<li>字符串或数值类型：可以在 DOM 中被渲染为文本节点</li>
<li>布尔类型或 null：什么都不渲染</li>
</ul>
</li>
</ul>
</li>
<li>getSnapshotBeforeUpdate(prevProps, prevState)<ul>
<li>在最近一次渲染输出（提交到 DOM 节点）之前调用</li>
<li>能在组件发生更改之前从 DOM 中捕获信息，例如滚动位置</li>
<li>此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate 的第三参数</li>
</ul>
</li>
<li>componentDidMount()<ul>
<li>组件挂载后（插入 DOM 树中），即首次渲染时，立即调用</li>
<li>适用于放置依赖 DOM 节点、网络请求获取数据、添加订阅等</li>
<li>可以直接调用 setState()，触发依赖于 DOM 节点大小或位置的渲染</li>
</ul>
</li>
<li>componentDidUpdate(prevProps, prevState, snapshot)<ul>
<li>组件更新后立即调用，首次渲染不会执行此方法</li>
<li>可以执行 DOM 操作，比较前后 props，网络请求</li>
<li>可以直接调用 setState()，它必须被包裹在一个条件语句里，避免死循环</li>
<li>如果组件实现了 getSnapshotBeforeUpdate() 生命周期，则生命周期的返回值将作为 componentDidUpdate 的第三个参数</li>
</ul>
</li>
<li>componentWillUnmount()<ul>
<li>组件卸载及销毁之前直接调用</li>
<li>用于执行必要的清理操作，清除定时器、取消网络请求以及在 componentDidMount() 中创建的订阅等</li>
<li>不应调用 setState()，避免组件永远不会重新渲染</li>
</ul>
</li>
</ul>
<h3 id="React-组件的生命周期可分为哪些阶段？"><a href="#React-组件的生命周期可分为哪些阶段？" class="headerlink" title="React 组件的生命周期可分为哪些阶段？"></a>React 组件的生命周期可分为哪些阶段？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-10"><a href="#面试高频指数：★-★-☆-☆-☆-10" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>React 组件的生命周期可以分为三个阶段</p>
<ul>
<li>“Render”阶段：纯净且不包含副作用，可能会被 React 暂停、中止或重新启动<ul>
<li>constructor(props)</li>
<li>getDerivedStateFromPorps(props, state)</li>
<li>shouldComponentUpdate(nextProps, nextState)</li>
<li>render()</li>
</ul>
</li>
<li>“Pre-commit”阶段：可以读取DOM<ul>
<li>getSnapshotBeforeUpdate(prevProps, prevState)</li>
</ul>
</li>
<li>“Commit”阶段：可以使用 DOM，运行副作用，安排更新<ul>
<li>挂载时：componentDidMount()</li>
<li>更新时：componentDidUpdate(prevProps, prevState, snapshot)</li>
<li>卸载时：componentWillUnmount()</li>
</ul>
</li>
</ul>
<h3 id="异步数据请求应在哪些生命周期里调用？"><a href="#异步数据请求应在哪些生命周期里调用？" class="headerlink" title="异步数据请求应在哪些生命周期里调用？"></a>异步数据请求应在哪些生命周期里调用？</h3><h4 id="面试高频指数：★-★-★-★-☆-2"><a href="#面试高频指数：★-★-★-★-☆-2" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul>
<li>通过网络请求获取数据或订阅数据更新<ul>
<li>componentDidMount()</li>
<li>原因<ul>
<li>首次挂载时执行</li>
<li>不会重复请求或订阅数据更新</li>
<li>无需条件不容易触发重复渲染</li>
</ul>
</li>
</ul>
</li>
<li>有条件地通过网络请求数据<ul>
<li>componentDidUpdate(prevProps, prevState, snapshot)</li>
<li>原因<ul>
<li>可对比更新前后的 props 或 states</li>
<li>设置条件<ul>
<li>当且仅当条件满足时，通过网络请求数据</li>
<li>避免触发重复渲染</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>取消网络请求或者清除在 componentDidMount() 中创建的订阅<ul>
<li>componentWillUnmount()</li>
</ul>
</li>
</ul>
<h3 id="useEffect-useLayoutEffect-与生命周期的对应关系是？"><a href="#useEffect-useLayoutEffect-与生命周期的对应关系是？" class="headerlink" title="useEffect useLayoutEffect 与生命周期的对应关系是？"></a>useEffect useLayoutEffect 与生命周期的对应关系是？</h3><h4 id="面试高频指数：★-★-★-★-☆-3"><a href="#面试高频指数：★-★-★-★-☆-3" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><p>useLayoutEffect</p>
<ul>
<li>执行时机是组件挂载或更新之后，浏览器执行绘制之前<ul>
<li>与 componentDidMount + componentDidUpdate 一致</li>
</ul>
</li>
<li>支持返回清除函数，函数执行时机是组件卸载之前<ul>
<li>与 componentWillUnmout 一致</li>
</ul>
</li>
</ul>
<p>useEffect</p>
<ul>
<li>执行时机是组件挂载或更新之后，浏览器完成布局和绘制之后，在一个延迟事件中被调用<ul>
<li>与 componentDidMount + componentDidUpdate 不同</li>
</ul>
</li>
<li>支持返回清除函数，函数执行时机是组件卸载之前<ul>
<li>与 componentWillUnmout 一致</li>
</ul>
</li>
</ul>
<p>两者都适用于在函数组件主体内，即 React 渲染阶段改变 DOM，添加订阅，设置定时器，记录日志以及执行其他包含副作用的操作</p>
<p>优先使用 useEffect 避免阻塞视觉更新，只在需要读取 DOM 布局，在浏览器绘制前，同步触发重渲染的场景使用 useLayoutEffect</p>
<h3 id="在-constructor-中使用-super-的意义是？"><a href="#在-constructor-中使用-super-的意义是？" class="headerlink" title="在 constructor 中使用 super 的意义是？"></a>在 constructor 中使用 super 的意义是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-11"><a href="#面试高频指数：★-★-☆-☆-☆-11" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>JavaScript 中，super 指向父类构造函数，React 类组件可以是 React.Component 等</li>
<li>JavaScript 中，调用 super 前不能用 this。React 中不能声明 this.state 或读取 this.props</li>
<li>React 中，调用 super(props) 后，可以在 constructor 中访问 this.props</li>
<li>React 中，调用 super() 不传参，不能在 constructor 中访问 this.props<ul>
<li>React 在调用构造函数后，将 props 赋值到实例</li>
<li>可以在其他生命周期中，访问 this.props</li>
</ul>
</li>
<li>不调用 super，参考 proposal-class-fields 提案，可以将 state 等实例属性写在 class 内</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>	state = &#123; time : <span class="hljs-number">0</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="对比-React-Hook-与生命周期"><a href="#对比-React-Hook-与生命周期" class="headerlink" title="对比 React Hook 与生命周期"></a>对比 React Hook 与生命周期</h3><h4 id="面试高频指数：★-★-☆-☆-☆-12"><a href="#面试高频指数：★-★-☆-☆-☆-12" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li><p>什么是 React Hook</p>
<ul>
<li>React Hook 是 React 16.8 的新增特性</li>
<li>开发者可以在不编写 Class 的情况下使用 State 以及其他的 React 特性</li>
</ul>
</li>
<li><p>为什么要用 React Hook 代替拥有生命周期的类组件</p>
<ul>
<li><p>类组件的弊端</p>
<ul>
<li><p>组件之间复用状态逻辑很难</p>
<ul>
<li><p>React 没有提供将可复用性行为“附加”到组件的途径</p>
</li>
<li><p>使用</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">render props</span><br></code></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">高阶组件<br></code></pre></td></tr></table></figure>

<ul>
<li>需要重新组织组件结构，使得代码难以理解</li>
<li>形成“嵌套地域”，难以调试和维护</li>
</ul>
</li>
</ul>
</li>
<li><p>复杂组件变得难以理解</p>
<ul>
<li>组件被状态逻辑和副作用充斥</li>
<li>不相关逻辑被放在同一生命周期，相关逻辑被分散在不同生命周期<ul>
<li><code>componentDidMount</code>&#x2F;<code>componentDidUpdate</code> 获取数据</li>
<li><code>componentDidMount</code> 可能还包含事件监听，需在 <code>componentWillUnmount</code> 清除</li>
</ul>
</li>
<li>大量的状态逻辑，许多人使用状态管理库，组件复用和调试都比较困难</li>
</ul>
</li>
<li><p>难以理解的类组件</p>
<ul>
<li>大量的 this 绑定，较高学习成本，区分函数组件和类组件的使用场景</li>
<li>类组件会无意中鼓励开发者使用一些让 <code>Prepack</code> 等组件预编译优化措施无效的方案</li>
<li>类组件不能被很好的压缩，热重载不稳定，实例化类组件有轻微额外性能消耗</li>
</ul>
</li>
<li><p>有限的是否渲染控制</p>
<ul>
<li>使用 PureComponent 执行一层浅比较 props 或 state，值变化时渲染</li>
<li>使用 shouldComponentUpdate 函数<ul>
<li>手动比较前后 props 或 state，返回 true 渲染，false 不渲染</li>
<li>若 state 为对象，使用不可变对象，简化并加速比较</li>
</ul>
</li>
<li>在 setState 前设置判断条件，满足条件后再 setState</li>
</ul>
</li>
</ul>
</li>
<li><p>React Hook 解决的问题</p>
<ul>
<li>提高组件复用<ul>
<li>Hook 在无需修改组件结构的情况下，复用状态逻辑，共享 Hook 变得更便捷</li>
</ul>
</li>
<li>简化组件<ul>
<li>Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</li>
<li>非按照生命周期划分，可以使用 Reducer 来管理组件内部状态，使其更加可预测</li>
</ul>
</li>
<li>函数组件代替类组件<ul>
<li>Hook 在不使用类组件的情况下使用 State 以及其他的 React 特性</li>
<li>Hook 改造类组件为函数组件，容易理解 this 和学习，便于预编译等优化措施</li>
<li>Hook 拥抱函数式声明式编程，而无需学习复杂的函数式或响应式编程技术</li>
</ul>
</li>
<li>丰富的更细粒度的是否渲染控制<ul>
<li>使用 React.memo 比较 props 再渲染组件<ul>
<li>不使用第二参数时，一层浅比较 props，变化时渲染</li>
<li>使用第二参数时，手动比较前后的 props，返回 false 渲染，true 不渲染</li>
</ul>
</li>
<li>使用 useMemo 指定依赖，细粒度渲染组件<ul>
<li>使用第二参数，传入依赖数组，当数组中的值发生变化时，更新返回值</li>
<li>通常包裹函数式组件的返回值，指定依赖的 props 或 state 的具体值</li>
<li>包裹任意需要复杂计算的函数，指定依赖的变量。能在同一组件中部分和多次使用</li>
</ul>
</li>
<li>使用 useCallback 避免函数重复创建引起渲染<ul>
<li>当函数式组件重新更新时，内部声明的函数可能会被重复创建<ul>
<li>将这些函数作为 props 传入的子组件会重复渲染</li>
<li>使用 useCallback 包裹函数，传入空数组，总是返回相同函数来避免重复创建引起的渲染</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>React 元素的事件处理和 DOM 元素的不同点</p>
<ul>
<li>事件命名<ul>
<li>React：小驼峰式</li>
<li>DOM：纯小写</li>
</ul>
</li>
<li>事件处理函数传参<ul>
<li>React：接受函数</li>
<li>DOM：字符串</li>
</ul>
</li>
<li>阻止默认行为<ul>
<li>React：显式的使用 preventDefault</li>
<li>DOM：return false</li>
</ul>
</li>
<li>事件处理函数，第一参数 e<ul>
<li>React：e 是一个合成事件。React 根据 W3C 规范来定义合成事件</li>
<li>DOM：e &#x3D; window.event</li>
</ul>
</li>
<li>添加事件监听<ul>
<li>React：元素初始渲染的时候添加监听器</li>
<li>DOM：使用 addEventListener</li>
</ul>
</li>
<li>this 指向<ul>
<li>React：在 class 组件中，手动 bind this，使用匿名箭头函数或者 class fields 语法来让 this 指向组件本身</li>
<li>DOM：触发事件的目标对象</li>
</ul>
</li>
<li>向事件处理程序传递参数<ul>
<li>React：通过箭头函数和 Function.prototype.bind 来实现</li>
<li>DOM：经常通过 DOM attribute 传参，读取参数时，先获取目标对象，再获取目标对象的 attribute</li>
</ul>
</li>
<li>事件委托<ul>
<li>React：16 及更早版本，对大多数事件执行 <code>document.addEventListener()</code> 17 后调用 <code>rootNode.addEventListener()</code></li>
<li>DOM：自行添加事件委托</li>
</ul>
</li>
</ul>
<h3 id="什么是-React-合成事件？"><a href="#什么是-React-合成事件？" class="headerlink" title="什么是 React 合成事件？"></a>什么是 React 合成事件？</h3><h4 id="面试高频指数：★-★-★-★-☆-4"><a href="#面试高频指数：★-★-★-★-☆-4" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul>
<li>React 合成事件是浏览器的原生事件的跨浏览器包装器<ul>
<li>兼容所有浏览器</li>
<li>接口与浏览器原生事件相同，包括 <code>stopPropagation()</code> 和 <code>preventDefault()</code></li>
<li>合成事件实例将被传递给事件处理函数</li>
</ul>
</li>
<li>事件池<ul>
<li>React 16 及更早版本，合成事件是合并而来，放入事件池统一管理<ul>
<li>事件对象可能会被重用<ul>
<li>在事件回调函数被调用后，所有属性失效</li>
<li>不能通过异步访问事件属性</li>
</ul>
</li>
<li>异步访问事件属性<ul>
<li>调用 <code>e.persist()</code>，从事件池中移除合成事件，允许用户代码保留对事件的引用</li>
<li>通过实例的 <code>nativeEvent</code>属性来使用浏览器的底层事件</li>
</ul>
</li>
</ul>
</li>
<li>React 17 合成事件不再放入事件池<ul>
<li><code>e.persist()</code> 存在，但不再生效</li>
<li>可以通过异步访问事件属性</li>
</ul>
</li>
</ul>
</li>
<li>事件执行顺序<ul>
<li>原生事件先执行</li>
<li>合成事件后执行<ul>
<li>默认事件处理函数在冒泡阶段触发</li>
<li>注册捕获阶段事件处理函数，应为事件名添加 Capture</li>
</ul>
</li>
</ul>
</li>
<li>合成事件会冒泡<ul>
<li>React 16 及更早版本，冒泡绑定到 document 上</li>
<li>React 17，冒泡到 rootNode 上，onScroll 事件不再冒泡</li>
</ul>
</li>
</ul>
<h3 id="如何在-React-事件处理阻止默认行为？"><a href="#如何在-React-事件处理阻止默认行为？" class="headerlink" title="如何在 React 事件处理阻止默认行为？"></a>如何在 React 事件处理阻止默认行为？</h3><p>调用 <code>e.preventDefault</code> 阻止默认行为。</p>
<h3 id="如何解决-类组件-中，事件处理的-this-为-undefined-的问题？"><a href="#如何解决-类组件-中，事件处理的-this-为-undefined-的问题？" class="headerlink" title="如何解决 类组件 中，事件处理的 this 为 undefined 的问题？"></a>如何解决 类组件 中，事件处理的 this 为 undefined 的问题？</h3><ul>
<li>使用 Function.pototype.bind，添加事件处理函数时，给函数绑定 this</li>
<li>使用 public class fields 语法，可以使用 class fields 正确的绑定回调函数</li>
<li>使用 匿名回调函数 添加事件，不推荐，原因是<ul>
<li>匿名回调函数成为组件的 prop 传入子组件，可能导致额外的重新渲染</li>
</ul>
</li>
</ul>
<h3 id="如何传参给事件处理函数？"><a href="#如何传参给事件处理函数？" class="headerlink" title="如何传参给事件处理函数？"></a>如何传参给事件处理函数？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-5"><a href="#面试高频指数：★-☆-☆-☆-☆-5" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>两种方式</p>
<ul>
<li>箭头函数<ul>
<li>声明一个匿名箭头函数，在其中调用事件处理函数并传参</li>
<li>不推荐，原因是：<ul>
<li>匿名回调函数成为组件的 prop 传入子组件，可能导致额外的重新渲染</li>
</ul>
</li>
</ul>
</li>
<li>Function.pototype.bind<ul>
<li>bind 将返回一个新函数，新函数的 this 是 bind 的一个参数，其余参数将作为函数的参数，供调用时使用</li>
</ul>
</li>
</ul>
<h3 id="如何阻止事件处理函数被频繁调用？"><a href="#如何阻止事件处理函数被频繁调用？" class="headerlink" title="如何阻止事件处理函数被频繁调用？"></a>如何阻止事件处理函数被频繁调用？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-13"><a href="#面试高频指数：★-★-☆-☆-☆-13" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li><p>节流</p>
<ul>
<li>一定时间内一定调用一次事件处理函数</li>
<li>核心区别：定时器不重置</li>
<li>连续重复调用，定时器不重置，只有第一次调用生效，忽略后面调用</li>
<li>手写代码<ul>
<li>原生</li>
</ul>
</li>
</ul>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> throttle = (fn, delay) =&gt; &#123;<br>	let timer = <span class="hljs-literal">null</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<br>		<span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span><br>		timer = setTimeout(() =&gt; &#123;<br>			timer = <span class="hljs-literal">null</span><br>			fn.apply(<span class="hljs-keyword">this</span>, args)<br>		&#125;, (delay + <span class="hljs-string">&#x27;&#x27;</span>) | <span class="hljs-number">0</span> || <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>)<br>	&#125;<br>&#125;<br>    * 原生  + React Hook<br></code></pre></td></tr></table></figure>

<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">const</span> useThrottle (<span class="hljs-function"><span class="hljs-keyword">fn</span>, <span class="hljs-title">delay</span>) =&gt; </span>&#123;<br>	<span class="hljs-keyword">const</span> ref = useRef(<span class="hljs-function"><span class="hljs-keyword">fn</span>)</span><br><span class="hljs-function">	<span class="hljs-title">useEffect</span><span class="hljs-params">(<span class="hljs-params">()</span> =&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">		ref.current = fn</span></span><br><span class="hljs-params"><span class="hljs-function">	&#125;)</span></span><br><span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-title">useCallback</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">throttle<span class="hljs-params">(<span class="hljs-params">(...args)</span> =&gt; ref.current<span class="hljs-params">(...args)</span>, delay)</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">[delay]</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>防抖</p>
<ul>
<li>一定时间内最多调用一次事件处理函数</li>
<li>核心区别：定时器重置</li>
<li>连续重复调用，定时器重置，只有最后一次调用生效，忽略前面调用</li>
<li>手写代码<ul>
<li>原生</li>
</ul>
</li>
</ul>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> debounce = (fn, delay) =&gt; &#123;<br>	let timer = <span class="hljs-literal">null</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<br>		<span class="hljs-keyword">if</span> (timer) clearTimeout(timer)<br>		timer = setTimeout(() =&gt; &#123;<br>			timer = <span class="hljs-literal">null</span><br>			fn.apply(<span class="hljs-keyword">this</span>, args)<br>		&#125;, (delay + <span class="hljs-string">&#x27;&#x27;</span>) | <span class="hljs-number">0</span> || <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>)<br>	&#125;<br>&#125;<br>    * 原生 + React Hook<br></code></pre></td></tr></table></figure>

<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">const</span> useDebounce (<span class="hljs-function"><span class="hljs-keyword">fn</span>, <span class="hljs-title">delay</span>) =&gt; </span>&#123;<br>	<span class="hljs-keyword">const</span> ref = useRef(<span class="hljs-function"><span class="hljs-keyword">fn</span>)</span><br><span class="hljs-function">	<span class="hljs-title">useEffect</span><span class="hljs-params">(<span class="hljs-params">()</span> =&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">		ref.current = fn</span></span><br><span class="hljs-params"><span class="hljs-function">	&#125;)</span></span><br><span class="hljs-function">	<span class="hljs-title">return</span> <span class="hljs-title">useCallback</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">	debounce<span class="hljs-params">(<span class="hljs-params">(...args)</span> =&gt; ref.current<span class="hljs-params">(...args)</span>, delay)</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">	[delay]</span></span><br><span class="hljs-params"><span class="hljs-function">	)</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="React-17-对事件处理做了哪些改进？"><a href="#React-17-对事件处理做了哪些改进？" class="headerlink" title="React 17 对事件处理做了哪些改进？"></a>React 17 对事件处理做了哪些改进？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-14"><a href="#面试高频指数：★-★-☆-☆-☆-14" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>更改事件委托<ul>
<li>更加安全地进行新旧版本 React 树嵌套，多版本都必须为 17 或更高版本<ul>
<li>React 16 及之前版本<ul>
<li>向 document 附加事件处理器</li>
<li>大多数事件执行 <code>document.addEventListener</code></li>
</ul>
</li>
<li>React 17<ul>
<li>向 React 树的根 DOM 容器附加事件处理器</li>
<li>大多数事件执行 <code>rootNode.addEventListener</code></li>
</ul>
</li>
</ul>
</li>
<li>React 嵌入使用其他技术构建的应用程序变得更加容易<ul>
<li>React 16 及之前版本<ul>
<li><code>e.stopPropagation()</code> 将被多 React 版本破坏，嵌套树结构中阻止了事件冒泡，但外部树依然能接收到它</li>
<li><code>e.stopPropagation()</code> 不会阻止其它技术构建应用的冒泡</li>
</ul>
</li>
<li>React 17 的事件冒泡更接近常规 DOM，更符合预期<ul>
<li><code>e.stopPropagation()</code> 将阻止多 React 版本的事件冒泡，包括前套树和外部树</li>
<li><code>e.stopPropagation()</code> 将阻止其它技术构建应用的冒泡</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>对标浏览器<ul>
<li>React 16 及之前版本<ul>
<li><code>onScroll</code> 事件冒泡，<code>onFocus</code> 事件冒泡</li>
<li><code>onFocus</code> 和 <code>onBlur</code> 事件底层由 React 实现</li>
<li>捕获事件（例如 <code>onClickCapture</code>）由 React 实现</li>
</ul>
</li>
<li>React 17 与浏览器行为更接近，并提高了互操作性<ul>
<li><code>onScroll</code> 事件不再冒泡</li>
<li><code>onFoucs</code> 和 <code>onBlur</code> 事件底层切换为原生的 <code>focusin</code> 和 <code>focusout</code> 事件</li>
<li>捕获事件（例如 <code>onClickCapture</code>）现在使用的是实际浏览器中的捕获监听器</li>
</ul>
</li>
</ul>
</li>
<li>去除事件池<ul>
<li>React 16 及以前版本<ul>
<li>使用 event pooling（事件池）</li>
<li>重用不同事件的事件对象，以提高性能</li>
<li>所有事件字段会被重置为 <code>null</code>，必须调用 <code>e.persist()</code> 才能正确使用事件，或者读取需要的属性</li>
</ul>
</li>
<li>React 17 去除事件池，事件对象行为符合预期<ul>
<li>去除事件池</li>
<li>不再重用事件对象，避免对现代浏览器的负优化</li>
<li>所有事件对象不会被重置为 <code>null</code>，无需调用 <code>e.persist()</code>，使用和读取属性与原生事件一致。<code>e.persist()</code> 为兼容而保留，已无实际作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="样式管理"><a href="#样式管理" class="headerlink" title="样式管理"></a>样式管理</h2><h3 id="如何在-React-中使用样式？"><a href="#如何在-React-中使用样式？" class="headerlink" title="如何在 React 中使用样式？"></a>如何在 React 中使用样式？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-6"><a href="#面试高频指数：★-☆-☆-☆-☆-6" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li>Style<ul>
<li><code>style</code> 属性接收含有驼峰命名的 javaScript 对象</li>
<li>属性名与 JS DOM API 一致，防止 XSS</li>
<li>React 自动添加 px 后缀到内联样式为数字的属性之后</li>
<li><code>style</code> 多用于在渲染过程中添加动态计算的样式</li>
<li>从性能角度来说，通常不推荐将 <code>style</code> 属性作为设置元素样式的主要方式，应使用<code>className</code> 属性来引用外部 CSS 样式表中定义的 class</li>
</ul>
</li>
<li>Class<ul>
<li><code>className</code> 支持字符串</li>
<li><code>className</code> 支持大括号包裹的 JS 表达式</li>
</ul>
</li>
<li>CSS-in-JS<ul>
<li>CSS 由 JavaScript 生成而不是在外部文件中定义</li>
<li>常用的库包括styled-componentsemotion radium 和 aphrodite 等</li>
<li>React 对样式如何定义没有明确态度<ul>
<li>存在疑惑时，比较好的方式是使用 <code>*.css</code> 定义样式，通过 <code>className</code> 指定它们</li>
</ul>
</li>
</ul>
</li>
<li>动画<ul>
<li>渐变效果，可选 <code>React Transition Group</code></li>
<li>动画效果，可选 <code>React Motion</code> 和 <code>React Spring</code></li>
</ul>
</li>
</ul>
<h3 id="如何按条件加载样式？"><a href="#如何按条件加载样式？" class="headerlink" title="如何按条件加载样式？"></a>如何按条件加载样式？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-7"><a href="#面试高频指数：★-☆-☆-☆-☆-7" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li>Style</li>
</ul>
<p><code>style</code> 采用小驼峰命名属性的 JavaScript 对象，可以按照 JavaScript 对象的方式，有条件地改变属性名和属性值</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> style = &#123;<br>	[<span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">&#x27;fontSize&#x27;</span> : <span class="hljs-string">&#x27;lineHeight&#x27;</span>] : <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">12</span> : <span class="hljs-number">1</span><br>&#125; <span class="hljs-comment">// &#123; fontSize: 12 &#125;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<br>	<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;style&#125;</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> <span class="hljs-comment">// style=&quot;font-size: 12px&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Class</li>
</ul>
<p><code>className</code> 属性，可以传入 JavaScript 表达式，有条件改变的类名</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> className = <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">&#x27;menu-active&#x27;</span> : <span class="hljs-string">&#x27;menu&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<br>	<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;className&#125;</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> <span class="hljs-comment">// class=&quot;menu-active&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>CSS-in-JS</li>
</ul>
<p>以styled-components 为例</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>模板字符串<br></code></pre></td></tr></table></figure>

<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = styled.<span class="hljs-property">button</span><span class="hljs-string">`</span><br><span class="hljs-string">background: <span class="hljs-subst">$&#123;props =&gt; props.primary ? <span class="hljs-string">&#x27;palevioletred&#x27;</span> : <span class="hljs-string">&#x27;white&#x27;</span>&#125;</span>,</span><br><span class="hljs-string">`</span> <span class="hljs-comment">// background: palevioletred</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<br>	<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br>&#125;<br>* <span class="hljs-title class_">JavaScript</span> 对象<br></code></pre></td></tr></table></figure>

<p>- </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = styled.<span class="hljs-title function_">div</span>(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> (&#123;<br>	<span class="hljs-attr">background</span>: props.<span class="hljs-property">primary</span> ? <span class="hljs-string">&#x27;palevioletred&#x27;</span> : <span class="hljs-string">&#x27;white&#x27;</span><br>&#125;)); <span class="hljs-comment">// background: palevioletred</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<br>	<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span><br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="如何合并多个内联样式"><a href="#如何合并多个内联样式" class="headerlink" title="如何合并多个内联样式?"></a>如何合并多个内联样式?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-8"><a href="#面试高频指数：★-☆-☆-☆-☆-8" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p><code>style</code>采用小驼峰命名属性的 JavaScript 对象</p>
<p>任何合并 JavaScript 对象的方法都可以用于合并内联样式</p>
<ul>
<li><p>拓展运算符</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> backgroundStyle = &#123; <span class="hljs-attr">background</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<br><span class="hljs-keyword">const</span> colorStyle = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<br>	<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">...backgroundStyle</span>, <span class="hljs-attr">...colorStyle</span> &#125;&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Object.assign</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> backgroundStyle = &#123; <span class="hljs-attr">background</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<br><span class="hljs-keyword">const</span> colorStyle = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<br>	<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;Object.assign(backgroundStyle,</span> <span class="hljs-attr">colorStyle</span>)&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>遍历赋值</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> backgroundStyle = &#123; <span class="hljs-attr">background</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<br><span class="hljs-keyword">const</span> colorStyle = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(colorStyle).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> backgroundStyle[key] = colorStyle[key])<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<br>	<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;backgroundStyle&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="如何模块化样式，如何避免样式名冲突-？"><a href="#如何模块化样式，如何避免样式名冲突-？" class="headerlink" title="如何模块化样式，如何避免样式名冲突 ？"></a>如何模块化样式，如何避免样式名冲突 ？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-15"><a href="#面试高频指数：★-★-☆-☆-☆-15" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>（1）什么是 CSS 模块化？</p>
<p>CSS 模块化是将 CSS 规则 拆分成相对独立的模块，便于开发者在项目中更有效率地组织 CSS</p>
<ul>
<li>管理层叠关系</li>
<li>避免命名冲突</li>
<li>提高复用度，减少冗余</li>
<li>便于维护或扩展</li>
</ul>
<p>CSS 模块化的方式</p>
<ul>
<li>基于文件拆分</li>
<li>不拆分但设置作用域</li>
<li>CSS in JS</li>
<li>内联样式、Shadow DOM 等</li>
</ul>
<p>无论哪种方式，核心都是通过 保证CSS类命名唯一，或者 避免命名使用内联样式，来模拟出CSS模块作用域的效果</p>
<p>（2）基于文件的 CSS 模块的加载</p>
<ul>
<li><code>&lt;link&gt;</code><br>将不同模块的 CSS 分文件存放，通过 <code>&lt;link&gt;</code> 标签按需引入</li>
<li><code>@import</code><br>@规则，将其它 CSS 嵌入当前 CSS<br>除现代浏览器外，也得到了 CSS 预处理器 Less、Sass 和 Stylus 的支持</li>
<li><code>import</code><br>在 Webpack 中，将 CSS 作为资源引入，通过 CSS Modules 生成独一无二的类名</li>
</ul>
<p>（3）CSS 模块化的实现方式</p>
<ul>
<li><p>分层拆分</p>
<p>将 CSS规则 分层存放，并约束不同层次间的命名规则</p>
<ul>
<li>SMACSS：按功能分成 Base Layout Module State Theme 五层</li>
<li>ITCSS：按从通用到具体分成 Settings Tools Generic Base Objects Components 七层</li>
</ul>
</li>
<li><p>分块拆分</p>
<p>将页面中视觉可复用的块独立出来，仅使用类选择器，并确保类名唯一</p>
<ul>
<li>OOCSS<ul>
<li>将盒模型规则与颜色、背景等主题规则拆分</li>
<li>将视觉可复用的块类名与页面结构解耦</li>
</ul>
</li>
<li>BEM<ul>
<li>将页面按 Block Element Modifier 划分</li>
<li>类名规则 block-name__element-name–modifier-name</li>
</ul>
</li>
</ul>
</li>
<li><p>原子化拆分</p>
<p>每个选择器只包含 1 个或少量属性，通过组合选择器定义复杂样式</p>
<ul>
<li>ACSS：属性名像函数，属性值像函数参数，像写内联样式一样组合类名</li>
<li>Utility-First CSS：提供一套可配置的 CSS 实用类库，使用时按需编译</li>
</ul>
</li>
<li><p>CSS in JS</p>
<ul>
<li>CSS Modules<ul>
<li>将 CSS 作为资源引入</li>
<li>根据内容的哈希字符串，计算出独一无二类名，CSS 规则 只对该类名下的元素生效</li>
</ul>
</li>
<li>styled-components Aphrodite Emotion 等<ul>
<li>通过 JS 创建包含属性定义的组件</li>
<li>生成独一无二的类名</li>
</ul>
</li>
<li>Radium 等<ul>
<li>通过 JS 创建包含属性定义的组件</li>
<li>生成内联样式</li>
</ul>
</li>
</ul>
</li>
<li><p>Shadow DOM<br>通过<code>attachShadow</code>给元素的影子DOM，附加<code>&lt;style&gt;</code>标签，其中规则不会影响外部元素。代表的框架有 Ionic 等</p>
</li>
</ul>
<p>（4）React 中的样式模块化</p>
<p>React 对样式如何定义，没有明确的态度，如果存在疑虑，比较好的方式是和平常一样，在一个单独的 <code>*.css</code> 定义你的样式，并通过 <code>className</code> 指定它们。此时，你可以参考 CSS 模块化的方案，通过文件或样式命名规则，来实现样式模块化</p>
<p>行内样式 <code>style</code> 是避免样式命名冲突的经典策略，但由于性能比 <code>className</code> 低，React 通常不推荐将 style 属性作为设置元素样式的主要方式。在多数情况下，应使用 <code>className</code> 属性来引用外部 CSS 样式表重定义的 <code>class</code>。<code>style</code> 在 React 应用中多用于在渲染过程中添加动态计算的样式</p>
<p>同样地，在 CSS-in-JS 中，早期有基于 <code>style</code> 实现的 Radium 库，现在比较流行的是基于随机 <code>className</code> 的 style-components 库，与之类似的有 Emotion 和 Glamor，还有面向愿意将 CSS 和 JavaScript 分开存放开发者的 JSS 等。</p>
<h2 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h2><h3 id="什么是-React-Hook"><a href="#什么是-React-Hook" class="headerlink" title="什么是 React Hook?"></a>什么是 React Hook?</h3><p>Hook 是 React 16.8 的新增特性</p>
<ul>
<li>允许开发者在函数组件里“钩入”React state 及生命周期等特性的函数<ul>
<li>React 内置如 useState、useEffect 等 Hook</li>
</ul>
</li>
<li>Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）<ul>
<li>非强制按照生命周期划分，避免每个生命周期包含不相关的逻辑</li>
</ul>
</li>
<li>开发者可以在不编写 class 的情况下使用 state 以及其他的 React 特性<ul>
<li>无需考虑 this，无需考虑函数和 class 组件的区别和应用场景</li>
<li>便于使用 Prepack 试验 component folding，使代码更易于优化</li>
<li>拥抱函数式编程</li>
</ul>
</li>
<li>Hook 和现有代码可以同时工作，渐进式地使用</li>
</ul>
<h3 id="什么是-State-Hook？"><a href="#什么是-State-Hook？" class="headerlink" title="什么是 State Hook？"></a>什么是 State Hook？</h3><h4 id="面试高频指数：★-★-★-☆-☆-7"><a href="#面试高频指数：★-★-★-☆-☆-7" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul>
<li>State Hook 允许开发者在 React 函数组件中添加 state 的 Hook</li>
<li>这种 Hook 在 React 的原生实现是 useState，它是一种函数调用时保存变量的方式，它与 class 里面的 this.state 提供的功能完全相同</li>
<li>useState 的唯一参数是初始 state，支持数字、字符串、对象等类型</li>
<li>useState 方法的返回值分别是当前 state 以及更新 state 的函数，使用数组解构获取赋值</li>
<li>state 只在组件首次渲染时创建，下次重新渲染时，返回当前的 state</li>
</ul>
<h3 id="什么是-Effect-Hook？"><a href="#什么是-Effect-Hook？" class="headerlink" title="什么是 Effect Hook？"></a>什么是 Effect Hook？</h3><h4 id="面试高频指数：★-★-★-☆-☆-8"><a href="#面试高频指数：★-★-★-☆-☆-8" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul>
<li>Effect Hook 允许开发者在函数组件中执行副作用操作，包括数据获取、设置订阅以及手动更改 React 组件中的 DOM。分为需要清除和不需要清除的</li>
<li>这种 Hook 在 React 的原生实现是 useEffect</li>
<li>useEfect 支持两个参数<ul>
<li>第一个参数为函数，默认在组件第一次渲染和每次更新、浏览器完成画面渲染之后执行，调用时机可以看作 class 组件的 componentDidMount、componentDidUpdate 生命周期 + 浏览器完成画面渲染时</li>
<li>第二个参数为数组，只有数组元素发生变化时，才会调用第一个参数的函数<ul>
<li>当第二个参数为空数组 [] 时，第一个参数的函数仅会在组件挂载和卸载时执行</li>
</ul>
</li>
</ul>
</li>
<li>useEffect 可以返回一个函数，用于移除订阅等副作用，区别 class 组件的 componetWillUnMount，React 会在执行当前 effect 之前对上一个 effect 进行清除</li>
<li>useEffect 放在最贱内部可以直接访问 state 和 props</li>
</ul>
<h3 id="如何清除-Effect-Hook-的副作用？"><a href="#如何清除-Effect-Hook-的副作用？" class="headerlink" title="如何清除 Effect Hook 的副作用？"></a>如何清除 Effect Hook 的副作用？</h3><h4 id="面试高频指数：★-★-★-★-☆-5"><a href="#面试高频指数：★-★-★-★-☆-5" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul>
<li>在 useEffect 的 effect 函数中，返回一个清除函数<ul>
<li>可以将添加和清除副作用的逻辑放在一起</li>
</ul>
</li>
<li>effect 在每次渲染的时候会执行，<ul>
<li>React 会在执行当前 effect 之前对上一个 effect 进行清除</li>
</ul>
</li>
</ul>
<h3 id="使用-Hook-需要遵循的规则是？"><a href="#使用-Hook-需要遵循的规则是？" class="headerlink" title="使用 Hook 需要遵循的规则是？"></a>使用 Hook 需要遵循的规则是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-16"><a href="#面试高频指数：★-★-☆-☆-☆-16" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>Hook 本质是 JavaScript 函数，使用 Hook 时需要遵循两条规则</p>
<ul>
<li>只在最顶层使用 Hook<ul>
<li>不要在循环，条件或嵌套函数中调用 Hook<ul>
<li>确保总在 React 函数的最顶层调用 Hook</li>
<li>确保 Hook 在每一次渲染都按照相同的顺序被调用<ul>
<li>多次的 useState 和 useEffect 调用中间保持 Hook 状态正确</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>只在 React 函数中调用 Hook<ul>
<li>仅在 React 的函数组件，而不要在普通的 JavaScript 函数中调用 Hook</li>
<li>在自定义 Hook 中调用其他 Hook</li>
</ul>
</li>
</ul>
<h3 id="如何校验-Hook-是否遵循规则？"><a href="#如何校验-Hook-是否遵循规则？" class="headerlink" title="如何校验 Hook 是否遵循规则？"></a>如何校验 Hook 是否遵循规则？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-17"><a href="#面试高频指数：★-★-☆-☆-☆-17" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>React 提供了一个名为 eslint-plugin-react-hooks 的 ESLint 插件来校验 Hook 是否遵循规则</p>
<ul>
<li><p>安装</p>
</li>
<li><p>shell</p>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> eslint-plugin-react-hooks -D<br></code></pre></td></tr></table></figure>

<ul>
<li><p>ESLint 配置</p>
</li>
<li><p>JSON</p>
</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>	<span class="hljs-string">&quot;plugin&quot;</span>: [<br>	<span class="hljs-regexp">//</span> ...<br>	<span class="hljs-string">&quot;react-hooks&quot;</span><br>	],<br>	<span class="hljs-string">&quot;rules&quot;</span>: &#123;<br>		<span class="hljs-regexp">//</span> ...<br>		<span class="hljs-string">&quot;react-hooks/rules-of-hooks&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-regexp">//</span> 检查 Hook 规则<br>		<span class="hljs-string">&quot;react-hooks/exhaustive-deps&quot;</span>: <span class="hljs-string">&quot;warn&quot;</span> <span class="hljs-regexp">//</span> 检查 effect 依赖<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="useMemo-和-useCallback-的区别是？"><a href="#useMemo-和-useCallback-的区别是？" class="headerlink" title="useMemo 和 useCallback 的区别是？"></a>useMemo 和 useCallback 的区别是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-18"><a href="#面试高频指数：★-★-☆-☆-☆-18" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>useMemo</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const memoizedValue = use<span class="hljs-constructor">Memo(()</span> =&gt; compute<span class="hljs-constructor">ExpensiveValue(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>, <span class="hljs-literal">[<span class="hljs-identifier">a</span>, <span class="hljs-identifier">b</span>]</span>)<br></code></pre></td></tr></table></figure>

<p>返回一个<code>memoized</code>值，把”创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销计算。<br>useCallback</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const memoizedCallback = use<span class="hljs-constructor">Callback(()</span> =&gt; &#123; <span class="hljs-keyword">do</span><span class="hljs-constructor">Something(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span> &#125;, <span class="hljs-literal">[<span class="hljs-identifier">a</span>, <span class="hljs-identifier">b</span>]</span>)<br></code></pre></td></tr></table></figure>

<p>返回一个<code>memoized</code>回调函数，把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。<br>useCallback 可看作函数组件的<code>shouldCompoentUpdate</code>，使用引用相等性避免非必要渲染</p>
<p>useCallback 返回的是函数，useMemo 返回的是值，也可以是函数</p>
<p>useCallback(fn, deps) 相当于 useMemo(() &#x3D;&gt; fn, deps)</p>
<h3 id="useReducer-和-useState-的区别是？"><a href="#useReducer-和-useState-的区别是？" class="headerlink" title="useReducer 和 useState 的区别是？"></a>useReducer 和 useState 的区别是？</h3><h4 id="面试高频指数：★-★-★-☆-☆-9"><a href="#面试高频指数：★-★-★-☆-☆-9" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>useReducer</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialArg, init)<br></code></pre></td></tr></table></figure>

<p>useReducer 是 useState 的替代方案，它接收一个形如<code>(state, action) =&gt; newState</code>的 reducer，返回当前的 state 及其配套的<code>dispatch</code>方法<br>useReducer 比 useState 更适用于某些场景</p>
<ul>
<li>state 逻辑较复杂，并且包含多个子值</li>
<li>下一个 state 依赖于之前的 state</li>
</ul>
<p>useReducer 第二个返回值是 dispatch 而不是回调函数</p>
<ul>
<li>可以向子组件传递 dispatch 而不是函数<ul>
<li>容易会触发深更新的组件做性能优化</li>
</ul>
</li>
</ul>
<h3 id="useLayoutEffect-和-useEffect-的区别是？"><a href="#useLayoutEffect-和-useEffect-的区别是？" class="headerlink" title="useLayoutEffect 和 useEffect 的区别是？"></a>useLayoutEffect 和 useEffect 的区别是？</h3><h4 id="面试高频指数：★-★-★-☆-☆-10"><a href="#面试高频指数：★-★-★-☆-☆-10" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>useLayoutEffect</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>	<span class="hljs-comment">// add effect</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"></span>) &#123;<br>		<span class="hljs-comment">// clean effect</span><br>	&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>相同</p>
<ul>
<li>useLayoutEffect 的签名与 useEffect 相同</li>
<li>服务端渲染时，useLayoutEffect 和 useEffect 都无法在 Javascript 代码加载完成前执行<ul>
<li>服务端渲染组件引入 useLayoutEffect 触发 React 告警，解决<ul>
<li>使用 useEffect 替代 useLayoutEffect</li>
<li>或将该组件延迟到客户端渲染完成后再显示</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>区别</p>
<ul>
<li>useLayoutEffect<ul>
<li>在所有 DOM 变更之后同步调用 effect，用来读取 DOM 布局并同步触发重渲染</li>
<li>在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新</li>
</ul>
</li>
<li>useEffect<ul>
<li>在所有 DOM 变更并且浏览器完成渲染后调用 effect</li>
<li>尽可能使用标准的 useEffect 以避免阻塞视觉更新<ul>
<li>只有 useEffect 有问题时，再尝试 useLayoutEffect</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="useRef-和-Refs-的区别是？"><a href="#useRef-和-Refs-的区别是？" class="headerlink" title="useRef 和 Refs 的区别是？"></a>useRef 和 Refs 的区别是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-19"><a href="#面试高频指数：★-★-☆-☆-☆-19" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>useRef</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">ref</span>Container = useRef(initialValue)<br></code></pre></td></tr></table></figure>

<p>useRef 返回一个可变的 ref 对象，其<code>.current</code>属性被初始化传入参数<code>initialValue</code><br>返回的 ref 对象在组件的整个生命周期保持不变</p>
<p>Refs</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>	constructor(props) &#123;<br>		<span class="hljs-keyword">super</span>(props)<br>		<span class="hljs-keyword">this</span>.myRef = <span class="hljs-type">React</span>.createRef()<br>	&#125;<br>	render() &#123;<br>		<span class="hljs-keyword">return</span> &lt;div ref=&#123;<span class="hljs-keyword">this</span>.myRef&#125; /&gt;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Refs 使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素<br>当 ref 被传递给 <code>render</code> 中的元素时，对节点的引用可以在 ref 的 <code>current</code> 属性中被访问</p>
<p>区别</p>
<p>useRef</p>
<ul>
<li><p>函数组件可用</p>
</li>
<li><p>用途多样，</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">useRef</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>创建一个普通 Javascript 对象，每次渲染时返回同一个 ref 对象</p>
<ul>
<li>可以在其<code>.current</code> 属性保存任何可变值</li>
</ul>
</li>
</ul>
<p>Refs</p>
<ul>
<li><p>class 组件或 HTML 元素，函数组件无实例，不可用</p>
</li>
<li><p>用途单一，</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.current</span><br></code></pre></td></tr></table></figure>

<p>属性为实例的引用，根据节点的类型不同</p>
<ul>
<li>当 <code>ref</code> 属性用于 HTML 元素时，构造函数中使用 <code>React.createRef()</code> 创建的<code>ref</code>接收底层 DOM 元素作为 <code>current</code> 属性</li>
<li>当 <code>ref</code> 属性用于自定义 class 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性</li>
</ul>
</li>
</ul>
<h3 id="如何自定义-Hook？"><a href="#如何自定义-Hook？" class="headerlink" title="如何自定义 Hook？"></a>如何自定义 Hook？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-20"><a href="#面试高频指数：★-★-☆-☆-☆-20" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>（1）自定义 Hook 定义</p>
<p>自定义 Hook，是将组件逻辑提取到可重用的函数，它可以像 <code>render props</code> 和高阶组件来共享组件之间的状态逻辑，而不增加组件</p>
<p>（2）如何自定义 Hook</p>
<p>自定义 Hook 是一个函数，可以调用其他的 Hook</p>
<ul>
<li>名称以 “use” 开头，表示这是一个 Hook<ul>
<li>便于 React 判断函数函数内部是否包含对其内部 Hook 的调用</li>
<li>自动检查 Hook 是否违法 Hook 规则</li>
</ul>
</li>
<li>参数和返回可以自定义，可以像使用函数一样在不同 Hook 间传递信息</li>
<li>其中所有 state 和副作用完全隔离，每次调用 Hook，都会获取独立的 state</li>
</ul>
<p>将两个函数组件的共同的状态逻辑提取到自定义 Hook 中，自定义 Hook 是一种自然遵循 Hook 设计的约定，而不是 React 的特性</p>
<p>（3）自定义 Hook 作用</p>
<p>自定义 Hook 解决了以前在 React 组件中无法灵活共享逻辑的问题</p>
<p>自定义 Hook 可以用于表单处理、动画、订阅声明、计时器等场景</p>
<p>尽量避免过早地增加抽象逻辑，当函数组件代码行数增多时，可以通过自定义 Hook 简化代码逻辑，解决组件杂乱无章。</p>
<h3 id="是否有必要使用-Hook-API-重写所有类组件？"><a href="#是否有必要使用-Hook-API-重写所有类组件？" class="headerlink" title="是否有必要使用 Hook API 重写所有类组件？"></a>是否有必要使用 Hook API 重写所有类组件？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-9"><a href="#面试高频指数：★-☆-☆-☆-☆-9" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>不，React 推荐称为编写 React 组件的主要方式，并且提供了自定义 Hook 等 class 组件无法实现的功能，更利于自动代码优化。但是</p>
<ul>
<li>Hook 暂时不能覆盖 class 组件的所有场景，比如生命周期<code>getSnapshotBeforeUpdate</code>，<code>getDerivedStateFromError</code> 和 <code>componentDidCatch</code> 暂无 Hook 等价写法</li>
<li>没有计划从 React 中移除 class</li>
</ul>
<p>所以，React 鼓励写新组件的时候开始尝试 Hook，不推荐用 Hook 重写已有的 class，除非开发者本来就打算重写它们（例如：为了修复 bug）</p>
<h3 id="useState-返回更新-state-的函数是同步，还是异步的？"><a href="#useState-返回更新-state-的函数是同步，还是异步的？" class="headerlink" title="useState 返回更新 state 的函数是同步，还是异步的？"></a>useState 返回更新 state 的函数是同步，还是异步的？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-21"><a href="#面试高频指数：★-★-☆-☆-☆-21" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>useState 返回更新 state 函数式异步的，接收参数可以是新状态的值，也可以是回调函数</p>
<p>可以通过两种方式，获取上一个 state 的状态值</p>
<ul>
<li>回调函数的第一个参数是上一个状态的值，可以像使用 useReducer 的 reducer 函数一样，基于上一个 state 来生成新的 state</li>
<li>或者可以在 useEffect 或 useLayoutEffect 中获取更新后的状态，将 useEffect 或 useLayoutEffect 封装到自定义 Hook 同样有效</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="什么是-Virtual-DOM"><a href="#什么是-Virtual-DOM" class="headerlink" title="什么是 Virtual DOM ?"></a>什么是 Virtual DOM ?</h3><h4 id="面试高频指数：★-★-★-★-★-2"><a href="#面试高频指数：★-★-★-★-★-2" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><p>Virtual DOM 是一编程概念</p>
<ul>
<li>UI 以一种理想化的，或者说“虚拟的”表现形式被保存在内存中<ul>
<li>支持可以优化的 Diff 算法</li>
</ul>
</li>
<li>通过 ReactDOM 等类库使之与“真实的” DOM 同步，这一过程叫做协调<ul>
<li>支持优先级，并行可中断的协调策略</li>
<li>支持 ReactCanvas 和 ReactNative 等其他渲染方式，甚至非浏览器环境</li>
</ul>
</li>
</ul>
<p>Virtual DOM 赋予 React 声明式的 API</p>
<ul>
<li>告诉 React 希望让 UI 是什么状态，React 就确保 DOM 匹配该状态</li>
<li>开发者不必关心属性操作、事件处理和手动 DOM 更新这些构建应用程序必要的操作</li>
</ul>
<p>Virtual DOM 是一种模式，在 React 中</p>
<ul>
<li>Virtual DOM 通常与 React 元素关联，代表用户界面的对象</li>
<li>fibers 内部对象来存放组件树的附加信息</li>
<li>React Fiber 是协调引擎，主要目的是使 Virtual DOM 可以增量式渲染</li>
</ul>
<h3 id="什么是-React-Diff，对比-Vue-Diff-？"><a href="#什么是-React-Diff，对比-Vue-Diff-？" class="headerlink" title="什么是 React Diff，对比 Vue Diff ？"></a>什么是 React Diff，对比 Vue Diff ？</h3><h4 id="面试高频指数：★-★-★-★-★-3"><a href="#面试高频指数：★-★-★-★-★-3" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><p>虚拟 DOM 的 Diff 算法</p>
<ul>
<li>将新旧虚拟 DOM 看作两棵节点树，节点个数为 n<ul>
<li>左侧树的节点需要与右侧树的节点一一对比，需要 O(n²) 复杂度</li>
<li>删除未找到的节点，需要再找合适节点放到被删除位置，需要 O(n) 复杂度</li>
<li>添加新节点，需要 O(n) 复杂度</li>
</ul>
</li>
<li>综上，Diff 虚拟 DOM 的复杂度是 O(n³)</li>
</ul>
<p>React 基于以下两个假设的基础之上提出 O(n) 的启发式算法</p>
<ul>
<li>两个不同类型的元素会产生不同的树</li>
<li>可以通过设置 <code>key</code> 属性，来告知渲染哪些子元素在不同的渲染下可以保存不变</li>
</ul>
<p>React Diffing 算法</p>
<ul>
<li>Tree Diff<ul>
<li>对比两棵树时，首选比较两棵树的根节点。不同类型的根节点元素会有不同的形态<ul>
<li>根节点为不同类型的元素<ul>
<li>React 会拆卸原有的树并且建立起新的树</li>
<li>当卸载一棵树时<ul>
<li>对应的 DOM 节点会被销毁<ul>
<li>建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中</li>
</ul>
</li>
<li>组件实例将执行 <code>componentWillUnmount()</code> 方法</li>
</ul>
</li>
</ul>
</li>
<li>根节点为相同类型的元素<ul>
<li>React 会保留节点</li>
<li>仅比对及更新有改变的属性</li>
</ul>
</li>
<li>处理完根节点，React 继续对子节点进行递归</li>
</ul>
</li>
<li>通过 updateDepth 控制 Virtual Dom 树层级</li>
<li>只比较同一个父节点的子节点</li>
<li>通过删除和创建节点实现跨层级移动</li>
<li>避免跨层级移动，优先 CSS 控制显示隐藏</li>
</ul>
</li>
<li>Component Diff<ul>
<li>同类型组件<ul>
<li>组件实例会保持不变，因此可以在不同的渲染时保持 state 一致</li>
<li>React 将更新该组件实例的 props 以及保证与最新的元素保持一致</li>
<li>调用该实例的 <code>UNSAFE_componentWillReceiveProps</code>、 <code>UNSAFE_componentWillUpdate()</code> 以及 <code>componentDidUpdate()</code> 方法</li>
<li>调用 <code>render()</code> 方法，diff 算法将在之前的结果以及新的结果中进行递归</li>
<li>通过 shouldComponentUpdate、useMemo、useCallback 手动优化</li>
<li>不同类型组件，输出内容相似<ul>
<li>建议改成同一类型，避免重新渲染组件</li>
</ul>
</li>
</ul>
</li>
<li>不同类型组件<ul>
<li>删除和创建</li>
</ul>
</li>
</ul>
</li>
<li>Element Diff<ul>
<li>默认情况下，React 会同时遍历两个子元素的列表，递归 DOM 节点的子元素<ul>
<li>产生差异时，生成一个 mutation</li>
</ul>
</li>
<li>用 key 标识节点<ul>
<li>避免使用索引 index，而应使用例如 id 唯一标识来作为 key</li>
</ul>
</li>
<li>只顺序移动位置变到前面的节点</li>
<li>相同类型 React 元素，保留 DOM 节点，仅对比及更新改变的属性</li>
</ul>
</li>
</ul>
<p>Vue 2.x 优化 Diff 算法</p>
<ul>
<li>基本优化与 React 相同</li>
<li>pathNode<ul>
<li>新老节点相同，不更新</li>
<li>新老节点都是静态节点，key 相同<ul>
<li>新节点.elm &#x3D; 老节点.elm</li>
<li>新节点.componentInstance &#x3D; 老节点.componentInstance</li>
</ul>
</li>
<li>新老节点存在，不相同<ul>
<li>用 updateChildren 更新</li>
</ul>
</li>
</ul>
</li>
<li>updateChildren<ul>
<li>虚拟 DOM 双指针，真实 DOM 双指针，一一对应</li>
<li>两端到中间，直到虚拟 DOM 或真实 DOM，左指针 &gt; 右指针</li>
</ul>
</li>
</ul>
<p>Vue 3.x 优化 Diff 算法</p>
<ul>
<li>创建 VNode 确定类型，内容不会变化的 DOM 添加静态标记</li>
<li>在 mount &#x2F; patch 中用位运算判断 VNode 类型<ul>
<li>静态提升 hoistStatic<ul>
<li>不参与更新的元素，只创建一次，渲染时直接复用</li>
</ul>
</li>
<li>事件侦听器缓存 cacheHandlers<ul>
<li>缓存函数，不追踪变化，提升性能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="什么是-React-Concurrent-模式"><a href="#什么是-React-Concurrent-模式" class="headerlink" title="什么是 React Concurrent 模式?"></a>什么是 React Concurrent 模式?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-10"><a href="#面试高频指数：★-☆-☆-☆-☆-10" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>Concurrent 模式是一组 React 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整</p>
<p>Concurrent 模式的特点包括</p>
<ul>
<li>可中断渲染<ul>
<li>中断一项正在执行的更新去做更重要的事情，然后再回到之前正在做的工作</li>
<li>减少防抖和节流在 UI 中的需求。因为渲染可以终端，不需要人为地延迟工作以避免卡顿</li>
</ul>
</li>
<li>有意的加载顺序<ul>
<li>React 首先在内存中准备新屏幕</li>
<li>之前，React 继续显示完全互动，带有内联加载指示器的旧屏幕</li>
<li>当新屏幕准备就绪之后，React 可以带我们跳转到新屏幕</li>
</ul>
</li>
<li>并发<ul>
<li>在 Concurrent 模式中，React 可以同时更新多个状态<ul>
<li>对于 CPU 密集更新（例如创建新的 DOM 节点和运行组件中的代码），并发意味着一个更急迫的更新可以“中断”已经开始的渲染</li>
<li>对于 IO 密集的更新（例如从网络加载代码或数据），并发意味着 React 甚至可以在全部数据到达之前就在内存中开始渲染</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Concurrent 模式的任务是帮助将人机交互研究的结果整合到真实的 UI 中</p>
<ul>
<li>避免在屏幕之间切换时显示过多的中间加载状态</li>
<li>对于用户输入、悬停、点击、页面转换等在内部使用不同的“优先级”，大致对应于人类感知研究中的交互类别</li>
</ul>
<p>Concurrent 模式的开启</p>
<ul>
<li><p>安装 React 实验版本</p>
</li>
<li><p>plain</p>
</li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install react@experimental react-dom@experimental<br></code></pre></td></tr></table></figure>

<ul>
<li>开启 Concurrent 模式<ul>
<li>blocking 模式：提供了 concurrent 模式的小部分功能，更接近于当前 React 的 legacy 模式<ul>
<li><code>ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)</code></li>
</ul>
</li>
<li>concurrent 模式：未来 React 默认开发模式<ul>
<li><code>ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Concurrent 模式常用 API</p>
<ul>
<li>Suspense<ul>
<li>允许组件在渲染之前进行“等待”，并在等待时显示 fallback 的内容</li>
</ul>
</li>
<li>SuspenseList<ul>
<li>通过编排向用户显示这些组件的顺序，来帮助协调血多可以挂起的组件</li>
</ul>
</li>
<li>useTransition<ul>
<li>允许组件在切换到下一个界面之前等待内容加载，从而避免不必要的加载状态</li>
<li>允许组件将速度较慢的数据获取更新推迟到随后渲染，以便能够立即渲染更重要的更新</li>
</ul>
</li>
<li>useDeferredValue<ul>
<li>返回一个延迟响应的值，该值可能“延后”的最长时间为 timeoutMs</li>
<li>适合立即渲染用户输入内容，同时需要等待数据获取的内容，保持接口可响应性的场景</li>
</ul>
</li>
</ul>
<h3 id="什么是-Suspense"><a href="#什么是-Suspense" class="headerlink" title="什么是 Suspense ?"></a>什么是 Suspense ?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-11"><a href="#面试高频指数：★-☆-☆-☆-☆-11" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li>Suspense 让组件“等待”某个异步操作，直到该异步操作结束即可渲染</li>
<li>Suspense 不是一个数据请求的库，而是一个机制<ul>
<li>这个机制是用来给数据请求库向React通信说明某个组件正在读取的数据当前仍不可用</li>
<li>通信之后，React可以继续等待数据的返回并更新UI</li>
</ul>
</li>
<li>Suspense不是什么<ul>
<li>不是数据获取的一种实现</li>
<li>不是直接用于数据获取的客户端</li>
<li>不使数据获取与视图层代码耦合</li>
</ul>
</li>
<li>Suspense可做什么<ul>
<li>让数据获取库与React紧密整合</li>
<li>让开发者有针对性地安排加载状态的展示</li>
<li>它能够消除 raceconditions，避免由于代码运行顺序的错误假设而导致的bug<ul>
<li>不是等到响应报文被接收之后，才去更新 State</li>
<li>反过来，发出请求之后，马上更新 State（外加开始渲染）</li>
</ul>
</li>
</ul>
</li>
<li>Suspense 可以不必等到数据全部返回才开始渲染<ul>
<li>一发送网络请求，马上开始渲染<ul>
<li>读取的数据没获取完毕，组件会处于“挂起”状态</li>
<li>React 会跳过“挂起”组件，继续渲染组件树中的其他组件</li>
</ul>
</li>
<li>随着更多数据的到来，React 将尝试重新渲染，并且每次都可能渲染出更加完整的组件树</li>
</ul>
</li>
</ul>
<h3 id="React-如何定义任务的优先级？"><a href="#React-如何定义任务的优先级？" class="headerlink" title="React 如何定义任务的优先级？"></a>React 如何定义任务的优先级？</h3><h4 id="面试高频指数：★-★-★-☆-☆-11"><a href="#面试高频指数：★-★-★-☆-☆-11" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>任务优先级是产生更新对象之后，React去执行一个更新任务，这个任务的优先级</p>
<p>任务优先级被用来区分多个更新任务的紧急程度，对比前后两次更新的任务优先级</p>
<ul>
<li>后者 &gt; 前者，React会取消前者的任务调度</li>
<li>后者&#x3D;前者，React 会将同等优先级的更新收敛到一次任务中</li>
<li>后者 &lt; 前者，React会在前者更新完成后，再对后者发起任务调度</li>
</ul>
<p>简而言之，任务优先级存在的意义</p>
<ul>
<li>保证高优先级任务及时响应</li>
<li>收敛同等优先级的任务调度</li>
</ul>
<p>React定义的任务优先级分为三类</p>
<ul>
<li>同步优先级：React的 legacy 同步渲染模式产生的更新任务的优先级</li>
<li>同步批量优先级：React的 blocking模式产生的更新任务的优先级</li>
<li>Concurrent 模式优先级：对于用户输入、悬停、点击、页面转换等在内部使用不同的“优先级”，大致对应于人类感知研究中的交互类别</li>
</ul>
<p><code>LanePriority</code> 越大，优先级越高</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">export</span> const SyncLanePriority: LanePriority = <span class="hljs-number">17</span><br><span class="hljs-attribute">export</span> const SyncBatchedLanePriority: LanePriority = <span class="hljs-number">16</span><br><span class="hljs-attribute">const</span> InputDiscreteHydrationLanePriority: LanePriority = <span class="hljs-number">15</span><br><span class="hljs-attribute">export</span> const InputDiscreteLanePriority: LanePriority = <span class="hljs-number">14</span><br><span class="hljs-attribute">const</span> InputContinuousHydrationLanePriority: LanePriority = <span class="hljs-number">13</span><br><span class="hljs-attribute">export</span> const InputContinuousLanePriority: LanePriority = <span class="hljs-number">12</span><br><span class="hljs-attribute">const</span> DefaultHydrationLanePriority: LanePriority = <span class="hljs-number">11</span><br><span class="hljs-attribute">export</span> const DefaultLanePriority: LanePriority = <span class="hljs-number">10</span><br><span class="hljs-attribute">const</span> TransitionShortHydrationLanePriority: LanePriority = <span class="hljs-number">9</span><br><span class="hljs-attribute">export</span> const TransitionShortLanePriority: LanePriority = <span class="hljs-number">8</span><br><span class="hljs-attribute">const</span> TransitionLongHydrationLanePriority: LanePriority = <span class="hljs-number">7</span><br><span class="hljs-attribute">export</span> const TransitionLongLanePriority: LanePriority = <span class="hljs-number">6</span><br><span class="hljs-attribute">const</span> RetryLanePriority: LanePriority = <span class="hljs-number">5</span><br><span class="hljs-attribute">const</span> SelectiveHydrationLanePriority: LanePriority = <span class="hljs-number">4</span><br><span class="hljs-attribute">const</span> IdleHydrationLanePriority: LanePriority = <span class="hljs-number">3</span><br><span class="hljs-attribute">const</span> IdleLanePriority: LanePriority = <span class="hljs-number">2</span><br><span class="hljs-attribute">const</span> OffscreenLanePriority: LanePriority = <span class="hljs-number">1</span><br><span class="hljs-attribute">export</span> const NoLanePriority: LanePriority = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h3 id="什么是-Redux"><a href="#什么是-Redux" class="headerlink" title="什么是 Redux ?"></a>什么是 Redux ?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-12"><a href="#面试高频指数：★-☆-☆-☆-☆-12" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>Redux 是 JavaScript 应用的可预测状态容器</p>
<ul>
<li>可预测<ul>
<li>在不同环境（客户端、服务器和移动端）行为一致，易于测试</li>
</ul>
</li>
<li>集中<ul>
<li>集中应用状态和逻辑，支持撤销、重做和持久化</li>
</ul>
</li>
<li>可调试<ul>
<li>Redux DevTools 可以方便地跟踪应用的状态何时、何处、为什么及如何改变</li>
<li>Rddux 架构允许开发者记录更改，使用“时间旅行调试”，向服务器发送完整错误报告</li>
</ul>
</li>
<li>灵活<ul>
<li>Redux 可用于任何 UI 层，并拥有一个庞大的插件生态系统来满足您的需求</li>
</ul>
</li>
</ul>
<h3 id="Flux-和-Redux-的区别是？"><a href="#Flux-和-Redux-的区别是？" class="headerlink" title="Flux 和 Redux 的区别是？"></a>Flux 和 Redux 的区别是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-22"><a href="#面试高频指数：★-★-☆-☆-☆-22" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>Flux</p>
<ul>
<li>Flux 是用于构建用户界面的应用程序架构，通过单向数据流补充 React 可组合的视图组件</li>
<li>Flux 更像模式而非框架，没有任何硬依赖</li>
<li>Flux 架构的应用包含 4 部分<ul>
<li>Action<ul>
<li>通过 Action creators 创建</li>
<li>每个 Action 拥有 type 或类似属性</li>
<li>传递给 Dispatcher</li>
</ul>
</li>
<li>Dispatcher<ul>
<li>分发 Actions 给所有注册 Store 的回调函数</li>
</ul>
</li>
<li>Store<ul>
<li>接受 Action 更新数据后，触发 change 事件，通知 View</li>
<li>可以由多个 Store</li>
</ul>
</li>
<li>View 视图组件，即 Controller-View<ul>
<li>家庭 change 事件，从 Store 取回数据，将数据传递给子组件或更新组件状态</li>
<li>响应用户输入，生成新的 Action</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Redux</p>
<ul>
<li><p>Redux 是 JavaScript 应用的可预测状态容器</p>
</li>
<li><p>Redux 对不同框架都有完整实现，Facebook 官方推荐使用代替 Flux</p>
</li>
<li><p>Redux 架构与 Flux 基本一致，但做了简化</p>
<ul>
<li><p>State 只读，更改 State 的方式是返回新的对象，即引入 Reducer 纯函数</p>
</li>
<li><p>Action 与 Dispatcher ，只需返回包含 type 和 payload 属性的对象</p>
</li>
<li><p>Store</p>
<ul>
<li>唯一</li>
<li><code>createStore</code> 基于 Reducer 纯函数创建</li>
<li><code>store.dispatch()</code> 调用 Action</li>
</ul>
</li>
<li><p>View</p>
<ul>
<li><p>通过 <code>store.getState()</code> 获取最新状态</p>
</li>
<li><p>通过</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">store.subscribe<span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure>

<p>订阅状态更新</p>
<ul>
<li><code>store.subscribe()</code> 返回函数可取消订阅</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>综上，Redux 与 Flux 都基于单向数据流，架构相似，但 Redux 默认应用只有唯一 Store，精简掉 Dispatcher，引入 Reducer 纯函数，通过返回新对象，而不是更改对象，更新状态。</p>
<p>对比 Flux 的官方实现，Redux 的 API 更简洁，并且提供了如 <code>combineReducers</code>等工具函数及 <code>React-Toolkit</code> 工具集，以及对状态的撤销、重做和持久化等更复杂的功能。提供如 <code>React-Redux</code> 等简化 Redux 与其他第三方库的连接。</p>
<p>Facebook 官方推荐在生产环境中使用代替 Flux。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/leetcode/" class="category-chain-item">leetcode</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/React/">#React</a>
      
        <a href="/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>前端通关手册-React</div>
      <div>http://example.com/2023/01/28/前端通关手册-React/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年1月28日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/01/29/webpack%E6%94%BB%E7%95%A5/" title="webpack攻略">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">webpack攻略</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" title="前端学习路线">
                        <span class="hidden-mobile">前端学习路线</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
