<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>前端通关手册-React | serendipity0321's blog</title><meta name="author" content="蓉"><meta name="copyright" content="蓉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概述Hello, React :-)React 是用于构建用户界面的 JavaScript 库，React 核心只关注视图，不断优化算法，改进性能，提高开发和交互体验。 React 迭代稳定，重视兼容和过渡，在国内外，尤其是南方，都有相当多的公司在使用 React。 渐进式的思想同样表现在 React 的学习曲线上，能够与传统的 Web 技术共存，灵活的 JSX 语法等都会让 React 上手很快">
<meta property="og:type" content="article">
<meta property="og:title" content="前端通关手册-React">
<meta property="og:url" content="http://serendipity0321.github.com/2023/01/28/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/index.html">
<meta property="og:site_name" content="serendipity0321&#39;s blog">
<meta property="og:description" content="概述Hello, React :-)React 是用于构建用户界面的 JavaScript 库，React 核心只关注视图，不断优化算法，改进性能，提高开发和交互体验。 React 迭代稳定，重视兼容和过渡，在国内外，尤其是南方，都有相当多的公司在使用 React。 渐进式的思想同样表现在 React 的学习曲线上，能够与传统的 Web 技术共存，灵活的 JSX 语法等都会让 React 上手很快">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png">
<meta property="article:published_time" content="2023-01-28T07:30:59.000Z">
<meta property="article:modified_time" content="2023-01-29T02:48:52.562Z">
<meta property="article:author" content="蓉">
<meta property="article:tag" content="React">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png"><link rel="shortcut icon" href="https://s2.loli.net/2022/10/08/k5M7H1NdmnZgtlY.png"><link rel="canonical" href="http://serendipity0321.github.com/2023/01/28/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 蓉","link":"链接: ","source":"来源: serendipity0321's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端通关手册-React',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-29 10:48:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/10/02/SRY7qntDHQe5l9F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png')"><nav id="nav"><span id="blog-info"><a href="/" title="serendipity0321's blog"><img class="site-icon" src="https://s2.loli.net/2022/10/09/HjKDX7pioRmTVhe.png"/><span class="site-name">serendipity0321's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端通关手册-React</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-28T07:30:59.000Z" title="发表于 2023-01-28 15:30:59">2023-01-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-29T02:48:52.562Z" title="更新于 2023-01-29 10:48:52">2023-01-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/leetcode/">leetcode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端通关手册-React"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h3 id="Hello-React"><a href="#Hello-React" class="headerlink" title="Hello, React :-)"></a>Hello, React :-)</h3><p>React 是用于构建用户界面的 JavaScript 库，React 核心只关注视图，不断优化算法，改进性能，提高开发和交互体验。</p>
<p>React 迭代稳定，重视兼容和过渡，在国内外，尤其是南方，都有相当多的公司在使用 React。</p>
<p>渐进式的思想同样表现在 React 的学习曲线上，能够与传统的 Web 技术共存，灵活的 JSX 语法等都会让 React 上手很快， 而庞大生态赋予了 React 更强能力的同时，也让开发者感叹花费了更多时间在社区里遨游。</p>
<h3 id="React-应用"><a href="#React-应用" class="headerlink" title="React 应用"></a>React 应用</h3><p>React 在前端开发领域应用广泛，使用 React 可以构建 Web，插件，单页应用，App，小程序，桌面端，服务端等，微服务，Serverless，低代码，虚拟现实等都有 React 的用武之地。</p>
<h3 id="React-面试注意事项"><a href="#React-面试注意事项" class="headerlink" title="React 面试注意事项"></a>React 面试注意事项</h3><p>React 面试题可以分为以下 4 个方面</p>
<ul>
<li>基础：ES5+ 作用域，class，箭头函数，this 指向，异步编程，高阶函数的循环等常问</li>
<li>会用：state，副作用，Hook，加载渲染过程，路由、测试、调试、TS、Redux 等常问</li>
<li>原理：Virtual DOM，Diff 算法，设计组件，优化性能，原理和实现等高级岗位、大厂常问</li>
<li>项目：项目结构，技术栈，工具链，解决问题，担任角色，亮点等常问，也是面试问题来源</li>
</ul>
<p>新手最好先熟练 ES5+ 的使用，再上手 React 时，可以边阅读边写代码，适当练习若干项目，再看原来生涩的表述，会有亲切的画面感。带着项目去看面试题，联想练习或工作中遇到的实际问题，加上自己的理解，你的回答一定可以比手册总结得更自然，更能得到面试官的肯定。</p>
<h3 id="对比-React-和-Vue-？"><a href="#对比-React-和-Vue-？" class="headerlink" title="对比 React 和 Vue ？"></a>对比 React 和 Vue ？</h3><p>相同点</p>
<ul>
<li>支持 Virtual DOM</li>
<li>支持响应式和组件化的视图组件</li>
<li>核心库、路由和状态管理分离</li>
<li>支持 JSX，移动端都支持原生渲染</li>
</ul>
<p>不同点</p>
<ul>
<li><p>预编译</p>
<ul>
<li>React 可以通过 Prepack 优化 JavaScript 源代码，在编译时执行原本在运行时的计算过程，通过简单的赋值序列提高 JavaScript 代码的执行效率，消除中间计算过程及分配对象操作。缓存 JavaScript 解析结果，优化效果最佳</li>
<li>Vue 可以静态分析 template，构造 AST 树，通过 PatchFlags 标记节点变化类型</li>
</ul>
</li>
<li><p>渲染</p>
<ul>
<li>React 通过 shouldComponentUpdate &#x2F; setState，使用 PureCompoent 等对比前后状态和属性，手动决定是否渲染来优化</li>
<li>Vue 推荐模板语法，自动追踪组件依赖，精确渲染状态改变的组件</li>
</ul>
</li>
<li><p>事件处理</p>
<ul>
<li><p>React</p>
<ul>
<li>React 17前，事件委托到 document，之后委托到 根节点</li>
<li>所有事件被合并为合成事件并兼容不同浏览器</li>
<li>事件处理函数中的 this 需要手动绑定或使用箭头函数声明</li>
</ul>
</li>
<li><p>Vue</p>
<ul>
<li><p>原生事件</p>
</li>
<li><p>this 自动绑定执行上下文</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="什么是-React"><a href="#什么是-React" class="headerlink" title="什么是 React ?"></a>什么是 React ?</h3><p>React 是用于构建用户界面的 JavaScript 库</p>
<ul>
<li>声明式编写 UI，代码可靠，便于调试</li>
<li>组件化开发，组件逻辑使用 JavaScript 编写而非模板，遵循单向数据流和数据绑定，状态与 DOM 分离</li>
<li>一次学习，随处编写，使用 Virtual DOM，支持 浏览器、Node 服务器等多种渲染方式 和 React Native 开发原生应用</li>
</ul>
<h3 id="对比-React-和-Angular"><a href="#对比-React-和-Angular" class="headerlink" title="对比 React 和 Angular ?"></a>对比 React 和 Angular ?</h3><ul>
<li>核心功能<ul>
<li>React 核心库只提供构建 UI 组件的方法，其他功能通过社区提供</li>
<li>Angular 集成了 路由、异步请求、表单、模块化 CSS 等功能</li>
</ul>
</li>
<li>组件<ul>
<li>React 组件推荐使用 JSX，可以一个文件包含 HTML、CSS 和 JS，也可以分开</li>
<li>Angular 组件 HTML、CSS 和 TS 分别是一个文件</li>
</ul>
</li>
<li>DOM<ul>
<li>React 基于 Virtual DOM，组件会被编译成 JS 对象，数据更改时通过 Diff 算法更新</li>
<li>Angular 基于 Incremental DOM，组件会被编译成指令，数据更改时就地更新。没有使用规定指令的组件可以被 Tree Shaking</li>
</ul>
</li>
<li>数据绑定<ul>
<li>React 单向数据绑定，声明状态，更新视图</li>
<li>Angular 双向数据绑定，数据改变，更新视图</li>
</ul>
</li>
<li>全局状态管理<ul>
<li>Angualr 可以用 Service 依赖注入实现</li>
<li>React 可以用全局对象或 Redux 实现</li>
</ul>
</li>
<li>上手成本<ul>
<li>React 推荐了解 JSX，是库，可以渐进式使用</li>
<li>Angluar 需要了解 TypeScript，Rxjs，OOP 和装饰器等，是框架，推荐独立使用</li>
</ul>
</li>
</ul>
<h3 id="你认为-React-的缺点是什么？"><a href="#你认为-React-的缺点是什么？" class="headerlink" title="你认为 React 的缺点是什么？"></a>你认为 React 的缺点是什么？</h3><ul>
<li>React 核心是 UI 库，路由，状态管理等由社区维护。细粒度需求和问题依赖社区解决</li>
<li>React 概念和约束较少，容易上手并与现有项目整合。代码风格和项目结构容易产生差别</li>
<li>React JSX 灵活性高，预编译时可以做的优化相对其他 HTML 分离的库有限</li>
<li>React setState 提供基于队列异步更新，手动优化渲染流程，需要关注业务之外的逻辑</li>
<li>React17 以前基于事件委托的合成事件，表现和使用与原生事件存在差异</li>
</ul>
<h3 id="什么是声明式编程？"><a href="#什么是声明式编程？" class="headerlink" title="什么是声明式编程？"></a>什么是声明式编程？</h3><ul>
<li>声明式编程是一种编程范式，描述目标，而不是流程</li>
<li>通过函数、推理规则或者重写规则，来描述变量间关系</li>
<li>通过编译器采用固定算法，使得这些关系产生结果</li>
</ul>
<h3 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h3><ul>
<li>函数式编程是一种编程范式，它是声明式编程的子集</li>
<li>避免使用状态、异变对象，最小化副作用</li>
<li>基于 lambda 演算，函数可以作为入参和出参</li>
</ul>
<h3 id="MVC-和-MVVM-的区别是？"><a href="#MVC-和-MVVM-的区别是？" class="headerlink" title="MVC 和 MVVM 的区别是？"></a>MVC 和 MVVM 的区别是？</h3><p>相同点</p>
<ul>
<li>目的相同：分离模型 Model 和视图 View</li>
</ul>
<p>不同点</p>
<ul>
<li>MVC<ul>
<li>构成：模型 Model - 视图 View - 控制器 Controller</li>
<li>分为主动 MVC 和 被动 MVC<ul>
<li>主动 MVC：视图订阅数据更新</li>
<li>被动 MVC：控制器操作视图</li>
</ul>
</li>
<li>渲染<ul>
<li>后端返回 HTML，利于 SEO</li>
<li>后端返回数据，前端使用模板引擎或操作 DOM</li>
</ul>
</li>
</ul>
</li>
<li>MVVM<ul>
<li>构成：模型 Model - 视图 View - 视图模型 ViewModel</li>
<li>ViewModel 单向或双向数据绑定 View 和 Model 层，实现自动同步</li>
<li>渲染<ul>
<li>后端减少关心视图，前端 SSR 利于 SEO</li>
<li>前端减少操作 DOM</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何组织-React-项目文件结构？"><a href="#如何组织-React-项目文件结构？" class="headerlink" title="如何组织 React 项目文件结构？"></a>如何组织 React 项目文件结构？</h3><p>React 建议</p>
<ul>
<li>项目目录嵌套最多3到4个层级</li>
<li>不要过度思考</li>
<li>没有官方推荐的组织方式，常见组织方式包括<ul>
<li>按功能和路由组织：相同功能或路由的 CSS、JS 和 测试文件放入同一目录</li>
<li>按文件类型组织：组件、页面、API、状态管理、静态文件分类存放</li>
</ul>
</li>
</ul>
<h3 id="如何组织-React-项目文件结构？-1"><a href="#如何组织-React-项目文件结构？-1" class="headerlink" title="如何组织 React 项目文件结构？"></a>如何组织 React 项目文件结构？</h3><p>React 建议</p>
<ul>
<li>项目目录嵌套最多3到4个层级</li>
<li>不要过度思考</li>
<li>没有官方推荐的组织方式，常见组织方式包括<ul>
<li>按功能和路由组织：相同功能或路由的 CSS、JS 和 测试文件放入同一目录</li>
<li>按文件类型组织：组件、页面、API、状态管理、静态文件分类存放</li>
</ul>
</li>
</ul>
<h3 id="React-18-都有哪些新特性？"><a href="#React-18-都有哪些新特性？" class="headerlink" title="React 18 都有哪些新特性？"></a>React 18 都有哪些新特性？</h3><ul>
<li>新的 Root API：ReactDom.creatRoot<ul>
<li>React 17 及之前版本<ul>
<li>通过 ReactDom.render 将应用渲染到页面的根元素</li>
<li>有限的自动批量处理<ul>
<li>如在浏览器事件触发多个状态更改，自动批量更新</li>
<li>而在异步函数中多个状态更改，不会批量更新</li>
</ul>
</li>
</ul>
</li>
<li>React 18<ul>
<li>可选通过 ReactDom.creatRoot 将应用渲染到页面的根元素</li>
<li>确保安全的前提下<ul>
<li>如对于每个用户触发的事件，在下一个事件前完成渲染</li>
<li>尽可能地多应用自动批量处理，包括异步函数中的多个状态更新</li>
</ul>
</li>
<li>可选 ReactDom.flushSync 退出批量更新</li>
</ul>
</li>
</ul>
</li>
<li>SSR 支持 React.lazy 和 React.Suspense<ul>
<li>React 17 及之前版本<ul>
<li>React.lazy() 和 React.Suspense 尚未在 ReactDOMServer 中支持</li>
</ul>
</li>
<li>React 18<ul>
<li>全新的 SSR 架构内置支持 React.lazy() 和 React.Suspense</li>
</ul>
</li>
</ul>
</li>
<li>startTransition<br>* React 17 及以前版本<br>* 所有更新都被紧急渲染<br>* 使用 <code>setTimeout</code> 和 防抖等方式，避免频繁更新<br>* React 18<br>* 所有渲染分为紧急和非紧急<br>* 非紧急渲染使用 <code>startTransition</code> 包裹<br>* 非紧急渲染的延迟时间由设备决定<br>* 非紧急渲染可中断，不会影响响应用户输入、动画等紧急渲染</li>
</ul>
<h3 id="什么是-JSX-？"><a href="#什么是-JSX-？" class="headerlink" title="什么是 JSX ？"></a>什么是 JSX ？</h3><ul>
<li><p>JSX 是 JavaScript 的语法扩展，生成 React 元素</p>
</li>
<li><p>JSX 是</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(component, props, ...children)</span><br></pre></td></tr></table></figure>

<p>函数的语法糖</p>
<ul>
<li>React 17 RC 开始，由编辑器自动引入 <code>import &#123; jsx &#125; from &#39;react/jsx-runtime&#39;</code></li>
</ul>
</li>
<li><p>JSX 支持 HTML 模板语法 和 表达式，支持条件和循环渲染，支持点语法和展开运算符</p>
</li>
<li><p>JSX 转义所有输入内容，防止注入攻击</p>
</li>
<li><p>JSX 忽略渲染 <code>false</code>，<code>null</code>，<code>undefined</code>，<code>true</code> 子元素</p>
</li>
</ul>
<h3 id="为什么推荐在-React-中使用-JSX-？"><a href="#为什么推荐在-React-中使用-JSX-？" class="headerlink" title="为什么推荐在 React 中使用 JSX ？"></a>为什么推荐在 React 中使用 JSX ？</h3><ul>
<li>React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合<ul>
<li>UI 中绑定处理事件</li>
<li>状态更新时通知 UI</li>
<li>UI 中展示数据</li>
</ul>
</li>
<li>React 将标记和逻辑共同存放在组件，实现关注点分离</li>
<li>React 不强制要求使用 JSX，但 JSX 与 UI 一起有视觉辅助作用</li>
<li>React 通过 JSX 可以显示更多有用错误和警告消息</li>
</ul>
<h3 id="为什么-JSX-可以有效降低-XSS-风险？"><a href="#为什么-JSX-可以有效降低-XSS-风险？" class="headerlink" title="为什么 JSX 可以有效降低 XSS 风险？"></a>为什么 JSX 可以有效降低 XSS 风险？</h3><ul>
<li>React DOM 在渲染所有输入内容前，默认会将它们转义成字符串，有效降低 XSS 风险</li>
<li>可以通过<code>dangerouslySetInnerHTML = &#123;&#123; __html: HTML &#125;&#125;</code>来显示转义前的内容</li>
</ul>
<h3 id="如何在-JSX-中条件渲染？"><a href="#如何在-JSX-中条件渲染？" class="headerlink" title="如何在 JSX 中条件渲染？"></a>如何在 JSX 中条件渲染？</h3><ul>
<li><p>if &#x2F; else 语句</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (condition) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>三元运算符</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> condition ? <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span> : <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>逻辑运算符</p>
</li>
<li><p>plain</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> condition &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>条件渲染组件</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="title function_">Condition</span> = props =&gt; &#123;</span><br><span class="line">		<span class="keyword">const</span> &#123; <span class="title class_">If</span>, children &#125; = props</span><br><span class="line">		<span class="keyword">return</span> <span class="title class_">If</span> &amp;&amp; children</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Condition</span> <span class="attr">If</span>=<span class="string">&#123;true&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> /&gt;</span><span class="tag">&lt;/<span class="name">Condition</span>&gt;</span></span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何在-JSX-中循环控制？"><a href="#如何在-JSX-中循环控制？" class="headerlink" title="如何在 JSX 中循环控制？"></a>如何在 JSX 中循环控制？</h3><ul>
<li>map 将数组每一项转成 UI，flatMap filter 等能返回数组的循环方法也被支持</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> &#123; data &#125; = props</span><br><span class="line">	<span class="keyword">return</span> data.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">b</span> <span class="attr">id</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.text&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 javaScript 的循环（for &#x2F; while &#x2F; do while），将结果存储到变量，将变量代入 JSX</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> &#123; data &#125; = props</span><br><span class="line">	<span class="keyword">const</span> datas = <span class="title class_">Array</span>(data.<span class="property">length</span>)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">const</span> item = data[i]</span><br><span class="line">		datas[i] = <span class="language-xml"><span class="tag">&lt;<span class="name">b</span> <span class="attr">id</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.text&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> datas</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 lodash 等第三方库或自定义可以返回数组的方法，以 lodash 为例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> &#123; data &#125; = props</span><br><span class="line">	<span class="keyword">return</span> _.<span class="title function_">times</span>(data.<span class="property">length</span>, <span class="function"><span class="params">i</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">b</span> <span class="attr">id</span>=<span class="string">&#123;data[i].id&#125;</span>&gt;</span>&#123;data[i].text&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么-JSX-中-class-变成了-className"><a href="#为什么-JSX-中-class-变成了-className" class="headerlink" title="为什么 JSX 中 class 变成了 className ?"></a>为什么 JSX 中 class 变成了 className ?</h3><ul>
<li>JSX 语法上更接近 JavaScript 而不是 HTML<ul>
<li>HTML 属性值通常为字符串</li>
<li>HTML DOM 对象属性值可以是任意数据类型</li>
</ul>
</li>
<li>JSX 的 className 更接近 HTML DOM 对象的属性，并且支持属性拓展运算符</li>
<li>JSX 通过匹配闭合标签提升可读性，而不是代替 HTML<ul>
<li>JSX 与 HTML 需要转换，直接使用 class 也无法避免其它转换工作</li>
</ul>
</li>
</ul>
<h3 id="什么是-React-组件？"><a href="#什么是-React-组件？" class="headerlink" title="什么是 React 组件？"></a>什么是 React 组件？</h3><ul>
<li>React 组件允许用户将 UI 拆分成独立可复用的代码片段，并对每个片段进行独立构思</li>
<li>React 组件从概念上类似于 JavaScript 函数</li>
<li>React 组件接受任意的入参 Props，返回用于描述页面展示内容的 React 元素</li>
</ul>
<h3 id="React-组件分成哪几类？"><a href="#React-组件分成哪几类？" class="headerlink" title="React 组件分成哪几类？"></a>React 组件分成哪几类？</h3><ul>
<li>按定义分类<ul>
<li>类组件，使用 ES6 的 class 定义，维护 state，有生命周期</li>
<li>函数组件，使用普通函数定义，可以通过 hooks 维护状态和副作用</li>
</ul>
</li>
<li>按状态分<ul>
<li>有状态组件，组件返回结果，受时间、空间或上下文影响</li>
<li>无状态组件，通常是纯展示 UI 组件，容易复用</li>
</ul>
</li>
<li>按定位分<ul>
<li>展示型组件，接收 props，负责 UI 展示</li>
<li>容器组件，管理 states，负责数据获取和组件间通信，多用于状态提升</li>
</ul>
</li>
<li>按 React 内置类型分类<ul>
<li>有状态组件<ul>
<li>ClassComponent，由 class 创建</li>
<li>ContextProvider，由 createContext 创建</li>
</ul>
</li>
<li>无状态组件<ul>
<li>IndeterminateComponent，FunctionCompoent 挂载前的初始类型</li>
<li>FunctionComponent，即函数组件</li>
<li>ForwardRef，由 React.forwardRef 创建，接收 ref 并转发给子组件</li>
<li>MemoComponent，由 React.memo 创建，条件渲染子组件</li>
<li>SimpleMemoCompoent，由 React.memo 创建且不指定条件</li>
</ul>
</li>
<li>FiberNode<ul>
<li>HostRoot，由 ReactDOM.render 创建</li>
<li>HostPortal，由 React.createPortal 创建，多用于模态框</li>
<li>HostComponent，对应元素节点</li>
<li>HostText，对应文本节点</li>
</ul>
</li>
<li>内置类型<ul>
<li>Fragment，分组子列表，无需向 DOM 添加额外节点，可用短语法 &lt;&gt;</li>
<li>Profiler，测量 React 应用多久渲染一次以及渲染一次的“代价”</li>
<li>StrictMode，严格模式，用来突出显示应用程序中潜在问题的工具</li>
<li>Suspense，等待目标代码加载，并且可以指定一个加载界面，在用户等待时显示</li>
<li>PureCompoent，浅层对比 prop 和 state 实现了 shouldComponentUpdate</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="类组件和函数组件的区别是？"><a href="#类组件和函数组件的区别是？" class="headerlink" title="类组件和函数组件的区别是？"></a>类组件和函数组件的区别是？</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">类组件</th>
<th align="left">函数组件</th>
</tr>
</thead>
<tbody><tr>
<td align="left">回调钩子</td>
<td align="left">生命周期</td>
<td align="left">useEffect &#x2F; useLayoutEffect</td>
</tr>
<tr>
<td align="left">this</td>
<td align="left">有，事件处理函数需绑定 this</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">state</td>
<td align="left">有，this.setState 更新</td>
<td align="left">无，useState &#x2F; useReducer 引入</td>
</tr>
<tr>
<td align="left">实例化</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">现代浏览器中，闭包和类的原始性能只有在极端场景才会有明显差别</td>
<td align="left">使用 Hooks 某些情况更加高效,避免了 class 需要的额外成本，如创建类实例和在构造函数绑定事件处理器的成本,符合语言习惯的代码不需要很深的组件库嵌套</td>
</tr>
</tbody></table>
<h3 id="受控组件和非受控组件的区别是？"><a href="#受控组件和非受控组件的区别是？" class="headerlink" title="受控组件和非受控组件的区别是？"></a>受控组件和非受控组件的区别是？</h3><h4 id="面试高频指数：★-★-★-★-☆"><a href="#面试高频指数：★-★-★-★-☆" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul>
<li>受控组件<ul>
<li>React 的 state 是表单元素的“唯一数据源”，控制用户输入过程中表单发生的操作</li>
<li>表单元素的 value 跟随 state 变化，默认值由 defaultValue 设置</li>
<li>表单元素需要被 React 组件包裹</li>
<li>每种数据变化都需要编写事件处理函数</li>
<li>不支持 value 只读的表单元素，如 <code>&lt;input type=&quot;file&quot; /&gt;</code> 的 value 由用户设置</li>
</ul>
</li>
<li>非受控组件<ul>
<li>表单数据交由 DOM 节点处理</li>
<li>使用 <code>ref</code> 从 DOM 节点获取表单数据</li>
<li>表单元素无需被 React 组件包裹</li>
<li>只关心业务需要的数据变化，减少代码量</li>
<li>集成 React 和 非 React 代码，不推荐使用</li>
</ul>
</li>
</ul>
<h3 id="什么是高阶组件？"><a href="#什么是高阶组件？" class="headerlink" title="什么是高阶组件？"></a>什么是高阶组件？</h3><ul>
<li>高阶组件是参数为组件，返回值为新组件的函数，某种角度上就是高阶函数</li>
<li>高阶组件是 React 中复用组件逻辑的一种高级技巧</li>
<li>高阶组件不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式</li>
</ul>
<h3 id="什么是-Pure-Components-？"><a href="#什么是-Pure-Components-？" class="headerlink" title="什么是 Pure Components ？"></a>什么是 Pure Components ？</h3><p>React.PureComponent 与 React.Component 相似，区别是</p>
<ul>
<li>React.Component 并未实现 shouldComponentUpdate</li>
<li>React.PureComponent 以浅层对比 prop 和 state 方式实现了 shouldComponentUpdate<ul>
<li>React.PureComponent 无法检查对象的深层差别</li>
<li>prop 和 state 使用深层数据结构时<ul>
<li>调用 <code>forceUpdate()</code> 来确保组件正确更新</li>
<li>使用 <code>immutable 对象</code> 加速嵌套数据的比较</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="展示组件和容器组件的区别是？"><a href="#展示组件和容器组件的区别是？" class="headerlink" title="展示组件和容器组件的区别是？"></a>展示组件和容器组件的区别是？</h3><p>React 组件按照用途可以分为展示组件和容器组件</p>
<p>React 推荐所有新组件，无论是展示组件，还是容器组件，都采用函数组件 + Hook 方式编写</p>
<ul>
<li>展示组件<ul>
<li>关心页面 UI，有自己的 HTML 标签和样式</li>
<li>如果有状态，仅与 UI 相关。与其他组件、store 无关</li>
<li>不关心数据源，通过 props 获取数据，并执行回调</li>
</ul>
</li>
<li>容器组件<ul>
<li>关心功能实现，无自己的 HTML 标签和样式</li>
<li>有状态。包含请求数据源等副作用。状态提升时，维护多个子组件的状态</li>
<li>可以由第三方库生成，如 React Redux 的 <code>connect()</code> 和 Relay 的 <code>createFragmentContainer</code></li>
</ul>
</li>
</ul>
<p>React 分离展示组件和容器组件的优势</p>
<ul>
<li>关注点分离，便于维护</li>
<li>提高展示组件的复用度，便于调整 UI</li>
<li>便于通过如 this.props.children 传递组件本身，减少相同 props 层层传递</li>
</ul>
<h3 id="如何劫持-React-组件提高组件复用度？"><a href="#如何劫持-React-组件提高组件复用度？" class="headerlink" title="如何劫持 React 组件提高组件复用度？"></a>如何劫持 React 组件提高组件复用度？</h3><p>劫持 React 组件又被称为渲染劫持</p>
<p>将已有组件包装，注入新属性和功能，输出高阶组件，来实现组件复用</p>
<p>劫持需要遵守高阶组件的约定</p>
<ul>
<li>不要改变原始组件，仅组合组件</li>
<li>保持组件的接口与已有组件相似，透传与自身无关的 props 给已有组件</li>
<li>最大化可组合性，确保函数签名类型一致，输入函数，返回函数，输入组件，返回组件</li>
<li>包装显示名称便于调试，如 <code>withSubscription(CommentList)</code></li>
</ul>
<h3 id="如何设计一个-React-组件？"><a href="#如何设计一个-React-组件？" class="headerlink" title="如何设计一个 React 组件？"></a>如何设计一个 React 组件？</h3><ul>
<li>根据数据源和原型和 UI 稿，了解数据结构和 UI 视图</li>
<li>划分组件层级<ul>
<li>根据单一功能原则分离 UI 与数据源的结构一一对应</li>
<li>明确组件的包含关系</li>
</ul>
</li>
<li>构建静态版本<ul>
<li>将静态数据通过 props 父组件到子组件单向传递</li>
<li>构建应用<ul>
<li>简单应用，自上而下，从高层组件到低层组件构建</li>
<li>大型应用，自下而上，从低层组件到高层组件构建，同时为低层组件编写测试</li>
</ul>
</li>
<li>确定 UI state 最小且完整表示<ul>
<li>排除通过 props 传递来的数据</li>
<li>排除不随时间变化的数据</li>
<li>排除可以由其他 state 或 props 计算得出的数据</li>
</ul>
</li>
<li>确定 state 放置位置<ul>
<li>找出根据 state 渲染的所有组件</li>
<li>找出这些组件的共同上级组件</li>
<li>state 应该放置在共同上级组件或者更高层级的组件中</li>
</ul>
</li>
<li>添加反向数据流<ul>
<li>state 只能由拥有它们的组件更改</li>
<li>在该组件添加修改 state 的回调函数</li>
<li>将该回调函数通过 props 传递给子组件，在子组件中，如事件处理函数中调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="React-组件与-Web-Components-共存的最佳实践是？"><a href="#React-组件与-Web-Components-共存的最佳实践是？" class="headerlink" title="React 组件与 Web Components 共存的最佳实践是？"></a>React 组件与 Web Components 共存的最佳实践是？</h3><ul>
<li>访问 Web Components 的命令式 API：使用 <code>ref</code>与 DOM 节点进行交互</li>
<li>引入第三方 Web Components：编写 React 组件包装该 Web Components</li>
<li>Web Components 触发事件：React 组件中手动添加事件处理器来处理事件</li>
</ul>
<h3 id="什么是-React-的状态？"><a href="#什么是-React-的状态？" class="headerlink" title="什么是 React 的状态？"></a>什么是 React 的状态？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆"><a href="#面试高频指数：★-☆-☆-☆-☆" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li>React 的状态 state 是一个对象<ul>
<li>类组件中，状态通过 this.state 创建，通过 this.setState 合并更改，异步更新</li>
<li>React Hook 中，状态通过 this.useState 或 this.useReducer 使用</li>
</ul>
</li>
<li>React 将组件看做状态机，状态改变触发渲染</li>
<li>React 建议减少有状态的组件，提高组件复用度，利于维护<ul>
<li>只将无法从 props 传递，无法从其他数据计算，并且随时间可能变化的数据作为 state</li>
<li>多个组件 state 的数据源相同，应将状态提升到父组件或容器组件</li>
<li>避免使用 context，仅在 React 的状态管理无法满足需求时使用 Redux</li>
</ul>
</li>
</ul>
<h3 id="什么是-React-的状态提升？"><a href="#什么是-React-的状态提升？" class="headerlink" title="什么是 React 的状态提升？"></a>什么是 React 的状态提升？</h3><ul>
<li>React 中，任何可变数据应当只有一个相对应的唯一“数据源”</li>
<li>多个组件反映相同的变化数据时，共享状态提升到最近的共同父组件<ul>
<li>state 应首先添加到需要渲染数据的组件</li>
<li>其他组件也需要这个 state，将它提升至这些组件的最近共同父组件</li>
</ul>
</li>
<li>state 只能由拥有它们的组件修改，bug 排查范围被大大缩减</li>
</ul>
<h3 id="状态和属性的区别是什么？"><a href="#状态和属性的区别是什么？" class="headerlink" title="状态和属性的区别是什么？"></a>状态和属性的区别是什么？</h3><p>相同点</p>
<ul>
<li>state 和 props 都是原生的 JavaScript 对象</li>
<li>state 和 props 的变化都会触发生命周期、useEffect &#x2F; useLayoutEffect、和渲染</li>
<li>state 和 props 相同，渲染结果相同</li>
<li>state 和 props 都可以在组件内部设置默认值</li>
</ul>
<p>不同点</p>
<ul>
<li>获取<ul>
<li>state 由当前组件声明</li>
<li>props 由父组件传入</li>
</ul>
</li>
<li>更新<ul>
<li>state<ul>
<li>由所在组件通过 useState &#x2F; useReducer 或 setState 方法更新</li>
<li>由子组件通过 state 所在组件传入的回调函数间接更新</li>
</ul>
</li>
<li>props 不允许修改</li>
</ul>
</li>
<li>数据<ul>
<li>state 通常存储可变数据，避免多层嵌套或使用不可变对象便于优化渲染</li>
<li>props 除数据外，还多用于回调函数，组件 ( children )，路由 ( history ) 的传递</li>
</ul>
</li>
</ul>
<h3 id="如何创建动态的状态名称？"><a href="#如何创建动态的状态名称？" class="headerlink" title="如何创建动态的状态名称？"></a>如何创建动态的状态名称？</h3><ul>
<li>状态是一个 JavaScript 对象，状态名称即对象的属性名称</li>
<li>从 ECMAScript 2015 开始，对象初始化语法开始支持计算属性名。在 [] 放入表达式，计算结果当做属性名。例如</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> h = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">h[i + <span class="number">1</span>] = i <span class="comment">// h = &#123;&#x27;1&#x27;: 0&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>计算属性名支持对象字面量，例：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; i &#125; = props <span class="comment">// props = &#123; i : 0 &#125;</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">	[i + <span class="number">1</span>] : i</span><br><span class="line">&#125; <span class="comment">// this.state = &#123; &#x27;1&#x27; : 0 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="setState-支持哪些用法？"><a href="#setState-支持哪些用法？" class="headerlink" title="setState 支持哪些用法？"></a>setState 支持哪些用法？</h3><h4 id="面试高频指数：★-★-☆-☆-☆"><a href="#面试高频指数：★-★-☆-☆-☆" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>setState(updater, [callback])<ul>
<li>updater 函数带有形式参数，基于 state 和 props 构建新对象表示变化</li>
<li>(state, props) &#x3D;&gt; stateChange，适合后续状态取决于当前状态的情况</li>
</ul>
</li>
<li>setState(stateChange[, callback])<ul>
<li>stateChange 为传入对象，会浅层合并到新的 state</li>
<li>同一周期内，后调用的 setState 会覆盖先调用的 setState</li>
</ul>
</li>
<li>setState 的第二参数为可选回调函数<ul>
<li>回调函数将在 setState 完成合并并重新渲染组件后执行</li>
<li>React 官方推荐使用 componentDidUpdate() 生命周期代替 setState 的回调函数</li>
</ul>
</li>
</ul>
<h3 id="setState-和-replaceState-的区别是？"><a href="#setState-和-replaceState-的区别是？" class="headerlink" title="setState 和 replaceState 的区别是？"></a>setState 和 replaceState 的区别是？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-1"><a href="#面试高频指数：★-☆-☆-☆-☆-1" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li>setState 会合并当前状态与之前状态</li>
<li>replaceState 会丢弃之前状态，用新状态替代</li>
<li>replaceState 等同于先在 setState 中将状态设置为 false &#x2F; null，再设置新状态</li>
</ul>
<h3 id="如何优化-setState，减少不必要更新？"><a href="#如何优化-setState，减少不必要更新？" class="headerlink" title="如何优化 setState，减少不必要更新？"></a>如何优化 setState，减少不必要更新？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-1"><a href="#面试高频指数：★-★-☆-☆-☆-1" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>通过 setState(updater, [callback]) 的用法，第一参数使用带有形式参数的函数</li>
<li>通过 updater 函数 (state, props) &#x3D;&gt; stateChange 的第一参数，接受原来的 state 状态值</li>
<li>对比新旧状态值<ul>
<li>相同，返回 null，不渲染</li>
<li>不同，返回新状态值，触发异步合并渲染</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getData = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> &#123; time &#125; = data</span><br><span class="line">	<span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> state.<span class="property">time</span> === time ?  <span class="literal">null</span> : &#123; time &#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="当-State-值为-Object-时，如何优化？"><a href="#当-State-值为-Object-时，如何优化？" class="headerlink" title="当 State 值为 Object 时，如何优化？"></a>当 State 值为 Object 时，如何优化？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-2"><a href="#面试高频指数：★-★-☆-☆-☆-2" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>避免使用 Object 作为 State 值，使用 PureComponent 的浅比较的自动优化失效</li>
<li>必要使用 Object 作为 State 值<ul>
<li>避免嵌套过多层级</li>
<li>设置更新 state 的前置条件或使用 shouldComponent 手动优化</li>
</ul>
</li>
<li>已经使用 Object 作为 State 值，并且嵌套层级过多<ul>
<li>拆分 State 到子组件</li>
<li>使用不可变对象 Immutable，只要 State 更新，返回对象新引用，重新渲染修改节点</li>
</ul>
</li>
</ul>
<h3 id="什么是-React-的属性？"><a href="#什么是-React-的属性？" class="headerlink" title="什么是 React 的属性？"></a>什么是 React 的属性？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-2"><a href="#面试高频指数：★-☆-☆-☆-☆-2" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li>属性是组件的入参，用法同 HTML 自定义属性，可将任意类型数据从父组件传给子组件</li>
<li>属性的改变可以触发组件的生命周期流程和渲染</li>
<li>建议从组件自身的角度，不依赖于调用中间的上下文命名 Props</li>
<li>属性具有只读性，所有 React 组件必须像纯函数一样保护它们的 props 不被更改</li>
<li>请避免使用匿名函数作为属性值，避免引起重复渲染</li>
<li>具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑</li>
</ul>
<h3 id="为什么不能直接修改属性？"><a href="#为什么不能直接修改属性？" class="headerlink" title="为什么不能直接修改属性？"></a>为什么不能直接修改属性？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-3"><a href="#面试高频指数：★-☆-☆-☆-☆-3" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li>React 是“单向”数据流，数据通过 props 传递</li>
<li>从 state 派生数据或 UI 只能影响“低于”它们的组件，设计简单高效，便于调试</li>
<li>所有 React 组件必须像纯函数一样保护它们的 props 不被更改，保证组件没有副作用</li>
</ul>
<h3 id="通过属性传递组件本身的方法有哪些？"><a href="#通过属性传递组件本身的方法有哪些？" class="headerlink" title="通过属性传递组件本身的方法有哪些？"></a>通过属性传递组件本身的方法有哪些？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-3"><a href="#面试高频指数：★-★-☆-☆-☆-3" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>props.children<ul>
<li>子组件可以获取父组件开始标签和结束标签之间的内容</li>
</ul>
</li>
<li>render props<ul>
<li>向子组件传入函数，返回组件需要渲染什么内容</li>
<li>直接在父组件的标签之间，调用函数返回组件</li>
<li>避免使用匿名函数返回组件，避免重复渲染</li>
</ul>
</li>
</ul>
<h3 id="使用-key-属性有哪些注意事项？"><a href="#使用-key-属性有哪些注意事项？" class="headerlink" title="使用 key 属性有哪些注意事项？"></a>使用 key 属性有哪些注意事项？</h3><h4 id="面试高频指数：★-★-★-☆-☆"><a href="#面试高频指数：★-★-★-☆-☆" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul>
<li>key 用来帮助 React 识别哪些元素改变</li>
<li>key 在数组列表及兄弟节点之间必须唯一</li>
<li>不建议使用索引作为 key 值，如果不显示指定 key 值，默认使用索引作为 key 值</li>
<li>key 只有放在就近的数组上下文中才有意义</li>
<li>key 不会传递给子组件，需要使用 key 属性的值，需使用其他属性显式传递</li>
</ul>
<h3 id="如何在-React-中进行静态类型检查？"><a href="#如何在-React-中进行静态类型检查？" class="headerlink" title="如何在 React 中进行静态类型检查？"></a>如何在 React 中进行静态类型检查？</h3><h4 id="面试高频指数：★-★-★-☆-☆-1"><a href="#面试高频指数：★-★-★-☆-☆-1" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul>
<li>React.PropTypes 或 prop-types 库<ul>
<li>提供一系列验证器，确保组件接收到的数据类型有效</li>
<li>PropTypes 仅在开发模下进行检查并在控制台显示警告</li>
<li>通过特定的 defaultProps 属性来定义 props 的默认值</li>
</ul>
</li>
<li>Flow<ul>
<li>Flow 是一个针对 JavaScript 代码的静态类型检测器</li>
<li>Facebook 开发，经常与 React 一起使用</li>
<li>Flow 通过特殊类型语法为变量、函数以及 React 组件提供注解</li>
<li>Flow 添加方法<ul>
<li>将 Flow 添加到项目依赖</li>
<li>确保编译后的代码已经去除 Flow 语法</li>
<li>添加类型注解并且运行 Flow 来检查</li>
</ul>
</li>
</ul>
</li>
<li>TypeScript<ul>
<li>TypeScript 是微软开发的编程语言，它是 JavaScript 的类型超集，包含独立编译器</li>
<li>类型语言，构建时可以发现 bug 和错误</li>
<li>TypeScript 添加方法<ul>
<li>将 TypeScript 添加到项目依赖</li>
<li>配置 TypeScript 编译选项</li>
<li>使用正确的文件扩展名，React 的 JSX 使用<code>.tsx</code>作为扩展名</li>
<li>为已经使用的库添加定义，现实其他包的错误和提示</li>
</ul>
</li>
</ul>
</li>
<li>新语法和工具链<ul>
<li>Reason，由 Facebook 开发，经过实战验证的 OCaml 语言</li>
<li>Kotlin，由 JetBrains 开发的静态类型语言</li>
</ul>
</li>
</ul>
<h3 id="如何限制某个属性是必须的？"><a href="#如何限制某个属性是必须的？" class="headerlink" title="如何限制某个属性是必须的？"></a>如何限制某个属性是必须的？</h3><p>React 中，可以在任何 PropTypes 属性后加上 isRequired，声明该属性必须</p>
<ul>
<li>当必须属性没有被提供值时，控制台打印警告信息</li>
<li>表示该属性必须，而不限制属性类型，可以使用 PropTypes.any.isRequired</li>
<li>表示必须包含一个元素，可以使用 PropTypes.element.isRequired</li>
</ul>
<h3 id="如何设置属性的默认值？"><a href="#如何设置属性的默认值？" class="headerlink" title="如何设置属性的默认值？"></a>如何设置属性的默认值？</h3><h4 id="面试高频指数：★-★-★-☆-☆-2"><a href="#面试高频指数：★-★-★-☆-☆-2" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>React 中，通过特定 defaultProps 属性来定义 props 默认值</p>
<ul>
<li>设置类组件或函数组件的静态属性 defaultProps</li>
<li>类组件，参考 proposal-class-fields 提案，在 class 内声明静态属性 defaultProps</li>
<li>当传入属性值为 undefined 时，使用属性的默认值</li>
</ul>
<h3 id="React-是否支持-HTML-属性？"><a href="#React-是否支持-HTML-属性？" class="headerlink" title="React 是否支持 HTML 属性？"></a>React 是否支持 HTML 属性？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-4"><a href="#面试高频指数：★-★-☆-☆-☆-4" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>React16 中，任何标准和自定义的 DOM 属性都是完全支持</li>
<li>React 为 DOM 提供了一套以 JavaScript 为中心的 API<ul>
<li>标准 DOM 属性采用小驼峰命名</li>
<li>自定义属性全部小写</li>
</ul>
</li>
<li>React 与 HTML 之间部分属性存在差异<ul>
<li>checked<ul>
<li>受控组件 checked</li>
<li>非受控组件用 defaultChecked 设置组件首次挂载时是否被选中</li>
</ul>
</li>
<li>classNmae<ul>
<li>用于指定 DOM 节点和 SVG 元素的 class</li>
<li>React 中，使用 Web Components，使用 class 属性代替</li>
</ul>
</li>
<li>dangerouslySetInnerHTML<ul>
<li>React 为浏览器 DOM 提供 innerHTML 的替换方案</li>
<li>需要向该属性传入 key 为 __html 的对象，用来警示跨站脚本（XSS）攻击风险</li>
</ul>
</li>
<li>htmlFor<ul>
<li>for 是 JavaScript 关键字</li>
<li>React 元素使用 htmlFor 代替</li>
</ul>
</li>
<li>onChange<ul>
<li>onChange 事件与预期行为一致：表单字段变化时，事件都会被触发</li>
<li>与浏览器已有的默认行为不一致：<ul>
<li>用户更改 <code>&lt;input&gt;</code>,<code>&lt;select&gt;</code> 和 <code>&lt;textarea&gt;</code> 元素的值并提交更改时 <code>change</code> 事件在这些元素上触发</li>
<li>与 <code>input</code> 事件不一样，<code>change</code> 事件不是每次元素的 <code>value</code> 改变时都会被触发</li>
</ul>
</li>
<li>React 依靠该事件实时处理用户输入</li>
</ul>
</li>
<li>selected<ul>
<li>将 <code>&lt;option&gt;</code> 标记为已选中状态，请在 <code>select</code> 的 <code>value</code> 中引用该选项的值</li>
</ul>
</li>
<li>style<ul>
<li>接受小驼峰命名属性的 JavaScript 对象，而不是 CSS 字符串</li>
<li>与 JavaScript 属性一致，同时会更高效，且能预防跨站脚本（XSS）的安全漏洞</li>
<li>样式不会自动补齐浏览器私有前缀，除 <code>ms</code> 外，浏览器引擎前缀都应以大写字母开头</li>
<li>React 自动添加 “px” 后缀到内联样式为数字的属性<ul>
<li>本来没有单位的属性 <code>zoom</code>,<code>order</code>,<code>flex</code> 不会转换像素字符串</li>
<li>需使用 “px” 以外单位，请将值设为数字与所需单位组成的字符串</li>
</ul>
</li>
</ul>
</li>
<li>suppressContentEditableWaring<ul>
<li>禁止拥有子节点的元素比标记为 contentEditable 时 React 发出警告</li>
</ul>
</li>
<li>suprressHydrationWarning<ul>
<li>禁止 React 服务端渲染与客户端渲染不同内容时发出警告</li>
<li>只会对元素一级深度有效，应急方案使用，不过过度使用</li>
</ul>
</li>
<li>value<ul>
<li><code>&lt;input&gt;</code>,<code>&lt;select&gt;</code>,<code>&lt;textarea&gt;</code> 组件支持 <code>value</code> 属性</li>
<li>非受控组件使用 <code>dafaultValue</code> 属性设置组件第一次挂载时的 <code>value</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="React-是否支持自定义属性？"><a href="#React-是否支持自定义属性？" class="headerlink" title="React 是否支持自定义属性？"></a>React 是否支持自定义属性？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-5"><a href="#面试高频指数：★-★-☆-☆-☆-5" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>React 16 前会忽略未知的 DOM 属性。JSX 属性 React 无法识别，将被跳过</li>
<li>React 16 中任何未知的属性都会在 DOM 显示，适用于<ul>
<li>非标准属性</li>
<li>尝试实验中的 DOM 接口</li>
<li>集成第三方库或 Web Components</li>
</ul>
</li>
</ul>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><h3 id="React-父子组件通信有哪些方法？"><a href="#React-父子组件通信有哪些方法？" class="headerlink" title="React 父子组件通信有哪些方法？"></a>React 父子组件通信有哪些方法？</h3><h4 id="面试高频指数：★-★-★-★-★"><a href="#面试高频指数：★-★-★-★-★" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><ul>
<li>props<ul>
<li>父组件将需要传递的数据，更改 state 的方法或组件本身通过 props 传递给子组件</li>
<li>子组件通过 props 传来的回调函数向父组件传递数据或更改状态</li>
</ul>
</li>
<li>refs<ul>
<li>适合在典型数据流之外强制修改子组件的场景，例如<ul>
<li>管理焦点，文本选择或媒体播放</li>
<li>触发强制动画</li>
<li>集成第三方 DOM 库</li>
</ul>
</li>
<li>DOM refs 打破组件封装，ref 转发更改开发者预期<ul>
<li>应避免过度使用，用声明式实现和状态提升代替</li>
<li>一定要使用时，建议添加注释和说明</li>
</ul>
</li>
<li>被修改的子组件可以是 React 组件实例或 DOM 元素</li>
<li>包含向子组件添加 ref、回调 refs 和 ref 转发三种方式</li>
</ul>
</li>
<li>context<ul>
<li>适合在组件之间共享如地区偏好，主题等数据，避免逐层传递 props</li>
<li>存在 context 的 value 更新，内部所有消费组件都重新渲染问题</li>
<li>过度使用组件的状态与上下文相关，复用度降低</li>
</ul>
</li>
<li>事件订阅发布<ul>
<li>实现并使用 Event Bus<ul>
<li>在需要数据的组件监听自定义事件，并传入改变状态更新组件的回调函数</li>
<li>在获取数据的组件触发自定义事件，并传入数据，执行回调函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Eventbus</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span> () &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">fns</span> = []</span><br><span class="line">	&#125;</span><br><span class="line">	emit (type, ...args) &#123;</span><br><span class="line">		<span class="keyword">const</span> fns = <span class="variable language_">this</span>.<span class="property">fns</span>[type]</span><br><span class="line">		<span class="keyword">if</span> (fns) fns.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args))</span><br><span class="line">	&#125;</span><br><span class="line">	addListener (type, fn) &#123;</span><br><span class="line">		<span class="keyword">const</span> fns = <span class="variable language_">this</span>.<span class="property">fns</span>[type]</span><br><span class="line">		fns ? fns.<span class="title function_">push</span>(fn) : (<span class="variable language_">this</span>.<span class="property">fns</span>[type] = [fn])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 使用 Node.js 的 events</span><br></pre></td></tr></table></figure>

<ul>
<li>使用状态管理，举例说明特点<ul>
<li>Redux<ul>
<li>单一数据源 store</li>
<li>state 只能通过 action 更改</li>
<li>使用 reducer 纯函数返回新 state 来更改 state</li>
</ul>
</li>
<li>Recoil<ul>
<li>任意地方灵活共享 state，并保持高性能</li>
<li>高效可靠地根据变化的 state 进行计算</li>
<li>支持持久化日志</li>
<li>支持 undo</li>
</ul>
</li>
<li>hox<ul>
<li>只有一个 API</li>
<li>使用 custom Hooks 定义 model</li>
<li>支持 TS</li>
<li>支持多数据源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="为什么-React-是单向数据流？"><a href="#为什么-React-是单向数据流？" class="headerlink" title="为什么 React 是单向数据流？"></a>为什么 React 是单向数据流？</h3><h4 id="面试高频指数：★-★-★-☆-☆-3"><a href="#面试高频指数：★-★-★-☆-☆-3" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul>
<li>React 组件不关心其他组件是否有状态和类型<ul>
<li>父组件可以把它的 state 作为 props 向下传递它的子组件中</li>
<li>子组件通过 props 接收父组件的数据，不关心数据来源于父组件的 state 或 props</li>
</ul>
</li>
<li>React 中这种自上而下的数据传递被称为单向数据流<ul>
<li>状态 state 总是所属于特定的组件</li>
<li>状态 state 派生的任何数据和 UI 只能影响树中“低于”它们的组件</li>
</ul>
</li>
<li>单向数据流单向绑定无关，对比双向绑定<ul>
<li>坏处：需要绑定更多“样板”代码</li>
<li>好处：排除和隔离 bug 所需的工作量将会减少<ul>
<li>状态 state 只有其所在组件自身可修改</li>
<li>Bug 可以使用 React 开发者工具来检查问题组件的 props</li>
<li>按照组件树结构逐级向上搜寻，直到定位到负责更新 state 的组件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="什么是-Context-？"><a href="#什么是-Context-？" class="headerlink" title="什么是 Context ？"></a>什么是 Context ？</h3><h4 id="面试高频指数：★-★-★-★-☆-1"><a href="#面试高频指数：★-★-★-★-☆-1" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul>
<li>Context 提供了一种无需为每层组件手动添加 props，能在组件树间进行数据传递的方法</li>
<li>Context 设计目的是共享或缓存组件树的全局数据，如用户认证，地区偏好，主题和语言</li>
<li>Context 应用场景是不同层级组件访问同样数据，副作用是降低组件的复用性</li>
<li>Context API<ul>
<li>React.createContext 创建 Context 对象，订阅该对象的组件从组件树中离自身最近的匹配的 Provider 中读取当前的 context 值</li>
<li>Context.Provider 接收 value 属性，当其发生变化时，内部所有消费组件都会重新渲染，忽略 shouldComponentUpdate 函数</li>
<li>Class.contextType 订阅单一 context，在任何生命周期中，使用 this.context 访问</li>
<li>Context.Consumer<ul>
<li>在函数式组件中订阅 context 的变更</li>
<li>需要一个函数作为子元素。函数接收当前 context 值，并返回一个 React 节点<ul>
<li>context 值由最近的 Provider 提供</li>
<li>没有 Provider 时等同于 createContext() 的 defaultValue</li>
</ul>
</li>
</ul>
</li>
<li>Context.displayName 指定组件在 DevToools 中显示的名称</li>
</ul>
</li>
</ul>
<h3 id="什么是-ContextType"><a href="#什么是-ContextType" class="headerlink" title="什么是 ContextType ?"></a>什么是 ContextType ?</h3><h4 id="面试高频指数：★-★-★-☆-☆-4"><a href="#面试高频指数：★-★-★-☆-☆-4" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ol>
<li>ContextType 用于订阅单一的 context</li>
</ol>
<ul>
<li><p>设置 class.contextType 为 React.createContext() 创建的 context 对象</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const MyContext = React.createContext(defaultValue)</span><br><span class="line">class NewClass extend React.Component &#123;</span><br><span class="line">	render() &#123;</span><br><span class="line">		const value = this.context</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">NewClass.contextType = MyContext</span><br></pre></td></tr></table></figure>

<ul>
<li><p>类组件参考 proposal-class-fields 提案</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const MyContext = React.createContext(defaultValue)</span><br><span class="line">class NewClass extend React.Component &#123;</span><br><span class="line">	static contextType = MyContext</span><br><span class="line">	render() &#123;</span><br><span class="line">		const value = this.context</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在 React 组件中，使用 this.context 访问通过 contextType 指定的 Context</li>
</ol>
<h3 id="如何优化-Context-？"><a href="#如何优化-Context-？" class="headerlink" title="如何优化 Context ？"></a>如何优化 Context ？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-6"><a href="#面试高频指数：★-★-☆-☆-☆-6" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>为什么要优化 Context ?</li>
</ul>
<p>Context 的 value 更新，它内部所有消费组件都会重新渲染，并且不受制于 shouldComponentUpdate 函数</p>
<ul>
<li>优化 Context 的方法<ul>
<li>避免使用对象字面量作为 value</li>
</ul>
</li>
</ul>
<p>context 使用参考标识（reference identity) 来决定渲染时机，当 Provider 接收 value 为对象字面量时，每次 value 都会被赋值新对象，建议将 value 状态提升到父节点的 state 里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 拆分 Context</span><br></pre></td></tr></table></figure>

<p>将原来同一个 Context 频繁变化的值拆分出来，分别放入不同的 Context</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 记忆化</span><br></pre></td></tr></table></figure>

<p>使用 React.memo 或 useMemo 包裹组件，指定需要比较的值，只有值变化时重新渲染</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 使用 createContext 的第二参数，不稳定，不推荐</span><br></pre></td></tr></table></figure>

<p>createContext 为函数，两个形参分别为更新前后值，接收 Number 类型作为返回值</p>
<p>在订阅 context 变化的组件上，使用 unstable_observedBits 设置重新渲染组件的条件</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const &#123; Consumer, Provider &#125; = React.createContext(null, (prev, next) =&gt; &#123;</span><br><span class="line">	if (prev.value1 !== next.value1) return 1</span><br><span class="line">	if (prev.value2 !== next.value2) return 10</span><br><span class="line">&#125;)</span><br><span class="line">const Consumer1 =&gt; &#123; // 只有当 value1 变化重新渲染</span><br><span class="line">	return &lt;Consumer unstable_observedBits=&#123;1&#125; children=&#123;value =&gt; (</span><br><span class="line">&lt;&gt;&#123;value&#125;&lt;/&gt;</span><br><span class="line">)&#125;</span><br><span class="line">/&gt;</span><br><span class="line">&#125;</span><br><span class="line">const Consumer2 =&gt; &#123;// 只有当 value2 变化重新渲染</span><br><span class="line">return &lt;Consumer unstable_oberverdBits=&#123;10&#125; children=&#123;value =&gt; (</span><br><span class="line">&lt;&gt;&#123;value&#125;&lt;/&gt;</span><br><span class="line">)&#125;</span><br><span class="line">/&gt;</span><br><span class="line">&#125;</span><br><span class="line">* 使用第三方库</span><br><span class="line">    * use-context-selector</span><br><span class="line">        * 使用 createContext 创建支持 useContextSelector 的特殊 context</span><br><span class="line">        * 使用 useContextSelector 选择 context 某个值，当且仅当该值变化时，重新渲染</span><br><span class="line">    * React Tracke</span><br></pre></td></tr></table></figure>

<h3 id="什么是-Ref-转发？"><a href="#什么是-Ref-转发？" class="headerlink" title="什么是 Ref 转发？"></a>什么是 Ref 转发？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-7"><a href="#面试高频指数：★-★-☆-☆-☆-7" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li><p>Ref 转发可以将</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref</span><br></pre></td></tr></table></figure>

<p>传递到子组件</p>
<ul>
<li>由 <code>React.forwardRef</code> 实现</li>
<li>向 <code>ref</code> 传入回调函数，函数第一参数是 React 组件实例或 HTML DOM 元素</li>
</ul>
</li>
<li><p>Ref 转发适合应用场景</p>
<ul>
<li>转发表单组件的 ref 到 DOM 节点，便于访问 DOM 节点，来管理焦点、选中或动画</li>
<li>在高阶组件内，转发外层组件的 ref 到 被包裹的组件</li>
</ul>
</li>
<li><p>Ref 转发更改了组件默认的 ref 指向，对组件使用者不可见，不建议使用</p>
<ul>
<li>不兼容之前同时使用组件和 ref 的应用</li>
<li>对组件使用者，ref 结果可能不符合直观预期</li>
</ul>
</li>
<li><p>由</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.forwardRef</span><br></pre></td></tr></table></figure>

<p>实现 Ref 转发，可以使用函数决定 ref 转发组件显示的内容</p>
<ul>
<li>设置传入 <code>React.forwardRef</code> 函数名称，例如</li>
</ul>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const newComponent = React.forwardRef(function myName(props, ref) &#123;</span><br><span class="line">	return &lt;innerComponent &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;</span><br><span class="line">&#125;)</span><br><span class="line">// DevTools DisplayName: ForwardRef(myName)</span><br><span class="line">* 设置函数的 displayName 来包含被包裹组件的名称</span><br></pre></td></tr></table></figure>

<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function myName(props, ref) &#123;</span><br><span class="line">	return &lt;innerComponent &#123;...props&#125; forwardedRef=&#123;ref&#125;</span><br><span class="line">&#125;</span><br><span class="line">myName.displayName = &#x27;myDisplayName&#x27;</span><br><span class="line">const newComponent = React.forwardRef(myName)</span><br><span class="line">// DevTools DisplayName: ForwardRef(myDisplayName)</span><br></pre></td></tr></table></figure>

<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><h3 id="React-返回空对象有哪些方法？"><a href="#React-返回空对象有哪些方法？" class="headerlink" title="React 返回空对象有哪些方法？"></a>React 返回空对象有哪些方法？</h3><ul>
<li>false &#x2F; true &#x2F; null &#x2F; undefined 将被忽略，不被渲染</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span> / <span class="literal">true</span> / <span class="literal">null</span> /<span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>React.Fragment &#x2F; &lt;&gt;</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span> /&gt;</span></span> <span class="regexp">/ &lt;/</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何优化不必要的渲染？"><a href="#如何优化不必要的渲染？" class="headerlink" title="如何优化不必要的渲染？"></a>如何优化不必要的渲染？</h3><h4 id="面试高频指数：★-★-★-★-★-1"><a href="#面试高频指数：★-★-★-★-★-1" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><ul>
<li><p>优化状态 state</p>
<ul>
<li>避免使用多层嵌套对象作为 state，降低比较效率，提高比较难度<ul>
<li>如果超过3层，建议继续拆分组件，将每一层状态放置在更内层的组件中</li>
</ul>
</li>
<li>状态提升和隔离<ul>
<li>多个组件需要反映相同的变化数据，共享状态提升到最近的共同父组件</li>
<li>仅影响组件本身的状态隔离放置在组件内部<ul>
<li>状态管理库可以使用 Recoil，其使用 Atom 更灵活地管理状态</li>
</ul>
</li>
</ul>
</li>
<li>合并状态更新，分离计算和渲染<ul>
<li>出于性能考虑，React 可能会把多个 setState 调用合并成一个调用</li>
<li>如果状态更新后，需要根据新状态计算或判断，再更新状态<ul>
<li>那么更新计算前的状态引发的渲染很可能不必要</li>
<li>分离计算逻辑，先计算状态的最终值，直接更新状态到最终值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>优化属性 props</p>
<ul>
<li>除高阶组件等需保持接口一致的场景外，props 保持简单，仅与组件单一职责关联</li>
<li>避免使用多层嵌套对象作为 props，降低比较效率，提高比较难度</li>
<li>组件只关心自身相关的 props<ul>
<li>例如标识单选、复选的选中状态、列表的激活项<ul>
<li>为每一项添加是否选中，是否激活标识优于额外添加选中项，激活项列表属性</li>
</ul>
</li>
</ul>
</li>
<li>避免在 render 等渲染函数中重复创建对象和函数，先赋值到变量再引用<ul>
<li>避免使用对象字面量作为 props，每次 render 创建新对象，相应子组件重复渲染</li>
<li>避免使用匿名函数作为 props，每次 render 创建新函数，相应子组件重复渲染</li>
</ul>
</li>
</ul>
</li>
<li><p>先比较再更新</p>
<ul>
<li>类组件<ul>
<li>使用 PureComponent 执行一层浅比较 props 或 state，值变化时渲染</li>
<li>使用 shouldComponentUpdate 函数<ul>
<li>手动比较前后 props 或 state，返回 true 渲染，false 不渲染</li>
<li>若 state 为对象，使用不可变对象，简化并加速比较</li>
</ul>
</li>
</ul>
</li>
<li>函数式组件<ul>
<li>使用 React.memo 比较 props 再渲染组件<ul>
<li>不使用第二参数时，一层浅比较 props，变化时渲染</li>
<li>使用第二参数时，手动比较前后的 props，返回 false 渲染，true 不渲染</li>
</ul>
</li>
<li>使用 useMemo 指定依赖，细粒度渲染组件<ul>
<li>使用第二参数，传入依赖数组，当数组中的值发生变化时，更新返回值</li>
<li>通常包裹函数式组件的返回值，指定依赖的 props 或 state 的具体值</li>
<li>包裹任意需要复杂计算的函数，指定依赖的变量。能在同一组件中部分和多次使用</li>
</ul>
</li>
<li>使用 useCallback 避免函数重复创建引起渲染<ul>
<li>当函数式组件重新更新时，内部声明的函数可能会被重复创建<ul>
<li>将这些函数作为 props 传入的子组件会重复渲染</li>
<li>使用 useCallback 包裹函数，传入空数组，总是返回相同函数来避免重复创建引起的渲染</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>减少嵌套</p>
<ul>
<li>减少不必要的根组件<ul>
<li>返回一个组件列表数组</li>
<li>使用内置组件文档碎片<code>React.Fragement</code>或其缩写<code>&lt;&gt;</code></li>
</ul>
</li>
<li>谨慎使用 CSS-in-JS 方案<ul>
<li>Class + 样式表方案的渲染性能和 CSS 本身的复用度总体优于内联方案</li>
<li>避免仅为书写内联样式而频繁地创建嵌套组件</li>
</ul>
</li>
</ul>
</li>
<li><p>惰性渲染</p>
<ul>
<li><p>key 唯一</p>
<ul>
<li>使用唯一标识作为 key，而不是 索引，让 React 精确判断变化，复用不变元素</li>
</ul>
</li>
<li><p>条件渲染</p>
<ul>
<li>使用 <code>if</code>&#x2F;<code>else</code> 三元运算符或逻辑运算符，仅在条件满足时，渲染组件</li>
<li>渲染列表时，当条件不满足时，返回 null 或空组件，保留组件位置</li>
</ul>
</li>
<li><p>防抖和节流</p>
<ul>
<li><p>使用 <code>window.requestAnimationFrame</code> 或定时器构建防抖或节流函数</p>
</li>
<li><p>使用 <code>MutationObserver</code> 代替定时器</p>
</li>
<li><p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intersection Observer</span><br></pre></td></tr></table></figure>

<p>代替</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.scroll</span><br></pre></td></tr></table></figure>

<ul>
<li>懒加载图片<ul>
<li>只渲染可视区域的图片</li>
</ul>
</li>
<li>懒加载 DOM<ul>
<li>只渲染可视区域的 DOM，如虚拟列表，商品详情<ul>
<li>虚拟列表库可以使用 react-virtualized 及其更新 react-window</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>异步路由</p>
</li>
</ul>
</li>
<li><p>优化 Context，减少 value 更新，内部所有消费组件的重新渲染</p>
<ul>
<li>拆分 Context<ul>
<li>将原属于同一 Context 的值拆分到不同的 Context</li>
</ul>
</li>
<li>记忆化<ul>
<li>使用 React.memo 或 useMemo 包裹组件，指定需要比较的值，只有值变化时重新渲染</li>
</ul>
</li>
<li>使用 createContext 的第二参数，不稳定，不推荐<ul>
<li>createContext 为函数，两个形参分别为更新前后值，接收 Number 类型作为返回值</li>
<li>在订阅 context 变化的组件上，使用 unstable_observedBits 设置重新渲染组件的条件</li>
</ul>
</li>
<li>使用第三方库<ul>
<li>use-context-selector</li>
<li>React Tracke</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="React-如何渲染-HTML-，有什么风险？"><a href="#React-如何渲染-HTML-，有什么风险？" class="headerlink" title="React 如何渲染 HTML ，有什么风险？"></a>React 如何渲染 HTML ，有什么风险？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-4"><a href="#面试高频指数：★-☆-☆-☆-☆-4" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li><p><code>dangerouslySetInnerHTML</code> 是 React 为浏览器 DOM 提供 <code>innerHTML</code> 的替换方案</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function newComponent() &#123;</span><br><span class="line">	return &lt;div dangerouslySetInnerHTML=&#123;&#123;__html: &#x27;&lt;b&gt;1&lt;/b&gt;&#x27;&#125;&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码直接设置 HTML 存在风险，很容易无意中使用户暴露于跨站脚本（XSS）攻击</li>
<li>React 设计此替换方案，通过名称警示开发者</li>
</ul>
<h3 id="React-为什么要引入基于-Fiber-协调器的异步渲染？"><a href="#React-为什么要引入基于-Fiber-协调器的异步渲染？" class="headerlink" title="React 为什么要引入基于 Fiber 协调器的异步渲染？"></a>React 为什么要引入基于 Fiber 协调器的异步渲染？</h3><h4 id="面试高频指数：★-★-★-☆-☆-5"><a href="#面试高频指数：★-★-★-☆-☆-5" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul>
<li>在经典渲染模式下，React 一旦开始渲染一次更新，不能中断包括创建新 DOM 节点和运行组件中代码在内的工作，这种渲染方法为“阻塞渲染”</li>
<li>渲染阻塞响应用户输入和动画，使用防抖牺牲一定的响应即时性，使用节流降低更新频率，都不能提供最佳用户体验。</li>
<li>React 提供 Concurrent 模式，将人机交互研究的结果整合到真实 UI 中<ul>
<li>渲染可中断</li>
<li>有意的加载顺序<ul>
<li>React 可以在旧屏幕桑多停留一段时间，跳过不够好的加载状态，直接展示新屏幕</li>
</ul>
</li>
<li>并发，使用启发式方法决定更新紧急性，同时更新多个状态<ul>
<li>对于 CPU 密集型更新，例如创建新 DOM 节点和运行组件中代码，任意一个更急迫更新可以中断已经开始的渲染</li>
<li>对于 IO 密集型更新，例如从网络加载代码或数据，在全部数据到达前在内存中渲染，跳过令人不愉快的空白加载状态</li>
<li>对于超出屏幕显示的更新，延迟它的相关逻辑</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="什么是-React-Fiber"><a href="#什么是-React-Fiber" class="headerlink" title="什么是 React Fiber ?"></a>什么是 React Fiber ?</h3><h4 id="面试高频指数：★-★-☆-☆-☆-8"><a href="#面试高频指数：★-★-☆-☆-☆-8" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li><p>React 组件是数据的函数 <code>v = f(d)</code></p>
</li>
<li><p>计算机通过调用栈跟踪程序执行</p>
<ul>
<li>函数执行，栈会添加新堆栈结构，代表函数执行的事务</li>
<li>太多事务同时执行，会导致动画掉帧，用户输入无法及时响应</li>
<li>现代浏览器提供 API<ul>
<li><code>requestIdleCallback</code> 调度一个低优先级函数在空闲阶段执行</li>
<li><code>requestAnimationFrame</code> 调度一个高优先级函数在下一个动画帧执行</li>
</ul>
</li>
<li>需要自定义调用栈行为，来使用这些 API 优化 UI 渲染</li>
</ul>
</li>
<li><p>React Fiber 是专门为 React 组件实现的堆栈重构</p>
<ul>
<li><p>堆栈结构可以保存在内存中，手动调度和操作</p>
</li>
<li><p>单个 fiber 是虚拟的堆栈结构，对应一个组件实例</p>
<ul>
<li><p>包含组件及其输入、输出信息的 JavaScript 对象</p>
<ul>
<li><pre><code>type
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  是执行会被堆栈结构跟踪的函数</span><br><span class="line"></span><br><span class="line">  - 复合函数、组件类 class 或字符串</span><br><span class="line"></span><br><span class="line">- `key` 决定协调算法 Fiber 是否可重用</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  child</span><br></pre></td></tr></table></figure>

 

指向

- 类组件 class 的 `render` 方法返回值
- 函数组件 的`return` 返回值
</code></pre>
</li>
<li><pre><code>sibling
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  指向</span><br><span class="line"></span><br><span class="line">  - 类组件 class 或函数组件返回数组，其中包含多个子节点的情况</span><br><span class="line"></span><br><span class="line">- `return` 返回父 fiber</span><br><span class="line"></span><br><span class="line">- 属性，即函数参数，以下两者相等，则 fiber 可复用</span><br><span class="line"></span><br><span class="line">  - `pendingProps` fiber 开始时设置</span><br><span class="line">  - `memoizedProps` fiber 结束时设置</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  pengdingWorkProiority</span><br></pre></td></tr></table></figure>

 

事务优先级数字

- 0 表示 `NoWork`
- 数字越大，优先级越低
- 调度器使用该字段搜索下一个要执行的事务
</code></pre>
</li>
<li><p>&#96;&#96;&#96;<br>alternate</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `flush` 渲染输出结果到屏幕</span><br><span class="line">  - `work-in-progress` 进行中的 fiber 代表未返回堆栈结构的 fiber</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  output</span><br></pre></td></tr></table></figure>

<ul>
<li><code>host component</code> 是 React 应用的叶子节点，浏览器环境是小写 HTML 标签</li>
<li>每个 fiber 输出结果由宿主组件创建，向上传递到整个树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="React-Fiber-异步渲染分为哪几个阶段，对应生命周期是什么？"><a href="#React-Fiber-异步渲染分为哪几个阶段，对应生命周期是什么？" class="headerlink" title="React Fiber 异步渲染分为哪几个阶段，对应生命周期是什么？"></a>React Fiber 异步渲染分为哪几个阶段，对应生命周期是什么？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-9"><a href="#面试高频指数：★-★-☆-☆-☆-9" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>不同于 Stack renconciler，Fiber reconciler 过程分为两个阶段：</p>
<ul>
<li><p>render &#x2F; reconciliation 可中断阶段</p>
<ul>
<li><p>以 Fiber tree 为蓝本，每个 Fiber 为工作单元，自顶向下构造 workInProgress Tree</p>
<ul>
<li><p>判断节点是否需要更新</p>
<ul>
<li><p>需要更新，标记当前节点</p>
<ul>
<li><p>更新当前节点状态和属性</p>
</li>
<li><p>调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate</span><br></pre></td></tr></table></figure>

<ul>
<li><p>返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ture</span><br></pre></td></tr></table></figure>

<p>需要更新</p>
<ul>
<li><p>调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render</span><br></pre></td></tr></table></figure>

<ul>
<li>返回子节点，并创建对应 <code>fiber</code></li>
<li>无子节点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>当前工作单元结束，返回副作用列表</p>
</li>
<li><p>检查 fiber 的 sibiling 或 child</p>
<ul>
<li>存在，作为下一个工作单元<ul>
<li>检查剩余可用时间<ul>
<li>有，立即开始下一个工作单元</li>
<li>无，等待下一次主线程空闲，开始下一个工作单元，通过 <code>requestIdleCallback</code> 实现</li>
</ul>
</li>
</ul>
</li>
<li>没有下一个工作单元，本阶段结束，进入 <code>pendingCommit</code> 状态</li>
</ul>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/react-interview/nafqor/">∨∧Page 2</a></p>
</li>
<li><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/"><img src="/../imgs/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/logo-dark-cn.c42314a8.svg+xml" alt="logo"></a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/">学习</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problemset/all/">题库</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/">讨论</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/contest/">竞赛</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/company/">求职</a></li>
<li>商店</li>
</ul>
</li>
<li></li>
<li></li>
<li></li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">-</a></p>
</li>
<li><p><img src="/../imgs/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/avatar_1645205761.webp" alt="img"><img src="/../imgs/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/plus-light.594ca211.svg+xml" alt="img"></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/detail/react-interview/">返回</a></p>
</li>
<li></li>
</ul>
</li>
<li><p>commit 不可中断阶段</p>
<ul>
<li>执行副作用列表<ul>
<li>更新 DOM 树，更新 ref 指向</li>
<li>调用组件的生命周期函数或 useEffect 声明的钩子</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对应生命周期</p>
<ul>
<li>render &#x2F; reconciliation<ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpate</li>
<li>componentWillUpdate</li>
</ul>
</li>
<li>commit<ul>
<li>componentDidMount</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ul>
</li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="React-组件有哪些生命周期方法？"><a href="#React-组件有哪些生命周期方法？" class="headerlink" title="React 组件有哪些生命周期方法？"></a>React 组件有哪些生命周期方法？</h3><h4 id="面试高频指数：★-★-★-☆-☆-6"><a href="#面试高频指数：★-★-★-☆-☆-6" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>React 每个组件都包含“生命周期”方法</p>
<p>开发者可以重写这些方法，便于在运行过程中特定阶段执行这些方法</p>
<ul>
<li>constructor(props)<ul>
<li>React 组件挂载之前调用</li>
<li>用于初始化 state 和 方法绑定，例如绑定事件处理函数的 this</li>
</ul>
</li>
<li>static getDerivedStateFromProps(props, state)<ul>
<li>React 组件调用 render 方法前，初始挂载及后续更新都会被调用</li>
<li>用于返回一个对象来更新 state，返回 null 不更新任何内容</li>
<li>每次渲染都会触发，包括父组件重新渲染以及组件本身调用 setState</li>
<li>以下场景不使用 getDerivedStateFromProps<ul>
<li>执行副作用应用 componentDidUpdate</li>
<li>prop 更改时重新计算某些数据，请使用 memoization helper 代替</li>
<li>prop 更改时“重置”某些 state<ul>
<li>请考虑使组件完全受控或使用 key 使组件完全不受控 代替</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>shouldComponentUpdate(nextProps, nextState)<ul>
<li>props 或 state 发生变化时，渲染执行之前被调用</li>
<li>首次渲染及 forceUpdate() 调用，React 参考返回 true &#x2F; false，决定是否重新渲染</li>
</ul>
</li>
<li>render()<ul>
<li>class 组件中唯一必须实现的方法，纯函数，每次调用应返回相同结果</li>
<li>当 render 被调用时，它会检查 this.props 和 this.state 变化，并返回<ul>
<li>React 元素：通过 JSX 创建</li>
<li>数组或 fragements：使得 render 方法可以返回多个元素</li>
<li>Portals：可以渲染子节点到不同 DOM 子树</li>
<li>字符串或数值类型：可以在 DOM 中被渲染为文本节点</li>
<li>布尔类型或 null：什么都不渲染</li>
</ul>
</li>
</ul>
</li>
<li>getSnapshotBeforeUpdate(prevProps, prevState)<ul>
<li>在最近一次渲染输出（提交到 DOM 节点）之前调用</li>
<li>能在组件发生更改之前从 DOM 中捕获信息，例如滚动位置</li>
<li>此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate 的第三参数</li>
</ul>
</li>
<li>componentDidMount()<ul>
<li>组件挂载后（插入 DOM 树中），即首次渲染时，立即调用</li>
<li>适用于放置依赖 DOM 节点、网络请求获取数据、添加订阅等</li>
<li>可以直接调用 setState()，触发依赖于 DOM 节点大小或位置的渲染</li>
</ul>
</li>
<li>componentDidUpdate(prevProps, prevState, snapshot)<ul>
<li>组件更新后立即调用，首次渲染不会执行此方法</li>
<li>可以执行 DOM 操作，比较前后 props，网络请求</li>
<li>可以直接调用 setState()，它必须被包裹在一个条件语句里，避免死循环</li>
<li>如果组件实现了 getSnapshotBeforeUpdate() 生命周期，则生命周期的返回值将作为 componentDidUpdate 的第三个参数</li>
</ul>
</li>
<li>componentWillUnmount()<ul>
<li>组件卸载及销毁之前直接调用</li>
<li>用于执行必要的清理操作，清除定时器、取消网络请求以及在 componentDidMount() 中创建的订阅等</li>
<li>不应调用 setState()，避免组件永远不会重新渲染</li>
</ul>
</li>
</ul>
<h3 id="React-组件的生命周期可分为哪些阶段？"><a href="#React-组件的生命周期可分为哪些阶段？" class="headerlink" title="React 组件的生命周期可分为哪些阶段？"></a>React 组件的生命周期可分为哪些阶段？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-10"><a href="#面试高频指数：★-★-☆-☆-☆-10" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>React 组件的生命周期可以分为三个阶段</p>
<ul>
<li>“Render”阶段：纯净且不包含副作用，可能会被 React 暂停、中止或重新启动<ul>
<li>constructor(props)</li>
<li>getDerivedStateFromPorps(props, state)</li>
<li>shouldComponentUpdate(nextProps, nextState)</li>
<li>render()</li>
</ul>
</li>
<li>“Pre-commit”阶段：可以读取DOM<ul>
<li>getSnapshotBeforeUpdate(prevProps, prevState)</li>
</ul>
</li>
<li>“Commit”阶段：可以使用 DOM，运行副作用，安排更新<ul>
<li>挂载时：componentDidMount()</li>
<li>更新时：componentDidUpdate(prevProps, prevState, snapshot)</li>
<li>卸载时：componentWillUnmount()</li>
</ul>
</li>
</ul>
<h3 id="异步数据请求应在哪些生命周期里调用？"><a href="#异步数据请求应在哪些生命周期里调用？" class="headerlink" title="异步数据请求应在哪些生命周期里调用？"></a>异步数据请求应在哪些生命周期里调用？</h3><h4 id="面试高频指数：★-★-★-★-☆-2"><a href="#面试高频指数：★-★-★-★-☆-2" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul>
<li>通过网络请求获取数据或订阅数据更新<ul>
<li>componentDidMount()</li>
<li>原因<ul>
<li>首次挂载时执行</li>
<li>不会重复请求或订阅数据更新</li>
<li>无需条件不容易触发重复渲染</li>
</ul>
</li>
</ul>
</li>
<li>有条件地通过网络请求数据<ul>
<li>componentDidUpdate(prevProps, prevState, snapshot)</li>
<li>原因<ul>
<li>可对比更新前后的 props 或 states</li>
<li>设置条件<ul>
<li>当且仅当条件满足时，通过网络请求数据</li>
<li>避免触发重复渲染</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>取消网络请求或者清除在 componentDidMount() 中创建的订阅<ul>
<li>componentWillUnmount()</li>
</ul>
</li>
</ul>
<h3 id="useEffect-useLayoutEffect-与生命周期的对应关系是？"><a href="#useEffect-useLayoutEffect-与生命周期的对应关系是？" class="headerlink" title="useEffect useLayoutEffect 与生命周期的对应关系是？"></a>useEffect useLayoutEffect 与生命周期的对应关系是？</h3><h4 id="面试高频指数：★-★-★-★-☆-3"><a href="#面试高频指数：★-★-★-★-☆-3" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><p>useLayoutEffect</p>
<ul>
<li>执行时机是组件挂载或更新之后，浏览器执行绘制之前<ul>
<li>与 componentDidMount + componentDidUpdate 一致</li>
</ul>
</li>
<li>支持返回清除函数，函数执行时机是组件卸载之前<ul>
<li>与 componentWillUnmout 一致</li>
</ul>
</li>
</ul>
<p>useEffect</p>
<ul>
<li>执行时机是组件挂载或更新之后，浏览器完成布局和绘制之后，在一个延迟事件中被调用<ul>
<li>与 componentDidMount + componentDidUpdate 不同</li>
</ul>
</li>
<li>支持返回清除函数，函数执行时机是组件卸载之前<ul>
<li>与 componentWillUnmout 一致</li>
</ul>
</li>
</ul>
<p>两者都适用于在函数组件主体内，即 React 渲染阶段改变 DOM，添加订阅，设置定时器，记录日志以及执行其他包含副作用的操作</p>
<p>优先使用 useEffect 避免阻塞视觉更新，只在需要读取 DOM 布局，在浏览器绘制前，同步触发重渲染的场景使用 useLayoutEffect</p>
<h3 id="在-constructor-中使用-super-的意义是？"><a href="#在-constructor-中使用-super-的意义是？" class="headerlink" title="在 constructor 中使用 super 的意义是？"></a>在 constructor 中使用 super 的意义是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-11"><a href="#面试高频指数：★-★-☆-☆-☆-11" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>JavaScript 中，super 指向父类构造函数，React 类组件可以是 React.Component 等</li>
<li>JavaScript 中，调用 super 前不能用 this。React 中不能声明 this.state 或读取 this.props</li>
<li>React 中，调用 super(props) 后，可以在 constructor 中访问 this.props</li>
<li>React 中，调用 super() 不传参，不能在 constructor 中访问 this.props<ul>
<li>React 在调用构造函数后，将 props 赋值到实例</li>
<li>可以在其他生命周期中，访问 this.props</li>
</ul>
</li>
<li>不调用 super，参考 proposal-class-fields 提案，可以将 state 等实例属性写在 class 内</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">	state = &#123; time : <span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对比-React-Hook-与生命周期"><a href="#对比-React-Hook-与生命周期" class="headerlink" title="对比 React Hook 与生命周期"></a>对比 React Hook 与生命周期</h3><h4 id="面试高频指数：★-★-☆-☆-☆-12"><a href="#面试高频指数：★-★-☆-☆-☆-12" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li><p>什么是 React Hook</p>
<ul>
<li>React Hook 是 React 16.8 的新增特性</li>
<li>开发者可以在不编写 Class 的情况下使用 State 以及其他的 React 特性</li>
</ul>
</li>
<li><p>为什么要用 React Hook 代替拥有生命周期的类组件</p>
<ul>
<li><p>类组件的弊端</p>
<ul>
<li><p>组件之间复用状态逻辑很难</p>
<ul>
<li><p>React 没有提供将可复用性行为“附加”到组件的途径</p>
</li>
<li><p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render props</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">高阶组件</span><br></pre></td></tr></table></figure>

<ul>
<li>需要重新组织组件结构，使得代码难以理解</li>
<li>形成“嵌套地域”，难以调试和维护</li>
</ul>
</li>
</ul>
</li>
<li><p>复杂组件变得难以理解</p>
<ul>
<li>组件被状态逻辑和副作用充斥</li>
<li>不相关逻辑被放在同一生命周期，相关逻辑被分散在不同生命周期<ul>
<li><code>componentDidMount</code>&#x2F;<code>componentDidUpdate</code> 获取数据</li>
<li><code>componentDidMount</code> 可能还包含事件监听，需在 <code>componentWillUnmount</code> 清除</li>
</ul>
</li>
<li>大量的状态逻辑，许多人使用状态管理库，组件复用和调试都比较困难</li>
</ul>
</li>
<li><p>难以理解的类组件</p>
<ul>
<li>大量的 this 绑定，较高学习成本，区分函数组件和类组件的使用场景</li>
<li>类组件会无意中鼓励开发者使用一些让 <code>Prepack</code> 等组件预编译优化措施无效的方案</li>
<li>类组件不能被很好的压缩，热重载不稳定，实例化类组件有轻微额外性能消耗</li>
</ul>
</li>
<li><p>有限的是否渲染控制</p>
<ul>
<li>使用 PureComponent 执行一层浅比较 props 或 state，值变化时渲染</li>
<li>使用 shouldComponentUpdate 函数<ul>
<li>手动比较前后 props 或 state，返回 true 渲染，false 不渲染</li>
<li>若 state 为对象，使用不可变对象，简化并加速比较</li>
</ul>
</li>
<li>在 setState 前设置判断条件，满足条件后再 setState</li>
</ul>
</li>
</ul>
</li>
<li><p>React Hook 解决的问题</p>
<ul>
<li>提高组件复用<ul>
<li>Hook 在无需修改组件结构的情况下，复用状态逻辑，共享 Hook 变得更便捷</li>
</ul>
</li>
<li>简化组件<ul>
<li>Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</li>
<li>非按照生命周期划分，可以使用 Reducer 来管理组件内部状态，使其更加可预测</li>
</ul>
</li>
<li>函数组件代替类组件<ul>
<li>Hook 在不使用类组件的情况下使用 State 以及其他的 React 特性</li>
<li>Hook 改造类组件为函数组件，容易理解 this 和学习，便于预编译等优化措施</li>
<li>Hook 拥抱函数式声明式编程，而无需学习复杂的函数式或响应式编程技术</li>
</ul>
</li>
<li>丰富的更细粒度的是否渲染控制<ul>
<li>使用 React.memo 比较 props 再渲染组件<ul>
<li>不使用第二参数时，一层浅比较 props，变化时渲染</li>
<li>使用第二参数时，手动比较前后的 props，返回 false 渲染，true 不渲染</li>
</ul>
</li>
<li>使用 useMemo 指定依赖，细粒度渲染组件<ul>
<li>使用第二参数，传入依赖数组，当数组中的值发生变化时，更新返回值</li>
<li>通常包裹函数式组件的返回值，指定依赖的 props 或 state 的具体值</li>
<li>包裹任意需要复杂计算的函数，指定依赖的变量。能在同一组件中部分和多次使用</li>
</ul>
</li>
<li>使用 useCallback 避免函数重复创建引起渲染<ul>
<li>当函数式组件重新更新时，内部声明的函数可能会被重复创建<ul>
<li>将这些函数作为 props 传入的子组件会重复渲染</li>
<li>使用 useCallback 包裹函数，传入空数组，总是返回相同函数来避免重复创建引起的渲染</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>React 元素的事件处理和 DOM 元素的不同点</p>
<ul>
<li>事件命名<ul>
<li>React：小驼峰式</li>
<li>DOM：纯小写</li>
</ul>
</li>
<li>事件处理函数传参<ul>
<li>React：接受函数</li>
<li>DOM：字符串</li>
</ul>
</li>
<li>阻止默认行为<ul>
<li>React：显式的使用 preventDefault</li>
<li>DOM：return false</li>
</ul>
</li>
<li>事件处理函数，第一参数 e<ul>
<li>React：e 是一个合成事件。React 根据 W3C 规范来定义合成事件</li>
<li>DOM：e &#x3D; window.event</li>
</ul>
</li>
<li>添加事件监听<ul>
<li>React：元素初始渲染的时候添加监听器</li>
<li>DOM：使用 addEventListener</li>
</ul>
</li>
<li>this 指向<ul>
<li>React：在 class 组件中，手动 bind this，使用匿名箭头函数或者 class fields 语法来让 this 指向组件本身</li>
<li>DOM：触发事件的目标对象</li>
</ul>
</li>
<li>向事件处理程序传递参数<ul>
<li>React：通过箭头函数和 Function.prototype.bind 来实现</li>
<li>DOM：经常通过 DOM attribute 传参，读取参数时，先获取目标对象，再获取目标对象的 attribute</li>
</ul>
</li>
<li>事件委托<ul>
<li>React：16 及更早版本，对大多数事件执行 <code>document.addEventListener()</code> 17 后调用 <code>rootNode.addEventListener()</code></li>
<li>DOM：自行添加事件委托</li>
</ul>
</li>
</ul>
<h3 id="什么是-React-合成事件？"><a href="#什么是-React-合成事件？" class="headerlink" title="什么是 React 合成事件？"></a>什么是 React 合成事件？</h3><h4 id="面试高频指数：★-★-★-★-☆-4"><a href="#面试高频指数：★-★-★-★-☆-4" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul>
<li>React 合成事件是浏览器的原生事件的跨浏览器包装器<ul>
<li>兼容所有浏览器</li>
<li>接口与浏览器原生事件相同，包括 <code>stopPropagation()</code> 和 <code>preventDefault()</code></li>
<li>合成事件实例将被传递给事件处理函数</li>
</ul>
</li>
<li>事件池<ul>
<li>React 16 及更早版本，合成事件是合并而来，放入事件池统一管理<ul>
<li>事件对象可能会被重用<ul>
<li>在事件回调函数被调用后，所有属性失效</li>
<li>不能通过异步访问事件属性</li>
</ul>
</li>
<li>异步访问事件属性<ul>
<li>调用 <code>e.persist()</code>，从事件池中移除合成事件，允许用户代码保留对事件的引用</li>
<li>通过实例的 <code>nativeEvent</code>属性来使用浏览器的底层事件</li>
</ul>
</li>
</ul>
</li>
<li>React 17 合成事件不再放入事件池<ul>
<li><code>e.persist()</code> 存在，但不再生效</li>
<li>可以通过异步访问事件属性</li>
</ul>
</li>
</ul>
</li>
<li>事件执行顺序<ul>
<li>原生事件先执行</li>
<li>合成事件后执行<ul>
<li>默认事件处理函数在冒泡阶段触发</li>
<li>注册捕获阶段事件处理函数，应为事件名添加 Capture</li>
</ul>
</li>
</ul>
</li>
<li>合成事件会冒泡<ul>
<li>React 16 及更早版本，冒泡绑定到 document 上</li>
<li>React 17，冒泡到 rootNode 上，onScroll 事件不再冒泡</li>
</ul>
</li>
</ul>
<h3 id="如何在-React-事件处理阻止默认行为？"><a href="#如何在-React-事件处理阻止默认行为？" class="headerlink" title="如何在 React 事件处理阻止默认行为？"></a>如何在 React 事件处理阻止默认行为？</h3><p>调用 <code>e.preventDefault</code> 阻止默认行为。</p>
<h3 id="如何解决-类组件-中，事件处理的-this-为-undefined-的问题？"><a href="#如何解决-类组件-中，事件处理的-this-为-undefined-的问题？" class="headerlink" title="如何解决 类组件 中，事件处理的 this 为 undefined 的问题？"></a>如何解决 类组件 中，事件处理的 this 为 undefined 的问题？</h3><ul>
<li>使用 Function.pototype.bind，添加事件处理函数时，给函数绑定 this</li>
<li>使用 public class fields 语法，可以使用 class fields 正确的绑定回调函数</li>
<li>使用 匿名回调函数 添加事件，不推荐，原因是<ul>
<li>匿名回调函数成为组件的 prop 传入子组件，可能导致额外的重新渲染</li>
</ul>
</li>
</ul>
<h3 id="如何传参给事件处理函数？"><a href="#如何传参给事件处理函数？" class="headerlink" title="如何传参给事件处理函数？"></a>如何传参给事件处理函数？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-5"><a href="#面试高频指数：★-☆-☆-☆-☆-5" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>两种方式</p>
<ul>
<li>箭头函数<ul>
<li>声明一个匿名箭头函数，在其中调用事件处理函数并传参</li>
<li>不推荐，原因是：<ul>
<li>匿名回调函数成为组件的 prop 传入子组件，可能导致额外的重新渲染</li>
</ul>
</li>
</ul>
</li>
<li>Function.pototype.bind<ul>
<li>bind 将返回一个新函数，新函数的 this 是 bind 的一个参数，其余参数将作为函数的参数，供调用时使用</li>
</ul>
</li>
</ul>
<h3 id="如何阻止事件处理函数被频繁调用？"><a href="#如何阻止事件处理函数被频繁调用？" class="headerlink" title="如何阻止事件处理函数被频繁调用？"></a>如何阻止事件处理函数被频繁调用？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-13"><a href="#面试高频指数：★-★-☆-☆-☆-13" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li><p>节流</p>
<ul>
<li>一定时间内一定调用一次事件处理函数</li>
<li>核心区别：定时器不重置</li>
<li>连续重复调用，定时器不重置，只有第一次调用生效，忽略后面调用</li>
<li>手写代码<ul>
<li>原生</li>
</ul>
</li>
</ul>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const throttle = (fn, delay) =&gt; &#123;</span><br><span class="line">	let timer = null</span><br><span class="line">	return function (...args) &#123;</span><br><span class="line">		if (timer) return</span><br><span class="line">		timer = setTimeout(() =&gt; &#123;</span><br><span class="line">			timer = null</span><br><span class="line">			fn.apply(this, args)</span><br><span class="line">		&#125;, (delay + &#x27;&#x27;) | 0 || 1000 / 60)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    * 原生  + React Hook</span><br></pre></td></tr></table></figure>

<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const useThrottle (fn, delay) =&gt; &#123;</span><br><span class="line">	const ref = useRef(fn)</span><br><span class="line">	useEffect(() =&gt; &#123;</span><br><span class="line">		ref.current = fn</span><br><span class="line">	&#125;)</span><br><span class="line">return useCallback(</span><br><span class="line">throttle((...args) =&gt; ref.current(...args), delay),</span><br><span class="line">[delay]</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>防抖</p>
<ul>
<li>一定时间内最多调用一次事件处理函数</li>
<li>核心区别：定时器重置</li>
<li>连续重复调用，定时器重置，只有最后一次调用生效，忽略前面调用</li>
<li>手写代码<ul>
<li>原生</li>
</ul>
</li>
</ul>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const debounce = (fn, delay) =&gt; &#123;</span><br><span class="line">	let timer = null</span><br><span class="line">	return function (...args) &#123;</span><br><span class="line">		if (timer) clearTimeout(timer)</span><br><span class="line">		timer = setTimeout(() =&gt; &#123;</span><br><span class="line">			timer = null</span><br><span class="line">			fn.apply(this, args)</span><br><span class="line">		&#125;, (delay + &#x27;&#x27;) | 0 || 1000 / 60)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    * 原生 + React Hook</span><br></pre></td></tr></table></figure>

<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const useDebounce (fn, delay) =&gt; &#123;</span><br><span class="line">	const ref = useRef(fn)</span><br><span class="line">	useEffect(() =&gt; &#123;</span><br><span class="line">		ref.current = fn</span><br><span class="line">	&#125;)</span><br><span class="line">	return useCallback(</span><br><span class="line">	debounce((...args) =&gt; ref.current(...args), delay),</span><br><span class="line">	[delay]</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="React-17-对事件处理做了哪些改进？"><a href="#React-17-对事件处理做了哪些改进？" class="headerlink" title="React 17 对事件处理做了哪些改进？"></a>React 17 对事件处理做了哪些改进？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-14"><a href="#面试高频指数：★-★-☆-☆-☆-14" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul>
<li>更改事件委托<ul>
<li>更加安全地进行新旧版本 React 树嵌套，多版本都必须为 17 或更高版本<ul>
<li>React 16 及之前版本<ul>
<li>向 document 附加事件处理器</li>
<li>大多数事件执行 <code>document.addEventListener</code></li>
</ul>
</li>
<li>React 17<ul>
<li>向 React 树的根 DOM 容器附加事件处理器</li>
<li>大多数事件执行 <code>rootNode.addEventListener</code></li>
</ul>
</li>
</ul>
</li>
<li>React 嵌入使用其他技术构建的应用程序变得更加容易<ul>
<li>React 16 及之前版本<ul>
<li><code>e.stopPropagation()</code> 将被多 React 版本破坏，嵌套树结构中阻止了事件冒泡，但外部树依然能接收到它</li>
<li><code>e.stopPropagation()</code> 不会阻止其它技术构建应用的冒泡</li>
</ul>
</li>
<li>React 17 的事件冒泡更接近常规 DOM，更符合预期<ul>
<li><code>e.stopPropagation()</code> 将阻止多 React 版本的事件冒泡，包括前套树和外部树</li>
<li><code>e.stopPropagation()</code> 将阻止其它技术构建应用的冒泡</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>对标浏览器<ul>
<li>React 16 及之前版本<ul>
<li><code>onScroll</code> 事件冒泡，<code>onFocus</code> 事件冒泡</li>
<li><code>onFocus</code> 和 <code>onBlur</code> 事件底层由 React 实现</li>
<li>捕获事件（例如 <code>onClickCapture</code>）由 React 实现</li>
</ul>
</li>
<li>React 17 与浏览器行为更接近，并提高了互操作性<ul>
<li><code>onScroll</code> 事件不再冒泡</li>
<li><code>onFoucs</code> 和 <code>onBlur</code> 事件底层切换为原生的 <code>focusin</code> 和 <code>focusout</code> 事件</li>
<li>捕获事件（例如 <code>onClickCapture</code>）现在使用的是实际浏览器中的捕获监听器</li>
</ul>
</li>
</ul>
</li>
<li>去除事件池<ul>
<li>React 16 及以前版本<ul>
<li>使用 event pooling（事件池）</li>
<li>重用不同事件的事件对象，以提高性能</li>
<li>所有事件字段会被重置为 <code>null</code>，必须调用 <code>e.persist()</code> 才能正确使用事件，或者读取需要的属性</li>
</ul>
</li>
<li>React 17 去除事件池，事件对象行为符合预期<ul>
<li>去除事件池</li>
<li>不再重用事件对象，避免对现代浏览器的负优化</li>
<li>所有事件对象不会被重置为 <code>null</code>，无需调用 <code>e.persist()</code>，使用和读取属性与原生事件一致。<code>e.persist()</code> 为兼容而保留，已无实际作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="样式管理"><a href="#样式管理" class="headerlink" title="样式管理"></a>样式管理</h2><h3 id="如何在-React-中使用样式？"><a href="#如何在-React-中使用样式？" class="headerlink" title="如何在 React 中使用样式？"></a>如何在 React 中使用样式？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-6"><a href="#面试高频指数：★-☆-☆-☆-☆-6" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li>Style<ul>
<li><code>style</code> 属性接收含有驼峰命名的 javaScript 对象</li>
<li>属性名与 JS DOM API 一致，防止 XSS</li>
<li>React 自动添加 px 后缀到内联样式为数字的属性之后</li>
<li><code>style</code> 多用于在渲染过程中添加动态计算的样式</li>
<li>从性能角度来说，通常不推荐将 <code>style</code> 属性作为设置元素样式的主要方式，应使用<code>className</code> 属性来引用外部 CSS 样式表中定义的 class</li>
</ul>
</li>
<li>Class<ul>
<li><code>className</code> 支持字符串</li>
<li><code>className</code> 支持大括号包裹的 JS 表达式</li>
</ul>
</li>
<li>CSS-in-JS<ul>
<li>CSS 由 JavaScript 生成而不是在外部文件中定义</li>
<li>常用的库包括styled-componentsemotion radium 和 aphrodite 等</li>
<li>React 对样式如何定义没有明确态度<ul>
<li>存在疑惑时，比较好的方式是使用 <code>*.css</code> 定义样式，通过 <code>className</code> 指定它们</li>
</ul>
</li>
</ul>
</li>
<li>动画<ul>
<li>渐变效果，可选 <code>React Transition Group</code></li>
<li>动画效果，可选 <code>React Motion</code> 和 <code>React Spring</code></li>
</ul>
</li>
</ul>
<h3 id="如何按条件加载样式？"><a href="#如何按条件加载样式？" class="headerlink" title="如何按条件加载样式？"></a>如何按条件加载样式？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-7"><a href="#面试高频指数：★-☆-☆-☆-☆-7" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li>Style</li>
</ul>
<p><code>style</code> 采用小驼峰命名属性的 JavaScript 对象，可以按照 JavaScript 对象的方式，有条件地改变属性名和属性值</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = &#123;</span><br><span class="line">	[<span class="number">2</span> &gt; <span class="number">1</span> ? <span class="string">&#x27;fontSize&#x27;</span> : <span class="string">&#x27;lineHeight&#x27;</span>] : <span class="number">2</span> &gt; <span class="number">1</span> ? <span class="number">12</span> : <span class="number">1</span></span><br><span class="line">&#125; <span class="comment">// &#123; fontSize: 12 &#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span> () &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> <span class="comment">// style=&quot;font-size: 12px&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Class</li>
</ul>
<p><code>className</code> 属性，可以传入 JavaScript 表达式，有条件改变的类名</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> className = <span class="number">2</span> &gt; <span class="number">1</span> ? <span class="string">&#x27;menu-active&#x27;</span> : <span class="string">&#x27;menu&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span> () &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> <span class="comment">// class=&quot;menu-active&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>CSS-in-JS</li>
</ul>
<p>以styled-components 为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 模板字符串</span><br></pre></td></tr></table></figure>

<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span> = styled.<span class="property">button</span><span class="string">`</span></span><br><span class="line"><span class="string">background: <span class="subst">$&#123;props =&gt; props.primary ? <span class="string">&#x27;palevioletred&#x27;</span> : <span class="string">&#x27;white&#x27;</span>&#125;</span>,</span></span><br><span class="line"><span class="string">`</span> <span class="comment">// background: palevioletred</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span> () &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">* <span class="title class_">JavaScript</span> 对象</span><br></pre></td></tr></table></figure>

<p>- </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span> = styled.<span class="title function_">div</span>(<span class="function"><span class="params">props</span> =&gt;</span> (&#123;</span><br><span class="line">	<span class="attr">background</span>: props.<span class="property">primary</span> ? <span class="string">&#x27;palevioletred&#x27;</span> : <span class="string">&#x27;white&#x27;</span></span><br><span class="line">&#125;)); <span class="comment">// background: palevioletred</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span> () &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何合并多个内联样式"><a href="#如何合并多个内联样式" class="headerlink" title="如何合并多个内联样式?"></a>如何合并多个内联样式?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-8"><a href="#面试高频指数：★-☆-☆-☆-☆-8" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p><code>style</code>采用小驼峰命名属性的 JavaScript 对象</p>
<p>任何合并 JavaScript 对象的方法都可以用于合并内联样式</p>
<ul>
<li><p>拓展运算符</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const backgroundStyle = &#123; background: &#x27;red&#x27; &#125;</span><br><span class="line">const colorStyle = &#123; color: &#x27;red&#x27; &#125;</span><br><span class="line">function Component () &#123;</span><br><span class="line">	return &lt;div style=&#123;&#123; ...backgroundStyle, ...colorStyle &#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Object.assign</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const backgroundStyle = &#123; background: &#x27;red&#x27; &#125;</span><br><span class="line">const colorStyle = &#123; color: &#x27;red&#x27; &#125;</span><br><span class="line">function Component () &#123;</span><br><span class="line">	return &lt;div style=&#123;Object.assign(backgroundStyle, colorStyle)&#125;&gt;&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>遍历赋值</p>
</li>
<li><p>JavaScript</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const backgroundStyle = &#123; background: &#x27;red&#x27; &#125;</span><br><span class="line">const colorStyle = &#123; color: &#x27;red&#x27; &#125;</span><br><span class="line">Object.keys(colorStyle).forEach(key =&gt; backgroundStyle[key] = colorStyle[key])</span><br><span class="line">function Component () &#123;</span><br><span class="line">	return &lt;div style=&#123;backgroundStyle&#125;&gt;&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何模块化样式，如何避免样式名冲突-？"><a href="#如何模块化样式，如何避免样式名冲突-？" class="headerlink" title="如何模块化样式，如何避免样式名冲突 ？"></a>如何模块化样式，如何避免样式名冲突 ？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-15"><a href="#面试高频指数：★-★-☆-☆-☆-15" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>（1）什么是 CSS 模块化？</p>
<p>CSS 模块化是将 CSS 规则 拆分成相对独立的模块，便于开发者在项目中更有效率地组织 CSS</p>
<ul>
<li>管理层叠关系</li>
<li>避免命名冲突</li>
<li>提高复用度，减少冗余</li>
<li>便于维护或扩展</li>
</ul>
<p>CSS 模块化的方式</p>
<ul>
<li>基于文件拆分</li>
<li>不拆分但设置作用域</li>
<li>CSS in JS</li>
<li>内联样式、Shadow DOM 等</li>
</ul>
<p>无论哪种方式，核心都是通过 保证CSS类命名唯一，或者 避免命名使用内联样式，来模拟出CSS模块作用域的效果</p>
<p>（2）基于文件的 CSS 模块的加载</p>
<ul>
<li><code>&lt;link&gt;</code><br>将不同模块的 CSS 分文件存放，通过 <code>&lt;link&gt;</code> 标签按需引入</li>
<li><code>@import</code><br>@规则，将其它 CSS 嵌入当前 CSS<br>除现代浏览器外，也得到了 CSS 预处理器 Less、Sass 和 Stylus 的支持</li>
<li><code>import</code><br>在 Webpack 中，将 CSS 作为资源引入，通过 CSS Modules 生成独一无二的类名</li>
</ul>
<p>（3）CSS 模块化的实现方式</p>
<ul>
<li><p>分层拆分</p>
<p>将 CSS规则 分层存放，并约束不同层次间的命名规则</p>
<ul>
<li>SMACSS：按功能分成 Base Layout Module State Theme 五层</li>
<li>ITCSS：按从通用到具体分成 Settings Tools Generic Base Objects Components 七层</li>
</ul>
</li>
<li><p>分块拆分</p>
<p>将页面中视觉可复用的块独立出来，仅使用类选择器，并确保类名唯一</p>
<ul>
<li>OOCSS<ul>
<li>将盒模型规则与颜色、背景等主题规则拆分</li>
<li>将视觉可复用的块类名与页面结构解耦</li>
</ul>
</li>
<li>BEM<ul>
<li>将页面按 Block Element Modifier 划分</li>
<li>类名规则 block-name__element-name–modifier-name</li>
</ul>
</li>
</ul>
</li>
<li><p>原子化拆分</p>
<p>每个选择器只包含 1 个或少量属性，通过组合选择器定义复杂样式</p>
<ul>
<li>ACSS：属性名像函数，属性值像函数参数，像写内联样式一样组合类名</li>
<li>Utility-First CSS：提供一套可配置的 CSS 实用类库，使用时按需编译</li>
</ul>
</li>
<li><p>CSS in JS</p>
<ul>
<li>CSS Modules<ul>
<li>将 CSS 作为资源引入</li>
<li>根据内容的哈希字符串，计算出独一无二类名，CSS 规则 只对该类名下的元素生效</li>
</ul>
</li>
<li>styled-components Aphrodite Emotion 等<ul>
<li>通过 JS 创建包含属性定义的组件</li>
<li>生成独一无二的类名</li>
</ul>
</li>
<li>Radium 等<ul>
<li>通过 JS 创建包含属性定义的组件</li>
<li>生成内联样式</li>
</ul>
</li>
</ul>
</li>
<li><p>Shadow DOM<br>通过<code>attachShadow</code>给元素的影子DOM，附加<code>&lt;style&gt;</code>标签，其中规则不会影响外部元素。代表的框架有 Ionic 等</p>
</li>
</ul>
<p>（4）React 中的样式模块化</p>
<p>React 对样式如何定义，没有明确的态度，如果存在疑虑，比较好的方式是和平常一样，在一个单独的 <code>*.css</code> 定义你的样式，并通过 <code>className</code> 指定它们。此时，你可以参考 CSS 模块化的方案，通过文件或样式命名规则，来实现样式模块化</p>
<p>行内样式 <code>style</code> 是避免样式命名冲突的经典策略，但由于性能比 <code>className</code> 低，React 通常不推荐将 style 属性作为设置元素样式的主要方式。在多数情况下，应使用 <code>className</code> 属性来引用外部 CSS 样式表重定义的 <code>class</code>。<code>style</code> 在 React 应用中多用于在渲染过程中添加动态计算的样式</p>
<p>同样地，在 CSS-in-JS 中，早期有基于 <code>style</code> 实现的 Radium 库，现在比较流行的是基于随机 <code>className</code> 的 style-components 库，与之类似的有 Emotion 和 Glamor，还有面向愿意将 CSS 和 JavaScript 分开存放开发者的 JSS 等。</p>
<h2 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h2><h3 id="什么是-React-Hook"><a href="#什么是-React-Hook" class="headerlink" title="什么是 React Hook?"></a>什么是 React Hook?</h3><p>Hook 是 React 16.8 的新增特性</p>
<ul>
<li>允许开发者在函数组件里“钩入”React state 及生命周期等特性的函数<ul>
<li>React 内置如 useState、useEffect 等 Hook</li>
</ul>
</li>
<li>Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）<ul>
<li>非强制按照生命周期划分，避免每个生命周期包含不相关的逻辑</li>
</ul>
</li>
<li>开发者可以在不编写 class 的情况下使用 state 以及其他的 React 特性<ul>
<li>无需考虑 this，无需考虑函数和 class 组件的区别和应用场景</li>
<li>便于使用 Prepack 试验 component folding，使代码更易于优化</li>
<li>拥抱函数式编程</li>
</ul>
</li>
<li>Hook 和现有代码可以同时工作，渐进式地使用</li>
</ul>
<h3 id="什么是-State-Hook？"><a href="#什么是-State-Hook？" class="headerlink" title="什么是 State Hook？"></a>什么是 State Hook？</h3><h4 id="面试高频指数：★-★-★-☆-☆-7"><a href="#面试高频指数：★-★-★-☆-☆-7" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul>
<li>State Hook 允许开发者在 React 函数组件中添加 state 的 Hook</li>
<li>这种 Hook 在 React 的原生实现是 useState，它是一种函数调用时保存变量的方式，它与 class 里面的 this.state 提供的功能完全相同</li>
<li>useState 的唯一参数是初始 state，支持数字、字符串、对象等类型</li>
<li>useState 方法的返回值分别是当前 state 以及更新 state 的函数，使用数组解构获取赋值</li>
<li>state 只在组件首次渲染时创建，下次重新渲染时，返回当前的 state</li>
</ul>
<h3 id="什么是-Effect-Hook？"><a href="#什么是-Effect-Hook？" class="headerlink" title="什么是 Effect Hook？"></a>什么是 Effect Hook？</h3><h4 id="面试高频指数：★-★-★-☆-☆-8"><a href="#面试高频指数：★-★-★-☆-☆-8" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul>
<li>Effect Hook 允许开发者在函数组件中执行副作用操作，包括数据获取、设置订阅以及手动更改 React 组件中的 DOM。分为需要清除和不需要清除的</li>
<li>这种 Hook 在 React 的原生实现是 useEffect</li>
<li>useEfect 支持两个参数<ul>
<li>第一个参数为函数，默认在组件第一次渲染和每次更新、浏览器完成画面渲染之后执行，调用时机可以看作 class 组件的 componentDidMount、componentDidUpdate 生命周期 + 浏览器完成画面渲染时</li>
<li>第二个参数为数组，只有数组元素发生变化时，才会调用第一个参数的函数<ul>
<li>当第二个参数为空数组 [] 时，第一个参数的函数仅会在组件挂载和卸载时执行</li>
</ul>
</li>
</ul>
</li>
<li>useEffect 可以返回一个函数，用于移除订阅等副作用，区别 class 组件的 componetWillUnMount，React 会在执行当前 effect 之前对上一个 effect 进行清除</li>
<li>useEffect 放在最贱内部可以直接访问 state 和 props</li>
</ul>
<h3 id="如何清除-Effect-Hook-的副作用？"><a href="#如何清除-Effect-Hook-的副作用？" class="headerlink" title="如何清除 Effect Hook 的副作用？"></a>如何清除 Effect Hook 的副作用？</h3><h4 id="面试高频指数：★-★-★-★-☆-5"><a href="#面试高频指数：★-★-★-★-☆-5" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul>
<li>在 useEffect 的 effect 函数中，返回一个清除函数<ul>
<li>可以将添加和清除副作用的逻辑放在一起</li>
</ul>
</li>
<li>effect 在每次渲染的时候会执行，<ul>
<li>React 会在执行当前 effect 之前对上一个 effect 进行清除</li>
</ul>
</li>
</ul>
<h3 id="使用-Hook-需要遵循的规则是？"><a href="#使用-Hook-需要遵循的规则是？" class="headerlink" title="使用 Hook 需要遵循的规则是？"></a>使用 Hook 需要遵循的规则是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-16"><a href="#面试高频指数：★-★-☆-☆-☆-16" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>Hook 本质是 JavaScript 函数，使用 Hook 时需要遵循两条规则</p>
<ul>
<li>只在最顶层使用 Hook<ul>
<li>不要在循环，条件或嵌套函数中调用 Hook<ul>
<li>确保总在 React 函数的最顶层调用 Hook</li>
<li>确保 Hook 在每一次渲染都按照相同的顺序被调用<ul>
<li>多次的 useState 和 useEffect 调用中间保持 Hook 状态正确</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>只在 React 函数中调用 Hook<ul>
<li>仅在 React 的函数组件，而不要在普通的 JavaScript 函数中调用 Hook</li>
<li>在自定义 Hook 中调用其他 Hook</li>
</ul>
</li>
</ul>
<h3 id="如何校验-Hook-是否遵循规则？"><a href="#如何校验-Hook-是否遵循规则？" class="headerlink" title="如何校验 Hook 是否遵循规则？"></a>如何校验 Hook 是否遵循规则？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-17"><a href="#面试高频指数：★-★-☆-☆-☆-17" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>React 提供了一个名为 eslint-plugin-react-hooks 的 ESLint 插件来校验 Hook 是否遵循规则</p>
<ul>
<li><p>安装</p>
</li>
<li><p>shell</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint-plugin-react-hooks -D</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ESLint 配置</p>
</li>
<li><p>JSON</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;plugin&quot;: [</span><br><span class="line">	// ...</span><br><span class="line">	&quot;react-hooks&quot;</span><br><span class="line">	],</span><br><span class="line">	&quot;rules&quot;: &#123;</span><br><span class="line">		// ...</span><br><span class="line">		&quot;react-hooks/rules-of-hooks&quot;: &quot;error&quot;, // 检查 Hook 规则</span><br><span class="line">		&quot;react-hooks/exhaustive-deps&quot;: &quot;warn&quot; // 检查 effect 依赖</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useMemo-和-useCallback-的区别是？"><a href="#useMemo-和-useCallback-的区别是？" class="headerlink" title="useMemo 和 useCallback 的区别是？"></a>useMemo 和 useCallback 的区别是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-18"><a href="#面试高频指数：★-★-☆-☆-☆-18" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>useMemo</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b])</span><br></pre></td></tr></table></figure>

<p>返回一个<code>memoized</code>值，把”创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销计算。<br>useCallback</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const memoizedCallback = useCallback(() =&gt; &#123; doSomething(a, b) &#125;, [a, b])</span><br></pre></td></tr></table></figure>

<p>返回一个<code>memoized</code>回调函数，把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。<br>useCallback 可看作函数组件的<code>shouldCompoentUpdate</code>，使用引用相等性避免非必要渲染</p>
<p>useCallback 返回的是函数，useMemo 返回的是值，也可以是函数</p>
<p>useCallback(fn, deps) 相当于 useMemo(() &#x3D;&gt; fn, deps)</p>
<h3 id="useReducer-和-useState-的区别是？"><a href="#useReducer-和-useState-的区别是？" class="headerlink" title="useReducer 和 useState 的区别是？"></a>useReducer 和 useState 的区别是？</h3><h4 id="面试高频指数：★-★-★-☆-☆-9"><a href="#面试高频指数：★-★-★-☆-☆-9" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>useReducer</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [state, dispatch] = useReducer(reducer, initialArg, init)</span><br></pre></td></tr></table></figure>

<p>useReducer 是 useState 的替代方案，它接收一个形如<code>(state, action) =&gt; newState</code>的 reducer，返回当前的 state 及其配套的<code>dispatch</code>方法<br>useReducer 比 useState 更适用于某些场景</p>
<ul>
<li>state 逻辑较复杂，并且包含多个子值</li>
<li>下一个 state 依赖于之前的 state</li>
</ul>
<p>useReducer 第二个返回值是 dispatch 而不是回调函数</p>
<ul>
<li>可以向子组件传递 dispatch 而不是函数<ul>
<li>容易会触发深更新的组件做性能优化</li>
</ul>
</li>
</ul>
<h3 id="useLayoutEffect-和-useEffect-的区别是？"><a href="#useLayoutEffect-和-useEffect-的区别是？" class="headerlink" title="useLayoutEffect 和 useEffect 的区别是？"></a>useLayoutEffect 和 useEffect 的区别是？</h3><h4 id="面试高频指数：★-★-★-☆-☆-10"><a href="#面试高频指数：★-★-★-☆-☆-10" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>useLayoutEffect</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useLayoutEffect(() =&gt; &#123;</span><br><span class="line">	// add effect</span><br><span class="line">	return cleanup() &#123;</span><br><span class="line">		// clean effect</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>相同</p>
<ul>
<li>useLayoutEffect 的签名与 useEffect 相同</li>
<li>服务端渲染时，useLayoutEffect 和 useEffect 都无法在 Javascript 代码加载完成前执行<ul>
<li>服务端渲染组件引入 useLayoutEffect 触发 React 告警，解决<ul>
<li>使用 useEffect 替代 useLayoutEffect</li>
<li>或将该组件延迟到客户端渲染完成后再显示</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>区别</p>
<ul>
<li>useLayoutEffect<ul>
<li>在所有 DOM 变更之后同步调用 effect，用来读取 DOM 布局并同步触发重渲染</li>
<li>在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新</li>
</ul>
</li>
<li>useEffect<ul>
<li>在所有 DOM 变更并且浏览器完成渲染后调用 effect</li>
<li>尽可能使用标准的 useEffect 以避免阻塞视觉更新<ul>
<li>只有 useEffect 有问题时，再尝试 useLayoutEffect</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="useRef-和-Refs-的区别是？"><a href="#useRef-和-Refs-的区别是？" class="headerlink" title="useRef 和 Refs 的区别是？"></a>useRef 和 Refs 的区别是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-19"><a href="#面试高频指数：★-★-☆-☆-☆-19" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>useRef</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const refContainer = useRef(initialValue)</span><br></pre></td></tr></table></figure>

<p>useRef 返回一个可变的 ref 对象，其<code>.current</code>属性被初始化传入参数<code>initialValue</code><br>返回的 ref 对象在组件的整个生命周期保持不变</p>
<p>Refs</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Component extends React.Component &#123;</span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		super(props)</span><br><span class="line">		this.myRef = React.createRef()</span><br><span class="line">	&#125;</span><br><span class="line">	render() &#123;</span><br><span class="line">		return &lt;div ref=&#123;this.myRef&#125; /&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Refs 使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素<br>当 ref 被传递给 <code>render</code> 中的元素时，对节点的引用可以在 ref 的 <code>current</code> 属性中被访问</p>
<p>区别</p>
<p>useRef</p>
<ul>
<li><p>函数组件可用</p>
</li>
<li><p>用途多样，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useRef()</span><br></pre></td></tr></table></figure>

<p>创建一个普通 Javascript 对象，每次渲染时返回同一个 ref 对象</p>
<ul>
<li>可以在其<code>.current</code> 属性保存任何可变值</li>
</ul>
</li>
</ul>
<p>Refs</p>
<ul>
<li><p>class 组件或 HTML 元素，函数组件无实例，不可用</p>
</li>
<li><p>用途单一，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.current</span><br></pre></td></tr></table></figure>

<p>属性为实例的引用，根据节点的类型不同</p>
<ul>
<li>当 <code>ref</code> 属性用于 HTML 元素时，构造函数中使用 <code>React.createRef()</code> 创建的<code>ref</code>接收底层 DOM 元素作为 <code>current</code> 属性</li>
<li>当 <code>ref</code> 属性用于自定义 class 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性</li>
</ul>
</li>
</ul>
<h3 id="如何自定义-Hook？"><a href="#如何自定义-Hook？" class="headerlink" title="如何自定义 Hook？"></a>如何自定义 Hook？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-20"><a href="#面试高频指数：★-★-☆-☆-☆-20" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>（1）自定义 Hook 定义</p>
<p>自定义 Hook，是将组件逻辑提取到可重用的函数，它可以像 <code>render props</code> 和高阶组件来共享组件之间的状态逻辑，而不增加组件</p>
<p>（2）如何自定义 Hook</p>
<p>自定义 Hook 是一个函数，可以调用其他的 Hook</p>
<ul>
<li>名称以 “use” 开头，表示这是一个 Hook<ul>
<li>便于 React 判断函数函数内部是否包含对其内部 Hook 的调用</li>
<li>自动检查 Hook 是否违法 Hook 规则</li>
</ul>
</li>
<li>参数和返回可以自定义，可以像使用函数一样在不同 Hook 间传递信息</li>
<li>其中所有 state 和副作用完全隔离，每次调用 Hook，都会获取独立的 state</li>
</ul>
<p>将两个函数组件的共同的状态逻辑提取到自定义 Hook 中，自定义 Hook 是一种自然遵循 Hook 设计的约定，而不是 React 的特性</p>
<p>（3）自定义 Hook 作用</p>
<p>自定义 Hook 解决了以前在 React 组件中无法灵活共享逻辑的问题</p>
<p>自定义 Hook 可以用于表单处理、动画、订阅声明、计时器等场景</p>
<p>尽量避免过早地增加抽象逻辑，当函数组件代码行数增多时，可以通过自定义 Hook 简化代码逻辑，解决组件杂乱无章。</p>
<h3 id="是否有必要使用-Hook-API-重写所有类组件？"><a href="#是否有必要使用-Hook-API-重写所有类组件？" class="headerlink" title="是否有必要使用 Hook API 重写所有类组件？"></a>是否有必要使用 Hook API 重写所有类组件？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-9"><a href="#面试高频指数：★-☆-☆-☆-☆-9" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>不，React 推荐称为编写 React 组件的主要方式，并且提供了自定义 Hook 等 class 组件无法实现的功能，更利于自动代码优化。但是</p>
<ul>
<li>Hook 暂时不能覆盖 class 组件的所有场景，比如生命周期<code>getSnapshotBeforeUpdate</code>，<code>getDerivedStateFromError</code> 和 <code>componentDidCatch</code> 暂无 Hook 等价写法</li>
<li>没有计划从 React 中移除 class</li>
</ul>
<p>所以，React 鼓励写新组件的时候开始尝试 Hook，不推荐用 Hook 重写已有的 class，除非开发者本来就打算重写它们（例如：为了修复 bug）</p>
<h3 id="useState-返回更新-state-的函数是同步，还是异步的？"><a href="#useState-返回更新-state-的函数是同步，还是异步的？" class="headerlink" title="useState 返回更新 state 的函数是同步，还是异步的？"></a>useState 返回更新 state 的函数是同步，还是异步的？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-21"><a href="#面试高频指数：★-★-☆-☆-☆-21" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>useState 返回更新 state 函数式异步的，接收参数可以是新状态的值，也可以是回调函数</p>
<p>可以通过两种方式，获取上一个 state 的状态值</p>
<ul>
<li>回调函数的第一个参数是上一个状态的值，可以像使用 useReducer 的 reducer 函数一样，基于上一个 state 来生成新的 state</li>
<li>或者可以在 useEffect 或 useLayoutEffect 中获取更新后的状态，将 useEffect 或 useLayoutEffect 封装到自定义 Hook 同样有效</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="什么是-Virtual-DOM"><a href="#什么是-Virtual-DOM" class="headerlink" title="什么是 Virtual DOM ?"></a>什么是 Virtual DOM ?</h3><h4 id="面试高频指数：★-★-★-★-★-2"><a href="#面试高频指数：★-★-★-★-★-2" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><p>Virtual DOM 是一编程概念</p>
<ul>
<li>UI 以一种理想化的，或者说“虚拟的”表现形式被保存在内存中<ul>
<li>支持可以优化的 Diff 算法</li>
</ul>
</li>
<li>通过 ReactDOM 等类库使之与“真实的” DOM 同步，这一过程叫做协调<ul>
<li>支持优先级，并行可中断的协调策略</li>
<li>支持 ReactCanvas 和 ReactNative 等其他渲染方式，甚至非浏览器环境</li>
</ul>
</li>
</ul>
<p>Virtual DOM 赋予 React 声明式的 API</p>
<ul>
<li>告诉 React 希望让 UI 是什么状态，React 就确保 DOM 匹配该状态</li>
<li>开发者不必关心属性操作、事件处理和手动 DOM 更新这些构建应用程序必要的操作</li>
</ul>
<p>Virtual DOM 是一种模式，在 React 中</p>
<ul>
<li>Virtual DOM 通常与 React 元素关联，代表用户界面的对象</li>
<li>fibers 内部对象来存放组件树的附加信息</li>
<li>React Fiber 是协调引擎，主要目的是使 Virtual DOM 可以增量式渲染</li>
</ul>
<h3 id="什么是-React-Diff，对比-Vue-Diff-？"><a href="#什么是-React-Diff，对比-Vue-Diff-？" class="headerlink" title="什么是 React Diff，对比 Vue Diff ？"></a>什么是 React Diff，对比 Vue Diff ？</h3><h4 id="面试高频指数：★-★-★-★-★-3"><a href="#面试高频指数：★-★-★-★-★-3" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><p>虚拟 DOM 的 Diff 算法</p>
<ul>
<li>将新旧虚拟 DOM 看作两棵节点树，节点个数为 n<ul>
<li>左侧树的节点需要与右侧树的节点一一对比，需要 O(n²) 复杂度</li>
<li>删除未找到的节点，需要再找合适节点放到被删除位置，需要 O(n) 复杂度</li>
<li>添加新节点，需要 O(n) 复杂度</li>
</ul>
</li>
<li>综上，Diff 虚拟 DOM 的复杂度是 O(n³)</li>
</ul>
<p>React 基于以下两个假设的基础之上提出 O(n) 的启发式算法</p>
<ul>
<li>两个不同类型的元素会产生不同的树</li>
<li>可以通过设置 <code>key</code> 属性，来告知渲染哪些子元素在不同的渲染下可以保存不变</li>
</ul>
<p>React Diffing 算法</p>
<ul>
<li>Tree Diff<ul>
<li>对比两棵树时，首选比较两棵树的根节点。不同类型的根节点元素会有不同的形态<ul>
<li>根节点为不同类型的元素<ul>
<li>React 会拆卸原有的树并且建立起新的树</li>
<li>当卸载一棵树时<ul>
<li>对应的 DOM 节点会被销毁<ul>
<li>建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中</li>
</ul>
</li>
<li>组件实例将执行 <code>componentWillUnmount()</code> 方法</li>
</ul>
</li>
</ul>
</li>
<li>根节点为相同类型的元素<ul>
<li>React 会保留节点</li>
<li>仅比对及更新有改变的属性</li>
</ul>
</li>
<li>处理完根节点，React 继续对子节点进行递归</li>
</ul>
</li>
<li>通过 updateDepth 控制 Virtual Dom 树层级</li>
<li>只比较同一个父节点的子节点</li>
<li>通过删除和创建节点实现跨层级移动</li>
<li>避免跨层级移动，优先 CSS 控制显示隐藏</li>
</ul>
</li>
<li>Component Diff<ul>
<li>同类型组件<ul>
<li>组件实例会保持不变，因此可以在不同的渲染时保持 state 一致</li>
<li>React 将更新该组件实例的 props 以及保证与最新的元素保持一致</li>
<li>调用该实例的 <code>UNSAFE_componentWillReceiveProps</code>、 <code>UNSAFE_componentWillUpdate()</code> 以及 <code>componentDidUpdate()</code> 方法</li>
<li>调用 <code>render()</code> 方法，diff 算法将在之前的结果以及新的结果中进行递归</li>
<li>通过 shouldComponentUpdate、useMemo、useCallback 手动优化</li>
<li>不同类型组件，输出内容相似<ul>
<li>建议改成同一类型，避免重新渲染组件</li>
</ul>
</li>
</ul>
</li>
<li>不同类型组件<ul>
<li>删除和创建</li>
</ul>
</li>
</ul>
</li>
<li>Element Diff<ul>
<li>默认情况下，React 会同时遍历两个子元素的列表，递归 DOM 节点的子元素<ul>
<li>产生差异时，生成一个 mutation</li>
</ul>
</li>
<li>用 key 标识节点<ul>
<li>避免使用索引 index，而应使用例如 id 唯一标识来作为 key</li>
</ul>
</li>
<li>只顺序移动位置变到前面的节点</li>
<li>相同类型 React 元素，保留 DOM 节点，仅对比及更新改变的属性</li>
</ul>
</li>
</ul>
<p>Vue 2.x 优化 Diff 算法</p>
<ul>
<li>基本优化与 React 相同</li>
<li>pathNode<ul>
<li>新老节点相同，不更新</li>
<li>新老节点都是静态节点，key 相同<ul>
<li>新节点.elm &#x3D; 老节点.elm</li>
<li>新节点.componentInstance &#x3D; 老节点.componentInstance</li>
</ul>
</li>
<li>新老节点存在，不相同<ul>
<li>用 updateChildren 更新</li>
</ul>
</li>
</ul>
</li>
<li>updateChildren<ul>
<li>虚拟 DOM 双指针，真实 DOM 双指针，一一对应</li>
<li>两端到中间，直到虚拟 DOM 或真实 DOM，左指针 &gt; 右指针</li>
</ul>
</li>
</ul>
<p>Vue 3.x 优化 Diff 算法</p>
<ul>
<li>创建 VNode 确定类型，内容不会变化的 DOM 添加静态标记</li>
<li>在 mount &#x2F; patch 中用位运算判断 VNode 类型<ul>
<li>静态提升 hoistStatic<ul>
<li>不参与更新的元素，只创建一次，渲染时直接复用</li>
</ul>
</li>
<li>事件侦听器缓存 cacheHandlers<ul>
<li>缓存函数，不追踪变化，提升性能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="什么是-React-Concurrent-模式"><a href="#什么是-React-Concurrent-模式" class="headerlink" title="什么是 React Concurrent 模式?"></a>什么是 React Concurrent 模式?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-10"><a href="#面试高频指数：★-☆-☆-☆-☆-10" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>Concurrent 模式是一组 React 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整</p>
<p>Concurrent 模式的特点包括</p>
<ul>
<li>可中断渲染<ul>
<li>中断一项正在执行的更新去做更重要的事情，然后再回到之前正在做的工作</li>
<li>减少防抖和节流在 UI 中的需求。因为渲染可以终端，不需要人为地延迟工作以避免卡顿</li>
</ul>
</li>
<li>有意的加载顺序<ul>
<li>React 首先在内存中准备新屏幕</li>
<li>之前，React 继续显示完全互动，带有内联加载指示器的旧屏幕</li>
<li>当新屏幕准备就绪之后，React 可以带我们跳转到新屏幕</li>
</ul>
</li>
<li>并发<ul>
<li>在 Concurrent 模式中，React 可以同时更新多个状态<ul>
<li>对于 CPU 密集更新（例如创建新的 DOM 节点和运行组件中的代码），并发意味着一个更急迫的更新可以“中断”已经开始的渲染</li>
<li>对于 IO 密集的更新（例如从网络加载代码或数据），并发意味着 React 甚至可以在全部数据到达之前就在内存中开始渲染</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Concurrent 模式的任务是帮助将人机交互研究的结果整合到真实的 UI 中</p>
<ul>
<li>避免在屏幕之间切换时显示过多的中间加载状态</li>
<li>对于用户输入、悬停、点击、页面转换等在内部使用不同的“优先级”，大致对应于人类感知研究中的交互类别</li>
</ul>
<p>Concurrent 模式的开启</p>
<ul>
<li><p>安装 React 实验版本</p>
</li>
<li><p>plain</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react@experimental react-dom@experimental</span><br></pre></td></tr></table></figure>

<ul>
<li>开启 Concurrent 模式<ul>
<li>blocking 模式：提供了 concurrent 模式的小部分功能，更接近于当前 React 的 legacy 模式<ul>
<li><code>ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)</code></li>
</ul>
</li>
<li>concurrent 模式：未来 React 默认开发模式<ul>
<li><code>ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Concurrent 模式常用 API</p>
<ul>
<li>Suspense<ul>
<li>允许组件在渲染之前进行“等待”，并在等待时显示 fallback 的内容</li>
</ul>
</li>
<li>SuspenseList<ul>
<li>通过编排向用户显示这些组件的顺序，来帮助协调血多可以挂起的组件</li>
</ul>
</li>
<li>useTransition<ul>
<li>允许组件在切换到下一个界面之前等待内容加载，从而避免不必要的加载状态</li>
<li>允许组件将速度较慢的数据获取更新推迟到随后渲染，以便能够立即渲染更重要的更新</li>
</ul>
</li>
<li>useDeferredValue<ul>
<li>返回一个延迟响应的值，该值可能“延后”的最长时间为 timeoutMs</li>
<li>适合立即渲染用户输入内容，同时需要等待数据获取的内容，保持接口可响应性的场景</li>
</ul>
</li>
</ul>
<h3 id="什么是-Suspense"><a href="#什么是-Suspense" class="headerlink" title="什么是 Suspense ?"></a>什么是 Suspense ?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-11"><a href="#面试高频指数：★-☆-☆-☆-☆-11" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul>
<li>Suspense 让组件“等待”某个异步操作，直到该异步操作结束即可渲染</li>
<li>Suspense 不是一个数据请求的库，而是一个机制<ul>
<li>这个机制是用来给数据请求库向React通信说明某个组件正在读取的数据当前仍不可用</li>
<li>通信之后，React可以继续等待数据的返回并更新UI</li>
</ul>
</li>
<li>Suspense不是什么<ul>
<li>不是数据获取的一种实现</li>
<li>不是直接用于数据获取的客户端</li>
<li>不使数据获取与视图层代码耦合</li>
</ul>
</li>
<li>Suspense可做什么<ul>
<li>让数据获取库与React紧密整合</li>
<li>让开发者有针对性地安排加载状态的展示</li>
<li>它能够消除 raceconditions，避免由于代码运行顺序的错误假设而导致的bug<ul>
<li>不是等到响应报文被接收之后，才去更新 State</li>
<li>反过来，发出请求之后，马上更新 State（外加开始渲染）</li>
</ul>
</li>
</ul>
</li>
<li>Suspense 可以不必等到数据全部返回才开始渲染<ul>
<li>一发送网络请求，马上开始渲染<ul>
<li>读取的数据没获取完毕，组件会处于“挂起”状态</li>
<li>React 会跳过“挂起”组件，继续渲染组件树中的其他组件</li>
</ul>
</li>
<li>随着更多数据的到来，React 将尝试重新渲染，并且每次都可能渲染出更加完整的组件树</li>
</ul>
</li>
</ul>
<h3 id="React-如何定义任务的优先级？"><a href="#React-如何定义任务的优先级？" class="headerlink" title="React 如何定义任务的优先级？"></a>React 如何定义任务的优先级？</h3><h4 id="面试高频指数：★-★-★-☆-☆-11"><a href="#面试高频指数：★-★-★-☆-☆-11" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>任务优先级是产生更新对象之后，React去执行一个更新任务，这个任务的优先级</p>
<p>任务优先级被用来区分多个更新任务的紧急程度，对比前后两次更新的任务优先级</p>
<ul>
<li>后者 &gt; 前者，React会取消前者的任务调度</li>
<li>后者&#x3D;前者，React 会将同等优先级的更新收敛到一次任务中</li>
<li>后者 &lt; 前者，React会在前者更新完成后，再对后者发起任务调度</li>
</ul>
<p>简而言之，任务优先级存在的意义</p>
<ul>
<li>保证高优先级任务及时响应</li>
<li>收敛同等优先级的任务调度</li>
</ul>
<p>React定义的任务优先级分为三类</p>
<ul>
<li>同步优先级：React的 legacy 同步渲染模式产生的更新任务的优先级</li>
<li>同步批量优先级：React的 blocking模式产生的更新任务的优先级</li>
<li>Concurrent 模式优先级：对于用户输入、悬停、点击、页面转换等在内部使用不同的“优先级”，大致对应于人类感知研究中的交互类别</li>
</ul>
<p><code>LanePriority</code> 越大，优先级越高</p>
<ul>
<li>JavaScript</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export const SyncLanePriority: LanePriority = 17</span><br><span class="line">export const SyncBatchedLanePriority: LanePriority = 16</span><br><span class="line">const InputDiscreteHydrationLanePriority: LanePriority = 15</span><br><span class="line">export const InputDiscreteLanePriority: LanePriority = 14</span><br><span class="line">const InputContinuousHydrationLanePriority: LanePriority = 13</span><br><span class="line">export const InputContinuousLanePriority: LanePriority = 12</span><br><span class="line">const DefaultHydrationLanePriority: LanePriority = 11</span><br><span class="line">export const DefaultLanePriority: LanePriority = 10</span><br><span class="line">const TransitionShortHydrationLanePriority: LanePriority = 9</span><br><span class="line">export const TransitionShortLanePriority: LanePriority = 8</span><br><span class="line">const TransitionLongHydrationLanePriority: LanePriority = 7</span><br><span class="line">export const TransitionLongLanePriority: LanePriority = 6</span><br><span class="line">const RetryLanePriority: LanePriority = 5</span><br><span class="line">const SelectiveHydrationLanePriority: LanePriority = 4</span><br><span class="line">const IdleHydrationLanePriority: LanePriority = 3</span><br><span class="line">const IdleLanePriority: LanePriority = 2</span><br><span class="line">const OffscreenLanePriority: LanePriority = 1</span><br><span class="line">export const NoLanePriority: LanePriority = 0</span><br></pre></td></tr></table></figure>

<h3 id="什么是-Redux"><a href="#什么是-Redux" class="headerlink" title="什么是 Redux ?"></a>什么是 Redux ?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-12"><a href="#面试高频指数：★-☆-☆-☆-☆-12" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>Redux 是 JavaScript 应用的可预测状态容器</p>
<ul>
<li>可预测<ul>
<li>在不同环境（客户端、服务器和移动端）行为一致，易于测试</li>
</ul>
</li>
<li>集中<ul>
<li>集中应用状态和逻辑，支持撤销、重做和持久化</li>
</ul>
</li>
<li>可调试<ul>
<li>Redux DevTools 可以方便地跟踪应用的状态何时、何处、为什么及如何改变</li>
<li>Rddux 架构允许开发者记录更改，使用“时间旅行调试”，向服务器发送完整错误报告</li>
</ul>
</li>
<li>灵活<ul>
<li>Redux 可用于任何 UI 层，并拥有一个庞大的插件生态系统来满足您的需求</li>
</ul>
</li>
</ul>
<h3 id="Flux-和-Redux-的区别是？"><a href="#Flux-和-Redux-的区别是？" class="headerlink" title="Flux 和 Redux 的区别是？"></a>Flux 和 Redux 的区别是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-22"><a href="#面试高频指数：★-★-☆-☆-☆-22" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>Flux</p>
<ul>
<li>Flux 是用于构建用户界面的应用程序架构，通过单向数据流补充 React 可组合的视图组件</li>
<li>Flux 更像模式而非框架，没有任何硬依赖</li>
<li>Flux 架构的应用包含 4 部分<ul>
<li>Action<ul>
<li>通过 Action creators 创建</li>
<li>每个 Action 拥有 type 或类似属性</li>
<li>传递给 Dispatcher</li>
</ul>
</li>
<li>Dispatcher<ul>
<li>分发 Actions 给所有注册 Store 的回调函数</li>
</ul>
</li>
<li>Store<ul>
<li>接受 Action 更新数据后，触发 change 事件，通知 View</li>
<li>可以由多个 Store</li>
</ul>
</li>
<li>View 视图组件，即 Controller-View<ul>
<li>家庭 change 事件，从 Store 取回数据，将数据传递给子组件或更新组件状态</li>
<li>响应用户输入，生成新的 Action</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Redux</p>
<ul>
<li><p>Redux 是 JavaScript 应用的可预测状态容器</p>
</li>
<li><p>Redux 对不同框架都有完整实现，Facebook 官方推荐使用代替 Flux</p>
</li>
<li><p>Redux 架构与 Flux 基本一致，但做了简化</p>
<ul>
<li><p>State 只读，更改 State 的方式是返回新的对象，即引入 Reducer 纯函数</p>
</li>
<li><p>Action 与 Dispatcher ，只需返回包含 type 和 payload 属性的对象</p>
</li>
<li><p>Store</p>
<ul>
<li>唯一</li>
<li><code>createStore</code> 基于 Reducer 纯函数创建</li>
<li><code>store.dispatch()</code> 调用 Action</li>
</ul>
</li>
<li><p>View</p>
<ul>
<li><p>通过 <code>store.getState()</code> 获取最新状态</p>
</li>
<li><p>通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.subscribe()</span><br></pre></td></tr></table></figure>

<p>订阅状态更新</p>
<ul>
<li><code>store.subscribe()</code> 返回函数可取消订阅</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>综上，Redux 与 Flux 都基于单向数据流，架构相似，但 Redux 默认应用只有唯一 Store，精简掉 Dispatcher，引入 Reducer 纯函数，通过返回新对象，而不是更改对象，更新状态。</p>
<p>对比 Flux 的官方实现，Redux 的 API 更简洁，并且提供了如 <code>combineReducers</code>等工具函数及 <code>React-Toolkit</code> 工具集，以及对状态的撤销、重做和持久化等更复杂的功能。提供如 <code>React-Redux</code> 等简化 Redux 与其他第三方库的连接。</p>
<p>Facebook 官方推荐在生产环境中使用代替 Flux。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://serendipity0321.github.com">蓉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://serendipity0321.github.com/2023/01/28/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/">http://serendipity0321.github.com/2023/01/28/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://serendipity0321.github.com" target="_blank">serendipity0321's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React/">React</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/29/webpack%E6%94%BB%E7%95%A5/" title="webpack攻略"><img class="cover" src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">webpack攻略</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/28/HTML%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="HTML学习记录"><img class="cover" src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">HTML学习记录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/17/React%E9%9D%A2%E8%AF%95%E9%A2%98/" title="React面试题"><img class="cover" src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="title">React面试题</div></div></a></div><div><a href="/2023/01/29/%E5%BE%AE%E5%89%8D%E7%AB%AF/" title="微前端"><img class="cover" src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-29</div><div class="title">微前端</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/10/02/SRY7qntDHQe5l9F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">蓉</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/serendipity0321"><i class="fab fa-github"></i><span>Follow Meeee</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/serendipity0321" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:r1727439300@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hello-React"><span class="toc-number">2.</span> <span class="toc-text">Hello, React :-)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">React 应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E9%9D%A2%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.</span> <span class="toc-text">React 面试注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-React-%E5%92%8C-Vue-%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">对比 React 和 Vue ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-React"><span class="toc-number">6.</span> <span class="toc-text">什么是 React ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-React-%E5%92%8C-Angular"><span class="toc-number">7.</span> <span class="toc-text">对比 React 和 Angular ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E8%AE%A4%E4%B8%BA-React-%E7%9A%84%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">你认为 React 的缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">什么是声明式编程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">什么是函数式编程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC-%E5%92%8C-MVVM-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">MVC 和 MVVM 的区别是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87-React-%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">如何组织 React 项目文件结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87-React-%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%9F-1"><span class="toc-number">13.</span> <span class="toc-text">如何组织 React 项目文件结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-18-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">React 18 都有哪些新特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JSX-%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">什么是 JSX ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E5%9C%A8-React-%E4%B8%AD%E4%BD%BF%E7%94%A8-JSX-%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">为什么推荐在 React 中使用 JSX ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-JSX-%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%95%88%E9%99%8D%E4%BD%8E-XSS-%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">为什么 JSX 可以有效降低 XSS 风险？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-JSX-%E4%B8%AD%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">如何在 JSX 中条件渲染？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-JSX-%E4%B8%AD%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">如何在 JSX 中循环控制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-JSX-%E4%B8%AD-class-%E5%8F%98%E6%88%90%E4%BA%86-className"><span class="toc-number">20.</span> <span class="toc-text">为什么 JSX 中 class 变成了 className ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-React-%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">什么是 React 组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E7%BB%84%E4%BB%B6%E5%88%86%E6%88%90%E5%93%AA%E5%87%A0%E7%B1%BB%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">React 组件分成哪几类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">类组件和函数组件的区别是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">受控组件和非受控组件的区别是？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86"><span class="toc-number">24.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ★ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">什么是高阶组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Pure-Components-%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">什么是 Pure Components ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">展示组件和容器组件的区别是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8A%AB%E6%8C%81-React-%E7%BB%84%E4%BB%B6%E6%8F%90%E9%AB%98%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8%E5%BA%A6%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">如何劫持 React 组件提高组件复用度？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA-React-%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">如何设计一个 React 组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E7%BB%84%E4%BB%B6%E4%B8%8E-Web-Components-%E5%85%B1%E5%AD%98%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%98%AF%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">React 组件与 Web Components 共存的最佳实践是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-React-%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">什么是 React 的状态？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-%E2%98%86"><span class="toc-number">31.1.</span> <span class="toc-text">面试高频指数：★ ☆ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-React-%E7%9A%84%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">什么是 React 的状态提升？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%92%8C%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">状态和属性的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%8D%E7%A7%B0%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">如何创建动态的状态名称？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setState-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E7%94%A8%E6%B3%95%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">setState 支持哪些用法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86"><span class="toc-number">35.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setState-%E5%92%8C-replaceState-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">setState 和 replaceState 的区别是？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-%E2%98%86-1"><span class="toc-number">36.1.</span> <span class="toc-text">面试高频指数：★ ☆ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-setState%EF%BC%8C%E5%87%8F%E5%B0%91%E4%B8%8D%E5%BF%85%E8%A6%81%E6%9B%B4%E6%96%B0%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">如何优化 setState，减少不必要更新？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-1"><span class="toc-number">37.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93-State-%E5%80%BC%E4%B8%BA-Object-%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">当 State 值为 Object 时，如何优化？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-2"><span class="toc-number">38.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-React-%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">什么是 React 的属性？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-%E2%98%86-2"><span class="toc-number">39.1.</span> <span class="toc-text">面试高频指数：★ ☆ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">为什么不能直接修改属性？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-%E2%98%86-3"><span class="toc-number">40.1.</span> <span class="toc-text">面试高频指数：★ ☆ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%B1%9E%E6%80%A7%E4%BC%A0%E9%80%92%E7%BB%84%E4%BB%B6%E6%9C%AC%E8%BA%AB%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">通过属性传递组件本身的方法有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-3"><span class="toc-number">41.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-key-%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">使用 key 属性有哪些注意事项？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86"><span class="toc-number">42.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-React-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">如何在 React 中进行静态类型检查？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-1"><span class="toc-number">43.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%98%AF%E5%BF%85%E9%A1%BB%E7%9A%84%EF%BC%9F"><span class="toc-number">44.</span> <span class="toc-text">如何限制某个属性是必须的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%EF%BC%9F"><span class="toc-number">45.</span> <span class="toc-text">如何设置属性的默认值？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-2"><span class="toc-number">45.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81-HTML-%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">46.</span> <span class="toc-text">React 是否支持 HTML 属性？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-4"><span class="toc-number">46.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">47.</span> <span class="toc-text">React 是否支持自定义属性？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-5"><span class="toc-number">47.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1"><span class="toc-number"></span> <span class="toc-text">通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">React 父子组件通信有哪些方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%85"><span class="toc-number">1.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ★ ★</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-React-%E6%98%AF%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">为什么 React 是单向数据流？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-3"><span class="toc-number">2.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Context-%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">什么是 Context ？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-1"><span class="toc-number">3.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ★ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-ContextType"><span class="toc-number">4.</span> <span class="toc-text">什么是 ContextType ?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-4"><span class="toc-number">4.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-Context-%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">如何优化 Context ？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-6"><span class="toc-number">5.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Ref-%E8%BD%AC%E5%8F%91%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">什么是 Ref 转发？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-7"><span class="toc-number">6.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93"><span class="toc-number"></span> <span class="toc-text">渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E8%BF%94%E5%9B%9E%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">React 返回空对象有哪些方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%B8%B2%E6%9F%93%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">如何优化不必要的渲染？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%85-1"><span class="toc-number">2.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ★ ★</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93-HTML-%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">React 如何渲染 HTML ，有什么风险？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-%E2%98%86-4"><span class="toc-number">3.1.</span> <span class="toc-text">面试高频指数：★ ☆ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E5%9F%BA%E4%BA%8E-Fiber-%E5%8D%8F%E8%B0%83%E5%99%A8%E7%9A%84%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">React 为什么要引入基于 Fiber 协调器的异步渲染？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-5"><span class="toc-number">4.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-React-Fiber"><span class="toc-number">5.</span> <span class="toc-text">什么是 React Fiber ?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-8"><span class="toc-number">5.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Fiber-%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">React Fiber 异步渲染分为哪几个阶段，对应生命周期是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-9"><span class="toc-number">6.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number"></span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">React 组件有哪些生命周期方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-6"><span class="toc-number">1.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%AF%E5%88%86%E4%B8%BA%E5%93%AA%E4%BA%9B%E9%98%B6%E6%AE%B5%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">React 组件的生命周期可分为哪些阶段？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-10"><span class="toc-number">2.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E5%BA%94%E5%9C%A8%E5%93%AA%E4%BA%9B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%87%8C%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">异步数据请求应在哪些生命周期里调用？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-2"><span class="toc-number">3.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ★ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useEffect-useLayoutEffect-%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E6%98%AF%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">useEffect useLayoutEffect 与生命周期的对应关系是？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-3"><span class="toc-number">4.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ★ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-constructor-%E4%B8%AD%E4%BD%BF%E7%94%A8-super-%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">在 constructor 中使用 super 的意义是？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-11"><span class="toc-number">5.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-React-Hook-%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.</span> <span class="toc-text">对比 React Hook 与生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-12"><span class="toc-number">6.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number"></span> <span class="toc-text">事件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-React-%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是 React 合成事件？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-4"><span class="toc-number">1.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ★ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-React-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">如何在 React 事件处理阻止默认行为？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-%E7%B1%BB%E7%BB%84%E4%BB%B6-%E4%B8%AD%EF%BC%8C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%9A%84-this-%E4%B8%BA-undefined-%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">如何解决 类组件 中，事件处理的 this 为 undefined 的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%A0%E5%8F%82%E7%BB%99%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">如何传参给事件处理函数？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-%E2%98%86-5"><span class="toc-number">4.1.</span> <span class="toc-text">面试高频指数：★ ☆ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E8%A2%AB%E9%A2%91%E7%B9%81%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">如何阻止事件处理函数被频繁调用？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-13"><span class="toc-number">5.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-17-%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E6%94%B9%E8%BF%9B%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">React 17 对事件处理做了哪些改进？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-14"><span class="toc-number">6.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="toc-number"></span> <span class="toc-text">样式管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-React-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%B7%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">如何在 React 中使用样式？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-%E2%98%86-6"><span class="toc-number">1.1.</span> <span class="toc-text">面试高频指数：★ ☆ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8C%89%E6%9D%A1%E4%BB%B6%E5%8A%A0%E8%BD%BD%E6%A0%B7%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">如何按条件加载样式？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-%E2%98%86-7"><span class="toc-number">2.1.</span> <span class="toc-text">面试高频指数：★ ☆ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">如何合并多个内联样式?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-%E2%98%86-8"><span class="toc-number">3.1.</span> <span class="toc-text">面试高频指数：★ ☆ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A8%A1%E5%9D%97%E5%8C%96%E6%A0%B7%E5%BC%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%A0%B7%E5%BC%8F%E5%90%8D%E5%86%B2%E7%AA%81-%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">如何模块化样式，如何避免样式名冲突 ？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-15"><span class="toc-number">4.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Hook"><span class="toc-number"></span> <span class="toc-text">React Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-React-Hook"><span class="toc-number">1.</span> <span class="toc-text">什么是 React Hook?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-State-Hook%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么是 State Hook？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-7"><span class="toc-number">2.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Effect-Hook%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">什么是 Effect Hook？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-8"><span class="toc-number">3.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4-Effect-Hook-%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">如何清除 Effect Hook 的副作用？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-5"><span class="toc-number">4.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ★ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Hook-%E9%9C%80%E8%A6%81%E9%81%B5%E5%BE%AA%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">使用 Hook 需要遵循的规则是？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-16"><span class="toc-number">5.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A0%A1%E9%AA%8C-Hook-%E6%98%AF%E5%90%A6%E9%81%B5%E5%BE%AA%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">如何校验 Hook 是否遵循规则？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-17"><span class="toc-number">6.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useMemo-%E5%92%8C-useCallback-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">useMemo 和 useCallback 的区别是？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-18"><span class="toc-number">7.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useReducer-%E5%92%8C-useState-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">useReducer 和 useState 的区别是？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-9"><span class="toc-number">8.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useLayoutEffect-%E5%92%8C-useEffect-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">useLayoutEffect 和 useEffect 的区别是？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-10"><span class="toc-number">9.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useRef-%E5%92%8C-Refs-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">useRef 和 Refs 的区别是？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-19"><span class="toc-number">10.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89-Hook%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">如何自定义 Hook？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-20"><span class="toc-number">11.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%9C%89%E5%BF%85%E8%A6%81%E4%BD%BF%E7%94%A8-Hook-API-%E9%87%8D%E5%86%99%E6%89%80%E6%9C%89%E7%B1%BB%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">是否有必要使用 Hook API 重写所有类组件？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-%E2%98%86-9"><span class="toc-number">12.1.</span> <span class="toc-text">面试高频指数：★ ☆ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useState-%E8%BF%94%E5%9B%9E%E6%9B%B4%E6%96%B0-state-%E7%9A%84%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%8C%E6%AD%A5%EF%BC%8C%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">useState 返回更新 state 的函数是同步，还是异步的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-21"><span class="toc-number">13.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">14.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Virtual-DOM"><span class="toc-number">15.</span> <span class="toc-text">什么是 Virtual DOM ?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%85-2"><span class="toc-number">15.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ★ ★</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-React-Diff%EF%BC%8C%E5%AF%B9%E6%AF%94-Vue-Diff-%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">什么是 React Diff，对比 Vue Diff ？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%85-3"><span class="toc-number">16.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ★ ★</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-React-Concurrent-%E6%A8%A1%E5%BC%8F"><span class="toc-number">17.</span> <span class="toc-text">什么是 React Concurrent 模式?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-%E2%98%86-10"><span class="toc-number">17.1.</span> <span class="toc-text">面试高频指数：★ ☆ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Suspense"><span class="toc-number">18.</span> <span class="toc-text">什么是 Suspense ?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-%E2%98%86-11"><span class="toc-number">18.1.</span> <span class="toc-text">面试高频指数：★ ☆ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">React 如何定义任务的优先级？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-11"><span class="toc-number">19.1.</span> <span class="toc-text">面试高频指数：★ ★ ★ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Redux"><span class="toc-number">20.</span> <span class="toc-text">什么是 Redux ?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-%E2%98%86-12"><span class="toc-number">20.1.</span> <span class="toc-text">面试高频指数：★ ☆ ☆ ☆ ☆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flux-%E5%92%8C-Redux-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">Flux 和 Redux 的区别是？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E6%8C%87%E6%95%B0%EF%BC%9A%E2%98%85-%E2%98%85-%E2%98%86-%E2%98%86-%E2%98%86-22"><span class="toc-number">21.1.</span> <span class="toc-text">面试高频指数：★ ★ ☆ ☆ ☆</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/17/React%E9%9D%A2%E8%AF%95%E9%A2%98/" title="React面试题"><img src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React面试题"/></a><div class="content"><a class="title" href="/2023/02/17/React%E9%9D%A2%E8%AF%95%E9%A2%98/" title="React面试题">React面试题</a><time datetime="2023-02-17T08:17:41.000Z" title="发表于 2023-02-17 16:17:41">2023-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/17/ES6%E9%9D%A2%E8%AF%95/" title="ES6面试"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ES6面试"/></a><div class="content"><a class="title" href="/2023/02/17/ES6%E9%9D%A2%E8%AF%95/" title="ES6面试">ES6面试</a><time datetime="2023-02-17T02:20:30.000Z" title="发表于 2023-02-17 10:20:30">2023-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/" title="前端面试之道"><img src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面试之道"/></a><div class="content"><a class="title" href="/2023/02/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/" title="前端面试之道">前端面试之道</a><time datetime="2023-02-15T14:06:38.000Z" title="发表于 2023-02-15 22:06:38">2023-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/15/axios%E5%B0%81%E8%A3%85/" title="无题"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/02/15/axios%E5%B0%81%E8%A3%85/" title="无题">无题</a><time datetime="2023-02-15T08:52:45.414Z" title="发表于 2023-02-15 16:52:45">2023-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/15/%E5%89%91%E6%8C%87offer/" title="剑指offer"><img src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="剑指offer"/></a><div class="content"><a class="title" href="/2023/02/15/%E5%89%91%E6%8C%87offer/" title="剑指offer">剑指offer</a><time datetime="2023-02-15T07:16:18.000Z" title="发表于 2023-02-15 15:16:18">2023-02-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 蓉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>