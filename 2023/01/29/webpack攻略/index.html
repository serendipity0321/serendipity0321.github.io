

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="webpack简介简介本质上，webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。 webpack的核心概念为以下模块，后续会对以下概念针对性输出文章。">
<meta property="og:type" content="article">
<meta property="og:title" content="webpack攻略">
<meta property="og:url" content="http://serendipity0321.github.com/2023/01/29/webpack%E6%94%BB%E7%95%A5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="webpack简介简介本质上，webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。 webpack的核心概念为以下模块，后续会对以下概念针对性输出文章。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/10/08/TDvFqbnLIOiusRt.jpg">
<meta property="article:published_time" content="2023-01-29T01:57:54.000Z">
<meta property="article:modified_time" content="2023-01-29T08:19:51.377Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="webpack">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2022/10/08/TDvFqbnLIOiusRt.jpg">
  
  
  
  <title>webpack攻略 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"serendipity0321.github.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>serendipity&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://s2.loli.net/2022/10/08/TDvFqbnLIOiusRt.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="webpack攻略"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-29 09:57" pubdate>
          2023年1月29日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          110k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          915 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">webpack攻略</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="webpack简介"><a href="#webpack简介" class="headerlink" title="webpack简介"></a>webpack简介</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本质上，webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。</p>
<p>webpack的核心概念为以下模块，后续会对以下概念针对性输出文章。</p>
<ul>
<li><p>入口（entry）</p>
</li>
<li><p>输出（output）</p>
</li>
<li><p>loader</p>
</li>
<li><p>插件（plugin）</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>webpack 对操作系统没有要求，使用 Windows、Mac、Linux 操作系统均可，它唯一的依赖是 Node.js，所以使用 webpack 前需要先安装 Node.js，安装地址为 [Nodejs]](<a href="https://leetcode.cn/link/?target=http://nodejs.cn/download/">http://nodejs.cn/download/</a>) 推荐安装TLS（长期维护）版本。node 安装完成后，在命令行输入 node -v，可显示版本号即安装成功。<br>接下来，我们需要使用 Node.js 的包管理器 npm 来安装 webpack ，安装模块的方式有两种：一种是全局安装，一种是本地安装，此处我们选择本地安装，主要有以下两点原因：</p>
<ol>
<li>如果采用全局安装，那在与他人协作时，由于每个人的 webpack 版本不同，可能导致打包出的内容不一致</li>
<li>通常会通过运行一个或多个 npm scripts 以在本地 node_modules 目录中查找安装的 webpack，来运行 webpack，所以在这种情况下可能导致本地全局都有，容易造成混淆</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>
    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span>
<span class="hljs-punctuation">&#125;</span></code></pre></div>

<p>基于以上两点，我们选择在项目内安装，首先新建一个工程目录，并执行 npm 的初始化命令</p>
<div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> webpack_init &amp;&amp; <span class="hljs-built_in">cd</span> webpack_init
npm init</code></pre></div>

<p>命令行输入项目的基本信息，如：名称、版本、描述、仓库地址等信息。成功后工程目录中会出现一个 package.json 文件。<br>接下来输入安装webpack的命令：</p>
<div class="code-wrapper"><pre><code class="hljs q">npm install webpack webpack-cli --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div>

<p>webpack v4+ 版本都需要手动安装 webpack-cli，webpack-cli 提供了许多命令用于在命令行中运行 webpack。具体包含命令可查看文档[webpack-cli]](<a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/api/cli/">https://webpack.docschina.org/api/cli/</a>) 检查安装是否成功执行 webpack -v ， webpack-cli -v ，显示对应版本则安装成功</p>
<h2 id="打包第一个应用"><a href="#打包第一个应用" class="headerlink" title="打包第一个应用"></a>打包第一个应用</h2><p>在 webpack_init 文件夹下添加 index.html、src 文件夹下添加 index.js、hello.js 文件</p>
<p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>src&#x2F;index.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> helloWorld <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hello.js&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">component</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>); 
  element.<span class="hljs-property">innerHTML</span> = <span class="hljs-title function_">helloWorld</span>();
  <span class="hljs-keyword">return</span> element;
&#125;

<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">component</span>());</code></pre></div>

<p>src&#x2F;hello.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world!!!&#x27;</span>
&#125;</code></pre></div>

<p>在控制台输入打包命令 npx webpack，</p>
<div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">npx webpack</span></code></pre></div>

<p>因为 npm 会从全局模块中找 webpack ，但是我并非全局安装，而是项目本地安装，所以报错。所以需要 npx 命令运行命令。npx 会先找当前目录下的 node_modules&#x2F;.bin 目录下的二进制可执行文件，如果当前目录下没有 npx 会在 PATH 目录下继续寻找，如果没有会自动下载安装 webpack。此时，第一步手动安装 npm install webpack –save-dev 可省略。执行命令成功后会在项目中增加一个 dist 文件，文件中有一个打包后的 main.js 文件。<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453743-XEjonp-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<p>此时我们在浏览器中打开 index.html 文件，在页面中看到 hello world!!!<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453821-swEKUQ-1.png" srcset="/img/loading.gif" lazyload alt="1.png"></p>
<p>在上面的命令中，我们采用了 webpack 的默认设置，我们也可以在命令行中指定入口文件、输出文件、打包模式等信息</p>
<div class="code-wrapper"><pre><code class="hljs routeros">npx webpack <span class="hljs-attribute">--entry</span>=./src/index.js <span class="hljs-attribute">--output-filename</span>=bundle.js <span class="hljs-attribute">--mode</span>=development</code></pre></div>

<p>删除 webpack 默认配置打包的内容，重新执行带配置的命令，打包后在 dist 目录下生成了 bundle.js 文件，将 index.html 中引入 js 文件地址 main.js 改为 bundle.js，在浏览器打开 index.html 发现控制台再一次输出了 hello world!!!。</p>
<h2 id="使用-npm-scripts"><a href="#使用-npm-scripts" class="headerlink" title="使用 npm scripts"></a>使用 npm scripts</h2><p>从上面的命令行配置打包例子来看，每次打包都需要在命令行输入冗长的命令，这样做会很耗时和容易出错，为了使命令更加简洁，可以在 package.json 文件中的”scripts”对象下添加一个打包命令脚本 build。<br>scripts 是 npm 提供的脚本命令功能，所以在这里我们可以直接使用 webpack 命令取代之前的 npx webpack。</p>
<div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>
  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span>
<span class="hljs-punctuation">&#125;</span></code></pre></div>

<p>在控制台输入npm命令，打包成功<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453846-cPODUe-3.png" srcset="/img/loading.gif" lazyload alt="3.png"></p>
<div class="code-wrapper"><pre><code class="hljs routeros">npm <span class="hljs-built_in">run</span> build</code></pre></div>

<h2 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h2><p>在 webpack4 中，可以无需配置采用默认方式打包，直接在控制台输入 npx webpack 即可打包，然后大多数项目需要很复杂的设置，如项目分包、压缩、懒加载等，所以大多数情况下还是需要一个配置文件，webpack 默认加载的配置文件为 webpack.config.js，也可以指定 webpack 配置文件，需要命令行指定。</p>
<h3 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><p>在项目 webpack_init 中新建一个 webpack.config.js 文件</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);

<span class="hljs-built_in">module</span>.exports = &#123;
  entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
  <span class="hljs-built_in">output</span>: &#123;
    filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,
    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)
  &#125;
&#125;;</code></pre></div>

<p>上面通过 module.exports 导出了一个对象，将之前命令行中输入的 key-value 形式的参数放在这个对象中。<br>这个对象包含连个属性，entry 为项目入口文件，output 为打包出口文件，其中 filename 为打包文件名称，path 为文件打包路径。通过调用 node.js 的path模块，将 __dirname(node.js内置全局变量，__dirname 为当前文件所在目录的绝对路径)与输出路径连接起来，得到了最终资源输出路径。</p>
<p>现在我们去掉 package.json 中 build 后面的参数去掉，只保留 “build”: “webpack”，然后在控制台输入 npm run build，打包成功了<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453847-kbCvea-4.png" srcset="/img/loading.gif" lazyload alt="4.png"></p>
<h3 id="使用不同的配置文件"><a href="#使用不同的配置文件" class="headerlink" title="使用不同的配置文件"></a>使用不同的配置文件</h3><p>出于某种原因，需要根据特定情况使用不同的配置文件，则可以通过在命令行中使用 –config 标志修改<br>删除项目中的 webpack-config.js，新建一个 webpack-config-dev.js，内容和 webpack-config.js 一致。在命令行输入npm run build –config webpack.config.dev.js 或者在 package.json 的 scripts 中增加配置</p>
<div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>
  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.config.dev.js&quot;</span>
<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span></code></pre></div>

<p>执行打包命令后。打包结果如下<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453849-gYWreG-5.png" srcset="/img/loading.gif" lazyload alt="5.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在上面我们介绍了</p>
<ul>
<li>webpack 的作用及包含核心模块</li>
<li>如何从零安装一个 webpack 运行环境</li>
<li>打包第一个 webpack 项目</li>
<li>告别命令行，通过配置文件打包 webpack</li>
</ul>
<p>下一节我们将介绍下 webpack 的配置文件，包含的参数及作用。</p>
<h1 id="资源处理流程"><a href="#资源处理流程" class="headerlink" title="资源处理流程"></a>资源处理流程</h1><p>借用 webpack 官网对 webpack 的描述： webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle</p>
<h2 id="什么是bundle"><a href="#什么是bundle" class="headerlink" title="什么是bundle"></a>什么是bundle</h2><p>代码分离是 webpack 的特性之一，使用 entry 配置入口起点，会将代码分成源代码和分发代码<br>其中源代码是开发编辑的代码，分发代码是经过 webpack 构建，可能经过转义、压缩或优化后的代码，这些代码存放于 bundle 中，可以被浏览器等环境直接运行</p>
<h2 id="什么是dependency-graph"><a href="#什么是dependency-graph" class="headerlink" title="什么是dependency graph"></a>什么是dependency graph</h2><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453942-GhafnS-6.png" srcset="/img/loading.gif" lazyload alt="6.png"></p>
<p>看了上面的内容，其实我们还是不清楚 webpack 到底做了哪些事情使浏览器不支持的语法变得可以执行，而去查看源码，会发现源码中代码对我们不是特别友好，经常左跳右跳无法持续跟踪，所以针对 webpack 打包流程，总结了下面的一个简版打包代码，让我们能大体看清 webpack 做了哪些操作，以下只是简版 demo，没有强行靠近 webpack 打包结果，让我们更能清晰的梳理流程。</p>
<h2 id="打包步骤总结"><a href="#打包步骤总结" class="headerlink" title="打包步骤总结"></a>打包步骤总结</h2><ol>
<li>我们工程的依赖路径 index.js -&gt; hello.js -&gt; message.js</li>
<li>根据 webpack.config.js 中定义的 entry 解析入口（index.js）文件，找到他的依赖</li>
<li>递归的构建依赖关系图</li>
<li>将所有内容打包到 webpack.config.js 定义的 output 文件</li>
</ol>
<p>在整理打包内容之前，我们先来看下我们现在项目的结构，项目名称为 webpack_demo，其中包含 webpack.config.js，package.json，dist&#x2F;main.js，src&#x2F;index.js，src&#x2F;hello.js，src&#x2F;message.js，src&#x2F;bundler.js，src&#x2F;complier.js。</p>
<p>webpack.config.js 定义对象，导出项目入口出口文件</p>
<div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)

<span class="hljs-built_in">module</span>.exports = &#123;
    entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
    <span class="hljs-built_in">output</span>: &#123;
        <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;./dist&#x27;</span>),
        filename: <span class="hljs-string">&#x27;main.js&#x27;</span>
    &#125;
&#125;</code></pre></div>

<p>src&#x2F;index.js 代码中导入 hello.js方法并执行</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> hello <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hello.js&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hello</span>())</code></pre></div>

<p>src&#x2F;hello.js 代码中导入 message.js中的message参数</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; message &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./message.js&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello &#x27;</span> + message;
&#125;</code></pre></div>

<p>src&#x2F;message.js 中定义了一个message变量</p>
<div class="code-wrapper"><pre><code class="hljs delphi"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">message</span> = <span class="hljs-string">&#x27;world!!!&#x27;</span></code></pre></div>

<p>上面的代码层层引用下来，可以在控制台输出 ‘hello world!!!’，就代表打包成功了。</p>
<p>上面的环境已经定义完成，接下来让我们按照步骤完成打包操作：</p>
<ol>
<li>在src&#x2F;complier.js文件中创建complier构造函数，在构造函数中获取webpack.config.js中定义的入口出口参数</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">Complier</span> &#123;
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;
      <span class="hljs-keyword">const</span> &#123; entry, output &#125; = options
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">entry</span> = entry
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(options)
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">output</span> = output
    &#125;
&#125;</code></pre></div>

<ol>
<li>在 src&#x2F;bundler.js 文件中引入 webpack.config.js 文件，创建 Complier 的实例化对象并传入 options</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">const</span> <span class="hljs-variable">complier</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;./complier&#x27;</span>)</span>
<span class="hljs-variable">const</span> <span class="hljs-variable">options</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;../webpack.config&#x27;</span>)</span>
<span class="hljs-variable">new</span> <span class="hljs-function"><span class="hljs-title">complier</span>(<span class="hljs-variable">options</span>)</span></code></pre></div>

<p>在命令行执行 node src&#x2F;bundler.js 后，在控制台会打印出 options 内容<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453942-qDwVoX-12.png" srcset="/img/loading.gif" lazyload alt="12.png"></p>
<ol>
<li>拿到配置参数后，开始根据入口文件解析文件内容，解析单流程整体为：<ol>
<li>根据入口文件名称通过 nodejs 提供的方法 fs.readFileSync 读取到文件内容</li>
<li>使用 @babel&#x2F;parser 将文件内容转换成ast语法树</li>
<li>ast 语法树中 node 节点中包含了文件依赖的文件名称，使用 @babel&#x2F;traverse 方法提取出依赖的文件名称并存储到一个数组中</li>
<li>通过 @babel&#x2F;core 中的 babel.transformFromAst 方法将 ast 转换成目标浏览器可执行的代码</li>
<li>将上述获取的参数返回个对象，对象包含文件名，依赖数组，文件可执行代码，这个对象即为一个依赖图谱中的一个节点</li>
<li>遍历入口文件的依赖数组，由于数组中是文件名，则递归执行上述方法，直到找到所有依赖</li>
<li>返回所有依赖对象</li>
</ol>
</li>
</ol>
<p>根据上面总结内容我们在 src&#x2F;complier.js 中创建一个 createAsset 方法</p>
<div class="code-wrapper"><pre><code class="hljs awk">const fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>)
const path = require(<span class="hljs-string">&#x27;path&#x27;</span>)
const parser = require(<span class="hljs-string">&#x27;@babel/parser&#x27;</span>)
const traverse = require(<span class="hljs-string">&#x27;@babel/traverse&#x27;</span>).default
const babel = require(<span class="hljs-string">&#x27;@babel/core&#x27;</span>)
...
<span class="hljs-regexp">//</span> 开始编译，构建ast语法树 filename: .<span class="hljs-regexp">/src/i</span>ndex.js
    createAsset(filename) &#123;
       <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>
       <span class="hljs-regexp">//</span> content 内容即为index.js中书写的内容
      const content = fs.readFileSync(filename, <span class="hljs-string">&#x27;utf-8&#x27;</span>)
      <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>
      <span class="hljs-regexp">//</span> ast 内容为对象，具体内容可以console.log(ast)查看
      <span class="hljs-regexp">//</span> https:<span class="hljs-regexp">//</span>astexplorer.net/ 在官网输入index.js内容即可看到对应的树
      const ast = parser.parse(content, &#123;
          sourceType: <span class="hljs-string">&#x27;module&#x27;</span>
      &#125;)
      <span class="hljs-regexp">//</span> 创建依赖对象
      const dependencies = &#123;&#125;
      <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>
      <span class="hljs-regexp">//</span> 获取抽象语法树中的依赖文件名
      traverse(ast, &#123;
            ImportDeclaration: (&#123;node&#125;) =&gt; &#123;
             <span class="hljs-regexp">//</span> 获取文件的路径名如 <span class="hljs-string">&#x27;./src/index.js&#x27;</span> dirname=<span class="hljs-string">&#x27;./src&#x27;</span>
             const dirname = path.dirname(filename)
             const absPath = path.join(dirname, node.source.value)
             <span class="hljs-regexp">//</span> node.source.value: .hello.js
             <span class="hljs-regexp">//</span> absPath: .<span class="hljs-regexp">/src/i</span>ndex.js
             dependencies[node.source.value] = absPath
            &#125;
      &#125;)
      <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>
      <span class="hljs-regexp">//</span> 将ast转换成可执行代码 
      <span class="hljs-regexp">//</span> https:<span class="hljs-regexp">//</span>www.babeljs.cn<span class="hljs-regexp">/docs/</span>babel-core 将index.js内容直接放在官网即可看到转译后代码
      const &#123; code &#125; = babel.transformFromAst(ast, null, &#123;
        presets: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]
      &#125;)
      <span class="hljs-regexp">//</span> <span class="hljs-number">5</span>
      return &#123;
          filename,
          dependencies,
          code
      &#125;
    &#125;</code></pre></div>

<p>入口文件的依赖关系已经定义好，接下来根据入口文件的 dependencies ，递归遍历出所有子依赖，在 src&#x2F;complier.js 文件中定义 run 方法</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 拿到参数、执行、分析入口文件</span>
 <span class="hljs-built_in">run</span>() &#123;
    <span class="hljs-comment">// 拿到入口文件的依赖</span>
    <span class="hljs-type">const</span> mainAsset = <span class="hljs-keyword">this</span>.<span class="hljs-built_in">createAsset</span>(<span class="hljs-keyword">this</span>.entry)
    <span class="hljs-type">const</span> queue = [mainAsset]
    <span class="hljs-comment">// 6</span>
    <span class="hljs-comment">// 遍历对象</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> asset of queue) &#123;
       <span class="hljs-comment">// 遍历文件的依赖文件，递归创建依赖图</span>
      Object.<span class="hljs-built_in">values</span>(asset.dependencies).forEach(filename =&gt; &#123;
          <span class="hljs-type">const</span> child = <span class="hljs-keyword">this</span>.<span class="hljs-built_in">createAsset</span>(filename)
          queue.<span class="hljs-built_in">push</span>(child)
      &#125;)
    &#125;
    <span class="hljs-comment">// 7</span>
    <span class="hljs-keyword">return</span> queue
 &#125;</code></pre></div>

<p>命令行执行 node src&#x2F;bundler.js 看下 queue 的内容如下<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453942-BjjsRD-8.png" srcset="/img/loading.gif" lazyload alt="8.png"></p>
<ol>
<li>依赖树已经拿到，接下来在 src&#x2F;bundler.js 中获取 complier 中返回的 queue</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs stata"><span class="hljs-comment">// 获取dependence graph</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">graph</span> = new complier(options).<span class="hljs-keyword">run</span>()</code></pre></div>

<ol>
<li>在 src&#x2F;bundler.js 中创建函数 bundle，解析 graph 树，定义 require 函数，定义 modules，通过 eval 函数执行依赖树中的 code，在此我们可以知道 webpack 重写了 require 函数，所以 babel 中转换的函数可以正常执行</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bundle</span>(<span class="hljs-params">graph</span>)</span>&#123;
  <span class="hljs-comment">// 得到依赖文件名的对象 </span>
  let modules = &#123;&#125;;
  graph.<span class="hljs-title function_ invoke__">forEach</span>(item =&gt; &#123;
     // 将文件名作为key, value为依赖文件，code为文件名对应的函数
    modules[item.filename] = &#123;
        <span class="hljs-attr">dependencies</span>: item.dependencies,
        <span class="hljs-attr">code</span>: item.code
    &#125;
  &#125;)
  modules = JSON.<span class="hljs-title function_ invoke__">stringify</span>(modules)
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">result</span> = `(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">graph</span>)</span>&#123;
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">require</span>(<span class="hljs-params">filepath</span>) </span>&#123;
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">localRequire</span>(<span class="hljs-params">relativePath</span>) </span>&#123;
            <span class="hljs-comment">// 将代码中的require中的路径转换成dependencies存储的带文件夹名的路径</span>
           <span class="hljs-keyword">return</span> <span class="hljs-keyword">require</span>(graph[filepath].dependencies[relativePath])
        &#125;
        <span class="hljs-keyword">var</span> exports = &#123;&#125;
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"><span class="hljs-keyword">require</span>, exports, code</span>) </span>&#123;
            <span class="hljs-keyword">eval</span>(code)
        &#125;
        <span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params">localRequire, exports, graph[filepath].code</span>)</span>
<span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">exports</span></span>
<span class="hljs-function">      &#125;</span>
<span class="hljs-function">      <span class="hljs-title">require</span>(<span class="hljs-params"><span class="hljs-string">&#x27;$&#123;entry&#125;&#x27;</span></span>)</span>
<span class="hljs-function">    &#125;)(<span class="hljs-params">$&#123;modules&#125;</span>)`</span>
<span class="hljs-function">  <span class="hljs-title">return</span> <span class="hljs-title">result</span></span>
<span class="hljs-function">&#125;</span>
<span class="hljs-function"></span>
<span class="hljs-function"><span class="hljs-title">const</span> <span class="hljs-title">graph</span> = <span class="hljs-title">new</span> <span class="hljs-title">complier</span>(<span class="hljs-params">options</span>).<span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>
<span class="hljs-function">// 执行<span class="hljs-title">bundle</span>函数</span>
<span class="hljs-function"><span class="hljs-title">const</span> <span class="hljs-title">result</span> = <span class="hljs-title">bundle</span>(<span class="hljs-params">graph</span>)</span></code></pre></div>

<p>命令行输出 result 内容，粘贴内容到浏览器控制台并回车执行，发现我们预期的 ‘hello world!!!’ 已经可以正常打印<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655454170-vhNhQb-11.png" srcset="/img/loading.gif" lazyload alt="11.png"></p>
<ol>
<li>以上我们已经拿到了编译后的代码，最后将它输出到 dist&#x2F;main.js 中，在 src&#x2F;bundler.js 中创建方法 createFile()，使用 fs 对象的 writeFileSync 将内容输出，在命令行执行命令后可以看到 src&#x2F;main.js 中输出了对应内容</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> create<span class="hljs-constructor">File(<span class="hljs-params">code</span>)</span> &#123;
    fs.write<span class="hljs-constructor">FileSync(<span class="hljs-params">path</span>.<span class="hljs-params">join</span>(<span class="hljs-params">output</span>.<span class="hljs-params">path</span>, <span class="hljs-params">output</span>.<span class="hljs-params">filename</span>)</span>, code)
&#125;</code></pre></div>

<ol>
<li>下面是 src&#x2F;complier.js和 src&#x2F;bundler.js文件全部内容</li>
</ol>
<p>complier.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 文件操作模块，读取文件内容</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)
<span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/parser&#x27;</span>)
<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/traverse&#x27;</span>).<span class="hljs-property">default</span>
<span class="hljs-keyword">const</span> babel = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/core&#x27;</span>)

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">Complier</span> &#123;
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;
      <span class="hljs-keyword">const</span> &#123; entry, output &#125; = options
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">entry</span> = entry
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">output</span> = output
    &#125;
    <span class="hljs-comment">// 拿到参数、执行、分析入口文件</span>
    <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;
       <span class="hljs-keyword">const</span> mainAsset = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createAsset</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">entry</span>)
       <span class="hljs-keyword">const</span> queue = [mainAsset]
       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> asset <span class="hljs-keyword">of</span> queue) &#123;
         <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(asset.<span class="hljs-property">dependencies</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span> &#123;
             <span class="hljs-keyword">const</span> child = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createAsset</span>(filename)
             queue.<span class="hljs-title function_">push</span>(child)
         &#125;)
       &#125;
       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue)
       <span class="hljs-keyword">return</span> queue
    &#125;
    <span class="hljs-comment">// 开始编译，构建ast语法树 filename: ./src/index.js</span>
    <span class="hljs-title function_">createAsset</span>(<span class="hljs-params">filename</span>) &#123;
      <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(filename, <span class="hljs-string">&#x27;utf-8&#x27;</span>)
      <span class="hljs-keyword">const</span> ast = parser.<span class="hljs-title function_">parse</span>(content, &#123;
          <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&#x27;module&#x27;</span>
      &#125;)
      <span class="hljs-comment">// 创建依赖</span>
      <span class="hljs-keyword">const</span> dependencies = &#123;&#125;
      <span class="hljs-title function_">traverse</span>(ast, &#123;
            <span class="hljs-title class_">ImportDeclaration</span>: <span class="hljs-function">(<span class="hljs-params">&#123;node&#125;</span>) =&gt;</span> &#123;
             <span class="hljs-comment">// 获取文件的路径名如 &#x27;./src/index.js&#x27; dirname=&#x27;./src&#x27;</span>
             <span class="hljs-keyword">const</span> dirname = path.<span class="hljs-title function_">dirname</span>(filename)
             <span class="hljs-keyword">const</span> absPath = path.<span class="hljs-title function_">join</span>(dirname, node.<span class="hljs-property">source</span>.<span class="hljs-property">value</span>)
             dependencies[node.<span class="hljs-property">source</span>.<span class="hljs-property">value</span>] = absPath
            &#125;
        &#125;)
      <span class="hljs-comment">// 将ast转换成代码 </span>
      <span class="hljs-comment">// https://www.babeljs.cn/docs/babel-core</span>
      <span class="hljs-keyword">const</span> &#123; code &#125; = babel.<span class="hljs-title function_">transformFromAst</span>(ast, <span class="hljs-literal">null</span>, &#123;
        <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]
      &#125;)

      <span class="hljs-keyword">return</span> &#123;
          filename,
          dependencies,
          code
      &#125;
    &#125;
&#125;</code></pre></div>

<p>bundler.js</p>
<div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// 引入配置</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">fs</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">path</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">options</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;../webpack.config&#x27;</span>)

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">complier</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;./complier&#x27;</span>)

<span class="hljs-keyword">const</span> &#123; entry, output &#125; = options

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bundle</span>(<span class="hljs-params">graph</span>)</span>&#123;
  <span class="hljs-comment">// 得到以依赖文件名的对象 </span>
  let modules = &#123;&#125;;
  graph.<span class="hljs-title function_ invoke__">forEach</span>(item =&gt; &#123;
    modules[item.filename] = &#123;
        <span class="hljs-attr">dependencies</span>: item.dependencies,
        <span class="hljs-attr">code</span>: item.code
    &#125;
  &#125;)
  modules = JSON.<span class="hljs-title function_ invoke__">stringify</span>(modules)
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">result</span> = `(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">graph</span>)</span>&#123;
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">require</span>(<span class="hljs-params">filepath</span>) </span>&#123;
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">localRequire</span>(<span class="hljs-params">relativePath</span>) </span>&#123;
            <span class="hljs-comment">// 将代码中的require中的路径转换成dependencies存储的带文件夹名的路径</span>
           <span class="hljs-keyword">return</span> <span class="hljs-keyword">require</span>(graph[filepath].dependencies[relativePath])
        &#125;
        <span class="hljs-keyword">var</span> exports = &#123;&#125;
        
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"><span class="hljs-keyword">require</span>, exports, code</span>) </span>&#123;
            <span class="hljs-keyword">eval</span>(code)
        &#125;
        
        <span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params">localRequire, exports, graph[filepath].code</span>)</span>
<span class="hljs-function"></span>
<span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">exports</span></span>
<span class="hljs-function">      &#125;</span>
<span class="hljs-function">      <span class="hljs-title">require</span>(<span class="hljs-params"><span class="hljs-string">&#x27;$&#123;entry&#125;&#x27;</span></span>)</span>
<span class="hljs-function">    &#125;)(<span class="hljs-params">$&#123;modules&#125;</span>)`</span>
<span class="hljs-function">  <span class="hljs-title">return</span> <span class="hljs-title">result</span></span>
<span class="hljs-function">&#125;</span>
<span class="hljs-function"></span>
<span class="hljs-function"><span class="hljs-title">function</span> <span class="hljs-title">createFile</span>(<span class="hljs-params">code</span>) </span>&#123;
    fs.<span class="hljs-title function_ invoke__">writeFileSync</span>(path.<span class="hljs-title function_ invoke__">join</span>(output.path, output.filename), code)
&#125;

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">graph</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">complier</span>(options).<span class="hljs-title function_ invoke__">run</span>()
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">result</span> = <span class="hljs-title function_ invoke__">bundle</span>(graph)
<span class="hljs-title function_ invoke__">createFile</span>(result)</code></pre></div>



<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>通过上面的 demo，我们已经可以大概了解 webpack 的编译流程，当然 webpack 的源码功能强大且复杂，感兴趣的小伙伴儿可以自行研究。</p>
<h3 id="Entry-和-Context"><a href="#Entry-和-Context" class="headerlink" title="Entry 和 Context"></a>Entry 和 Context</h3><h1 id="配置入口context和entry"><a href="#配置入口context和entry" class="headerlink" title="配置入口context和entry"></a>配置入口context和entry</h1><p>webpack 在构建打包时，通过 context 和 entry 这两个配置来找到打包入口路径。在配置入口时其实做了两件事：</p>
<ul>
<li><p>确认入口文件位置，告诉 webpack 从哪个文件开始打包</p>
</li>
<li><p>描述 chunk name。如果传入一个字符串或字符串数组，那么默认的 chunk name 为 “main”，如果传入的是一个对象，则每个属性的 key 会是 chunk 的名称，该属性的值描述了 chunk 的入口点</p>
</li>
</ul>
<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>context 可以理解为配置资源入口的基础目录，在配置时要求必须使用绝对路径。如：现有的目录结构入口为 &#x2F;src&#x2F;script&#x2F;index.js，则我们可以通过下面的配置来指定入口目录</p>
<div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-built_in">module</span>.exports = &#123;
  context: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;./src/script&#x27;</span>),
  entry: <span class="hljs-string">&#x27;./index.js&#x27;</span>
&#125;;
<span class="hljs-built_in">module</span>.exports = &#123;
  context: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;./src&#x27;</span>),
  entry: <span class="hljs-string">&#x27;./script/index.js&#x27;</span>
&#125;;</code></pre></div>

<p>这样配置后，命令行执行打包，发现依然成功的找到了入口并顺利打包（我们使用 hello world 的那个 demo 来执行现有配置）<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655454753-KcOwRo-1.png" srcset="/img/loading.gif" lazyload alt="1.png"></p>
<p>配置 context 的目的可以使 entry 的写法更加简洁，尤其是在多入口文件的情况下。不过 context 是可以省略的，默认值为当前工程的根目录。</p>
<h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>在 webpack 配置中有多种方式定义 entry 属性，如：字符串、数组、对象、函数，接下来我们展示下每种类型如何配置</p>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>直接定义入口名称</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  entry: <span class="hljs-string">&#x27;./src/script/index.js&#x27;</span>,
&#125;;
<span class="hljs-comment">// entry 单入口语法，是下面的简写</span>
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  entry: &#123;
    main: <span class="hljs-string">&#x27;./src/script/index.js&#x27;</span>,
  &#125;,
&#125;;</code></pre></div>



<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>传入一个数组的作用是将多个文件预先合并，最终将多个依赖的内容绘制在一个 chunk 中，在打包时 webpack 会将数组中的最后一个元素作为实际的入口路径，其余文件会预先构建到入口文件。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  entry: [<span class="hljs-string">&#x27;lodash&#x27;</span>, <span class="hljs-string">&#x27;./src/script/index.js&#x27;</span>],
&#125;;</code></pre></div>

<p>这种配置和下面是等效的</p>
<div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>
<span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-keyword">module</span>.exports = &#123;
  entry: <span class="hljs-string">&#x27;./src/script/index.js&#x27;</span>,
&#125;</code></pre></div>

<p>这种写法会将 lodash 打包到我们的 bundle.js 中。这种写法类似于在 index.js 中引入 lodash，在控制台执行打包命令我们来看下生成的文件，从下面两张图可以看到在 index 中我们没有引入 lodash，但打包的文件中已经引入了 lodash<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655454755-pHqfJy-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>如果要定义多入口文件则需要使用对象的形式，通过这种方式可以自定义 chunk name，其中对象的key即为 chunk name，对象的 value 为入口路径。在使用对象描述入口时，我们可以使用以下属性</p>
<ul>
<li>dependOn: 当前入口所依赖的入口。它们必须在该入口被加载前被加载</li>
<li>filename: 指定要输出的文件名称</li>
<li>import: 启动时需加载的模块</li>
<li>library: 指定 library 选项，为当前 entry 构建一个 library</li>
<li>runtime: 运行时 chunk 的名字。如果设置了，就会创建一个新的运行时 chunk。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时 chunk</li>
<li>publicPath: 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共 URL 地址</li>
</ul>
<p>多入口配置本质上打包后生成多个js文件</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  entry: &#123;
    index: [<span class="hljs-string">&#x27;lodash&#x27;</span>, <span class="hljs-string">&#x27;./src/script/index.js&#x27;</span>],
    vendor: <span class="hljs-string">&#x27;./vendor&#x27;</span>
  &#125;
&#125;</code></pre></div>



<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>使用函数类型定义入口时，只要返回上面介绍的几种形式即可，如</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 返回字符串
module.<span class="hljs-built_in">exports</span> = &#123;
  entry: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">&#x27;./src/script/index.js&#x27;</span>
&#125;
<span class="hljs-regexp">//</span> 返回对象
module.<span class="hljs-built_in">exports</span> = &#123;
  entry: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&#123;
    index: [<span class="hljs-string">&#x27;lodash&#x27;</span>, <span class="hljs-string">&#x27;./src/script/index.js&#x27;</span>],
    vendor: <span class="hljs-string">&#x27;./vendor&#x27;</span>
  &#125;)
&#125;</code></pre></div>

<p>传入函数的优点是我们可以通过函数中增加一些逻辑来动态改变打包入口</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本章我们梳理了 webpack 入口配置的几种方式，包括字符串、对象、数组、函数几种</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/"><img src="https://static.leetcode.cn/cn-mono-assets/production/assets/logo-dark-cn.c42314a8.svg" srcset="/img/loading.gif" lazyload alt="logo"></a></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/avatar_1645205761.webp" srcset="/img/loading.gif" lazyload alt="img"><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/plus-light.594ca211.svg+xml" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/detail/qian-duan-webpack-gong-lue/">返回 前端 Webpack 攻略</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0tokh/">新手上路</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n03ct1/">前言</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n085q3/">Hello World</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0q4u7/">核心概念-入口</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0zlwc/">资源处理流程</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0sdvi/">Entry 和 Context</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n04nne/">Entry 配置实例</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n06gi5/">核心概念-出口</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n01mag/">配置参数详解</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0yomv/">输出配置实例</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0kq76/">核心概念-Loader</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0c5rj/">概述</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0cfot/">HTML-Loader</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0bcer/">URL-Loader</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0j45s/">File-Loader</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0fgxd/">CSS-Loader</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n7hqhh/">Style-Loader</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n7xuj3/">Postcss-Loader</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n757bm/">Sass-Loader</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n79wy1/">Svg-URL-Loader</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n7e217/">Svg-Sprite-Loader</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n7op45/">VUE-Loader</a><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n7rez6/">VUE-Style-Loader</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0gt02/">核心概念-Plugin</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/nsnsns/">配置</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/nsvk2d/">优化</a></p>
<h3 id="Entry-配置实例"><a href="#Entry-配置实例" class="headerlink" title="Entry 配置实例"></a>Entry 配置实例</h3><h1 id="entry-配置实例"><a href="#entry-配置实例" class="headerlink" title="entry 配置实例"></a>entry 配置实例</h1><p>webpack 的 entry 配置在实际的应用中可以分几个场景。</p>
<ul>
<li>单页应用</li>
<li>多页应用</li>
<li>分离应用程序和第三方库</li>
</ul>
<p>下面我们来介绍下这几种应用</p>
<h2 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h2><p>对于单页应用，我们一般来定义单一入口即可</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
&#125;;</code></pre></div>

<p>通过单一入口打包文件，可以将所有入口文件依赖的 框架、引入的工具库、各个页面内容打包到一起。这样的好处是将所有内容都打包成一个 js 文件，依赖关系清晰。但是这种方式也有个弊端，即所有模块都打到一个包中，当应用规模上升到一定程度后导致打包资源体积过大，导致页面首次加载速度变慢</p>
<h2 id="多页应用"><a href="#多页应用" class="headerlink" title="多页应用"></a>多页应用</h2><p>对于多页应用的场景，为了尽可能减少打包资源的体积，我们希望每个页面都只加载各自必要的逻辑，而不是将所有内容都打包到一个 bundle 中，我们来看下多应用的配置</p>
<div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-built_in">module</span>.exports = &#123;
  entry: &#123;
    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
    hello: <span class="hljs-string">&#x27;./src/hello.js&#x27;</span>
  &#125;,
  <span class="hljs-built_in">output</span>: &#123;
    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)
  &#125;
&#125;;</code></pre></div>

<p>打包后的文件如下，可以看到打包的内容中包含了 index.js 和 hello.js 两个文件。<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655454806-jTABfY-1.png" srcset="/img/loading.gif" lazyload alt="1.png"></p>
<h2 id="分离应用程序和第三方库"><a href="#分离应用程序和第三方库" class="headerlink" title="分离应用程序和第三方库"></a>分离应用程序和第三方库</h2><p>在一个应用中，我们使用的框架、库、第三方依赖等往往很少会有改动，如果我们将所有内容都打包到一个 bundle 文件，一旦业务代码有一点点变更，那用户就要重新下载整个资源，这对于页面的性能是很不友好的。为了解决这个问题，我们可以使用应用程序和第三方库分离的方式来打包文件。也就是将业务代码和不频繁变更的第三方依赖分 bundle 打包，示例如下<br>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  mode: <span class="hljs-string">&#x27;development&#x27;</span>,
  entry: &#123;
    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
    vendor: [<span class="hljs-string">&#x27;lodash&#x27;</span>]
  &#125;
&#125;;</code></pre></div>

<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span></code></pre></div>

<p>在上面的配置中，index.js 仍然和之前一样不做任何处理，只是我们新添加了一个 chunk name 为 vendor 的入口，并通过数组的形式将第三方依赖添加进去，执行打包命令我们看到输出了两个打包文件。<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655454806-dpjQmi-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<p>其实上面的代码虽然打包成功了，也成功提取了 vender 文件，但是打开打包后的 dist&#x2F;index.js 我们发现 lodash 还是被打到文件中了，对于这种情况我们可以配合使用 optimization.splitChunks，将 vender 和 index 中的公共代码提取出来，这个方法我们后面的文章在详细介绍。</p>
<p>通过上面的配置，我们可以业务依赖的第三方模块抽取成一个独立的 bundle，由于这个 bundle 不经常变动，因此可以有效的利用客户端缓存，在用户后续请求页面时加快整体渲染速度。</p>
<h2 id="配置参数详解"><a href="#配置参数详解" class="headerlink" title="配置参数详解"></a>配置参数详解</h2><h1 id="output-输出配置详解"><a href="#output-输出配置详解" class="headerlink" title="output 输出配置详解"></a>output 输出配置详解</h1><p>output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 .&#x2F;dist&#x2F;main.js，其他生成文件默认放置在 .&#x2F;dist 文件夹中。</p>
<p>我们可以通过在配置中指定一个 output 对象，来配置这些处理过程：</p>
<div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-built_in">module</span>.exports = &#123;
  mode: <span class="hljs-string">&#x27;development&#x27;</span>,
  entry: &#123;
    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>
  &#125;,
  <span class="hljs-built_in">output</span>: &#123;
    filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,
    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),
    publicPath: <span class="hljs-string">&#x27;/assets/&#x27;</span>,
    library: <span class="hljs-string">&#x27;DemoLibrary&#x27;</span>, // 导出名称
    libraryTarget: <span class="hljs-string">&#x27;window&#x27;</span> // 挂载目标
  &#125;
&#125;;</code></pre></div>

<p>output 对象中可以包含数十个配置项，其中大部分开发中使用频率不高，我们在本章内容中只介绍几个常用配置，对其他配置感兴趣的同学可以查看官网 <a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/configuration/output/#outputlibrary">output配置</a></p>
<h2 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h2><p>filename 决定了每个输出 bundle 的名称。这些 bundle 将写入到 output.path 选项指定的目录下。<br>对于单个入口起点，filename 会是一个静态名称。 filename 支持以字符串和函数的形式定义参数。</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 字符串形式</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
  ...
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,
  &#125;
&#125;;
<span class="hljs-comment">// 函数形式</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
  ...
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-function">(<span class="hljs-params">pathData</span>) =&gt;</span> &#123;
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pathData)
      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[name].js&#x27;</span>;
    &#125;
  &#125;
&#125;;</code></pre></div>

<p>字符串形式的 filename，会在输出文件中生成 bundle.js，函数形式的 filename 会在输出文件中生成 index.js (以 chunk name 命名)，在控制台输出下 pathData，我们可以看到返回了一个包含 chunk 内容等信息的对象。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455164-gvBnpN-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<p>filename 可以不仅仅是 bundle 的名字，还可以使用像 ‘js&#x2F;[name]&#x2F;bundle.js’ 这样的文件路径，即便路径中的目录不存在也没关系，webpack 会在输出资源时创建该目录。例子如下：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  output: &#123;
    filename: <span class="hljs-string">&#x27;js/[name]/bundle.js&#x27;</span>
  &#125;
&#125;;</code></pre></div>

<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455238-APpelQ-3.png" srcset="/img/loading.gif" lazyload alt="3.png"></p>
<p>当通过多个入口起点(entry point)、代码拆分(code splitting)或各种插件(plugin)创建多个 bundle，应该使用以下一种替换方式，来赋予每个 bundle 一个唯一的名称</p>
<table>
<thead>
<tr>
<th>替换方式</th>
<th>变量名称</th>
<th>功能描述</th>
<th>使用方式</th>
<th>打包结果</th>
</tr>
</thead>
<tbody><tr>
<td>入口名称</td>
<td>[name]</td>
<td>如果设置，则为此 chunk 的名称，否则使用 chunk 的 ID</td>
<td>filename: ‘[name].bundle.js’</td>
<td><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455277-rmXrzq-4.png" srcset="/img/loading.gif" lazyload alt="4.png"></td>
</tr>
<tr>
<td>chunk id</td>
<td>[id]</td>
<td>指代 此 chunk 的 id</td>
<td>filename: ‘[id].bundle.js’</td>
<td><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455277-XjORkS-5.png" srcset="/img/loading.gif" lazyload alt="5.png"></td>
</tr>
<tr>
<td>chunk hash</td>
<td>[chunkhash]</td>
<td>此 chunk 的 hash 值，包含该 chunk 的所有元素</td>
<td>filename: ‘[chunkhash].bundle.js’</td>
<td><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455277-XrOcco-6.png" srcset="/img/loading.gif" lazyload alt="6.png"></td>
</tr>
<tr>
<td>content hash</td>
<td>[contenthash]</td>
<td>指代由生成的内容产生的 hash</td>
<td>filename: ‘[contenthash].bundle.js’</td>
<td><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455277-HqewjZ-7.png" srcset="/img/loading.gif" lazyload alt="7.png"></td>
</tr>
</tbody></table>
<p>上面的配置除了可以对不同的 bundle 进行名称区分，还能起到一个控制客户端缓存的作用，表中的[chunkhash] 和 [contenthash] 都与文件内容直接相关，在 filename 中使用了这些变量后，当对文件内容做了修改，可以引起 bundle 文件名的修改，从而用户在下一次请求文件资源时会重新加载文件，而不会直接命中缓存资源。</p>
<p>在实际的工程中，我们一般使用较多的是[name]，一般与定义的 chunk 一一对应，可读性较高，为了控制客户端缓存，我们一般还加上 [contenthash]，如：</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  output: &#123;
    filename: <span class="hljs-string">&#x27;[name]-[contenthash].js&#x27;</span>
  &#125;
&#125;;</code></pre></div>

<p>打包结果如下<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455351-gcqeym-8.png" srcset="/img/loading.gif" lazyload alt="8.png"></p>
<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>path 可以指定资源输出位置，要求必须使用绝对路径，如</p>
<div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-built_in">module</span>.exports = &#123;
  mode: <span class="hljs-string">&#x27;development&#x27;</span>,
  entry: &#123;
    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
  &#125;,
  <span class="hljs-built_in">output</span>: &#123;
    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)
  &#125;
&#125;;</code></pre></div>

<p>上述配置将工程的dist目录设置为资源的输出目录，在 webpack 4 之后，output.path 已经默认为 dist 目录，除非我们需要修改他，否则可以不用单独配置。</p>
<h2 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h2><p>publicPath 从功能上来说，用于指定资源的请求位置。页面中的资源分为两种，一种是由 HTML 页面直接请求的，比如通过 script 标签加载 js，通过 link 标签加载 css。另一种是由 js 或 css 请求的，如加载图片字体文件等。 publicPath 就用来指定第二种间接资源的请求位置。如果指定了一个错误的值，则在加载这些资源时会收到 404 错误。</p>
<p>publicPath 有以下三种形式</p>
<ol>
<li><p>相对于 HTML</p>
</li>
<li><p>相对于 HOST</p>
</li>
<li><p>相对于 CDN</p>
</li>
</ol>
<h3 id="相对于-HTML"><a href="#相对于-HTML" class="headerlink" title="相对于 HTML"></a>相对于 HTML</h3><p>在请求资源时，会以当前 html 页面所在路径加上 publicPath 的相对路径来构成实际请求的 URL，如</p>
<div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 假设当前 html 页面地址为 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/webpack/i</span>ndex.html
<span class="hljs-regexp">//</span> 需要请求文件名为 demo.png
module.exports = &#123;
  ...
  output: &#123;
    publicPath: <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/webpack/</span>demo.png
    publicPath: <span class="hljs-string">&#x27;./css&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/webpack/</span>css/demo.png
    publicPath: <span class="hljs-string">&#x27;../assets/&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/assets/</span>demo.png
  &#125;
&#125;;</code></pre></div>



<h3 id="相对于-HOST"><a href="#相对于-HOST" class="headerlink" title="相对于 HOST"></a>相对于 HOST</h3><p>若 publicPath 的值以 “&#x2F;” 开始，则代表此时 publicPath 是以当前页面的域名加上 publicPath 的相对路径来构成实际请求的 URL，如</p>
<div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 假设当前 html 页面地址为 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/webpack/i</span>ndex.html
<span class="hljs-regexp">//</span> 需要请求文件名为 demo.png
module.exports = &#123;
  ...
  output: &#123;
    publicPath: <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 http:<span class="hljs-regexp">//</span>demo.com/demo.png
    publicPath: <span class="hljs-string">&#x27;/css&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/css/</span>demo.png
    publicPath: <span class="hljs-string">&#x27;../assets/&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/assets/</span>demo.png
  &#125;
&#125;;</code></pre></div>



<h3 id="相对于-CDN"><a href="#相对于-CDN" class="headerlink" title="相对于 CDN"></a>相对于 CDN</h3><p>上面两种配置都是相对路径，我们也可以使用绝对路径的形式配置 publicPath，这种情况一般发生在将静态资源放在 CDN 上面，如</p>
<div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 假设当前 html 页面地址为 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/webpack/i</span>ndex.html
<span class="hljs-regexp">//</span> 需要请求文件名为 demo.png
module.exports = &#123;
  ...
  output: &#123;
    publicPath: <span class="hljs-string">&#x27;http://cdn.example.com/assets/&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 http:<span class="hljs-regexp">//</span>cdn.example.com<span class="hljs-regexp">/assets/</span>demo.png
    publicPath: <span class="hljs-string">&#x27;https://cdn.example.com/assets/&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 https:<span class="hljs-regexp">//</span>cdn.example.com<span class="hljs-regexp">/assets/</span>demo.png
    publicPath: <span class="hljs-string">&#x27;//cdn.example.com/assets/&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 <span class="hljs-regexp">//</span>cdn.example.com<span class="hljs-regexp">/assets/</span>demo.png
  &#125;
&#125;;</code></pre></div>

<p>webpack-dev-server 也会默认从 publicPath 为基准，使用它来决定在哪个目录下启用服务，来访问 webpack 输出的文件。</p>
<h2 id="library"><a href="#library" class="headerlink" title="library"></a>library</h2><p>library 的作用是将打包的内容生成一个库，可以供其他工程加载使用。这一点在目前流行的微前端架构实战上面很有用，如子应用通过输出类库的形式将内容输出到一个对象上，这样主应用就可以通过加载 js 的方式去引入子应用，并且可以通过子应用输出的对象名称来加载子应用的内容。library 具体的使用方法，我们来看下面的例子：</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
  output: &#123;
    library: <span class="hljs-string">&#x27;DemoLibrary&#x27;</span>
  &#125;
&#125;;</code></pre></div>

<p>src&#x2F;index.js 的入口中导出了如下函数</p>
<div class="code-wrapper"><pre><code class="hljs arcade">export <span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">webpack</span>) &#123;
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`hello <span class="hljs-subst">$&#123;webpack&#125;</span>`</span>);
&#125;</code></pre></div>

<p>此时，变量 DemoLibrary 将与入口文件所导出的文件进行绑定，下面是如何使用打包生成的index.js文件：<br>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>测试DemoLibrary库<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./dist/index.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-title class_">DemoLibrary</span>.<span class="hljs-title function_">hello</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);</span>
<span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>在浏览器中可以看到成功输出 hello webpack。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455351-EBIJbq-9.png" srcset="/img/loading.gif" lazyload alt="9.png"></p>
<p>library 的类型可以为字符串、数组、和对象，字符串的参数类型则直接指代库的名称，与对象中设置 name 属性作用相同。如果 entry 入口设置为 object，所有入口都可以通过 library 的 array 语法暴露：</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
  <span class="hljs-regexp">//</span> …
  entry: &#123;
    a: <span class="hljs-string">&#x27;./src/a.js&#x27;</span>,
    b: <span class="hljs-string">&#x27;./src/b.js&#x27;</span>,
  &#125;,
  output: &#123;
    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,
    library: [<span class="hljs-string">&#x27;DemoLibrary&#x27;</span>, <span class="hljs-string">&#x27;[name]&#x27;</span>], <span class="hljs-regexp">//</span> [name] 为 chunk name
  &#125;,
&#125;;</code></pre></div>

<p>假设 a.js 与 b.js 导出名为 hello 的函数，下面就是如何使用这些库的方法：</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>测试DemoLibrary库<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./dist/a.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./dist/b.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">    <span class="hljs-title class_">DemoLibrary</span>.<span class="hljs-property">a</span>.<span class="hljs-title function_">hello</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);</span>
<span class="language-javascript">    <span class="hljs-title class_">DemoLibrary</span>.<span class="hljs-property">b</span>.<span class="hljs-title function_">hello</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);</span>
<span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>请注意，如果你打算在每个入口点配置 library 配置项的话，以上配置将不能按照预期执行。这里是如何 在每个入口点下 做的方法：</p>
<div class="code-wrapper"><pre><code class="hljs dart">module.exports = &#123;
  <span class="hljs-comment">// …</span>
  entry: &#123;
    main: &#123;
      <span class="hljs-keyword">import</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
      <span class="hljs-keyword">library</span>: &#123;
        <span class="hljs-comment">// `output.library` 下的所有配置项可以在这里使用</span>
        name: <span class="hljs-string">&#x27;MyLibrary&#x27;</span>,
        type: <span class="hljs-string">&#x27;umd&#x27;</span>,
        umdNamedDefine: <span class="hljs-keyword">true</span>,
      &#125;,
    &#125;,
    another: &#123;
      <span class="hljs-keyword">import</span>: <span class="hljs-string">&#x27;./src/another.js&#x27;</span>,
      <span class="hljs-keyword">library</span>: &#123;
        name: <span class="hljs-string">&#x27;AnotherLibrary&#x27;</span>,
        type: <span class="hljs-string">&#x27;commonjs2&#x27;</span>,
      &#125;,
    &#125;,
  &#125;,
&#125;;</code></pre></div>

<p>library 包含以下可配置参数</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>功能描述</th>
<th>支持类型</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>指定库的名称</td>
<td>字符串、数组、对象</td>
</tr>
<tr>
<td>type</td>
<td>配置将库暴露的方式</td>
<td>字符串</td>
</tr>
<tr>
<td>export</td>
<td>指定哪一个导出应该被暴露为一个库</td>
<td>字符串、数组</td>
</tr>
<tr>
<td>auxiliaryComment</td>
<td>在 UMD 包装器中添加注释</td>
<td>字符串、对象</td>
</tr>
<tr>
<td>umdNamedDefine</td>
<td>将 AMD 模块命名为 UMD 构建</td>
<td>布尔</td>
</tr>
</tbody></table>
<p>这里我们说下 type 类型，在实际的使用中，我们可能根据工程运行环境的需要，而需要将类库暴露为不同的类型，如 支持 esModule、amd、cmd、umd 等，type 配置就可以帮我们完成不同输出方式。</p>
<p>type 类型默认包括 ‘var’、’module’、’assign’、’assign-properties’、’this’、’window’、’self’、’global’、’commonjs’、’commonjs2’、’commonjs-module’、’commonjs-static’、’amd’、’amd-require’、’umd’、’umd2’、’jsonp’ 以及 ‘system’，除此之外也可以通过插件添加。官方文档对每种类型给了详细说明和事例，具体我们可查看官方文档，<a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/configuration/output/#outputlibrarytype">output.target.type 配置</a></p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>以上为我们在实际开发中使用的 output 配置，包含 path、filename、publicPath、library，日常使用中可能还会用到 libraryTarget ，不过 webpack 未来会放弃对 output.libraryTarget 的支持，所以可以使用 output.library.type 替代 output.libraryTarget。</p>
<h2 id="输出配置实例"><a href="#输出配置实例" class="headerlink" title="输出配置实例"></a>输出配置实例</h2><h1 id="output-输出配置实例"><a href="#output-输出配置实例" class="headerlink" title="output 输出配置实例"></a>output 输出配置实例</h1><p>到目前为止，我们都是在 index.html 文件中手动引入打包生成的资源，然而随着应用程序增长，并且一旦开始在文件名中使用 hash 并输出 多个 bundle，如果继续手动管理 index.html 文件，就会变得困难起来。然而，通过一些插件可以使这个过程更容易管控。HtmlWebpackPlugin 可以帮我们解决这个问题。</p>
<h2 id="设置-HtmlWebpackPlugin"><a href="#设置-HtmlWebpackPlugin" class="headerlink" title="设置 HtmlWebpackPlugin"></a>设置 HtmlWebpackPlugin</h2><p>继续使用之前的工程文件，目录结构为：</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455531-GLJkvW-1.png" srcset="/img/loading.gif" lazyload alt="1.png"></p>
<p>首先安装插件，并且调整 webpack.config.js 文件：<br>安装 html-webpack-plugin 插件</p>
<div class="code-wrapper"><pre><code class="hljs css">npm install <span class="hljs-attr">--save-dev</span> <span class="hljs-selector-tag">html</span>-webpack-plugin</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,
  <span class="hljs-attr">entry</span>: &#123;
    <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
    <span class="hljs-attr">hello</span>: <span class="hljs-string">&#x27;./src/hello.js&#x27;</span>
  &#125;,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>
  &#125;,
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;
      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;管理输出&#x27;</span>,
    &#125;),
  ],
&#125;;</code></pre></div>

<p>执行构建命令 npm run build，我们看下打包后的结果，我们可以看到，打包文件包含两个入口文件对应的 js 文件，还包含一个 index.html 文件</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455531-mkBBWv-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<p>在 dist 目录下我们看下打包的 index.html 文件，我们可以看到 HtmlWebpackPlugin 创建了一个全新的 index.html 文件，所有的 bundle 会自动添加到 html 中。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455531-YxKehy-3.png" srcset="/img/loading.gif" lazyload alt="3.png"></p>
<h2 id="清理-x2F-dist-文件夹"><a href="#清理-x2F-dist-文件夹" class="headerlink" title="清理 &#x2F;dist 文件夹"></a>清理 &#x2F;dist 文件夹</h2><p>你可能已经注意到，由于遗留了之前指南中的代码示例，我们的 &#x2F;dist 文件夹显得相当杂乱。webpack 将生成文件并放置在 &#x2F;dist 文件夹中，但是它不会追踪哪些文件是实际在项目中用到的。</p>
<p>通常比较推荐的做法是，在每次构建前清理 &#x2F;dist 文件夹，这样 &#x2F;dist 文件夹中只有最近一次生成的文件。让我们使用 output.clean（ webpack 5.20.0 及以上版本支持）配置项实现这个需求。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  output: &#123;
    clean: <span class="hljs-literal">true</span>
  &#125;
&#125;;</code></pre></div>

<p>现在，执行 npm run build，检查 &#x2F;dist 文件夹。如果一切顺利，现在只会看到构建后生成的文件，而没有旧文件！</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>本章我们介绍了一个优化开发效率的插件和一个配置项，使用 HtmlWebpackPlugin 插件可以动态的生成 index.html 文件，以及动态的向 index.html 文件插入 bundle。了解了如何在编译时清空 dist 文件内容。</p>
<h1 id="核心概念-Loader"><a href="#核心概念-Loader" class="headerlink" title="核心概念-Loader"></a>核心概念-Loader</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h1 id="loader-概述"><a href="#loader-概述" class="headerlink" title="loader 概述"></a>loader 概述</h1><p>到目前为止，我们的案例都是都是介绍的如何打包 js 文件，对于工程中的其他类型资源，如 CSS、图片、字体等， webpack 会如何处理呢？在实际的项目开发中，我们经常会用到 Sass 或者 Less 来编写样式，我们使用 Typescript 增加静态类型检查，我们使用浏览器不支持的 ECMAScript 新特性，如何让 webpack 来对所有的编译进行统一管理呢？</p>
<p>本章我们会介绍 loader（预处理器），它赋予了 webpack 可以处理不同资源的能力，极大丰富了其可扩展性。</p>
<h2 id="loader-作用"><a href="#loader-作用" class="headerlink" title="loader 作用"></a>loader 作用</h2><p>在 webpack 中，一切皆模块，我们可以使用 import、require 等方式 在JavaScript 模块中导入 JS、CSS、图片、字体等多种类型的静态资源，loader 用于对模块的源代码进行转换。loader 可以使我们在导入模块时预处理文件。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript。loader 甚至允许我们直接在 JavaScript 模块中 import CSS 文件！</p>
<p>loader 本质上是 node module 导出的一个函数，当资源需要被转换时，调用这个函数。下面我们通过自定义 loader，来看 loader 的使用方法。</p>
<p>src&#x2F;index.js</p>
<div class="code-wrapper"><pre><code class="hljs arcade">const demoName = <span class="hljs-string">&#x27;webpack loader&#x27;</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(demoName)</code></pre></div>

<p>webpack 默认支持解析 js 文件，我们增加解析 js 的 loader 只为展示 loader 是如何工作的</p>
<p>src&#x2F;js-loader.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(source)
  <span class="hljs-keyword">return</span> <span class="hljs-string">`module.exports=<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(source)&#125;</span>`</span>
&#125;</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,
  <span class="hljs-attr">entry</span>: &#123;
    <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>
  &#125;,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>,
    <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>
  &#125;,
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;
      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;loader&#x27;</span>,
    &#125;),
  ],
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-attr">use</span>: <span class="hljs-string">&quot;./src/js-loader.js&quot;</span>
      &#125;
    ]
  &#125;
&#125;;</code></pre></div>

<p>执行构建命令，在控制台可以看到 js-loader 文件的 console.log 输出了 index.js 文件内容，从上面的 简易版 js-loader.js 文件中可以看出，loader 本身就是一个函数，在该函数中对接收的内容进行转换，然后返回转换后的结果。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456019-nGbqaR-1.png" srcset="/img/loading.gif" lazyload alt="1.png"></p>
<h2 id="loader-使用方式配置"><a href="#loader-使用方式配置" class="headerlink" title="loader 使用方式配置"></a>loader 使用方式配置</h2><p>在我们的应用中，有两种使用 loader 的方式，分别是 配置方式（推荐），内联方式。</p>
<h3 id="配置方式（推荐）"><a href="#配置方式（推荐）" class="headerlink" title="配置方式（推荐）"></a>配置方式（推荐）</h3><p>module.rules 允许我们在 webpack 配置中指定多个 loader。 这种方式是展示 loader 的一种简明方式，并且有助于使代码变得简洁和易于维护。同时让我们对各个 loader 有个全局概览：</p>
<p>loader 从右到左（或从下到上）地取值(evaluate)&#x2F;执行(execute)。在下面的示例中，从 css-loader 开始执行，最后以 style-loader 为结束。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  <span class="hljs-keyword">module</span>: &#123;
    rules: [
      &#123;
        test: /\.css$/,
        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>,<span class="hljs-string">&#x27;css-loader&#x27;</span>]
      &#125;
    ]
  &#125;
&#125;;</code></pre></div>

<p>src&#x2F;index.js</p>
<div class="code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;</code></pre></div>

<p>src&#x2F;index.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;
    <span class="hljs-attribute">color</span>: red;
    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
    <span class="hljs-attribute">text-align</span>: center;
&#125;</code></pre></div>

<p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml">...
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>import css<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./dist/index.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div>

<p>webpack 无法处理 CSS 语法，此时我们执行打包命令 控制台会报 “请使用合适的loader来处理这个文件类型”</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456019-nygaex-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<p>下面我们将 css-loader，style-loader 加到工程中，loader 都是一些第三方 npm 模块，webpack 本身不包含任何 loader, 所以使用前我们需要先安装这些 loader，在工程中执行以下命令安装。</p>
<div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> css-loader style-loader</code></pre></div>

<p>安装成功后，在控制台执行打包命令，我们可以看到错误已经消失了，在浏览器打开index.html 文件我们可以看到，样式正常展示。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456019-xKzhzK-3.png" srcset="/img/loading.gif" lazyload alt="3.png"></p>
<h3 id="内联方式"><a href="#内联方式" class="headerlink" title="内联方式"></a>内联方式</h3><p>loader 除了使用配置的方式，还有一种内联的用法，可以在 import 语句或任何 与 “import” 方法同等的引用方式 中指定 loader。使用 ! 将资源中的 loader 分开。每个部分都会相对于当前目录解析。</p>
<p>在上面的例子中，我们注释掉 webpack.config.js 中 module.rules 的配置，将引入方式改为内联方式。</p>
<p>src&#x2F;index.js</p>
<div class="code-wrapper"><pre><code class="hljs llvm">import &#x27;<span class="hljs-title">!style-loader</span><span class="hljs-title">!css-loader</span><span class="hljs-title">!.</span>/index.css&#x27;<span class="hljs-comment">;</span></code></pre></div>

<p>执行打包命令后，我们在浏览器中打开 index.html 文件，可以看到样式正常显示。我们在工程中尽可能使用 module.rules，因为这样可以减少源码中的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。</p>
<h2 id="loader-特性"><a href="#loader-特性" class="headerlink" title="loader 特性"></a>loader 特性</h2><ul>
<li>loader 支持链式调用。链中的每个 loader 会将转换应用在已处理过的资源上。一组链式的 loader 将按照相反的顺序执行。链中的第一个 loader 将其结果（也就是应用过转换后的资源）传递给下一个 loader，依此类推。最后，链中的最后一个 loader，返回 webpack 所期望的 JavaScript。</li>
<li>loader 可以是同步的，也可以是异步的。</li>
<li>loader 运行在 Node.js 中，并且能够执行任何操作。</li>
<li>loader 可以通过 options 对象配置（仍然支持使用 query 参数来设置选项，但是这种方式已被废弃）。</li>
<li>除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块。</li>
<li>插件(plugin)可以为 loader 带来更多特性。</li>
<li>loader 能够产生额外的任意文件。</li>
</ul>
<h3 id="HTML-Loader"><a href="#HTML-Loader" class="headerlink" title="HTML-Loader"></a>HTML-Loader</h3><h1 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a>html-loader</h1><p>html-loader 用于将 html 文件转换为字符串，支持压缩、导出、对内容预处理。下面让我们来看一个例子。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>html-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./src/assets/card-mark.png&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">const</span> <span class="hljs-variable">HtmlWebpackPlugin</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;
      <span class="hljs-comment">// 使用 index.html 内容作为输出模版 </span>
      template: <span class="hljs-string">&quot;./index.html&quot;</span>, 
    &#125;),
  ],</code></pre></div>

<p>在index.html 中我们使用 img 标签展示一张图片，图片为相对路径，在 src&#x2F;assets 文件夹下增加名为 card-mark.png 的图片，在浏览器直接打开 index.html 我们可以看到，图片可以正常展示。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456744-FeKOzS-1.png" srcset="/img/loading.gif" lazyload alt="1.png"></p>
<p>此时我们在控制台执行打包命令 npm run build，在 dist 文件夹中 输出了 index.html 文件，我们直接在浏览器打开 index.html 文件，此时图片无法打开。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456744-qKyiJP-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<p>图片打不开的原因为 src 地址使用了相对路径，dist 文件夹与 src 文件夹同目录，所以 src&#x3D;”.&#x2F;src&#x2F;assets&#x2F;card-mark.png” 这个地址无法找到图片，导致图片无法展示。此时我们就可以借助 html-loader 来帮我们解决这个问题。</p>
<p>安装 html-loader</p>
<div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> html-loader -D</code></pre></div>

<p>安装成功后，将 html-loader 配置到 webpack.config.js 中</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
  ...
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;
      <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;./index.html&quot;</span>,
    &#125;),
  ],
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.html$/</span>,
        <span class="hljs-attr">use</span>: &#123;
          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;html-loader&#x27;</span>,
        &#125;
      &#125;
    ]
  &#125;
&#125;;</code></pre></div>

<p>此时在执行打包命令，可以看到在 dist 文件夹下除了index.html 文件和 index.js 文件，又多了一个 扩展名为 .png 的文件，我们打开 dist 文件夹下的 index.html 发现 src 的引用地址已修改，此时在浏览器中直接打开 dist 文件夹下的 index.html 发现图片可以正常显示。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456744-siwEwv-3.png" srcset="/img/loading.gif" lazyload alt="3.png"></p>
<h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><p>html-loader 包含下面四个配置项</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>支持类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>sources</td>
<td>{Boolean、Object}</td>
<td>true</td>
<td>启用&#x2F;禁用 sources 处理</td>
</tr>
<tr>
<td>preprocessor</td>
<td>{Function}</td>
<td>undefined</td>
<td>允许在处理前对内容进行预处理</td>
</tr>
<tr>
<td>minimize</td>
<td>{Boolean、Object}</td>
<td>在生产模式下为 true，其他情况为 false</td>
<td>通知 html-loader 压缩 HTML</td>
</tr>
<tr>
<td>esModule</td>
<td>{Boolean}</td>
<td>true</td>
<td>启用&#x2F;禁用 ES modules 语法</td>
</tr>
</tbody></table>
<h3 id="sources"><a href="#sources" class="headerlink" title="sources"></a>sources</h3><h4 id="sources-默认值为-true"><a href="#sources-默认值为-true" class="headerlink" title="sources 默认值为 true"></a>sources 默认值为 true</h4><p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">    rules:</span> [
      <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        test:</span> /\.html$/,
<span class="hljs-symbol">        loader:</span> <span class="hljs-string">&quot;html-loader&quot;</span>,
<span class="hljs-symbol">        options:</span> <span class="hljs-punctuation">&#123;</span>
          <span class="hljs-comment">// 设置为 false 则不会对可加载属性做任何处理</span>
<span class="hljs-symbol">          sources:</span> false,
        <span class="hljs-punctuation">&#125;</span>,
      <span class="hljs-punctuation">&#125;</span>,
    ],
  <span class="hljs-punctuation">&#125;</span>,
<span class="hljs-punctuation">&#125;;</span></code></pre></div>

<p>默认情况下，每个可加载属性（例如 img 图片导入）都将被导入（ const img &#x3D; require (‘.&#x2F;image.png’) 或 import img from “.&#x2F;image.png” ）。 你可能需要为配置中的图片指定 loader（我们前面的例子，如果配置 html-loader 的参数 esModule: false，则需要使用 loader 对图片进行处理，否则打包报错）。</p>
<p>html-loader 支持处理的 可加载属性 包括：</p>
<ul>
<li><p>audio 标签的 src 属性</p>
</li>
<li><p>img 标签的 src 属性</p>
</li>
<li><p>img 标签的 srcset 属性</p>
</li>
<li><p><a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/loaders/html-loader/#sources">剩余标签和属性可查看文档</a></p>
</li>
</ul>
<h4 id="source-设置为-Object"><a href="#source-设置为-Object" class="headerlink" title="source 设置为 Object"></a>source 设置为 Object</h4><p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">    rules:</span> [
      <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        test:</span> /\.html$/,
<span class="hljs-symbol">        loader:</span> <span class="hljs-string">&quot;html-loader&quot;</span>,
<span class="hljs-symbol">       options:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">            sources:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">              list:</span> [
                <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">                  tag:</span> <span class="hljs-string">&quot;img&quot;</span>,
<span class="hljs-symbol">                  attribute:</span> <span class="hljs-string">&quot;data-src&quot;</span>,
<span class="hljs-symbol">                  type:</span> <span class="hljs-string">&quot;src&quot;</span>,
                <span class="hljs-punctuation">&#125;</span>
              ]
            <span class="hljs-punctuation">&#125;</span>,
          <span class="hljs-punctuation">&#125;</span>,
      <span class="hljs-punctuation">&#125;</span>,
    ],
  <span class="hljs-punctuation">&#125;</span>,
<span class="hljs-punctuation">&#125;;</span></code></pre></div>

<p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;./src/assets/card-mark.png&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./src/assets/card-mark.png&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div>

<p>执行打包命令，看下 dist 文件夹下的 index.html 文件，发现 html-loader 只对 img 标签的 data-src 属性做了转换。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456744-dAdrmF-4.png" srcset="/img/loading.gif" lazyload alt="4.png"></p>
<p>sources 对象中 支持 list 和 urlFilter 属性，<a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/loaders/html-loader/#sources">详情可查看文档</a></p>
<h3 id="preprocessor"><a href="#preprocessor" class="headerlink" title="preprocessor"></a>preprocessor</h3><p>允许在处理之前对内容进行预处理。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Handlebars</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;handlebars&quot;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.html$/</span>,
        <span class="hljs-attr">use</span>: &#123;
          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;html-loader&#x27;</span>,
          <span class="hljs-attr">options</span>: &#123;
            <span class="hljs-attr">preprocessor</span>: <span class="hljs-function">(<span class="hljs-params">content, loaderContext</span>) =&gt;</span> &#123;
              <span class="hljs-keyword">let</span> result;
  
              <span class="hljs-keyword">try</span> &#123;
                result = <span class="hljs-title class_">Handlebars</span>.<span class="hljs-title function_">compile</span>(content)(&#123;
                  <span class="hljs-attr">firstname</span>: <span class="hljs-string">&quot;Value&quot;</span>,
                  <span class="hljs-attr">lastname</span>: <span class="hljs-string">&quot;OtherValue&quot;</span>,
                &#125;);
              &#125; <span class="hljs-keyword">catch</span> (error) &#123;
                loaderContext.<span class="hljs-title function_">emitError</span>(error);
  
                <span class="hljs-keyword">return</span> content;
              &#125;
              <span class="hljs-keyword">return</span> result;
            &#125;
          &#125;
        &#125;
       &#125;,
      &#125;,
    ],
  &#125;,
&#125;;</code></pre></div>

<p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span>
<span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>html-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span>
<span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">firstname</span>&#125;&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">lastname</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  </span>
<span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./src/assets/card-mark.png&quot;</span> /&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div>

<p>在 webpack.config.js 中我们使用了 handlebars ，需要先安装 handlebars。</p>
<p><a href="https://leetcode.cn/link/?target=https://handlebarsjs.com/">Handlebars</a> 是一种简单的模板语言。<br>它使用模板和输入对象来生成 HTML 或其他文本格式。Handlebars 模板看起来像带有嵌入式 Handlebars 表达式的常规文本。</p>
<div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">firstname</span>&#125;&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">lastname</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> </span></code></pre></div>

<p>执行打包命令后，查看 dist 文件夹下的 index.html 文件，可以看到 p 标签内容已被替换。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456744-wtxzhT-5.png" srcset="/img/loading.gif" lazyload alt="5.png"></p>
<h3 id="minimize"><a href="#minimize" class="headerlink" title="minimize"></a>minimize</h3><p>告诉 html-loader 编译时需要压缩 HTML 字符串。<br>默认情况下，启用压缩的规则如下：</p>
<div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">(&#123;</span>
  <span class="hljs-attr">caseSensitive:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
  <span class="hljs-attr">collapseWhitespace:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
  <span class="hljs-attr">conservativeCollapse:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
  <span class="hljs-attr">keepClosingSlash:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
  <span class="hljs-attr">minifyCSS:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
  <span class="hljs-attr">minifyJS:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
  <span class="hljs-attr">removeComments:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
  <span class="hljs-attr">removeRedundantAttributes:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
  <span class="hljs-attr">removeScriptTypeAttributes:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
  <span class="hljs-attr">removeStyleLinkTypeAttributes:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>
<span class="hljs-string">&#125;);</span></code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">    rules:</span> [
      <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        test:</span> /\.html$/i,
<span class="hljs-symbol">        loader:</span> <span class="hljs-string">&quot;html-loader&quot;</span>,
<span class="hljs-symbol">        options:</span> <span class="hljs-punctuation">&#123;</span>
          <span class="hljs-comment">// boolean</span>
<span class="hljs-symbol">          minimize:</span> true,
          <span class="hljs-comment">// 对象</span>
<span class="hljs-symbol">          minimize:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">            removeComments:</span> false,
<span class="hljs-symbol">            collapseWhitespace:</span> false,
          <span class="hljs-punctuation">&#125;</span>,
        <span class="hljs-punctuation">&#125;</span>,
      <span class="hljs-punctuation">&#125;</span>,
    ],
  <span class="hljs-punctuation">&#125;</span>,
<span class="hljs-punctuation">&#125;;</span></code></pre></div>



<h3 id="esModule"><a href="#esModule" class="headerlink" title="esModule"></a>esModule</h3><p>默认情况下， html-loader 生成使用 ES modules 语法的 JS 模块。 在某些情况下，使用 ES modules 会更好，例如在进行模块合并和 tree shaking 时。</p>
<p>你可以使用以下方法启用 CommonJS 模块语法：<br>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">    rules:</span> [
      <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        test:</span> /\.html$/i,
<span class="hljs-symbol">        loader:</span> <span class="hljs-string">&quot;html-loader&quot;</span>,
<span class="hljs-symbol">        options:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">          esModule:</span> false,
        <span class="hljs-punctuation">&#125;</span>,
      <span class="hljs-punctuation">&#125;</span>,
    ],
  <span class="hljs-punctuation">&#125;</span>,
<span class="hljs-punctuation">&#125;;</span></code></pre></div>



<h1 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 html-loader 的使用方法和 html-loader 包含的 4 个参数 sources、preprocessor、minimize、esModule, 它们分别对应 html-loader 在项目实践中的 4 个重要功能：</p>
<ol>
<li>将 HTML 中标签的可加载属性引入的文件作为模块导入</li>
<li>预处理 HTML，常用来支持模板引擎</li>
<li>压缩 HTML</li>
<li>默认导出 ES modules 便于模块合并和 tree shaking</li>
</ol>
<h3 id="URL-Loader"><a href="#URL-Loader" class="headerlink" title="URL-Loader"></a>URL-Loader</h3><h1 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h1><p>当我们在文件中加载图片、字体等资源时，webpack 无法直接处理以上资源，在 webpack 5 之前需要使用相应 loader 来处理资源文件，url-loader 可以将一个文件转换为 base64 编码来代替访问地址，这样做的好处是可以减少一次网络请求，下面我们来看看如何使用 url-loader 及 url-loader 有哪些常用配置。</p>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>url-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>index.js</p>
<p>index.js 文件中引入一张图片，创建image标签后，将导入的图片赋值给 image 标签的 src 属性，将 image 标签添加到页面中</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Back</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./img/back.png&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">component</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>); 
  element.<span class="hljs-property">src</span>=<span class="hljs-title class_">Back</span>
  <span class="hljs-keyword">return</span> element;
&#125;

<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">component</span>());</code></pre></div>

<p>安装 url-loader</p>
<div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> url-loader -D</code></pre></div>

<p>安装成功后，将 url-loader 配置到 webpack.config.js 中</p>
<div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">module.exports = &#123;</span>
<span class="hljs-attribute">  ...</span>
<span class="hljs-attribute">   module</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span>
    <span class="hljs-attribute">rules</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>
      <span class="hljs-attribute">&#123;</span>
<span class="hljs-attribute">        test</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/\.(png|jpg)$/,</span>
        <span class="hljs-attribute">use</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>
          <span class="hljs-attribute">&#123;</span>
<span class="hljs-attribute">            loader</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;url-loader&#x27;</span>
          &#125;
        ]
      &#125;
    ]
  &#125;
&#125;;</code></pre></div>

<p>此时在执行打包命令，此时在浏览器中直接打开 dist 文件夹下的 index.html 发现页面中展示一张图片。</p>
<h2 id="配置项-1"><a href="#配置项-1" class="headerlink" title="配置项"></a>配置项</h2><p>url-loader 包含下面 3 个配置项</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>支持类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>limit</td>
<td>Boolean、Number、String</td>
<td>true</td>
<td>需要转换为 base64 的资源大小限制</td>
</tr>
<tr>
<td>mimetype</td>
<td>Boolean、String</td>
<td>基于mime-types 查找</td>
<td>为文件指定MIME类型</td>
</tr>
<tr>
<td>fallback</td>
<td>String</td>
<td>file-loader</td>
<td>文件大小等于或者超过 limit 限制后使用的资源处理 loader</td>
</tr>
</tbody></table>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">module.exports</span> <span class="hljs-string">=</span> &#123;
  <span class="hljs-attr">module:</span> &#123;
    <span class="hljs-attr">rules:</span> [
      &#123;
        <span class="hljs-attr">test:</span> <span class="hljs-string">/\.(png|jpg)$/</span>,
        <span class="hljs-attr">use:</span> [
          &#123;
            <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;url-loader&#x27;</span>,
            <span class="hljs-attr">options:</span> &#123;
              <span class="hljs-attr">limit:</span> <span class="hljs-number">2048</span> <span class="hljs-string">//</span> <span class="hljs-string">2Kb</span>
            &#125;
          &#125;
        ]
      &#125;
    ]
  &#125;
&#125;<span class="hljs-string">;</span></code></pre></div>

<p>一般情况下，当资源文件大小小于 2Kb 时，我们需要将资源路径转换为 base64 的格式将资源打包到 bundle 中，这样可以减少一次网络请求，当一个页面中引入多个资源文件时可以明显减少请求次数，但这种方式带来了另外一个问题，如果资源文件体积较大，就会导致 bundle 的体积增大，体积大的情况下网络请求时间变长，会导致页面白屏时间变长，非常影响用户体验。所以在处理资源文件时，一般会加上 limit 配置，文件资源体积超过配置的大小后，更改资源文件的处理方式，默认使用 file-loader 来处理。</p>
<p>上面的配置在执行打包命令时会报 “Cannot find module ‘file-loader’” 的错误，所以在使用 limit 配置时，我们先下载安装 file-loader。</p>
<p>安装 file-loader</p>
<div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> <span class="hljs-keyword">file</span>-loader -D</code></pre></div>

<p>再次执行打包命令，在 dist 文件夹下输出了一个扩展名为 .png 的图片，让我们来对比下增加 limit 配置前和增加 limit 配置后 dist 文件夹和 index.js 文件的变化。</p>
<p>增加 limit 配置前</p>
<p>dist 文件夹</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655702983-rBTYab-3.png" srcset="/img/loading.gif" lazyload alt="3.png"></p>
<p>index.js</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655702983-VEfXJw-4.png" srcset="/img/loading.gif" lazyload alt="4.png"></p>
<p>增加 limit 配置后</p>
<p>dist 文件夹</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655702983-btTkSZ-5.png" srcset="/img/loading.gif" lazyload alt="5.png"><br>index.js</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655702983-ypgcON-6.png" srcset="/img/loading.gif" lazyload alt="6.png"></p>
<h3 id="mimetype"><a href="#mimetype" class="headerlink" title="mimetype"></a>mimetype</h3><p>设置文件的转换类型。如果未指定，将使用文件扩展名来查找MIME 类型。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs css">rules: [
     &#123;
       test: /\.(png|jpg)$/,
       use: [
         &#123;
           loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,
           options: &#123;
             mimetype: <span class="hljs-string">&#x27;image/jpg&#x27;</span>
           &#125;
         &#125;
       ]
     &#125;
   ]</code></pre></div>



<h3 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h3><p>指定当目标文件的大小等于或超过限制选项中设置的限制时，使用的替代加载 loader，默认为 file-loader。</p>
<div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">module:</span> &#123;
    <span class="hljs-attr">rules:</span> [
      &#123;
        <span class="hljs-attr">test:</span> <span class="hljs-string">/\.(png|jpg)$/</span>,
        <span class="hljs-attr">use:</span> [
          &#123;
            <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;url-loader&#x27;</span>,
            <span class="hljs-attr">options:</span> &#123;
              <span class="hljs-attr">limit:</span> <span class="hljs-number">2048</span>,
              <span class="hljs-attr">fallback:</span> <span class="hljs-string">&#x27;responsive-loader&#x27;</span>
            &#125;
          &#125;
        ]
      &#125;
    ]
  &#125;</code></pre></div>



<h1 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 url-loader 的使用方法和 url-loader 包含的 3 个参数 limit、minitype、fallback, url-loader 设置了 limit 参数后，超过设置的限制大小后，默认使用 file-loader 加载资源文件，所以 file-loader 的可配置参数在 url-loader 中也可配置生效，剩余可配置参数在 file-loader 中继续总结。</p>
<h3 id="File-Loader"><a href="#File-Loader" class="headerlink" title="File-Loader"></a>File-Loader</h3><h1 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h1><p>在 webpack 5 之前处理图片、字体等资源，除了使用 url-loader 之外还经常使用 file-loader，file-loader 的处理方式和 url-loader 有些不同，url-loader 通过 limit 参数判断如果没有超过配置大小，则将文件转做 base64 编码，直接嵌入到 CSS&#x2F;JS&#x2F;HTML 代码中。而 file-loader 并不会对文件内容进行任何转换，只是复制一份文件内容，并根据配置为他生成一个唯一的文件名, 下面让我们梳理下 file-loader 如何使用及有哪些可配置参数。我们继续使用 url-loader 的例子, 只是对个别配置做些修改。</p>
<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>file-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>index.js</p>
<p>index.js 文件中引入一张图片，创建 image 标签后，将导入的图片赋值给 image 标签的 src 属性，将 image 标签添加到页面中。</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Back</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./img/back.png&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">component</span>(<span class="hljs-params"></span>) &#123;
  <span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>); 
  element.<span class="hljs-property">src</span>=<span class="hljs-title class_">Back</span>
  <span class="hljs-keyword">return</span> element;
&#125;

<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">component</span>());</code></pre></div>

<p>安装 file-loader</p>
<div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> <span class="hljs-keyword">file</span>-loader -D</code></pre></div>

<p>安装成功后，将 file-loader 配置到 webpack.config.js 中</p>
<div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">module.exports = &#123;</span>
<span class="hljs-attribute">  ...</span>
<span class="hljs-attribute">   module</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span>
    <span class="hljs-attribute">rules</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>
      <span class="hljs-attribute">&#123;</span>
<span class="hljs-attribute">        test</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/\.(png|jpg)$/,</span>
        <span class="hljs-attribute">use</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>
          <span class="hljs-attribute">&#123;</span>
<span class="hljs-attribute">            loader</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;file-loader&#x27;</span>
          &#125;
        ]
      &#125;
    ]
  &#125;
&#125;;</code></pre></div>

<p>执行打包命令，此时在浏览器中直接打开 dist 文件夹下的 index.html 发现页面中展示一张图片，此时我们在 dist 目录下可以看到一张扩展名为 .png 的图片，直接点击图片打开，可以看到与我们引入的图片一致。</p>
<h2 id="配置项-2"><a href="#配置项-2" class="headerlink" title="配置项"></a>配置项</h2><p>file-loader 包含下面几个配置项</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>支持类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>String、Function</td>
<td>[contenthash].[ext]</td>
<td>为文件配置自定义文件名模板</td>
</tr>
<tr>
<td>context</td>
<td>String</td>
<td>this.options.context</td>
<td>配置自定义文件 context，默认为 webpack.config.js 的 context</td>
</tr>
<tr>
<td>publicPath</td>
<td>String、Function</td>
<td>output.publicPath + outputPath</td>
<td>为文件配置自定义 public 发布目录</td>
</tr>
<tr>
<td>outputPath</td>
<td>String、Function</td>
<td>undefined</td>
<td>为文件配置自定义 output 输出目录</td>
</tr>
<tr>
<td>useRelativePath</td>
<td>Boolean</td>
<td>false</td>
<td>当设置为 true, 为每个文件生成一个相对 url 的 context</td>
</tr>
<tr>
<td>emitFile</td>
<td>Boolean</td>
<td>true</td>
<td>设置为 false, 禁止复制文件</td>
</tr>
</tbody></table>
<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>可以使用查询参数名称为您的文件配置一个自定义的文件名模板。默认情况下，不配置 name 属性生成的文件的文件名就是文件内容的 MD5 哈希值与原始扩展名。name 属性支持传入字符串或函数配置。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">module.exports = &#123;</span>
<span class="hljs-attribute">  module</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span>
    <span class="hljs-attribute">rules</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>
      <span class="hljs-attribute">&#123;</span>
<span class="hljs-attribute">        test</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/\.(png|jpg)$/,</span>
        <span class="hljs-attribute">use</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>
          <span class="hljs-attribute">&#123;</span>
<span class="hljs-attribute">            loader</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;file-loader&#x27;,</span>
            <span class="hljs-attribute">options</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span>
              <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[name].[ext]</span>
            &#125;
          &#125;
        ]
      &#125;
    ]
  &#125;
&#125;;</code></pre></div>

<p>name 参数可以传入以下常用占位符</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>[ext]</td>
<td>String</td>
<td>file.extname</td>
<td>资源扩展名</td>
</tr>
<tr>
<td>[name]</td>
<td>String</td>
<td>file.basename</td>
<td>资源的名称</td>
</tr>
<tr>
<td>[path]</td>
<td>String</td>
<td>file.dirname</td>
<td>资源相对于 context 的路径</td>
</tr>
<tr>
<td>[hash]</td>
<td>String</td>
<td>md5</td>
<td>内容的哈希值, [hashes]]<a href="https://leetcode.cn/link/?target=https://www.webpackjs.com/loaders/file-loader/#hashes">https://www.webpackjs.com/loaders/file-loader/#hashes</a> 配置中有更多信息</td>
</tr>
</tbody></table>
<p>常见的打包命名方式是：assets&#x2F;[name]-[hash].[ext]，即将所有 file-loader 处理的图片按照 name 传入的文件名称 + hash 值.扩展名的方式打包到 assets 目录下。其中</p>
<ol>
<li><p>[ext] 表示是原文件的扩展名，如 back.png 就是指 png</p>
</li>
<li><p>[name] 表示原文件的文件名。如 back.png 就是指 back，但一般生产环境不推荐直接使用 [name]，一般和 [hash] 一起使用，这样可以防止命名冲突。</p>
</li>
<li><p>[path] 相对于 context 的路径，context 默认是 webpack.config.js 的路径</p>
</li>
<li><p>[hash:6]可以控制 hash 值的长度，6 表示长度为 6，默认是 32</p>
</li>
</ol>
<h3 id="context-1"><a href="#context-1" class="headerlink" title="context"></a>context</h3><p>修改打包文件生成路径，其实影响的 是 path 占位符，context 需要和 path 占位符同时配置才会影响文件生成路径。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs css">&#123;
  loader: <span class="hljs-string">&#x27;file-loader&#x27;</span>,
  options: &#123;
    name: <span class="hljs-string">&#x27;[path][name].[ext]&#x27;</span>,
    context: __dirname + <span class="hljs-string">&#x27;/../&#x27;</span>
  &#125;
&#125;</code></pre></div>

<p>打包后，当前项目根文件夹和图片所在路径形成了打包文件的新路径，如果不设置 context 则打包路径相对于 webpack.config.js 的 context 的路径。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655703446-hNPQck-1.png" srcset="/img/loading.gif" lazyload alt="1.png"></p>
<h3 id="publicPath-1"><a href="#publicPath-1" class="headerlink" title="publicPath"></a>publicPath</h3><p>publicPath 一般会用 webpack 本身配置的，和那个效果也一样，但假如你想单独配置，就用这个。设置 publicPath 后，文件的请求地址会被打包进 js 文件。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs css">&#123;
  loader: <span class="hljs-string">&#x27;file-loader&#x27;</span>,
  options: &#123;
    name: <span class="hljs-string">&#x27;[name].[ext]&#x27;</span>,
    outputPath: <span class="hljs-string">&#x27;https://www.abc.cn/img/&#x27;</span>
  &#125;
&#125;</code></pre></div>

<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655703446-bgMKWl-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<h3 id="outputPath"><a href="#outputPath" class="headerlink" title="outputPath"></a>outputPath</h3><p>outputPath 在文件前增加路径，也就是增加文件夹。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs css">&#123;
  loader: <span class="hljs-string">&#x27;file-loader&#x27;</span>,
  options: &#123;
    name: <span class="hljs-string">&#x27;[name].[ext]&#x27;</span>,
    outputPath: <span class="hljs-string">&#x27;images/&#x27;</span>
  &#125;
&#125;</code></pre></div>



<h1 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 file-loader 的使用方法和 file-loader 包含的几个常用参数配置。file-loader 的可配置选项在 url-loader 中配置也可生效（limit 生效的情况下），在 webpack5 以前对于资源文件的处理一般使用这两种插件，webpack5 提供了一种模块<a href="https://leetcode.cn/link/?target=https://webpack.js.org/guides/asset-modules/">Asset Modules</a>，它允许人们在不配置额外加载器的情况下使用资源文件（字体、图标等）</p>
<h3 id="CSS-Loader"><a href="#CSS-Loader" class="headerlink" title="CSS-Loader"></a>CSS-Loader</h3><h1 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h1><p>css-loader 会对 import 和 url() 进行处理，就像 js 解析 import&#x2F;require() 一样。</p>
<h2 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h2><p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>css-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>index.js</p>
<p>src&#x2F;index.js 文件中使用 import 导入 index.css 并输出导入的样式内容。</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> indexCss <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(indexCss.<span class="hljs-title function_">toString</span>())</code></pre></div>

<p>index.css</p>
<p>src&#x2F;index.css 文件中使用 import 导入 index.css。</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;
  <span class="hljs-attribute">background-color</span>: aqua;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;
&#125;</code></pre></div>

<p>安装 css-loader</p>
<div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> css-loader -D</code></pre></div>

<p>安装成功后，将 css-loader 配置到 webpack.config.js 中</p>
<div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">module.exports = &#123;</span>
<span class="hljs-attribute">  ...</span>
<span class="hljs-attribute">   module</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span>
    <span class="hljs-attribute">rules</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>
      <span class="hljs-attribute">&#123;</span>
<span class="hljs-attribute">        test</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/\.(css)$/,</span>
        <span class="hljs-attribute">use</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>
          <span class="hljs-attribute">&#123;</span>
<span class="hljs-attribute">            loader</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;css-loader&#x27;</span>
          &#125;
        ]
      &#125;
    ]
  &#125;
&#125;;</code></pre></div>

<p>执行打包命令，此时在浏览器中打开 dist&#x2F;index.html 发现页面没有正确展示我们定义的样式，但是控制台中输出了我们定义的样式，到了这一步，css-loader 我们就正确引入并使用了，没有正确展示效果的原因是 css-loader 对 index.js 中的 import 进行处理，默认生成一个数组存放处理后的样式字符串，并将其导出。而 style-loader 负责将 css 插入到 html 中，style-loader 的使用我们在下一节展示。</p>
<h2 id="配置项-3"><a href="#配置项-3" class="headerlink" title="配置项"></a>配置项</h2><p>css-loader 包含下面几个配置项</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>支持类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>Boolean</td>
<td>true</td>
<td>启用&#x2F;禁用 url() 处理</td>
</tr>
<tr>
<td>import</td>
<td>Boolean</td>
<td>true</td>
<td>启用&#x2F;禁用 @import 处理</td>
</tr>
<tr>
<td>modules</td>
<td>Boolean</td>
<td>false</td>
<td>启用&#x2F;禁用 CSS 模块</td>
</tr>
<tr>
<td>sourceMap</td>
<td>Boolean</td>
<td>取决于 compiler.devtool 值</td>
<td>启用&#x2F;禁用 Sourcemap</td>
</tr>
<tr>
<td>esModule</td>
<td>Boolean&#x2F;String</td>
<td>true</td>
<td>是否使用 ES 模块语法</td>
</tr>
<tr>
<td>importLoaders</td>
<td>Number</td>
<td>0</td>
<td>在 css-loader 前应用的 loader 的数量</td>
</tr>
<tr>
<td>exportType</td>
<td>“array”&#x2F;“string”&#x2F;“css-style-sheet”</td>
<td>[]</td>
<td>允许导出样式为模块数组、字符串或者可构造样式（即 CSSStyleSheet）</td>
</tr>
</tbody></table>
<h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><p>允许启用&#x2F;禁用处理 CSS 函数 url 和 image-set。如果设置为false, css-loader 将不会解析 url 或 image-set 中指定的任何路径。还可以通过传递函数来根据资源路径动态地控制这种行为。从版本4.0.0开始，绝对路径是基于服务器根目录进行解析的。</p>
<p>src&#x2F;index.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;
    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">./img/1.png</span>);
&#125;</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">module.exports</span> <span class="hljs-string">=</span> &#123;
  <span class="hljs-string">...</span>
   &#123;
      <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;css-loader&#x27;</span>,
      <span class="hljs-attr">options:</span> &#123;
          <span class="hljs-attr">url:</span> <span class="hljs-literal">false</span>,
          <span class="hljs-string">//</span> <span class="hljs-attr">url:</span> <span class="hljs-literal">true</span>
      &#125;
    &#125;
&#125;<span class="hljs-string">;</span></code></pre></div>

<p>在控制台我们在 index.js 中输出了 index.css 导出的字符串，我们来看下 url 设置为 false 和 true 的 background 区别。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655709629-GTgEyK-1.png" srcset="/img/loading.gif" lazyload alt="1.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655709629-RPGYMd-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<p>当 url 设置为 false 时， url 中的图片地址没做任何处理，当 url 值为 true 时，编译后地址为图片的路径，并且 dist 文件夹下会生成一张图片。</p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>允许启用&#x2F;禁用 @import 处理。</p>
<p>src&#x2F;index.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&#x27;./main.css&#x27;</span>);

<span class="hljs-selector-tag">body</span> &#123;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;
&#125;</code></pre></div>

<p>src&#x2F;main.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
&#125;</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
...
  &#123;
    loader: <span class="hljs-string">&#x27;css-loader&#x27;</span>,
    options: &#123;
        <span class="hljs-keyword">import</span>: <span class="hljs-literal">false</span>
        <span class="hljs-comment">// import: true</span>
    &#125;
  &#125;
&#125;;</code></pre></div>

<p>为了方便看到样式，我这安装了 style-loader 并添加到了 loader 中，我们来看下 import 设置为 false 和 true 的区别。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655709644-gvVFJh-3.png" srcset="/img/loading.gif" lazyload alt="3.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655709644-EOifyM-4.png" srcset="/img/loading.gif" lazyload alt="4.png"></p>
<p>当设置为 false 时 index.css 中的 @import 没有解析导致运行代码时找不到 main.css。</p>
<h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>查询参数 modules 会启用 CSS 模块规范。</p>
<p>默认情况下，这将启用局部作用域 CSS。（你可以使用 :global(…) 或 :global 关闭选择器 and&#x2F;or 规则。详情可查看 <a href="https://leetcode.cn/link/?target=https://www.webpackjs.com/loaders/css-loader/#modules">modules</a></p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs yaml">&#123;
  <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;css-loader&#x27;</span>,
  <span class="hljs-attr">options:</span> &#123;
      <span class="hljs-attr">modules:</span> <span class="hljs-literal">true</span>
  &#125;
&#125;</code></pre></div>



<h3 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h3><p>设置 sourceMap 选项查询参数来引入 source map。</p>
<p>例如 extract-text-webpack-plugin 能够处理它们。</p>
<p>默认情况下取决于compiler.devtool 值，值为 false 和 eval 时，不会生成 source map，一般情况下不启用它，因为它们会导致运行时的额外开销，并增加了 bundle 大小 (JS source map 不会)。此外，相对路径是错误的，你需要使用包含服务器 URL 的绝对公用路径。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs yaml">&#123;
  <span class="hljs-string">...</span>
  <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;css-loader&#x27;</span>,
  <span class="hljs-attr">options:</span> &#123;
      <span class="hljs-attr">sourceMap:</span> <span class="hljs-literal">true</span>
  &#125;
&#125;</code></pre></div>



<h3 id="esModule-1"><a href="#esModule-1" class="headerlink" title="esModule"></a>esModule</h3><p>css-loader 中有时生成 esModule 模块化的形式是有益的，比如 module-concatenation 和 tree-shaking 时必须使用 esModule 模式才会生效。如果想启用 CommonJS 模块语法，则 esModule 设置为 false。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs yaml">&#123;
  <span class="hljs-string">...</span>
  <span class="hljs-attr">options:</span> &#123;
    <span class="hljs-attr">esModule:</span> <span class="hljs-literal">true</span>
  &#125;
&#125;</code></pre></div>



<h3 id="importLoaders"><a href="#importLoaders" class="headerlink" title="importLoaders"></a>importLoaders</h3><p>在 src&#x2F;index.css 中使用的 @import ‘.&#x2F;main.css’，importLoaders 选项可以定义在 @import 时使用哪些插件编译。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span>
  ...
<span class="hljs-symbol">  use:</span> [
    <span class="hljs-string">&quot;style-loader&quot;</span>,
    <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;css-loader&quot;</span>,
<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span>
        <span class="hljs-comment">// 0 =&gt; no loaders (default);</span>
        <span class="hljs-comment">// 1 =&gt; postcss-loader;</span>
        <span class="hljs-comment">// 2 =&gt; postcss-loader, sass-loader</span>
<span class="hljs-symbol">        importLoaders:</span> <span class="hljs-number">2</span>,
      <span class="hljs-punctuation">&#125;</span>,
    <span class="hljs-punctuation">&#125;</span>,
    <span class="hljs-string">&quot;postcss-loader&quot;</span>,
    <span class="hljs-string">&quot;sass-loader&quot;</span>,
  ],
<span class="hljs-punctuation">&#125;</span></code></pre></div>



<h3 id="exportType"><a href="#exportType" class="headerlink" title="exportType"></a>exportType</h3><p>允许将样式导出为带有模块的数组、字符串或可构造样式表(如CSSStyleSheet)。默认值是 ‘array’。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs css">&#123;
  ...
  use: [
    &#123;
      loader: <span class="hljs-string">&#x27;css-loader&#x27;</span>,
      options: &#123;
          exportType: <span class="hljs-string">&#x27;string&#x27;</span>
      &#125;
    &#125;
    ]
  &#125;
&#125;</code></pre></div>

<p>src&#x2F;index.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> indexCss <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(indexCss)</code></pre></div>

<p>打包后，执行 dist&#x2F;index.html 可以看到控制台输出了 index.css 中定义的样式字符串。</p>
<h1 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 css-loader 的使用方法和 css-loader 包含的几个常用参数配置。css-loader 可以将 js 中的 import 导入样式文件进行编译并且拿到导出内容供其他插件使用。</p>
<h3 id="Style-Loader"><a href="#Style-Loader" class="headerlink" title="Style-Loader"></a>Style-Loader</h3><h1 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h1><p>style-loader 一般和 css-loader 配合使用，css-loader 识别模块，通过特定的语法规则进行内容转换最后导出，style-loader 将 css-loader 导出的内容插入到 DOM。</p>
<h2 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h2><p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>style-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>index.js</p>
<p>src&#x2F;index.js 文件中使用 import 导入 index.css。</p>
<div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> indexCss <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;</code></pre></div>

<p>index.css</p>
<p>设置一个长宽均为 200 像素的带红色边框的正方形</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
&#125;</code></pre></div>

<p>安装 style-loader</p>
<div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> style-loader -D</code></pre></div>

<p>安装成功后，将 style-loader 配置到 webpack.config.js 中，配置中我们使用 css-loader 和 style-loader 两个加载器，webpack 中 loader 的解析一般由右向左，由下向上解析，所以 webpack 会先执行 css-loader，css-loader 导出内容传给 style-loader，最后在执行 style-loader。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
   <span class="hljs-keyword">module</span>: &#123;
    rules: [
      &#123;
        test: /\.css$/,
        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>,<span class="hljs-string">&#x27;css-loader&#x27;</span>]
      &#125;
    ]
  &#125;
&#125;;</code></pre></div>

<p>执行打包命令，此时在浏览器中打开 dist&#x2F;index.html 发现页面可以正常展示我们设置的样式，我们在控制台可以看到样式被插入到 head 标签中。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655715388-rMhlfZ-1.png" srcset="/img/loading.gif" lazyload alt="1.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655710417-NiFgBX-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<h2 id="配置项-4"><a href="#配置项-4" class="headerlink" title="配置项"></a>配置项</h2><p>style-loader 包含下面几个配置项</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>支持类型</th>
<th>默认值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>injectType</td>
<td>String</td>
<td>styleTag</td>
<td>如何将样式注入到 DOM 中</td>
</tr>
<tr>
<td>attributes</td>
<td>Object</td>
<td>{}</td>
<td>向标签添加自定义属性</td>
</tr>
<tr>
<td>insert</td>
<td>String、Function</td>
<td>head</td>
<td>在 DOM 中给定的位置插入标签</td>
</tr>
<tr>
<td>styleTagTransform</td>
<td>String、Function</td>
<td>undefined</td>
<td>当插入 style 标签到 DOM 时转换标签和 css</td>
</tr>
<tr>
<td>esModule</td>
<td>Boolean</td>
<td>true</td>
<td>使用 ES 模块语法</td>
</tr>
<tr>
<td>base</td>
<td>Number</td>
<td>true</td>
<td>设置模块ID基数(DLLPlugin)</td>
</tr>
</tbody></table>
<h3 id="injectType"><a href="#injectType" class="headerlink" title="injectType"></a>injectType</h3><p>设置样式如何注入 DOM，默认为 styleTag，即使用多个<style></style> 模式。</p>
<table>
<thead>
<tr>
<th>模式配置</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>styleTag</td>
<td>多个 <style></style> 模式</td>
</tr>
<tr>
<td>singletonStyleTag</td>
<td>单个 <style></style> 模式</td>
</tr>
<tr>
<td>autoStyleTag</td>
<td>与 styleTag 相同，但如果在 IE6-9 中执行，则打开 singletonStyleTag 模式。</td>
</tr>
<tr>
<td>lazyStyleTag</td>
<td>按需加载模式插入多个 <style></style> 模式</td>
</tr>
<tr>
<td>lazySingletonStyleTag</td>
<td>按需加载模式插入单个 <style></style> 模式</td>
</tr>
<tr>
<td>lazyAutoStyleTag</td>
<td>与 lazyStyleTag 相同，但如果在 IE6-9 中执行，则打开 lazySingletonStyleTag 模式。</td>
</tr>
<tr>
<td>linkTag</td>
<td>多个 <link rel="stylesheet" href="path/to/file.css"> 形式插入 DOM</td>
</tr>
</tbody></table>
<h4 id="styleTag"><a href="#styleTag" class="headerlink" title="styleTag"></a>styleTag</h4><p>src&#x2F;index.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&#x27;style.css&#x27;</span>);
<span class="hljs-selector-class">.bar</span> &#123;
    <span class="hljs-attribute">color</span>: blue;
&#125;</code></pre></div>

<p>src&#x2F;style.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.foo</span> &#123;
    <span class="hljs-attribute">color</span>: red;
&#125;</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs gradle">module.exports = &#123;
  ...
  &#123;
    test: <span class="hljs-regexp">/\.(css)$/</span>,
    use: [
      &#123;
        loader: <span class="hljs-string">&#x27;style-loader&#x27;</span>,
        <span class="hljs-keyword">options</span>: &#123; injectType: <span class="hljs-string">&quot;styleTag&quot;</span> &#125;
      &#125;, <span class="hljs-string">&#x27;css-loader&#x27;</span>
    ]
  &#125;
&#125;;</code></pre></div>

<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> index <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;

<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);
divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;foo&quot;</span>;
divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;style-loader&#x27;</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement)</code></pre></div>

<p>执行打包命令，在浏览器中打开 dist&#x2F;index.html 文件，我们可以看到 head 中插入了两个 style 标签，div 中的文字颜色可以正常显示。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655704064-BOjtxr-3.png" srcset="/img/loading.gif" lazyload alt="3.png"></p>
<h4 id="singletonStyleTag"><a href="#singletonStyleTag" class="headerlink" title="singletonStyleTag"></a>singletonStyleTag</h4><p>将多个样式文件内容在一个 style 标签中插入 DOM。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs gradle">module.exports = &#123;
  ...
  &#123;
    test: <span class="hljs-regexp">/\.(css)$/</span>,
    use: [
      &#123;
        loader: <span class="hljs-string">&#x27;style-loader&#x27;</span>,
        <span class="hljs-keyword">options</span>: &#123; injectType: <span class="hljs-string">&quot;singletonStyleTag&quot;</span> &#125;
      &#125;, <span class="hljs-string">&#x27;css-loader&#x27;</span>
    ]
  &#125;
&#125;;</code></pre></div>

<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655704064-QFOJaJ-4.png" srcset="/img/loading.gif" lazyload alt="4.png"></p>
<h4 id="lazyStyleTag"><a href="#lazyStyleTag" class="headerlink" title="lazyStyleTag"></a>lazyStyleTag</h4><style></style> 按需注入到 DOM 。建议遵循 .lazy.css 惰性样式的命名约定和 .css 基本style-loader用法。当使用 lazyStyleTag 时，可以通过 style-loader 的 style.use()、style.unuse() 按需使用。

<p>src&#x2F;style.lazy.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.foo</span> &#123;
    <span class="hljs-attribute">color</span>: red;
&#125;</code></pre></div>

<p>src&#x2F;index.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./style.lazy.css&quot;</span>;
styles.<span class="hljs-title function_">use</span>();
<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);
divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;foo&quot;</span>;
divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;style-loader&#x27;</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement)</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs gradle">module.exports = &#123;
...
 &#123;
    test: <span class="hljs-regexp">/\.(css)$/</span>,
    use: [
      &#123;
        loader: <span class="hljs-string">&#x27;style-loader&#x27;</span>,
        <span class="hljs-keyword">options</span>: &#123; injectType: <span class="hljs-string">&quot;lazyStyleTag&quot;</span> &#125;
      &#125;, <span class="hljs-string">&#x27;css-loader&#x27;</span>
    ]
  &#125;
&#125;;</code></pre></div>

<p>打包后，可以看到样式被插入到 DOM，并且颜色已生效，如果 index.js 中没有调用 styles.use()，则样式不会被插入到 DOM。</p>
<h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><p>将指定的属性值附加到 <style> 或 <link> 标签</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs css">&#123;
  loader: <span class="hljs-string">&#x27;style-loader&#x27;</span>,
  options: &#123; attributes: &#123;id: <span class="hljs-string">&#x27;styleLoader&#x27;</span>&#125; &#125;
&#125;</code></pre></div>

<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655704064-PSQoUz-5.png" srcset="/img/loading.gif" lazyload alt="5.png"></p>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>默认情况下 style-loader 会将<style>、<link> 标签插入到 <head> 标签尾部，设置 insert 后，可以将样式标签插入到其他位置。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs css">&#123;
  loader: <span class="hljs-string">&#x27;style-loader&#x27;</span>,
  options: &#123; insert: <span class="hljs-string">&#x27;body&#x27;</span> &#125;
&#125;</code></pre></div>

<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655704064-YppEjv-6.png" srcset="/img/loading.gif" lazyload alt="6.png"></p>
<h3 id="styleTagTransform"><a href="#styleTagTransform" class="headerlink" title="styleTagTransform"></a>styleTagTransform</h3><p>当插入 style 标签到 DOM 时转换标签和 css，可以设置自定义方法解析 style 标签插入方式。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript">&#123;
  ...
    <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;style-loader&#x27;</span>,
    <span class="hljs-attr">options</span>: &#123; <span class="hljs-attr">styleTagTransform</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">css, style</span>) &#123;
      style.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;css&#125;</span>.modify&#123;&#125;\n`</span>
      <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(style)
    &#125; 
&#125;</code></pre></div>

<p>打包后，在浏览器中打开 dist&#x2F;index.html，我们可以看到 css 样式后面添加了我们在方法中书写的内容。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655704064-uATShJ-7.png" srcset="/img/loading.gif" lazyload alt="7.png"></p>
<h3 id="esModule-2"><a href="#esModule-2" class="headerlink" title="esModule"></a>esModule</h3><p>style-loader 中生成 esModule 模块化的形式是有益的，比如 tree-shacking 时必须使用 esModule 模式才会生效。如果想启用 CommonJS 模块语法，则 esModule 设置为 false。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs yaml">&#123;
  <span class="hljs-string">...</span>
  <span class="hljs-attr">options:</span> &#123;
    <span class="hljs-attr">esModule:</span> <span class="hljs-literal">true</span>
  &#125;
&#125;</code></pre></div>



<h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><p>当使用一个或多个 DllPlugin 时，此设置主要用作 css 冲突的解决方法。允许您通过指定大于 DllPlugin1 使用的范围的 css 模块 ID 基数来防止 app 的 css（或DllPlugin2 的 css）覆盖 DllPlugin1 的 css</p>
<p>webpack.dll1.config.js</p>
<div class="code-wrapper"><pre><code class="hljs prolog">&#123;
  ...
  use: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],
&#125;</code></pre></div>

<p>webpack.dll2.config.js</p>
<div class="code-wrapper"><pre><code class="hljs yaml">&#123;
  <span class="hljs-string">...</span>
  <span class="hljs-attr">use:</span> [
    &#123; <span class="hljs-attr">loader:</span> <span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-attr">options:</span> &#123; <span class="hljs-attr">base:</span> <span class="hljs-number">1000</span> &#125; &#125;,
    <span class="hljs-string">&quot;css-loader&quot;</span>,
  ],
&#125;</code></pre></div>

<p>webpack.app.config.js</p>
<div class="code-wrapper"><pre><code class="hljs yaml">&#123;
  <span class="hljs-string">...</span>
  <span class="hljs-attr">use:</span> [
    &#123; <span class="hljs-attr">loader:</span> <span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-attr">options:</span> &#123; <span class="hljs-attr">base:</span> <span class="hljs-number">2000</span> &#125; &#125;,
    <span class="hljs-string">&quot;css-loader&quot;</span>,
  ],
&#125;</code></pre></div>



<h1 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 style-loader 的使用方法和 style-loader 包含的几个常用参数配置。style-loader 一般和 css-loader 配合使用。</p>
<h3 id="Postcss-Loader"><a href="#Postcss-Loader" class="headerlink" title="Postcss-Loader"></a>Postcss-Loader</h3><h1 id="postcss-loader"><a href="#postcss-loader" class="headerlink" title="postcss-loader"></a>postcss-loader</h1><p>在使用 postcss-loader 之前，我们先来了解下 <a href="https://leetcode.cn/link/?target=https://postcss.org/">PostCSS</a>。以下摘自 PostCSS 简介。</p>
<div class="code-wrapper"><pre><code class="hljs gams">PostCSS 是一个允许使用 JS 插件转换样式的工具。 这些插件可以检查（lint）你的 CSS，支持 CSS <span class="hljs-keyword">Variables</span> 和 Mixins， 编译尚未被浏览器广泛支持的先进的 CSS 语法，内联图片，以及其它很多优秀的功能。<span class="hljs-comment">PostCSS</span> 的 <span class="hljs-comment">Autoprefixer</span> 插件是最流行的 <span class="hljs-comment">CSS</span> 处理工具之一。</code></pre></div>

<p>由此我们可以知道通过使用 PostCSS 和 相应的插件，我们可以完成样式格式化、自动根据浏览器的支持情况增加样式前缀、使用先进的 CSS 特性等很多优秀的功能，截止到目前，PostCSS 有 200 多个插件。你可以在 <a href="https://leetcode.cn/link/?target=https://github.com/postcss/postcss/blob/main/docs/plugins.md">插件列表</a> 找到他们。如果我们想在 webpack 中使用 PostCSS 及 相应插件完成我们想要的功能，这时就需要通过 postcss-loader 来处理。</p>
<h2 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h2><p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>postcss-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>index.js</p>
<p>src&#x2F;index.js 文件中使用 import 导入 index.css 并输出导入的样式内容。</p>
<div class="code-wrapper"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> indexCss <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;</code></pre></div>

<p>index.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;
 <span class="hljs-attribute">display</span>: flex;
&#125;</code></pre></div>

<p>安装 postcss-loader 和 postcss</p>
<div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> postcss-loader postcss -D</code></pre></div>

<p>安装成功后，将 postcss-loader 配置到 webpack.config.js 中，postcss-loader 通过加载插件转换 css 内容，转换后的内容虽然是 .css 文件，但是仍需传递给 css-loader 做后续处理。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
   <span class="hljs-keyword">module</span>: &#123;
    rules: [
      &#123;
        test: /\.(css)$/,
        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;postcss-loader&#x27;</span>]
      &#125;
    ]
  &#125;
&#125;;</code></pre></div>

<p>以上只是将 postcss-loader 配置到了 webpack 中，执行打包命令可以正常打包，但 css 内容不会发生变化，postcss-loader 需要通过插件来达到我们想要的效果，下面我们以自动添加前缀为例看下效果。</p>
<p>安装 autoprefixer</p>
<div class="code-wrapper"><pre><code class="hljs angelscript">npm install <span class="hljs-built_in">auto</span>prefixer -D</code></pre></div>

<p>postcss.config.js</p>
<p>项目根目录下新建 postcss.config.js 文件，配置 autoprefixer 插件，和要对应的浏览器版本。其中 browsers 的配置可以配置到 package.json 或者 .browserslistrc 文件下，如果配置到 postcss.config.js 中打包时会有警告，不过我们为了演示 autoprefixer 效果，不对此做处理。</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript">module.<span class="hljs-built_in">exports</span> = &#123;
    plugins: [
      <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;autoprefixer&#x27;</span>)(&#123;
        <span class="hljs-string">&#x27;browsers&#x27;</span>: [<span class="hljs-string">&#x27;&gt; 1%&#x27;</span>, <span class="hljs-string">&#x27;last 2 versions&#x27;</span>]
      &#125;)
    ]
&#125;;</code></pre></div>

<p>配置完成后，执行打包命令，打包成功后在浏览器中打开 dist&#x2F;index.html 文件，在控制台中我们可以看到，样式代码已经自动增加前缀。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655704774-Lklqfv-1.png" srcset="/img/loading.gif" lazyload alt="1.png"></p>
<h2 id="配置项-5"><a href="#配置项-5" class="headerlink" title="配置项"></a>配置项</h2><p>postcss-loader 包含下面几个配置项</p>
<ul>
<li>execute</li>
<li>postcssOptions</li>
<li>sourceMap</li>
<li>implementation</li>
</ul>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><p>默认：undefined</p>
<p>值类型：Boolean</p>
<p>作用：在 CSS-in-JS 中，如果您想要处理在 JavaScript 中书写的样式，需要使用 postcss-js 解析器，添加 execute 选项并设置为 true。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
  ...
   <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;postcss-loader&quot;</span>,
<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        postcssOptions:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">          parser:</span> <span class="hljs-string">&quot;postcss-js&quot;</span>,
        <span class="hljs-punctuation">&#125;</span>,
<span class="hljs-symbol">        execute:</span> true,
      <span class="hljs-punctuation">&#125;</span>,
    <span class="hljs-punctuation">&#125;</span>
<span class="hljs-punctuation">&#125;;</span></code></pre></div>



<h3 id="postcssOptions"><a href="#postcssOptions" class="headerlink" title="postcssOptions"></a>postcssOptions</h3><p>默认：undefined</p>
<p>值类型：Object | Function</p>
<p>作用：允许设置 PostCSS options 和插件。支持所有PostCSS选项。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
  ...
   <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;postcss-loader&quot;</span>,
<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span>
        <span class="hljs-comment">// object</span>
<span class="hljs-symbol">        postcssOptions:</span> <span class="hljs-punctuation">&#123;</span>
          ...
        <span class="hljs-punctuation">&#125;</span>
        <span class="hljs-comment">// function</span>
<span class="hljs-symbol">        postcssOptions:</span> (loaderContext) =&gt; <span class="hljs-punctuation">&#123;</span>
          <span class="hljs-title class_">return</span> <span class="hljs-punctuation">&#123;</span>
            ...
          <span class="hljs-punctuation">&#125;</span>
        <span class="hljs-punctuation">&#125;</span>
      <span class="hljs-punctuation">&#125;</span>,
    <span class="hljs-punctuation">&#125;</span>
<span class="hljs-punctuation">&#125;;</span></code></pre></div>



<h3 id="sourceMap-1"><a href="#sourceMap-1" class="headerlink" title="sourceMap"></a>sourceMap</h3><p>默认：取决于 <a href="https://leetcode.cn/link/?target=https://webpack.js.org/configuration/devtool/">devtool</a> 选项</p>
<p>值类型：Boolean</p>
<p>作用：是否开启 sourceMap</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
  ...
   <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;postcss-loader&quot;</span>,
<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        sourceMap:</span> true
      <span class="hljs-punctuation">&#125;</span>,
    <span class="hljs-punctuation">&#125;</span>
<span class="hljs-punctuation">&#125;;</span></code></pre></div>



<h3 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h3><p>默认：postcss</p>
<p>值类型：Function | String</p>
<p>作用：implementation 选项决定使用哪个 PostCSS 实现。覆盖本地安装的 postcss 的 peerDependency 版本</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs ada">module.exports = &#123;
  ...
   &#123;
      loader: <span class="hljs-string">&quot;postcss-loader&quot;</span>,
      options : &#123;  <span class="hljs-type">implementation</span> : <span class="hljs-type">require</span> ( <span class="hljs-string">&quot;postcss&quot;</span> )  &#125;
    &#125;
&#125;;</code></pre></div>



<h1 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 postcss-loader 的使用方法，postcss-loader 主要是 PostCSS 在 webpack 环境下的使用方法，通过加载不同的插件来达到处理样式文件的效果，PostCSS 支持的插件非常丰富，本文只是通过自动添加前缀的例子做一个展示，想看其他插件的使用方法可以去 PostCSS 官网查看。</p>
<h3 id="Sass-Loader"><a href="#Sass-Loader" class="headerlink" title="Sass-Loader"></a>Sass-Loader</h3><h1 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h1><h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a><a href="https://leetcode.cn/link/?target=https://www.sasscss.com/documentation">Sass</a></h2><div class="code-wrapper"><pre><code class="hljs gams">sass 是一种 css 的预编译语言。它提供了 变量（<span class="hljs-keyword">variables</span>）、嵌套（nested <span class="hljs-comment">rules</span>）、 混合（<span class="hljs-comment">mixins</span>）、 函数（<span class="hljs-comment">functions</span>）等功能，并且完全兼容 <span class="hljs-comment">css</span>，<span class="hljs-comment">sass</span> 能够帮助复杂的样式表更有条理，并且易于在项目内部或跨项目共享设计。</code></pre></div>

<p>当 css 变得越来越臃肿、 越来越复杂、越来越难以维护时 sass 为我们提供了 css 中不存在的特性辅助我们编写健壮、 可维护的 css 代码。</p>
<p>在使用 sass 之前，需要在项目中安装它，而 sass-loader 的作用是加载 sass&#x2F;scss 文件并将其编译为 css，通过将 style-loader 和 css-loader 与 sass-loader 链式调用，可以立刻将样式作用在 DOM 元素。</p>
<h2 id="使用-6"><a href="#使用-6" class="headerlink" title="使用"></a>使用</h2><p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>sass-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello sass<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>index.js</p>
<p>src&#x2F;index.js 文件中使用 import 导入 index.scss。</p>
<div class="code-wrapper"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> indexCss <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.scss&quot;</span>;</code></pre></div>

<p>index.scss</p>
<p>sass 和 scss 其实是同一种东西，我们平时都称之为 sass，不过两者之间写法也存在些区别，感兴趣的小伙伴儿可自行查阅，我们本案例都以 scss 为例。</p>
<div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-variable">$primary</span>-<span class="hljs-attribute">color</span>: <span class="hljs-number">#f00</span>;

<span class="hljs-selector-tag">body</span> &#123;
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$primary</span>-color;
&#125;</code></pre></div>

<p>安装 sass-loader 和 sass</p>
<div class="code-wrapper"><pre><code class="hljs q">npm install sass-loader sass --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div>

<p>安装成功后，将 sass-loader 配置到 webpack.config.js 中。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
   <span class="hljs-keyword">module</span>: &#123;
    rules: [
      &#123;
        test: /\.scss$/,
        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]
      &#125;
    ]
  &#125;
&#125;;</code></pre></div>

<p>执行打包命令后，在浏览器打开 dist&#x2F;index.html 文件，我们可以看到我们在 index.scss 文件中定义的颜色常量被正确的显示到了标签上面，在控制台可以看到，color 的颜色属性已由定义的变量转换成了定义的颜色值。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655972361-xCPFRy-4.png" srcset="/img/loading.gif" lazyload alt="4.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655972355-lPHDnq-5.png" srcset="/img/loading.gif" lazyload alt="5.png"></p>
<h2 id="配置项-6"><a href="#配置项-6" class="headerlink" title="配置项"></a>配置项</h2><p>sass-loader 可以通过指定 options 参数，向 sass 传递选项参数。</p>
<ul>
<li>implementation</li>
<li>sassOptions</li>
<li>sourceMap</li>
<li>additionalData</li>
<li>webpackImporter</li>
<li>warnRuleAsWarning</li>
</ul>
<h3 id="implementation-1"><a href="#implementation-1" class="headerlink" title="implementation"></a>implementation</h3><p>默认值：sass</p>
<p>值类型：Object | String</p>
<p>作用：sass-loader 要使用的 sass 实现。默认情况下，sass-loader 会根据你的依赖解析需要使用的实现。 只需将必需的实现添加到 package.json（sass 或 node-sass 包）中并安装依赖项即可。</p>
<p>package.json</p>
<div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> sass-loader 将会使用 sass 实现
&#123;
  <span class="hljs-string">&quot;devDependencies&quot;</span>: &#123;
    <span class="hljs-string">&quot;sass-loader&quot;</span>: <span class="hljs-string">&quot;^7.2.0&quot;</span>,
    <span class="hljs-string">&quot;sass&quot;</span>: <span class="hljs-string">&quot;^1.22.10&quot;</span>
  &#125;
&#125;</code></pre></div>

<p>package.json</p>
<div class="code-wrapper"><pre><code class="hljs crmsh">// sass-loader 将会使用 <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span> 实现
&#123;
  <span class="hljs-string">&quot;devDependencies&quot;</span>: &#123;
    <span class="hljs-string">&quot;sass-loader&quot;</span>: <span class="hljs-string">&quot;^7.2.0&quot;</span>,
    <span class="hljs-string">&quot;node-sass&quot;</span>: <span class="hljs-string">&quot;^5.0.0&quot;</span>
  &#125;
&#125;</code></pre></div>

<p>同时安装 node-sass 和 sass 的情况下，sass-loader 默认会选择 sass。 为了避免这种情况，你可以使用 implementation 选项。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">module</span>.exports = &#123;
  ...
   &#123;
      loader: <span class="hljs-string">&quot;sass-loader&quot;</span>,
      options: &#123;
        <span class="hljs-comment">// Object</span>
        <span class="hljs-keyword">implementation</span>: require(<span class="hljs-string">&#x27;sass&#x27;</span>)
        <span class="hljs-comment">// String</span>
        <span class="hljs-keyword">implementation</span>: require.resolve(<span class="hljs-string">&#x27;sass&#x27;</span>)
      &#125;,
    &#125;
&#125;;</code></pre></div>



<h3 id="sassOptions"><a href="#sassOptions" class="headerlink" title="sassOptions"></a>sassOptions</h3><p>默认值：sass 实现的默认值</p>
<p>值类型：Object | Function</p>
<p>作用：设置 sass 实现的启动选项。</p>
<p>在使用他们之前，请查阅有关文档：<a href="https://leetcode.cn/link/?target=https://github.com/sass/dart-sass#javascript-api">Dart Sass</a> 文档提供了所有可用的 sass 选项。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
  ...
  &#123;
    &#123;
      loader: <span class="hljs-string">&quot;sass-loader&quot;</span>,
      options: &#123;
        <span class="hljs-regexp">//</span> Object
        sassOptions: &#123;
          includePaths: [<span class="hljs-string">&#x27;absolute/a&#x27;</span>, <span class="hljs-string">&#x27;absolute/b&#x27;</span>],
        &#125;,
        <span class="hljs-regexp">//</span> Function
        sassOptions: (loaderContext) =&gt; &#123;
          <span class="hljs-regexp">//</span> 有关可用属性的更多信息 https:<span class="hljs-regexp">//</span>webpack.js.org<span class="hljs-regexp">/api/</span>loaders/
          ...
          return &#123;
            includePaths: [<span class="hljs-string">&#x27;absolute/a&#x27;</span>, <span class="hljs-string">&#x27;absolute/b&#x27;</span>],
          &#125;;
        &#125;,
      &#125;,
    &#125;
  &#125;
&#125;;</code></pre></div>



<h3 id="sourceMap-2"><a href="#sourceMap-2" class="headerlink" title="sourceMap"></a>sourceMap</h3><p>默认值：取决于 complier.devtool值，值为 false 和 eval 时，不会生成 source map。</p>
<p>值类型：Boolean</p>
<p>作用：是否开启 sourceMap</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
  ...
   <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;sass-loader&quot;</span>,
<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        sourceMap:</span> true
      <span class="hljs-punctuation">&#125;</span>,
    <span class="hljs-punctuation">&#125;</span>
<span class="hljs-punctuation">&#125;;</span></code></pre></div>



<h3 id="additionalData"><a href="#additionalData" class="headerlink" title="additionalData"></a>additionalData</h3><p>默认值：undefined</p>
<p>值类型： String | Function</p>
<p>作用：在实际的文件之前要添加的 sass &#x2F; scss 代码。下面的示例中，����ℎ、<em>w<strong>i</strong>d<strong>t</strong>h</em>、value 可以在 index.scss 中直接引用。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript">module.<span class="hljs-built_in">exports</span> = &#123;
  ...
  &#123;
    loader: <span class="hljs-string">&quot;sass-loader&quot;</span>,
    options : &#123;  
      <span class="hljs-regexp">//</span> <span class="hljs-built_in">String</span>
      additionalData: <span class="hljs-string">&#x27;$width:&#x27;</span> + process.env.NODE_ENV + <span class="hljs-string">&#x27;;&#x27;</span>,
      <span class="hljs-regexp">//</span> <span class="hljs-built_in">Function</span> sync
      additionalData: <span class="hljs-function"><span class="hljs-params">(content, loaderContext)</span> =&gt;</span> &#123;
        ...
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;$value: 100px;&#x27;</span> + content;
      &#125;
      <span class="hljs-regexp">//</span> <span class="hljs-built_in">Function</span> <span class="hljs-keyword">async</span> 
      additionalData: <span class="hljs-keyword">async</span> (content, loaderContext) =&gt; &#123;
        ...
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;$value: 100px;&#x27;</span> + content;
      &#125;
    &#125;
  &#125;
&#125;;</code></pre></div>



<h3 id="webpackImporter"><a href="#webpackImporter" class="headerlink" title="webpackImporter"></a>webpackImporter</h3><p>默认值：true</p>
<p>值类型： Boolean</p>
<p>作用：开启 &#x2F; 关闭默认的 Webpack importer。在某些情况下，可以提高性能。但是请谨慎使用，因为 aliases 和以 〜 开头的 @import 规则将不起作用。 你可以传递自己的 importer 来解决这个问题（参阅 <a href="https://leetcode.cn/link/?target=https://github.com/sass/node-sass#importer--v200---experimental">importer docs</a>）。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  &#123;
    loader: <span class="hljs-string">&quot;sass-loader&quot;</span>,
    options : &#123;  
      webpackImporter: <span class="hljs-literal">false</span>,
    &#125;
  &#125;
&#125;;</code></pre></div>



<h3 id="warnRuleAsWarning"><a href="#warnRuleAsWarning" class="headerlink" title="warnRuleAsWarning"></a>warnRuleAsWarning</h3><p>默认值：false (在下一个大版本发布中它将默认设置为 true)</p>
<p>值类型： Boolean</p>
<p>作用：将 @warn 规则视为 webpack 警告而不是日志。</p>
<p>index.scss</p>
<div class="code-wrapper"><pre><code class="hljs mel">$known-prefixes: webkit, moz, ms, o;

@mixin prefix($property, $value, $prefixes) &#123;
  @each $prefix <span class="hljs-keyword">in</span> $prefixes &#123;
    @if not index($known-prefixes, $prefix) &#123;
      @warn <span class="hljs-string">&quot;Unknown prefix #&#123;$prefix&#125;.&quot;</span>;
    &#125;

    -#&#123;$prefix&#125;-#&#123;$property&#125;: $value;
  &#125;
  #&#123;$property&#125;: $value;
&#125;

body &#123;
  @include prefix(<span class="hljs-string">&#x27;display&#x27;</span>, <span class="hljs-string">&#x27;flex&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>);
&#125;</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
   &#123;
      loader: <span class="hljs-string">&quot;sass-loader&quot;</span>,
      options : &#123;  
        warnRuleAsWarning: <span class="hljs-literal">true</span>,
      &#125;
    &#125;
&#125;;</code></pre></div>

<p>在上面的例子中，我们 $prefixes 值传入 a，执行打包命令，虽然可以打包成功，但是控制台会输出警告，如果我们将 $prefixes 值传入 $known-prefixes 中定义的 o，则控制台不会显示警告。</p>
<h1 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 sass-loader 的使用方法和一些配置参数。通过使用 sass-loader 和 sass 可以让我们让我们的样式表更有条理并且易于维护。</p>
<h3 id="Svg-URL-Loader"><a href="#Svg-URL-Loader" class="headerlink" title="Svg-URL-Loader"></a>Svg-URL-Loader</h3><h1 id="svg-url-loader"><a href="#svg-url-loader" class="headerlink" title="svg-url-loader"></a>svg-url-loader</h1><p>svg-url-loader 可以将 svg 文件加载为 utf-8 编码的 data-uri 字符串。url-loader 也可以加载 svg 文件，和 svg-url-loader 的区别是 url-loader 将 svg 文件加载为 base64 编码的字符串。</p>
<p>utf-8 编码相对于 base64 编码有一些优势。</p>
<ul>
<li><p>编译结果字符串更短（对于 2K 大小的图标，可以缩短约 2 倍）；</p>
</li>
<li><p>使用 gzip 压缩时，生成的字符串将被更好地压缩；</p>
</li>
<li><p>浏览器解析 utf-8 编码的字符串比 base64 编码的字符串更快；</p>
</li>
</ul>
<h2 id="使用-7"><a href="#使用-7" class="headerlink" title="使用"></a>使用</h2><p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>svg-url-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;svg-loader&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> svgContent from <span class="hljs-string">&#x27;./img/headIcon.svg&#x27;</span>;

<span class="hljs-built_in">window</span>.<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;svg-loader&#x27;</span>).src = svgContent;</code></pre></div>

<p>安装 svg-url-loader</p>
<div class="code-wrapper"><pre><code class="hljs q">npm install svg-url-loader --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div>

<p>安装成功后，将 svg-url-loader 配置到 webpack.config.js 中。</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
  ...
<span class="hljs-symbol">   module:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">    rules:</span> [
      <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        test:</span> /\.svg/,
<span class="hljs-symbol">        use:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">          loader:</span> <span class="hljs-string">&quot;svg-url-loader&quot;</span>,
        <span class="hljs-punctuation">&#125;</span>,
      <span class="hljs-punctuation">&#125;</span>
    ]
  <span class="hljs-punctuation">&#125;</span>
<span class="hljs-punctuation">&#125;;</span></code></pre></div>

<p>执行打包命令后，在浏览器打开 dist&#x2F;index.html 文件，我们可以看到 svg 图片被展示在页面是上，打开 dist&#x2F;main-[hash].js 文件可以看到 svg 图片被编译成了 utf-8 编码的字符串。</p>
<h2 id="配置项-7"><a href="#配置项-7" class="headerlink" title="配置项"></a>配置项</h2><p>svg-url-loader 包含下面参数。</p>
<ul>
<li><p>limit</p>
</li>
<li><p>stripdeclarations</p>
</li>
<li><p>iesafe</p>
</li>
<li><p>encoding</p>
</li>
</ul>
<h3 id="limit-1"><a href="#limit-1" class="headerlink" title="limit"></a>limit</h3><p>默认值：无</p>
<p>值类型：Number</p>
<p>作用：当设置 limit，如果源文件的内容大于这个限制，svg-url-loader 将不编码源文件。如果文件大于 limit 设置的限制，将使用 file-loader 加载文件，svg-url-loader 中设置的参数会传递给 file-loader。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
  ...
  <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">    test:</span> /\.svg/,
<span class="hljs-symbol">    use:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;svg-url-loader&quot;</span>,
<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        limit:</span> <span class="hljs-number">1024</span> <span class="hljs-comment">// 文件大小 1M</span>
      <span class="hljs-punctuation">&#125;</span>
    <span class="hljs-punctuation">&#125;</span>
  <span class="hljs-punctuation">&#125;</span>
<span class="hljs-punctuation">&#125;;</span></code></pre></div>



<h3 id="stripdeclarations"><a href="#stripdeclarations" class="headerlink" title="stripdeclarations"></a>stripdeclarations</h3><p>默认值：true</p>
<p>值类型：Boolean</p>
<p>作用：它将在下一个主要版本中被删除，删除所有 XML 声明。例如：svg 图片开头的 <?xml version="1.0" encoding="UTF-8"?>。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
  ...
  <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">    test:</span> /\.svg/,
<span class="hljs-symbol">    use:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;svg-url-loader&quot;</span>,
<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        stripdeclarations:</span> false
      <span class="hljs-punctuation">&#125;</span>
    <span class="hljs-punctuation">&#125;</span>
  <span class="hljs-punctuation">&#125;</span>
<span class="hljs-punctuation">&#125;;</span></code></pre></div>



<h3 id="iesafe"><a href="#iesafe" class="headerlink" title="iesafe"></a>iesafe</h3><p>默认值：无</p>
<p>值类型：Boolean</p>
<p>作用：当 iesafe 选项设置为 true，svg-url-loader 在编译文件时，如果文件包含一个样式元素并且编码大小超过 4kB，则无论指定的限制如何，都使用 file-loader 编译。因为 ie 浏览器包括 ie11 已经停止解析 svg 数据中的样式元素和大小超过 4kb 的文件，会导致所有样式的形状都是黑色填充。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
  ...
   <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;svg-url-loader&quot;</span>,
<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        iesafe:</span> true
      <span class="hljs-punctuation">&#125;</span>,
    <span class="hljs-punctuation">&#125;</span>
<span class="hljs-punctuation">&#125;;</span></code></pre></div>



<h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>默认值：”none”</p>
<p>值类型：”none” ｜ “base64”</p>
<p>作用：设置 svg-url-loader 构造数据 URI 时要使用的编码。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
  ...
  <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">    loader:</span> <span class="hljs-string">&quot;svg-url-loader&quot;</span>,
<span class="hljs-symbol">    options:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">      encoding:</span> <span class="hljs-string">&quot;base64&quot;</span>
    <span class="hljs-punctuation">&#125;</span>,
  <span class="hljs-punctuation">&#125;</span>
<span class="hljs-punctuation">&#125;;</span></code></pre></div>



<h1 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 svg-url-loader 的使用方法和一些配置参数。svg-url-loader 主要用来编译 svg 格式文件，默认采用 utf-8 编码。</p>
<h3 id="Svg-Sprite-Loader"><a href="#Svg-Sprite-Loader" class="headerlink" title="Svg-Sprite-Loader"></a>Svg-Sprite-Loader</h3><h1 id="svg-sprite-loader"><a href="#svg-sprite-loader" class="headerlink" title="svg-sprite-loader"></a>svg-sprite-loader</h1><p>svg-sprite-loader 作用是合并多个单个的 svg 图片为一个 sprite 雪碧图，并把合成好的内容，插入到 html 内，其原理是利用 svg 的 symbol 元素，将每个 svg 图片 包括在 symbol 中，通过 use 元素使用该 symbol。<a href="https://leetcode.cn/link/?target=https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element">svg</a> 元素参考。</p>
<h2 id="使用-8"><a href="#使用-8" class="headerlink" title="使用"></a>使用</h2><p>index.html</p>
<p>在 index.html 中，通过使用 svg 的 use 元素渲染两张 svg 图片，分别对应 img 文件夹下的 headIcon.svg 和 home.svg。</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>svg-sprite-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#headIcon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>    
    <span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#home&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>        
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>index.js</p>
<p>导入 index.html 中 use 元素加载的两张 svg 图片。</p>
<div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> svgContent <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./img/headIcon.svg&#x27;</span>;
<span class="hljs-keyword">import</span> svgHome <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./img/home.svg&#x27;</span>;</code></pre></div>

<p>安装 svg-sprite-loader</p>
<div class="code-wrapper"><pre><code class="hljs q">npm install svg-sprite-loader --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div>

<p>安装成功后，将 svg-sprite-loader 配置到 webpack.config.js 中。</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
  ...
<span class="hljs-symbol">   module:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">    rules:</span> [
      <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        test:</span> /\.svg/,
<span class="hljs-symbol">        use:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">          loader:</span> <span class="hljs-string">&quot;svg-sprite-loader&quot;</span>
        <span class="hljs-punctuation">&#125;</span>,
      <span class="hljs-punctuation">&#125;</span>
    ]
  <span class="hljs-punctuation">&#125;</span>
<span class="hljs-punctuation">&#125;;</span></code></pre></div>

<p>执行打包命令后，在浏览器打开 dist&#x2F;index.html 文件，我们可以看到 svg 图片被展示在页面上，在控制台查看 elements 选项，可以看到两个 svg 图片被包裹在 两个 symbol 标签中，使用时通过 use 标签传入 symbol 元素 id 来显示不同的 svg 图片。</p>
<h2 id="配置项-8"><a href="#配置项-8" class="headerlink" title="配置项"></a>配置项</h2><p>svg-sprite-loader 包含下面基础参数配置。</p>
<ul>
<li><p>symbolId</p>
</li>
<li><p>symbolRegExp</p>
</li>
<li><p>esModule</p>
</li>
</ul>
<h3 id="symbolId"><a href="#symbolId" class="headerlink" title="symbolId"></a>symbolId</h3><p>默认值：[name]</p>
<p>值类型：String | Function</p>
<p>作用：设置 svg 标签中 symbol 元素的 id 值。</p>
<p>html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#icon-headIcon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
  ...
  &#123;
    test: <span class="hljs-regexp">/\.svg/</span>,
    use: &#123;
      loader: <span class="hljs-string">&quot;svg-sprite-loader&quot;</span>,
      options: &#123;
        <span class="hljs-regexp">//</span> string
        symbolId: <span class="hljs-string">&#x27;icon-[name]&#x27;</span>
        <span class="hljs-regexp">//</span> <span class="hljs-keyword">function</span>
        symbolId: filePath =&gt; path.basename(filePath)
      &#125;          
    &#125;
  &#125;
&#125;;</code></pre></div>



<h3 id="symbolRegExp"><a href="#symbolRegExp" class="headerlink" title="symbolRegExp"></a>symbolRegExp</h3><p>默认值：’’</p>
<p>值类型：String</p>
<p>作用：传递给 symbolId 插值器以支持 loader-utils 名称插值器中的 [N] 模式。</p>
<h3 id="esModule-3"><a href="#esModule-3" class="headerlink" title="esModule"></a>esModule</h3><p>默认值：true</p>
<p>值类型：Boolean</p>
<p>作用：是否使用 esModule 语法。如果使用 CommonJS 语法则参数设置为 false。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
  ...
   <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;svg-sprite-loader&quot;</span>,
<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        esModule:</span> true
      <span class="hljs-punctuation">&#125;</span>,
    <span class="hljs-punctuation">&#125;</span>
<span class="hljs-punctuation">&#125;;</span></code></pre></div>

<p>svg-sprite-loader 还支持<a href="https://leetcode.cn/link/?target=https://github.com/JetBrains/svg-sprite-loader#runtime-configuration">运行时配置</a>和<a href="https://leetcode.cn/link/?target=https://github.com/JetBrains/svg-sprite-loader#extract-configuration">提取配置</a>，想了解的小伙伴儿可自行查阅文档。</p>
<h1 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 svg-sprite-loader 的使用方法和一些配置参数。svg-sprite-loader 主要用来将从 css&#x2F;scss&#x2F;sass&#x2F;less&#x2F;styl&#x2F;html 导入的图像生成外部 sprite 文件，通过使用 svg 的 use 元素展示 图像内容。达到统一管理的目的。</p>
<h3 id="VUE-Loader"><a href="#VUE-Loader" class="headerlink" title="VUE-Loader"></a>VUE-Loader</h3><h1 id="vue-loader"><a href="#vue-loader" class="headerlink" title="vue-loader"></a>vue-loader</h1><p>Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件。</p>
<p>Vue Loader 还提供了很多酷炫的特性：</p>
<ul>
<li>允许为 Vue 组件的每个部分使用其它的 webpack loader，例如在 <style> 的部分使用 Sass 和在 <template> 的部分使用 Pug；</li>
<li>允许在一个 .vue 文件中使用自定义块，并对其运用自定义的 loader 链；</li>
<li>使用 webpack loader 将 <style> 和 <template> 中引用的资源当作模块依赖来处理；</li>
<li>为每个组件模拟出 scoped CSS；</li>
<li>在开发过程中使用热重载来保持状态；</li>
</ul>
<h2 id="使用-9"><a href="#使用-9" class="headerlink" title="使用"></a>使用</h2><p>在下面的例子中，正常要使用 <a href="https://leetcode.cn/link/?target=https://cn.vuejs.org/">Vue.js</a> 将组件渲染到页面上。但是这样会增加一些额外的代码，容易混淆，所以下面的例子只是完成打包不报错即认为 vue-loader 起到了作用。</p>
<p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>vue-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>index.vue</p>
<div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span>
<span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span>
<span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span>
<span class="language-javascript"><span class="language-xml">  data () &#123;</span></span>
<span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span>
<span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Hello world!&#x27;</span></span></span>
<span class="language-javascript"><span class="language-xml">    &#125;</span></span>
<span class="language-javascript"><span class="language-xml">  &#125;</span></span>
<span class="language-javascript"><span class="language-xml">&#125;</span></span>
<span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span>
<span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.demo</span> &#123;</span></span>
<span class="language-css"><span class="language-xml">  <span class="hljs-attribute">color</span>: blue;</span></span>
<span class="language-css"><span class="language-xml">&#125;</span></span>
<span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span></code></pre></div>

<p>安装 vue-loader</p>
<p>vue-loader 需要配合 <a href="https://leetcode.cn/link/?target=https://www.npmjs.com/package/vue-template-compiler">vue-template-compiler</a> 一起使用。</p>
<div class="code-wrapper"><pre><code class="hljs pgsql">npm install vue-loader vue-<span class="hljs-keyword">template</span>-compiler <span class="hljs-comment">--save-dev</span></code></pre></div>

<p>安装成功后，将 vue-loader 配置到 webpack.config.js 中。</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
...
<span class="hljs-regexp">//</span> webpack.config.js
const &#123; VueLoaderPlugin &#125; = require(<span class="hljs-string">&#x27;vue-loader&#x27;</span>);

module.exports = &#123;
    ...
    module: &#123;
        rules: [
            &#123;
                test: <span class="hljs-regexp">/\.vue$/</span>,
                loader: <span class="hljs-string">&#x27;vue-loader&#x27;</span>,
            &#125;,
            <span class="hljs-regexp">//</span> 它会应用到普通的 `.css` 文件
            <span class="hljs-regexp">//</span> 以及 `.vue` 文件中的 `&lt;style&gt;` 块
            &#123;
                test: <span class="hljs-regexp">/\.css$/</span>,
                use: [
                    <span class="hljs-string">&#x27;style-loader&#x27;</span>,
                    <span class="hljs-string">&#x27;css-loader&#x27;</span>
                ]
            &#125;
        ]
    &#125;,
    plugins: [
         <span class="hljs-regexp">//</span> 请确保引入这个插件！
         <span class="hljs-regexp">//</span> 这个插件是必须的！它的职责是将你定义过的其它规则复制并应用到 .vue 文件里相应语言的块。例如，如果你有一条匹配 <span class="hljs-regexp">/\.js$/</span> 的规则，那么它会应用到 .vue 文件里的 &lt;script&gt; 块。
         new VueLoaderPlugin()
    ]
&#125;;</code></pre></div>

<p>执行打包命令后，控制台显示编译成功。</p>
<h2 id="配置项-9"><a href="#配置项-9" class="headerlink" title="配置项"></a>配置项</h2><p>vue-loader 参数配置。</p>
<ul>
<li>transformAssetUrls</li>
<li>compiler</li>
<li>compilerOptions</li>
<li>transpileOptions</li>
<li>optimizeSSR</li>
<li>hotReload</li>
<li>productionMode</li>
<li>shadowMode</li>
<li>cacheDirectory &#x2F; cacheIdentifier</li>
<li>prettify</li>
<li>exposeFilename</li>
</ul>
<p>vue-loader 的配置项官网显示很清楚，大家可以去官网查看，<a href="https://leetcode.cn/link/?target=https://vue-loader.vuejs.org/zh/options.html#transformasseturls">vue-loader配置</a>。</p>
<h1 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h1><p>vue-loader 的总结大部分源自<a href="https://leetcode.cn/link/?target=https://vue-loader.vuejs.org/">官网介绍</a>，通过上面的使用我们可以完成一个简单的 vue-loader 配置及使用。</p>
<h3 id="VUE-Style-Loader"><a href="#VUE-Style-Loader" class="headerlink" title="VUE-Style-Loader"></a>VUE-Style-Loader</h3><h1 id="vue-style-loader"><a href="#vue-style-loader" class="headerlink" title="vue-style-loader"></a>vue-style-loader</h1><p>vue-style-loader 是基于 style-loader 的分支，功能与 style-loader 类似，都可以与 css-loader 链接将 style 标签注入到文档中，vue-style-loader 一般不需要自己配置加载，因为他已经作为依赖项包含在 vue-loader 中。vue-style-loader 除了将 style 注入到文档中，还做了一些服务端渲染的支持，所以如果我们 vue 项目中需要做服务端渲染，可能就要使用 vue-style-loader 来插入样式了。</p>
<h2 id="使用-10"><a href="#使用-10" class="headerlink" title="使用"></a>使用</h2><p>vue-style-loader 的使用方法与 style-loader 类似。都是与 css-loader 链接起来使用。</p>
<p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>vue-style-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> indexCss <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;
<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);
divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;demo&quot;</span>;
divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;vue-style-loader&#x27;</span>;
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div>

<p>index.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;
    <span class="hljs-attribute">color</span>: red;
&#125;</code></pre></div>

<p>安装 vue-style-loader</p>
<div class="code-wrapper"><pre><code class="hljs maxima">npm install vue-<span class="hljs-built_in">style</span>-loader --<span class="hljs-built_in">save</span>-dev</code></pre></div>

<p>安装成功后，将 vue-style-loader 配置到 webpack.config.js 中。</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
...
  <span class="hljs-attr">rules</span>: [
    &#123;
      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
      <span class="hljs-attr">use</span>: [
          <span class="hljs-string">&#x27;vue-style-loader&#x27;</span>,
          <span class="hljs-string">&#x27;css-loader&#x27;</span>
      ]
    &#125;
  ]
&#125;;</code></pre></div>

<p>打包成功后，打开 dist&#x2F;index.html 可以看到浏览器中文字颜色已经变成红色，在控制台 element 中可以看到 index.css 中的样式属性已经被包裹了 style 标签并插入到 head 中。</p>
<h2 id="配置项-10"><a href="#配置项-10" class="headerlink" title="配置项"></a>配置项</h2><p>vue-style-loader 参数配置。</p>
<ul>
<li><p>manualInject</p>
</li>
<li><p>ssrId</p>
</li>
</ul>
<h3 id="manualInject"><a href="#manualInject" class="headerlink" title="manualInject"></a>manualInject</h3><p>默认值：无</p>
<p>值类型：Boolean</p>
<p>作用：当 manualInject 参数值为 true 时，导入的样式对象会提供一个__inject__方法，然后可以在适当的时间手动调用该方法。此方法接收一个对象参数，最后将样式文件内容绑定到传入的对象上。</p>
<div class="code-wrapper"><pre><code class="hljs reasonml">注意：只有运行环境为 <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Node</span>.</span></span>js 且 manualInject 为 <span class="hljs-literal">true</span> 时，样式对象才会提供__inject__方法。</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">module.exports</span> <span class="hljs-string">=</span> &#123;
  <span class="hljs-string">...</span>
  &#123;
    <span class="hljs-attr">test:</span> <span class="hljs-string">/\.svg/</span>,
    <span class="hljs-attr">use:</span> [
      &#123;
        <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;vue-style-loader&#x27;</span>,
        <span class="hljs-attr">options:</span> &#123;
          <span class="hljs-attr">manualInject:</span> <span class="hljs-literal">true</span>,
        &#125;
      &#125;,
    ]
  &#125;
&#125;<span class="hljs-string">;</span></code></pre></div>



<h3 id="ssrId"><a href="#ssrId" class="headerlink" title="ssrId"></a>ssrId</h3><p>默认值：无</p>
<p>值类型：Boolean</p>
<p>作用：向 style 标签添加 data-vue-ssr-id 属性，可以用作预渲染避免样式重复注入。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">module.exports</span> <span class="hljs-string">=</span> &#123;
  <span class="hljs-string">...</span>
  &#123;
    <span class="hljs-attr">test:</span> <span class="hljs-string">/\.svg/</span>,
    <span class="hljs-attr">use:</span> [
      &#123;
        <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;vue-style-loader&#x27;</span>,
        <span class="hljs-attr">options:</span> &#123;
          <span class="hljs-attr">ssrId:</span> <span class="hljs-literal">true</span>
        &#125;
      &#125;,
    ]
  &#125;
&#125;<span class="hljs-string">;</span></code></pre></div>

<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655707832-TLxisk-1.png" srcset="/img/loading.gif" lazyload alt="1.png"></p>
<h2 id="区别于-style-loader"><a href="#区别于-style-loader" class="headerlink" title="区别于 style-loader"></a>区别于 style-loader</h2><ul>
<li>如果你正在构建一个 Vue SSR 应用程序，你可能也应该使用这个加载器来处理从 JavaScript 文件导入的 CSS</li>
<li>不支持 url 模式和引用计数模式。还删除了 singleton 和insertAt 查询选项。不支持样式懒加载。如果您需要这些功能，您可能应该使用原始功能 style-loader。</li>
</ul>
<h1 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h1><p>本章节我们介绍了 vue-style-loader 的使用、配置和它与 style-loader 的区别，vue-style-loader 支持 vue 中的 ssr（服务端渲染），所以如果需要支持服务端渲染的 vue 项目，就需要用到 vue-style-loader 了。但是如果是一般的项目，style-laoder 的功能会更多些。</p>
<h1 id="核心概念-Plugin"><a href="#核心概念-Plugin" class="headerlink" title="核心概念-Plugin"></a>核心概念-Plugin</h1><h3 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h3><h1 id="DefinePlugin-1"><a href="#DefinePlugin-1" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h1><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">DefinePlugin</span> 允许在编译时将你代码中的变量替换为其他值或表达式。这在需要根据开发模式与生产模式进行不同的操作时，非常有用。例如，如果想在开发构建中进行日志记录，而不在生产构建中进行，就可以定义一个全局常量去判断是否记录日志。这就是 DefinePlugin 的发光之处，设置好它，就可以忘掉开发环境和生产环境的构建规则。</code></pre></div>



<h2 id="使用-11"><a href="#使用-11" class="headerlink" title="使用"></a>使用</h2><p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DefinePlugin<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>index.js</p>
<p>我们将 webpack 中传入 DefinePlugin 中的参数打印出来。</p>
<div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(PRODUCTION)
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(DEVELOPMENT)
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(VERSION)
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(BROWSER_SUPPORTS_HTML5)
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(TWO)
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> window)
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(process.env.NODE_ENV)</code></pre></div>

<p>webpack.config.js</p>
<p>DefinePlugin 是 webpack 提供的插件，所以不需要单独安装，直接在 webpack 包中引入即可。</p>
<div class="code-wrapper"><pre><code class="hljs javascript">...
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
  ...
  <span class="hljs-attr">plugins</span>: [
        ...
        <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DefinePlugin</span>(&#123;
            <span class="hljs-attr">PRODUCTION</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>)&#125;,
            <span class="hljs-attr">DEVELOPMENT</span>: &#123;
                <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>
            &#125;,
            <span class="hljs-attr">VERSION</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&#x27;5fa3b9&#x27;</span>),
            <span class="hljs-attr">BROWSER_SUPPORTS_HTML5</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-string">&#x27;TWO&#x27;</span>: <span class="hljs-string">&#x27;1+1&#x27;</span>,
            <span class="hljs-string">&#x27;typeof window&#x27;</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&#x27;object&#x27;</span>),
            <span class="hljs-string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&quot;development&quot;</span>)
        &#125;)
    ]
&#125;;</code></pre></div>

<p>执行打包命令后，我们在浏览器查看输出结果。</p>
<div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(PRODUCTION) <span class="hljs-comment">// ƒ () &#123;console.log(111)&#125;</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(DEVELOPMENT) <span class="hljs-comment">// &#123;name: 1, value: 2&#125;</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(VERSION) <span class="hljs-comment">// 5fa3b9 </span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(BROWSER_SUPPORTS_HTML5) <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(TWO) <span class="hljs-comment">// 2</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> window) <span class="hljs-comment">// object</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(process.env.NODE_ENV) <span class="hljs-comment">// development</span></code></pre></div>



<h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><p>传递给 DefinePlugin 的每个键都是一个标识符或多个以 . 连接的标识符。</p>
<ul>
<li>如果该值为字符串，它将被作为代码片段来使用。</li>
<li>如果该值不是字符串，则将被转换成字符串（包括函数方法）。</li>
<li>如果值是一个对象，则它所有的键将使用相同方法定义。</li>
<li>如果键添加 typeof 作为前缀，它会被定义为 typeof 调用。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs powershell">警告：在为 <span class="hljs-keyword">process</span> 定义值时，<span class="hljs-string">&#x27;process.env.NODE_ENV&#x27;</span>: JSON.stringify(<span class="hljs-string">&#x27;production&#x27;</span>) 会比 <span class="hljs-keyword">process</span>: &#123; env: &#123; NODE_ENV: JSON.stringify(<span class="hljs-string">&#x27;production&#x27;</span>) &#125; &#125; 更好，后者会覆盖 <span class="hljs-keyword">process</span> 对象，这可能会破坏与某些模块的兼容性，因为这些模块会在 <span class="hljs-keyword">process</span> 对象上定义其他值。</code></pre></div>

<p>DefinePlugin 插件提供的功能在实际项目中将非常实用，通过传入标识符可以在生产&#x2F;开发构建中开启&#x2F;关闭不同特性。通过标识符传入的参数经过 webpack 压缩后可以只保留标识符为 true 的代码片段。可以通过传入服务地址来区分生产&#x2F;开发。</p>
<p>开启&#x2F;关闭特性</p>
<div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-comment">// NICE_FEATURE: JSON.stringify(true),</span>
<span class="hljs-keyword">if</span> (!NICE_FEATURE) &#123;
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;bad feature info&#x27;</span>);
&#125;
<span class="hljs-keyword">if</span> (NICE_FEATURE) &#123;
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;nice feature log&#x27;</span>);
&#125;
<span class="hljs-comment">// 经过压缩后：</span>
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;nice feature log&#x27;</span>);</code></pre></div>

<p>区分服务地址</p>
<div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&#x27;development&#x27;</span>) &#123;
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;development service url&#x27;</span>);
&#125;

<span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&#x27;product&#x27;</span>) &#123;
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;product service url&#x27;</span>);
&#125;</code></pre></div>



<h1 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h1><p>通过上面的例子，我们可以看到 DefinePlugin 就是帮助我们将传入的参数值替换到代码中，通过传入的内容做判断，最后保留下正确的代码片段。可以让我们针对不同环境和不同特性做不同的处理。</p>
<h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><h1 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h1><p>DllPlugin 是一个 webpack 插件，html-webpack-plugin 可以自动创建 html 文件，也支持使用 html 文件模版。html-webpack-plugin 会自动将所有必要的 css、javascript、manifest 和 favicon 文件注入到生成的 html 文件中。html-webpack-plugin 还提供了 <a href="https://leetcode.cn/link/?target=https://github.com/jantimon/DllPlugin#events">hooks</a> 来扩展功能。已经有很多零配置的插件可以继承进来。<a href="https://leetcode.cn/link/?target=https://github.com/jantimon/DllPlugin">插件列表</a>。</p>
<h2 id="使用-12"><a href="#使用-12" class="headerlink" title="使用"></a>使用</h2><p>使用下面的例子我们完成使用 DllPlugin 插件自动生成 index.html 文件。</p>
<p>安装 DllPlugin</p>
<div class="code-wrapper"><pre><code class="hljs q">npm install DllPlugin --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div>

<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;DllPlugin&#x27;</span>);</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs lasso">module.exports = &#123;
<span class="hljs-params">...</span>
  const HtmlWebpackPlugin = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;DllPlugin&#x27;</span>);
  entry: &#123;
      index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
  &#125;,
  output: &#123;
    <span class="hljs-params">...</span>
    filename: <span class="hljs-string">&#x27;[name]-[hash].js&#x27;</span>
  &#125;
  plugins: <span class="hljs-meta">[</span>
        <span class="hljs-params">...</span>
        <span class="hljs-literal">new</span> HtmlWebpackPlugin()
    <span class="hljs-meta">]</span>
&#125;;</code></pre></div>

<p>执行打包命令后，在 dist 文件及下可以看到生成了一个 index.html 文件，入口文件 index.js 被编译成 index-[hash].js 文件名的文件，并且在 index-[hash].js 通过 script 标签插入到了 index.html 中。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="title-filename-template"><a href="#title-filename-template" class="headerlink" title="title | filename | template"></a>title | filename | template</h3><p>默认值：Webpack App ｜ ‘index.html’ ｜ ‘’</p>
<p>值类型：String | String、Function | String</p>
<p>作用：title 配置项传入的内容会插入到生成的 html 文件的 title 标签中，即 html 文件的标题。filename 配置项传入的内容为生成的 html 文件的名字，默认为 index.html。template 配置项传入的内容为使用的模版 html，如本地存在 index.html 则 DllPlugin 将以本地 index.html 作为模版生成新的 html 文件。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
  ...
module: &#123;
  loaders: [
    &#123; test: <span class="hljs-regexp">/\.hbs$/</span>, loader: <span class="hljs-string">&quot;handlebars-loader&quot;</span> &#125;
  ]
&#125;,
  plugins: [
    new HtmlWebpackPlugin(&#123;
        <span class="hljs-regexp">//</span> string
        filename: <span class="hljs-string">&#x27;index.[contenthash].html&#x27;</span>,
        <span class="hljs-regexp">//</span> <span class="hljs-keyword">function</span>
        filename: (entryName) =&gt; entryName + <span class="hljs-string">&#x27;-test.html&#x27;</span>,
        title: <span class="hljs-string">&#x27;DllPlugin&#x27;</span>,
        template: <span class="hljs-string">&#x27;./index.html&#x27;</span>,
        <span class="hljs-regexp">//</span> 使用 handlebars-loader 加载器解析 hbs 模版
        template: <span class="hljs-string">&#x27;index.hbs&#x27;</span>
    &#125;)
  ]
&#125;;</code></pre></div>

<p>在使用本地模版并且定义了 title 的情况下，本地模版的 html 文件中的 title 标签要使用下面的写法，生成的 html 文件中 title 才会生效。</p>
<p>本地 index.html 模版</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>



<h3 id="templateContent"><a href="#templateContent" class="headerlink" title="templateContent"></a>templateContent</h3><p>默认值：false</p>
<p>值类型：string | Function | false</p>
<p>作用：templateContent 传入内容可作为生成的 html 文件的模版，可替换 template 使用，但是 templateContent 不允许为您的模板使用 webpack 加载器，并且不会监视模板文件的更改。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs xquery"><span class="hljs-keyword">module</span>.exports = &#123;
  ...
  plugins: [
    new HtmlWebpackPlugin(&#123;
      title: <span class="hljs-string">&#x27;DllPlugin&#x27;</span>,
      templateContent: `
          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span>
<span class="language-xml">          </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"></span>
<span class="language-xml">          </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span>
<span class="language-xml">              </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml"></span>
<span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"></span>
<span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span>
      `
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="templateParameters"><a href="#templateParameters" class="headerlink" title="templateParameters"></a>templateParameters</h3><p>默认值：false</p>
<p>值类型：Boolean | Object | Function</p>
<p>作用：覆盖模板中使用的参数。</p>
<p>本地 index.html 模版</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&lt;%= foo %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;
        template: <span class="hljs-string">&#x27;./index.html&#x27;</span>,
        templateParameters: &#123;
            <span class="hljs-string">&#x27;foo&#x27;</span>: <span class="hljs-string">&#x27;DllPlugin&#x27;</span>
        &#125;,
    &#125;)
  ]
&#125;;</code></pre></div>

<p>打包成功后，生成的 index.html 文件中的 &lt;%&#x3D; foo %&gt; 被替换成了 ”html-webpack-plugin“。</p>
<h3 id="inject"><a href="#inject" class="headerlink" title="inject"></a>inject</h3><p>默认值：true</p>
<p>值类型：Boolean | String</p>
<p>作用：通过设置 inject 不同的参数，来指定 CSS、JS、manifest 和 favicon 等文件注入到模版文件的位置。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs gradle">module.exports = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;
        <span class="hljs-keyword">inject</span>: <span class="hljs-keyword">false</span> <span class="hljs-comment">// 不注入</span>
        <span class="hljs-keyword">inject</span>: <span class="hljs-string">&#x27;head&#x27;</span> <span class="hljs-comment">// 注入到 head 标签中</span>
        <span class="hljs-keyword">inject</span>: <span class="hljs-string">&#x27;body&#x27;</span> <span class="hljs-comment">// 注入到 body 标签中</span>
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="publicPath-2"><a href="#publicPath-2" class="headerlink" title="publicPath"></a>publicPath</h3><p>默认值：’auto’</p>
<p>值类型：’auto’ | String</p>
<p>作用：脚本文件注入到模版中时，增加 publicPath 传入的路径</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;
      <span class="hljs-comment">// &lt;script defer src=&quot;/javascript/index-059c24f59da85973176b.js&quot;&gt;&lt;/script&gt;</span>
      publicPath: <span class="hljs-string">&#x27;/javascript&#x27;</span> 
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="scriptLoading"><a href="#scriptLoading" class="headerlink" title="scriptLoading"></a>scriptLoading</h3><p>默认值：’defer’</p>
<p>值类型：’blocking’ | ‘defer’ | ‘module’</p>
<p>作用：现代浏览器支持非阻塞 javascript 加载 (‘defer’) 以提高页面启动性能。传入 scriptLoading 配置可以给 script 标签设置 type 属性。设置为 ‘module’ 添加属性 type&#x3D;”module”</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs xquery"><span class="hljs-keyword">module</span>.exports = &#123;
  ...
  plugins: [
    new HtmlWebpackPlugin(&#123;
      scriptLoading: <span class="hljs-string">&#x27;module&#x27;</span> // <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index-059c24f59da85973176b.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
      scriptLoading: <span class="hljs-string">&#x27;defer&#x27;</span> // &lt;script defer src=<span class="hljs-string">&quot;index-059c24f59da85973176b.js&quot;</span>&gt;&lt;/script&gt;
      scriptLoading: <span class="hljs-string">&#x27;blocking&#x27;</span> // <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index-059c24f59da85973176b.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="favicon"><a href="#favicon" class="headerlink" title="favicon"></a>favicon</h3><p>默认值：’’</p>
<p>值类型：String</p>
<p>作用：将给定的 favicon 路径添加到输出的 HTML 中。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs sas">module.exports = &#123;
  ...
  plugins: [
    new HtmlWebpackPlugi<span class="hljs-meta">n</span>(&#123;
      // 生成的 <span class="hljs-keyword">index</span>.html 中增加了 &lt;<span class="hljs-keyword">link</span> rel=<span class="hljs-string">&quot;icon&quot;</span> href=<span class="hljs-string">&quot;headIcon.svg&quot;</span>&gt;
      favicon: <span class="hljs-string">&#x27;./src/headIcon.svg&#x27;</span>
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><p>默认值：{}</p>
<p>值类型：Object</p>
<p>作用：允许注入 meta-tags。例如 meta: {viewport: ‘width&#x3D;device-width, initial-scale&#x3D;1, shrink-to-fit&#x3D;no’}</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
  ...
  plugins: [
    new HtmlWebpackPlugin(&#123;
      <span class="hljs-regexp">//</span> 生成的 index.html 中增加了 &lt;meta name=<span class="hljs-string">&quot;keywords&quot;</span> content=<span class="hljs-string">&quot;HTML,CSS,XML,JavaScript&quot;</span>&gt;
      meta: &#123;
        keywords: <span class="hljs-string">&#x27;HTML,CSS,XML,JavaScript&#x27;</span>
      &#125;
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="base-1"><a href="#base-1" class="headerlink" title="base"></a>base</h3><p>默认值：false</p>
<p>值类型：Object | String | false</p>
<p>作用：允许注入注入 base 标签</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs roboconf">module.exports = &#123;
  ...
  <span class="hljs-attribute">plugins</span>: [
    new HtmlWebpackPlugin(&#123;
      // 生成的 index<span class="hljs-variable">.html</span> 中增加了 &lt;base href=&quot;http://www<span class="hljs-variable">.example</span><span class="hljs-variable">.com</span>/&quot;&gt;
      base: &#123;
          href: &quot;http://www<span class="hljs-variable">.example</span><span class="hljs-variable">.com</span>/&quot;
      &#125;
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="minify"><a href="#minify" class="headerlink" title="minify"></a>minify</h3><p>默认值：mode 是 ‘production’ 为 true，否则为 false</p>
<p>值类型：Boolean | Object</p>
<p>作用：是否压缩输出内容，并且以何种方式压缩。当 minify 值为 true，生成的 HTML 将使用 html-minifier-terser 和以下选项进行缩小：</p>
<div class="code-wrapper"><pre><code class="hljs yaml">&#123;
  <span class="hljs-attr">collapseWhitespace:</span> <span class="hljs-literal">true</span>,
  <span class="hljs-attr">keepClosingSlash:</span> <span class="hljs-literal">true</span>,
  <span class="hljs-attr">removeComments:</span> <span class="hljs-literal">true</span>,
  <span class="hljs-attr">removeRedundantAttributes:</span> <span class="hljs-literal">true</span>,
  <span class="hljs-attr">removeScriptTypeAttributes:</span> <span class="hljs-literal">true</span>,
  <span class="hljs-attr">removeStyleLinkTypeAttributes:</span> <span class="hljs-literal">true</span>,
  <span class="hljs-attr">useShortDoctype:</span> <span class="hljs-literal">true</span>
&#125;</code></pre></div>

<p>要使用自定义 <a href="https://leetcode.cn/link/?target=https://github.com/terser/html-minifier-terser#options-quick-reference">html-minifier</a> 选项，请将对象传递给minify。此对象不会与上述默认值合并。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;
      minify: <span class="hljs-literal">false</span> <span class="hljs-comment">// 生产环境不做压缩</span>
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>默认值：false</p>
<p>值类型：Boolean</p>
<p>作用：如果 hash 值为 true，将哈希值附加到所有包含的脚本和 CSS 文件路径后。这对更新静态文件很有效。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;
      <span class="hljs-comment">// 生成的 index.html 中 script 文件地址后面增加了 hash</span>
      <span class="hljs-comment">// &lt;script defer src=&quot;index-77c62f233f4dc40c523c.js?77c62f233f4dc40c523c&quot;&gt;&lt;/script&gt;</span>
      hash: <span class="hljs-literal">true</span>
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>默认值：true</p>
<p>值类型：Boolean</p>
<p>作用：传入参数为 true，将调用 webpack 生成资源方法，传入缓存中之前生成的 html，反之，总是重新编译并更新缓存，调用 webpack 生成资源方法，传入生成的 html。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;
      cache: <span class="hljs-literal">false</span>
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="showErrors"><a href="#showErrors" class="headerlink" title="showErrors"></a>showErrors</h3><p>默认值：true</p>
<p>值类型：Boolean</p>
<p>作用：将错误信息输出到 html 文件中。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;
      showErrors: <span class="hljs-literal">false</span>
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="chunks"><a href="#chunks" class="headerlink" title="chunks"></a>chunks</h3><p>默认值：? | ‘’</p>
<p>值类型：{?} | {Array.<string>}</p>
<p>作用：允许生成的 html 文件中包含哪些 chunk。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs sas">module.exports = &#123;
    entry: &#123;
        <span class="hljs-keyword">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
        main: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>
    &#125;,
    <span class="hljs-keyword">output</span>: &#123;
        path: path.<span class="hljs-meta">resolve</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>), 
        <span class="hljs-keyword">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>
    &#125;,
    plugins: [
        ...
        new HtmlWebpackPlugi<span class="hljs-meta">n</span>(&#123; 
            chunks: [<span class="hljs-string">&#x27;main&#x27;</span>]
        &#125;)
    ]
&#125;;</code></pre></div>

<p>上面的代码中，我们使用多入口打包，打包后生成 index.js 和 main.js 两个文件，chunks 传入 main，则生成的 html 模版中只插入了 main.js。</p>
<h3 id="excludeChunks"><a href="#excludeChunks" class="headerlink" title="excludeChunks"></a>excludeChunks</h3><p>默认值：’’</p>
<p>值类型：{Array.<string>}</p>
<p>作用：允许生成的 html 文件中不包含哪些 chunk。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;
      excludeChunks: [<span class="hljs-string">&#x27;main&#x27;</span>] <span class="hljs-comment">// 生成的 html 文件中没有插入 main.js 文件</span>
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="xhtml"><a href="#xhtml" class="headerlink" title="xhtml"></a>xhtml</h3><p>默认值：false</p>
<p>值类型：Boolean</p>
<p>作用：如果传入 xhtml 为 true，则生成的 html 文件兼容 xhtml 规则。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;
      xhtml: <span class="hljs-literal">true</span>
    &#125;)
  ]
&#125;;</code></pre></div>



<h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><p>DllPlugin 还为其他插件提供了一些 <a href="https://leetcode.cn/link/?target=https://github.com/jantimon/DllPlugin#events">hooks</a>，感兴趣的小伙伴可自行查看。</p>
<h1 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h1><p>DllPlugin 帮助我们自动生成 html 模版，并且会自动将脚本样式等文件插入到模版，同时又提供了很多配置让我们修改生成的模版，这在项目中将非常实用。</p>
<h3 id="DllPlugin-1"><a href="#DllPlugin-1" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><h1 id="DllPlugin-2"><a href="#DllPlugin-2" class="headerlink" title="DllPlugin"></a>DllPlugin</h1><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">DllPlugin</span> 和 DllReferencePlugin 用某种方法实现了拆分 bundles，同时还大幅度提升了构建的速度。<span class="hljs-string">&quot;DLL&quot;</span> 一词代表微软最初引入的动态链接库。</code></pre></div>

<p>通过使用 DllPlugin 可以拆分项目中版本不经常变更的或者包大小比较大的三方依赖。将依赖拆分成单独的 bundles，这样可以提升项目打包速度、减少包体积来加快加载速度。</p>
<h2 id="使用-13"><a href="#使用-13" class="headerlink" title="使用"></a>使用</h2><p>本章中主要介绍 DllPlugin 的使用及配置，由于需要打包第三方依赖库，所以下面以 lodash 为例。</p>
<p>安装 lodash</p>
<div class="code-wrapper"><pre><code class="hljs q">npm install loadsh --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div>

<p>webpack.config.dll.js</p>
<p>新建一个 webpack.config.dll.js 文件，用来添加 dll 配置，在执行打包命令之前先生成 dll 文件。</p>
<div class="code-wrapper"><pre><code class="hljs lua">const webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);
const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-built_in">module</span>.exports = &#123;
    entry: &#123;
        lodash: [<span class="hljs-string">&#x27;lodash&#x27;</span>]
    &#125;,
    <span class="hljs-built_in">output</span>: &#123;
        filename: <span class="hljs-string">&#x27;[name]_dll.js&#x27;</span>,
        library: <span class="hljs-string">&quot;[name]&quot;</span>,
        <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist/dll&#x27;</span>)
    &#125;,
    plugins: [
        new webpack.DllPlugin(&#123;
            context: __dirname,
            <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&#x27;dist/dll&#x27;</span>, <span class="hljs-string">&#x27;[name]-mainfest.json&#x27;</span>),
            name: <span class="hljs-string">&#x27;[name]&#x27;</span>
        &#125;),
    ]
&#125;</code></pre></div>

<p>在上面的配置中，entry 为项目入库文件，output 为项目输出文件名称及输出目录。其中要注意的是 output 中的 library 参数，增加 library 配置后 mainfest.json 会暴露 dll 库的全局名称。此参数定义的名称要与 DllPlugin 插件中的 name 属性定义名称一致。</p>
<p>在命令行执行 npx webpack –config webpack.config.dll.js 命令，打包成功后在 dist 文件下可以看到生成了一个 dll.js 一个 mainfest.json 文件。</p>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><h3 id="context-2"><a href="#context-2" class="headerlink" title="context"></a>context</h3><p>默认值：webpack 的 context</p>
<p>值类型：String</p>
<p>作用：生成的 manifest.json 文件中 content 对象中的文件映射地址。</p>
<p>webpack.config.dll.js</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
  plugins: [
    new webpack.DllPlugin(&#123;
      <span class="hljs-regexp">//</span> &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;vendors&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:&#123;<span class="hljs-string">&quot;./node_modules/lodash/lodash.js&quot;</span>:&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">486</span>,<span class="hljs-string">&quot;buildMeta&quot;</span>:&#123;&#125;&#125;&#125;&#125;
      context: __dirname <span class="hljs-regexp">//</span> 根目录地址
      <span class="hljs-regexp">//</span> 下面的 mainfest.json 文件将找不到 lodash.js，映射地址错误
      <span class="hljs-regexp">//</span> &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;vendors&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:&#123;<span class="hljs-string">&quot;../node_modules/lodash/lodash.js&quot;</span>:&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">486</span>,<span class="hljs-string">&quot;buildMeta&quot;</span>:&#123;&#125;&#125;&#125;&#125;
      <span class="hljs-regexp">//</span> context: <span class="hljs-string">&#x27;src&#x27;</span>
    &#125;),
  ]
&#125;;</code></pre></div>



<h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>默认值：false</p>
<p>值类型：Boolean</p>
<p>作用：如果值为 true，生成的 mainfest.json 文件将被格式化。</p>
<p>webpack.config.dll.js</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
  plugins: [
    new webpack.DllPlugin(&#123;
      <span class="hljs-regexp">//</span> &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;vendors&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:&#123;<span class="hljs-string">&quot;./node_modules/lodash/lodash.js&quot;</span>:&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">486</span>,<span class="hljs-string">&quot;buildMeta&quot;</span>:&#123;&#125;&#125;&#125;&#125;
      format: false,
      <span class="hljs-regexp">//</span> &#123;
      <span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;vendors&quot;</span>,
      <span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;content&quot;</span>: &#123;
      <span class="hljs-regexp">//</span>     <span class="hljs-string">&quot;./node_modules/lodash/lodash.js&quot;</span>: &#123;
      <span class="hljs-regexp">//</span>       <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">486</span>,
      <span class="hljs-regexp">//</span>       <span class="hljs-string">&quot;buildMeta&quot;</span>: &#123;&#125;
      <span class="hljs-regexp">//</span>     &#125;
      <span class="hljs-regexp">//</span>   &#125;
      <span class="hljs-regexp">//</span> &#125;
      format: true
    &#125;),
  ]
&#125;;</code></pre></div>



<h3 id="name-1"><a href="#name-1" class="headerlink" title="name"></a>name</h3><p>默认值：’’</p>
<p>值类型：String</p>
<p>作用：生成的 mainfest.json 文件中的 name 属性值。</p>
<p>webpack.config.dll.js</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
  ...
  plugins: [
    new webpack.DllPlugin(&#123;
      <span class="hljs-regexp">//</span> &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;lodash-name&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:&#123;<span class="hljs-string">&quot;./node_modules/lodash/lodash.js&quot;</span>:&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">486</span>,<span class="hljs-string">&quot;buildMeta&quot;</span>:&#123;&#125;&#125;&#125;&#125;
      name: <span class="hljs-string">&quot;lodash-name&quot;</span>
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="path-1"><a href="#path-1" class="headerlink" title="path"></a>path</h3><p>默认值：无（必须）</p>
<p>值类型：String</p>
<p>作用：生成 mainfest.json 文件的路径。</p>
<p>webpack.config.dll.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">webpack</span>.DllPlugin(&#123;
      <span class="hljs-comment">// 在根目录的 dist/dll 文件夹下生成 [name]-mainfest.json</span>
      path: path.join(__dirname, <span class="hljs-string">&#x27;dist/dll&#x27;</span>, <span class="hljs-string">&#x27;[name]-mainfest.json&#x27;</span>),
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="entryOnly"><a href="#entryOnly" class="headerlink" title="entryOnly"></a>entryOnly</h3><p>默认值：true</p>
<p>值类型：Boolean</p>
<p>作用：如果为 true，则仅暴露入口。</p>
<p>webpack.config.dll.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">DllPlugin</span>(&#123;
      entryOnly: <span class="hljs-literal">false</span>
    &#125;)
  ]
&#125;;
建议 DllPlugin 只在 entryOnly: <span class="hljs-literal">true</span> 时使用，否则 DLL 中的 tree shaking 将无法工作，因为所有 <span class="hljs-keyword">exports</span> 均可使用。</code></pre></div>



<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>类型：”var” | “module” | “assign” |”assign-properties” | “this” | “window” | “self” | “global” | “commonjs” | “commonjs2” | “commonjs-module” |”commonjs-static” | “amd” | “amd-require” | “umd” | “umd2” | “jsonp” | “system”</p>
<p>作用：配置 dll 库暴露的方式。</p>
<p>webpack.config.dll.js</p>
<div class="code-wrapper"><pre><code class="hljs ada">module.exports = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> DllPlugin(&#123;
      // &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;lodash-name&quot;</span>,<span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;window&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:&#123;<span class="hljs-string">&quot;./node_modules/lodash/lodash.js&quot;</span>:&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">486</span>,<span class="hljs-string">&quot;buildMeta&quot;</span>:&#123;&#125;&#125;&#125;&#125;
      <span class="hljs-keyword">type</span>: <span class="hljs-symbol">&#x27;window</span>&#x27;
    &#125;)
  ]
&#125;;</code></pre></div>



<h1 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h1><p>此章节演示了 DllPlugin 的用法和包含的配置参数。生成的 dll.js 和 mainfest.json 文件，在下个 DllReferencePlugin 章节来展示如何使用。</p>
<h3 id="DllReferencePlugin"><a href="#DllReferencePlugin" class="headerlink" title="DllReferencePlugin"></a>DllReferencePlugin</h3><h1 id="DllReferencePlugin-1"><a href="#DllReferencePlugin-1" class="headerlink" title="DllReferencePlugin"></a>DllReferencePlugin</h1><p>在上一章节的 DllPlugin 插件中，DllPlugin 插件会将第三方依赖生成一个 [name]-dll.js 文件和一个 [name]-manifest.json 文件，其中 [name]-dll.js 文件包含第三方依赖所有的源码，[name]-manifest.json 文件包含所有第三方依赖的名称位置和与 [name]-dll.js 映射的索引 ID，执行相应命令生成了 [name]-dll.js 和 [name]-manifest.json 后，就可以执行工程的打包命令。在 webpack 打包过程中，通过 DllReferencePlugin 插件，可以将 [name]-manifest.json 文件中的第三方依赖的映射关系进行解析，当检索到有第三方依赖的映射关系时，会将三方依赖索引 ID 值注入到使用依赖的文件中。如果没有检索到三方依赖映射关系，将去 node_modules 或者项目中查找并将检索内容添加到需要使用依赖的文件中。</p>
<h2 id="使用-14"><a href="#使用-14" class="headerlink" title="使用"></a>使用</h2><p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-type">name</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./main.js&#x27;</span>;
console.log(_.<span class="hljs-keyword">join</span>([<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>], <span class="hljs-string">&#x27;-&#x27;</span>))
console.log(<span class="hljs-type">name</span>);</code></pre></div>

<p>main.js</p>
<div class="code-wrapper"><pre><code class="hljs delphi"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;dll&#x27;</span>;</code></pre></div>

<p>webpack.config.dll.js</p>
<div class="code-wrapper"><pre><code class="hljs lua">const webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);
const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-built_in">module</span>.exports = &#123;
    entry: &#123;
        vendors: [<span class="hljs-string">&#x27;lodash&#x27;</span>, <span class="hljs-string">&#x27;./src/main.js&#x27;</span>],
    &#125;,
    <span class="hljs-built_in">output</span>: &#123;
        filename: <span class="hljs-string">&#x27;[name]-dll.js&#x27;</span>,
        library: <span class="hljs-string">&quot;[name]&quot;</span>,
        <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist/dll&#x27;</span>)
    &#125;,
    plugins: [
        new webpack.DllPlugin(&#123;
            context: __dirname,
            <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&#x27;dist/dll&#x27;</span>, <span class="hljs-string">&#x27;[name]-manifest.json&#x27;</span>),
            name: <span class="hljs-string">&#x27;[name]&#x27;</span>,
            <span class="hljs-built_in">format</span>: <span class="hljs-literal">true</span>
        &#125;),
    ]
&#125;</code></pre></div>

<p>在上面的配置中，将 lodash 和本地 main.js 生成 dll 文件。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);


<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,
    <span class="hljs-attr">entry</span>: &#123;
        <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
    &#125;,
    <span class="hljs-attr">output</span>: &#123;
        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>), 
        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>
    &#125;,
    <span class="hljs-attr">plugins</span>: [
        <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DllReferencePlugin</span>(&#123;
            <span class="hljs-comment">// 对动态链接库的文件内容的描述或者映射关系，非 dll 本身</span>
            <span class="hljs-attr">manifest</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./dist/dll/vendors-manifest.json&#x27;</span>),
        &#125;)
    ]
&#125;</code></pre></div>

<p>在 webpack.config.js 的 DllReferencePlugin 插件中引入 DllPlugin 插件生成的 manifest.json 文件。执行 npm run build 打包命令。我们看下生成的 index.js 文件内容。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655707974-pZSKII-1.png" srcset="/img/loading.gif" lazyload alt="1.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655708324-MmeVkB-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<p>从上面的截图我们可以看到 DllReferencePlugin 插件解析了 manifest.json 中的第三方依赖对应的映射关系，将 ID 值传入到 index.js 的方法中，我们接下来需要手动将 dll&#x2F;vendors-dll.js 通过 <code>&lt;script&gt;</code> 标签添加到 index.html 中。vendors-dll.js 文件中包含第三方依赖的代码和 manifest.json 中的 ID 值，index.js 中通过加载 ID 值来使用第三方依赖方法。</p>
<div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Webpack App<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./dll/vendors-dll.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>

<p>在浏览器中打开 index.html 文件，在控制台可以看到输出的内容，main.js 和 lodash 方法均可正常使用。</p>
<p>DllReferencePlugin 在解析 manifest.json 文件时，虽然 manifest.json 包含多个第三方依赖的映射关系，但是插件会根据 index.js 中的引用来注入对应的代码。即当 index.js 中只引用了 main.js 文件时，打包后生成的 index.js 文件则只包含 main.js 的映射关系。在实际的项目中，就可以将不常改动的第三方依赖打包成 dll，将 dll 的链接通过 CDN 等方式引入到项目中，这样可以减少主包的大小，加快打包速度。</p>
<div class="code-wrapper"><pre><code class="hljs delphi">注意：[<span class="hljs-keyword">name</span>]-dll.js 可以通过插件动态插入到 <span class="hljs-keyword">index</span>.html，小伙伴儿可自行查阅。</code></pre></div>



<h2 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h2><h3 id="context-3"><a href="#context-3" class="headerlink" title="context"></a>context</h3><p>类型：String</p>
<p>默认值：webpack 的 context</p>
<p>作用：(绝对路径) manifest 中请求的上下文。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
  plugins: [
    new webpack.DllReferencePlugin(&#123;
      ...
      context: __dirname <span class="hljs-regexp">//</span> 根目录地址
      <span class="hljs-regexp">//</span> 下面的配置会在 dist 文件夹下查找 manifest 的地址，当找不到 manifest.json 文件时，会将依赖代码打包到 bundle.js 中
      <span class="hljs-regexp">//</span> path.resolve(__dirname, <span class="hljs-string">&quot;dist&quot;</span>)
    &#125;),
  ]
&#125;;</code></pre></div>

<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655709393-wsvekM-4.png" srcset="/img/loading.gif" lazyload alt="4.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655709393-nMFiXo-3.png" srcset="/img/loading.gif" lazyload alt="3.png"></p>
<h3 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h3><p>类型：String</p>
<p>作用：用于加载 manifest.json 路径。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">webpack</span>.DllReferencePlugin(&#123;
      <span class="hljs-comment">// 动态链接库的文件内容</span>
      manifest: require(<span class="hljs-string">&#x27;./dist/dll/vendors-manifest.json&#x27;</span>),
    &#125;),
  ]
&#125;;</code></pre></div>



<h3 id="name-2"><a href="#name-2" class="headerlink" title="name"></a>name</h3><p>类型：String</p>
<p>默认值：manifest.json 的 name 属性。</p>
<p>作用：[name]-dll.js 暴露的全局变量方法名称，将 manifest.json 中的 索引 ID 传入全局方法中，可返回对应模块方法。</p>
<p>index.js</p>
<p>其中的 vendors(225)，vendors 为 dll 暴露的全局变量，225 为 manifest.json 中 main.js 依赖的 ID 索引值。</p>
<div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-type">name</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./main.js&#x27;</span>;
console.log(_.<span class="hljs-keyword">join</span>([<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>], <span class="hljs-string">&#x27;-&#x27;</span>))
console.log(vendors(<span class="hljs-number">225</span>));
console.log(vendors(<span class="hljs-number">225</span>).plugin);</code></pre></div>

<p>main.js</p>
<div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> plugin = <span class="hljs-string">&#x27;dll&#x27;</span>;</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">webpack</span>.DllReferencePlugin(&#123;
      ...
      name: <span class="hljs-string">&#x27;vendors&#x27;</span>
    &#125;)
  ]
&#125;;</code></pre></div>

<p>打包成功后，控制台打开 dist&#x2F;index.html，可以看到 输出了 hello-world、 main.js 模块代码和 main.js 代码中的 plugin 变量。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655708137-OwpPBR-5.png" srcset="/img/loading.gif" lazyload alt="5.png"></p>
<h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>类型：Object</p>
<p>默认值：manifest.json 的 content 属性。</p>
<p>作用：传入请求依赖到模块 ID 的映射关系。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">webpack</span>.DllReferencePlugin(&#123;
      content: &#123;
        <span class="hljs-string">&quot;./src/main.js&quot;</span>: &#123;
          <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">225</span>,
          <span class="hljs-string">&quot;exports&quot;</span>: [
            <span class="hljs-string">&quot;plugin&quot;</span>
          ]
        &#125;,
      &#125;
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="sourceType"><a href="#sourceType" class="headerlink" title="sourceType"></a>sourceType</h3><p>类型：”var” | “assign” | “this” | “window” | “global” | “commonjs” | “commonjs2” | “commonjs-module” | “amd” | “amd-require” | “umd” | “umd2” | “jsonp” | “system”</p>
<p>作用：dll 中的模块代码以哪种模式暴露给外部调用 <a href="https://leetcode.cn/link/?target=https://webpack.js.org/configuration/output/#outputlibrarytype">output.library.type</a></p>
<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> &#123; <span class="hljs-type">name</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./main.js&#x27;</span>;
console.log(<span class="hljs-keyword">window</span>.vendors(<span class="hljs-number">225</span>));</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;
      ...
      sourceType: <span class="hljs-string">&#x27;window&#x27;</span>
    &#125;)
  ]
&#125;;</code></pre></div>



<h1 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h1><p>此章节演示了 DllReferencePlugin 的用法和包含的配置参数。DllReferencePlugin 通过解析 manifest.json 将依赖的映射索引注入到需要的依赖中。通过将不常变动的依赖打包成 dll 的方式，可以减少 bundle 的大小，同时能加快打包速度。</p>
<h3 id="MiniCssExtractPlugin"><a href="#MiniCssExtractPlugin" class="headerlink" title="MiniCssExtractPlugin"></a>MiniCssExtractPlugin</h3><h1 id="MiniCssExtractPlugin-1"><a href="#MiniCssExtractPlugin-1" class="headerlink" title="MiniCssExtractPlugin"></a>MiniCssExtractPlugin</h1><p>MiniCssExtractPlugin 插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件。这个插件需要在 webpack 5 中才能正常工作，webpack 4 中使用 extract-text-webpack-plugin 插件做 CSS 分离。之前的文章中我们介绍了 style-loader 的使用，style-loader 是将 JS 中包含的 CSS 内容以 <code>&lt;style&gt;</code> 标签的形式插入到 DOM 中，而 MiniCssExtractPlugin 插件则是将 JS 中包含的 CSS 创建一个新的文件，并且以 <code>&lt;link&gt;</code> 标签的形式插入链接到加载依赖的文件中。MiniCssExtractPlugin 作用与 style-loader 类似，但是实现方式却完全不同。MiniCssExtractPlugin 一般与 css-loader 同时使用。</p>
<div class="code-wrapper"><pre><code class="hljs autohotkey">注意：下面【使用】模块的案例，index.css 分离是 MiniCssExtractPlugin 做的，而通过 `&lt;link&gt;` 标签插入index.html 是 HtmlWebpackPlugin 插件做的，MiniCssExtractPlugin 插件可以将非入口文件通过 `&lt;link&gt;` 标签插入到加载依赖的文件中，即 MiniCssExtractPlugin 插入 `&lt;link&gt;` 仅适用于非初始（异步）块。</code></pre></div>



<h2 id="使用-15"><a href="#使用-15" class="headerlink" title="使用"></a>使用</h2><p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;
<span class="hljs-keyword">import</span> main <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./main.css&quot;</span>;

<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);
divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;demo&quot;</span>;
divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>;
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div>

<p>index.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;
    <span class="hljs-attribute">color</span>: red;
&#125;</code></pre></div>

<p>main.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;
&#125;</code></pre></div>

<p>安装 mini-css-extract-plugin</p>
<div class="code-wrapper"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>mini-css-<span class="hljs-keyword">extract-plugin </span>-D</code></pre></div>

<p>安装成功后，将 mini-css-extract-plugin 配置到 webpack.config.js 的 plugins 和 module 中。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript">...
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
    ...
    <span class="hljs-attr">module</span>: &#123;
        <span class="hljs-attr">rules</span>: [
          &#123;
            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>,
            <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],
          &#125;,
        ],
    &#125;,
    <span class="hljs-attr">plugins</span>: [
        ...
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>()
    ]
&#125;</code></pre></div>

<p>我们在入口文件 index.js 中导入了 main.css 和 index.css 两个样式文件。一个改变字体，一个改变字体颜色。执行打包命令，可以看到在 dist 文件夹下除了 index.js 和 index.html 文件之外还生成了一个 index.css 文件。index.css 文件中包含 main.css 和 index.css 的内容。在 index.html 中通过 <code>&lt;link&gt;</code> 标签的形式引入了 index.css 文件。在浏览器中打开 dist&#x2F;index.html 可以看到样式被正常展示。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132739-yLUVon-1.png" srcset="/img/loading.gif" lazyload alt="1.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132739-bWqEsK-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<p>上面的例子中在 index.js 中导入了两个样式文件，接下来我们试一下在入口文件 index.js 中导入 main.js 和 index.css，其中 main.js 中导入 main.css。其他配置保持不变。</p>
<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;
<span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> mainElement &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./main&#x27;</span>;

<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);
divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;demo&quot;</span>;
divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>;
divElement.<span class="hljs-title function_">appendChild</span>(mainElement);
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div>

<p>main.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> main <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./main.css&quot;</span>;

<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);
divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;demo-main&quot;</span>;
divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;demo-main&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> divElement;</code></pre></div>

<p>main.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo-main</span> &#123;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;
&#125;</code></pre></div>

<p>执行打包命令后，dist 文件夹下依然只有 index.html，index.js，index.css 文件。查看后发现虽然在 main.js 中导入的 main.css，但由于 main.js 被 index.js 依赖。所以 css 文件内容依然都打包到了 index.css 中。</p>
<h2 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h2><p>MiniCssExtractPlugin 包含两部分配置，plugin 配置和 loader 配置。</p>
<h3 id="Plugin-Options"><a href="#Plugin-Options" class="headerlink" title="Plugin Options"></a>Plugin Options</h3><h4 id="filename-1"><a href="#filename-1" class="headerlink" title="filename"></a>filename</h4><p>类型：string | ((pathData: PathData, assetInfo?: AssetInfo) &#x3D;&gt; string);</p>
<p>默认值：[name].css</p>
<p>作用：输出的 css 文件的名称，默认为 chunkName 值。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
  plugins: [
    new MiniCssExtractPlugin(&#123;
      ...
       filename: <span class="hljs-string">&#x27;[name].css&#x27;</span> <span class="hljs-regexp">//</span> index.css
      <span class="hljs-regexp">//</span>  filename: (pathData) =&gt; &#123;
      <span class="hljs-regexp">//</span>     return pathData.hash + <span class="hljs-string">&#x27;-index.css&#x27;</span>;
      <span class="hljs-regexp">//</span>  &#125;, <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>de455759e47e7f4d53b-index.css
    &#125;),
  ]
&#125;;</code></pre></div>



<h4 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h4><p>类型：string | ((pathData: PathData, assetInfo?: AssetInfo) &#x3D;&gt; string);</p>
<p>默认值：基于 filename</p>
<p>作用：修改非入口文件的打包后的名称。</p>
<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;
<span class="hljs-comment">// 将 main.js 打包到单独文件</span>
<span class="hljs-keyword">const</span> mainElement = <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;main&quot; */</span> <span class="hljs-string">&#x27;./main&#x27;</span>);
...</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;
      chunkFilename: <span class="hljs-string">&#x27;chunk-[id].css&#x27;</span>, <span class="hljs-comment">// chunk-main.css</span>
    &#125;),
  ]
&#125;;</code></pre></div>

<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132739-gWZpeT-3.png" srcset="/img/loading.gif" lazyload alt="3.png"></p>
<p>打开 dist 我们可以看到 main.js 文件已经单独打包，并且生成了一个 chunk-name.css 文件。</p>
<h4 id="ignoreOrder"><a href="#ignoreOrder" class="headerlink" title="ignoreOrder"></a>ignoreOrder</h4><p>类型：boolean</p>
<p>默认值：false</p>
<p>作用：模块中加载 css 文件顺序不一致是否发出警告，例如：1.js 中加载 css 的顺序是 a.css、b.css，2.js 中加载顺序是 b.css、a.css，就会发出警告，详细可看下官网 <a href="https://leetcode.cn/link/?target=https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250">issue</a></p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;
      ignoreOrder: <span class="hljs-literal">false</span>,
    &#125;)
  ]
&#125;;</code></pre></div>



<h4 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h4><p>类型：string | ((linkTag: HTMLLinkElement) &#x3D;&gt; void)</p>
<p>默认值：document.head.appendChild(linkTag)，即默认插入到 DOM 文件的 head 中</p>
<p>作用：打包的 CSS 文件，通过 <code>&lt;link&gt;</code> 标签插入的位置。</p>
<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> styles from <span class="hljs-string">&quot;./index.css&quot;</span>;
<span class="hljs-keyword">const</span> divElement = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);
<span class="hljs-comment">// import 方法导入的模块为异步加载</span>
<span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;main&quot; */</span> <span class="hljs-string">&#x27;./main&#x27;</span>).then(res =&gt; &#123;
  divElement.appendChild(res.<span class="hljs-keyword">default</span>)
&#125;);

divElement.className = <span class="hljs-string">&quot;demo&quot;</span>;
divElement.innerHTML = <span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>;
<span class="hljs-built_in">document</span>.body.appendChild(divElement);</code></pre></div>

<p>index.html</p>
<div class="code-wrapper"><pre><code class="hljs xml">...
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div-element&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;
      insert: <span class="hljs-string">&#x27;#div-element&#x27;</span>
    &#125;)
  ]
&#125;;</code></pre></div>

<p>执行打包命令后，在 dist&#x2F;index.html 文件中，只包含了 index.css 的 <code>&lt;link&gt;</code> 标签，在浏览器中运行 index.html，在控制台可以看到 chunk-main.css 的 <code>&lt;link&gt;</code> 标签被插入到选择器为 <code>#div-element</code> 元素的后面。在生成的 index.js 文件中可以看到创建 link 标签的源码。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132739-xZlArH-5.png" srcset="/img/loading.gif" lazyload alt="5.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132739-jgrsql-6.png" srcset="/img/loading.gif" lazyload alt="6.png"></p>
<h4 id="attributes-1"><a href="#attributes-1" class="headerlink" title="attributes"></a>attributes</h4><p>类型：object</p>
<p>默认值：{}</p>
<p>作用：在 <code>&lt;link&gt;</code> 标签中添加属性</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs llvm"><span class="hljs-keyword">module</span>.exports <span class="hljs-operator">=</span> &#123;
  ...
<span class="hljs-symbol">  plugins:</span> [
    ...
    new MiniCssExtractPlugin(&#123;
<span class="hljs-symbol">        attributes:</span> &#123;
            <span class="hljs-string">&quot;data-target&quot;</span>: <span class="hljs-string">&quot;data&quot;</span> // &lt;link data-<span class="hljs-keyword">target</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;data&quot;</span> rel<span class="hljs-operator">=</span><span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-keyword">type</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;text/css&quot;</span> href<span class="hljs-operator">=</span><span class="hljs-string">&quot;.../dist/main.css&quot;</span>&gt;
        &#125;<span class="hljs-punctuation">,</span>
    &#125;)
  ]
&#125;<span class="hljs-comment">;</span></code></pre></div>



<h4 id="linkType"><a href="#linkType" class="headerlink" title="linkType"></a>linkType</h4><p>类型：string | boolean</p>
<p>默认值：text&#x2F;css</p>
<p>作用：修改 <code>&lt;link&gt;</code> 标签中 type 属性，type 的默认值为 text&#x2F;css。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
  ...
  plugins: [
    ...
    new MiniCssExtractPlugin(&#123;
        linkType: <span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-regexp">//</span> &lt;link type=<span class="hljs-string">&quot;text/css&quot;</span> ...&gt;
        <span class="hljs-regexp">//</span> linkType: false <span class="hljs-regexp">//</span> &lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> href=<span class="hljs-string">&quot;.../dist/main.css&quot;</span>&gt;
    &#125;)
  ]
&#125;;</code></pre></div>



<h4 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h4><p>类型：boolean</p>
<p>默认值：true</p>
<p>作用：允许启用&#x2F;禁用运行时生成。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  plugins: [
    ...
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;
        runtime: <span class="hljs-literal">false</span> <span class="hljs-comment">// 运行 index.html 时，main.css 不会被插入到 DOM 中。</span>
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="Loader-Options"><a href="#Loader-Options" class="headerlink" title="Loader Options"></a>Loader Options</h3><h4 id="publicPath-3"><a href="#publicPath-3" class="headerlink" title="publicPath"></a>publicPath</h4><p>类型：string | ((resourcePath: string, rootContext: string) &#x3D;&gt; string)</p>
<p>默认值：webpackOptions.output 选项的值</p>
<p>作用：输出的 CSS 文件中，为图像、文件等外部资源指定自定义公共路径。</p>
<p>main.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo-main</span> &#123;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;
    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">./img/1.png</span>);
&#125;</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
  ...
  module: &#123;
        rules: [
          &#123;
            test: <span class="hljs-regexp">/\.css$/i</span>,
            use: [
                &#123;
                    loader: MiniCssExtractPlugin.loader,
                    options: &#123;
                      publicPath: <span class="hljs-string">&quot;/public/path/to/&quot;</span>, <span class="hljs-regexp">//</span> main.css background: url(<span class="hljs-regexp">/public/</span>path<span class="hljs-regexp">/to/</span>e30cb9c395cbb5ae00e9.png);
                    &#125;,
                &#125;, <span class="hljs-string">&quot;css-loader&quot;</span>],
          &#125;,
        ],
    &#125;,
&#125;;</code></pre></div>

<p>打包成功后，查看生成的 main.css 文件，background 地址已经被替换成传入的 publicPath，通过传入 publicPath 可以引用外部资源。</p>
<h4 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h4><p>类型：boolean</p>
<p>默认值：true</p>
<p>作用：提取的 CSS 是否生成对应文件。当 emit 值为 true 会生成 CSS 文件，值为 false 不生成 CSS 文件。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
  ...
<span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        rules:</span> [
          <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">            test:</span> /\.css$/i,
<span class="hljs-symbol">            use:</span> [
                <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">                    loader:</span> MiniCssExtractPlugin.loader,
<span class="hljs-symbol">                    options:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">                      emit:</span> false, <span class="hljs-comment">// 打包后的 dist 中没有生成 index.css 和 main.css，运行 index.html 样式不生效</span>
                    <span class="hljs-punctuation">&#125;</span>,
                <span class="hljs-punctuation">&#125;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],
          <span class="hljs-punctuation">&#125;</span>,
        ],
    <span class="hljs-punctuation">&#125;</span>,
<span class="hljs-punctuation">&#125;;</span></code></pre></div>



<h4 id="esModule-4"><a href="#esModule-4" class="headerlink" title="esModule"></a>esModule</h4><p>类型：boolean</p>
<p>默认值：true</p>
<p>作用：生成的文件是否使用 ES 模块语法，开启 ES 语法对 tree-shaking 将非常有用。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>
  ...
<span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">        rules:</span> [
          <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">            test:</span> /\.css$/i,
<span class="hljs-symbol">            use:</span> [
                <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">                    loader:</span> MiniCssExtractPlugin.loader,
<span class="hljs-symbol">                    options:</span> <span class="hljs-punctuation">&#123;</span>
<span class="hljs-symbol">                      esModule:</span> false, <span class="hljs-comment">// 启用CommonJS 语法</span>
                    <span class="hljs-punctuation">&#125;</span>,
                <span class="hljs-punctuation">&#125;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],
          <span class="hljs-punctuation">&#125;</span>,
        ],
    <span class="hljs-punctuation">&#125;</span>,
<span class="hljs-punctuation">&#125;;</span></code></pre></div>



<h1 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h1><p>此章节演示了 MiniCssExtractPlugin 的用法和包含的配置参数。MiniCssExtractPlugin 还有一些推荐的例子，感兴趣的同学可查看<a href="https://leetcode.cn/link/?target=https://www.npmjs.com/package/mini-css-extract-plugin">官方</a>。</p>
<h3 id="WebpackManifestPlugin"><a href="#WebpackManifestPlugin" class="headerlink" title="WebpackManifestPlugin"></a>WebpackManifestPlugin</h3><h1 id="WebpackManifestPlugin-1"><a href="#WebpackManifestPlugin-1" class="headerlink" title="WebpackManifestPlugin"></a>WebpackManifestPlugin</h1><p>WebpackManifestPlugin 是一个 webpack 插件，此插件的作用是生成资产清单即 manifest.json 文件，在使用此插件前，我们先看下什么是 manifest 以及 manifest 的作用，以下引自 webpack 官网。</p>
<blockquote>
<p>一旦你的应用在浏览器中以 index.html 文件的形式被打开，一些 bundle 和应用需要的各种资源都需要用某种方式被加载与链接起来。在经过打包、压缩、&gt;为延迟加载而拆分为细小的 chunk 这些 webpack 优化 之后，你精心安排的 &#x2F;src 目录的文件结构都已经不再存在。所以 webpack 如何管理所有所需模 &gt;块之间的交互呢？这就是 manifest 数据用途的由来……</p>
</blockquote>
<p>总结来说，manifest.json 就是记录项目中生成的 bundle 之间的映射关系。有了这份清单，我们可以通过特定的方法加载资源，如服务端渲染或通过遍历 manifest.json 将记录输出到页面上等。在当前流行的微前端框架中，通过引入不同子项目的 manifest.json 文件，并遍历文件内容动态输出到 DOM 中，从而实现加载不同子项目工程，这会比手动获取子项目资源清单减少出错概率和省事的多。</p>
<h2 id="使用-16"><a href="#使用-16" class="headerlink" title="使用"></a>使用</h2><p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;
<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);
divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;demo&quot;</span>;
divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;webpack-manifest-plugin&#x27;</span>;
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div>

<p>index.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;
    <span class="hljs-attribute">color</span>: red;
    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">./img/1.png</span>);
&#125;</code></pre></div>

<p>安装 webpack-manifest-plugin</p>
<div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> webpack-manifest-plugin -D</code></pre></div>

<p>安装成功后，将 webpack-manifest-plugin 配置到 webpack.config.js 的 plugins 中。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs lasso"><span class="hljs-params">...</span>
const &#123; WebpackManifestPlugin &#125; = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;webpack-manifest-plugin&#x27;</span>);

module.exports = &#123;
    <span class="hljs-params">...</span>
    plugins: <span class="hljs-meta">[</span>
        <span class="hljs-params">...</span>
        <span class="hljs-literal">new</span> WebpackManifestPlugin(&#123;
            publicPath: <span class="hljs-string">&#x27;./&#x27;</span>
        &#125;)
    <span class="hljs-meta">]</span>
&#125;</code></pre></div>

<p>我们在 index.js 文件中创建了一个 div 标签，在 index.css 中设置了 div 标签的字体颜色和背景图片，此时执行打包命令，打包成功后在 dist 中可以看到除了项目资源文件外还有一个 manifest.json 文件。打开 manifest.json 文件看下内容。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132966-dqklgB-1.png" srcset="/img/loading.gif" lazyload alt="1.png"></p>
<p>manifest.json 包含了资源的映射关系，我们需要遍历 manifest.json 对象的内容，将需要的如 js 资源通过 createElement 等方式挂载到 index.html 中项目即可正常使用。</p>
<h2 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h2><p>以下为包含部分常用配置，全部配置可查看<a href="https://leetcode.cn/link/?target=https://github.com/shellscape/webpack-manifest-plugin">官网</a></p>
<h3 id="basePath"><a href="#basePath" class="headerlink" title="basePath"></a>basePath</h3><p>类型：String</p>
<p>默认值：’’</p>
<p>作用：生成的 manifest.json 文件中，basePath 参数传入的值将添加到对象的 key 值前面。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
  plugins: [
    new WebpackManifestPlugin(&#123;
      ...
      basePath: <span class="hljs-string">&#x27;src&#x27;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;src/index.js&quot;</span>: <span class="hljs-string">&quot;.../index.js&quot;</span>,
      basePath: <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;index.js&quot;</span>: <span class="hljs-string">&quot;.../index.js&quot;</span>,
    &#125;),
  ]
&#125;;</code></pre></div>



<h3 id="fileName"><a href="#fileName" class="headerlink" title="fileName"></a>fileName</h3><p>类型：String</p>
<p>默认值：manifest.json</p>
<p>作用：fileName 传入的值作为输出的文件清单的名称。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebpackManifestPlugin</span>(&#123;
        fileName: <span class="hljs-string">&#x27;manifest-filename.json&#x27;</span> <span class="hljs-comment">// manifest.json -&gt; manifest-filename.json</span>
    &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>类型：(file: FileDescriptor) &#x3D;&gt; Boolean</p>
<p>默认值：undefined</p>
<p>作用：执行 filter 回调函数，返回 true 则 manifest.json 中包含 bundle 的映射关系，返回 false 则不包含此 bundle 映射关系。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript">module.<span class="hljs-built_in">exports</span> = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> WebpackManifestPlugin(&#123;
      filter: <span class="hljs-function"><span class="hljs-params">(file)</span> =&gt;</span> &#123;
          <span class="hljs-keyword">return</span> file?.name?.endsWith(<span class="hljs-string">&#x27;.js&#x27;</span>) <span class="hljs-regexp">//</span> manifest.json 中只包含 js 拓展名的文件
      &#125;
    &#125;)
  ]
&#125;;</code></pre></div>

<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132966-mPOfFh-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>类型：(seed: Object, files: FileDescriptor[], entries: string[]) &#x3D;&gt; Object</p>
<p>默认值：undefined</p>
<p>作用：自定义修改生成的 manifest.json 中的键值对内容，generate 传入的函数返回值需要为对象。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs arcade">module.exports = &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> WebpackManifestPlugin(&#123;
      <span class="hljs-attr">generate</span>: <span class="hljs-function">(<span class="hljs-params">seed, files, entries</span>) =&gt;</span> &#123;
          <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(seed, <span class="hljs-string">&#x27;seed&#x27;</span>)
          <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(files, <span class="hljs-string">&#x27;files&#x27;</span>)
          <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(entries, <span class="hljs-string">&#x27;entries&#x27;</span>)
          <span class="hljs-keyword">return</span> &#123; <span class="hljs-string">&#x27;main-index&#x27;</span>: <span class="hljs-string">&#x27;index.js&#x27;</span> &#125;
      &#125;
    &#125;) <span class="hljs-comment">// manifest.json 中内容 &#123; &quot;main-index&quot;: &quot;index.js&quot; &#125;</span>
  ]
&#125;;</code></pre></div>



<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>类型：(file: FileDescriptor) &#x3D;&gt; FileDescriptor</p>
<p>默认值：undefined</p>
<p>作用：自定义修改生成的 manifest.json 中的键值对内容。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs sas">module.exports = &#123;
  ...
  plugins: [
    ...
    new WebpackManifestPlugi<span class="hljs-meta">n</span>(&#123;
        map: (<span class="hljs-keyword">file</span>) =&gt; &#123;
            const <span class="hljs-keyword">fileName</span> = <span class="hljs-keyword">file</span>?.name;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">file</span>?.name?.endsWith(<span class="hljs-string">&#x27;.js&#x27;</span>)) &#123;
                <span class="hljs-keyword">file</span>.name = <span class="hljs-string">&#x27;assets.&#x27;</span> + <span class="hljs-keyword">fileName</span>
            &#125;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">file</span>
        &#125;
    &#125;) 
    // &#123; <span class="hljs-string">&quot;assets.main.js&quot;</span>: <span class="hljs-string">&quot;auto/main.js&quot;</span> ... &#125;
  ]
&#125;;</code></pre></div>



<h3 id="publicPath-4"><a href="#publicPath-4" class="headerlink" title="publicPath"></a>publicPath</h3><p>类型：String</p>
<p>默认值：webpack.config.js 中的 output.publicPath 值</p>
<p>作用：publicPath 传入的内容将添加到 manifest.json 对象的值前面。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;
  ...
  plugins: [
    ...
     new WebpackManifestPlugin(&#123;
        <span class="hljs-regexp">//</span> &#123;
        <span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;index.js&quot;</span>: <span class="hljs-string">&quot;./dist-public/index.js&quot;</span>,
        <span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;1.png&quot;</span>: <span class="hljs-string">&quot;./dist-public/2b2001bb98465dd14a87.png&quot;</span>,
        <span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;index.html&quot;</span>: <span class="hljs-string">&quot;./dist-public/index.html&quot;</span>
        <span class="hljs-regexp">//</span> &#125;
        publicPath: <span class="hljs-string">&#x27;./dist-public&#x27;</span>  
      &#125;)
  ]
&#125;;</code></pre></div>



<h3 id="serialize"><a href="#serialize" class="headerlink" title="serialize"></a>serialize</h3><p>类型：(Object) &#x3D;&gt; string</p>
<p>默认值：undefined</p>
<p>作用：格式化 manifest.json 中的内容。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript">module.<span class="hljs-built_in">exports</span> = &#123;
  ...
  plugins: [
    ...
    <span class="hljs-keyword">new</span> WebpackManifestPlugin(&#123;
        serialize: <span class="hljs-function"><span class="hljs-params">(obj)</span> =&gt;</span> &#123;
            console.log(obj)
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(obj) <span class="hljs-regexp">//</span> &#123;<span class="hljs-string">&quot;index.js&quot;</span>:<span class="hljs-string">&quot;auto/index.js&quot;</span>,<span class="hljs-string">&quot;1.png&quot;</span>:<span class="hljs-string">&quot;auto/2b2001bb98465dd14a87.png&quot;</span>,<span class="hljs-string">&quot;index.html&quot;</span>:<span class="hljs-string">&quot;auto/index.html&quot;</span>&#125;
        &#125;
    &#125;)
  ]
&#125;;</code></pre></div>



<h1 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h1><p>此章节演示了 WebpackManifestPlugin 的用法和包含的部分常用配置参数，通过 WebpackManifestPlugin 生成的资源清单可以让我们在项目中快速找到引用的依赖文件路径，这对于服务端渲染或微前端等将非常有用。</p>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><h1 id="开发环境调优"><a href="#开发环境调优" class="headerlink" title="开发环境调优"></a>开发环境调优</h1><p>在之前的章节中我们介绍了 Webpack 的基础配置，一些 Loader 和 Plugin 的使用方法，到此我们应该对 Webpack 有了一定的认识，Webpack 作为打包工具的重要使命之一就是提升效率，下面我们介绍一些对日常开发有一定帮助的 Webpack 插件、配置。</p>
<ul>
<li><p>source map</p>
</li>
<li><p>插件介绍</p>
</li>
<li><p>使用 webpack-dev-server</p>
</li>
<li><p>模块热替换</p>
</li>
</ul>
<h2 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h2><p>Webpack 打包编译后的代码基本不具备可读性，工程发布或启动后此时若代码跑出一个错误，想要回溯它的调用栈是非常困难的。而有了 source map 在加上浏览器的调试工具，要做到追踪错误和警告就容易的多了。source map 指的是将编译、打包、压缩等操作后的代码映射回原文件的过程。开发环境通过 source map 我们可以直接看到源代码调试，生产环境通过 source map 我们可以通过工具回溯到报错的代码位置。为我们进一步分析错误提供了便利。</p>
<p>在开发环境即 mode 选项设置为 development 模式下，Webpack 将自动生成映射文件，source map 除了将 Javascript 映射回原文件外，还同样适用于样式文件。</p>
<h3 id="source-map-配置"><a href="#source-map-配置" class="headerlink" title="source map 配置"></a>source map 配置</h3><p>Javascript 的 source map 通过配置项 devtool 来启用，只要在 webpack.config.js 中添加 devtool 即可。</p>
<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> divElement = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);
divElement.className = <span class="hljs-string">&quot;demo&quot;</span>;
divElement.innerHTML = <span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>;
<span class="hljs-built_in">document</span>.body.appendChild(divElement);</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">const</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
    <span class="hljs-comment">// ...</span>
    devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>,
&#125;</code></pre></div>

<p>对于 CSS、SCSS、Less 来说，需要在 loader 中添加 source map 配置。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
    <span class="hljs-comment">// ...</span>
     <span class="hljs-attr">module</span>: &#123;
        <span class="hljs-attr">rules</span>: [
            &#123;
            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(css)$/</span>,
            <span class="hljs-attr">use</span>: [
                <span class="hljs-string">&#x27;style-loader&#x27;</span>,
                &#123;
                    <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;css-loader&#x27;</span>,
                    <span class="hljs-attr">options</span>: &#123;
                        <span class="hljs-attr">sourceMap</span>: <span class="hljs-literal">true</span>
                    &#125;
                &#125;
              ]
            &#125;
        ]
    &#125;,
&#125;</code></pre></div>

<p>打包后，在 dist 文件夹下除了 index.js 外还生成了一个 index.js.map 文件。在生成 mapping 文件的同时，还为 index.js 添加了一个引用注释，以便开发工具知道在哪里可以找到它。</p>
<p>dist&#x2F;index.js</p>
<div class="code-wrapper"><pre><code class="hljs awk">(<span class="hljs-keyword">function</span>() &#123;
  <span class="hljs-regexp">//</span> 内容
&#125;)();
<span class="hljs-regexp">//</span><span class="hljs-comment"># sourceMappingURL=index.js.map</span></code></pre></div>

<p>当我们打开浏览器的开发者工具时，map 文件会同时被加载，这时浏览器会使用它来对打包后的 bundle 进行解析。分析出源码的内容。当我们打断点进行调试时，可以直接调试源码。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133154-bhTBwe-1.png" srcset="/img/loading.gif" lazyload alt="1.png"></p>
<h3 id="source-map-分类"><a href="#source-map-分类" class="headerlink" title="source map 分类"></a>source map 分类</h3><p>Webpack 支持的 source map 大概分为两种，inline（内连） 和 separate（独立）两种方式。inline 类型即生成的映射关系内容保存在 bundle 中不生成单独的文件，separate 类型即可生成单独的 map 文件可以独立使用。source map 支持类型很多，下面只介绍其中几种，详细信息可官网查看，<a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/configuration/devtool">source map官网</a></p>
<h4 id="inline-source-map-类型"><a href="#inline-source-map-类型" class="headerlink" title="inline source map 类型"></a>inline source map 类型</h4><p>Webpack 提供了多种内联映射文件类型。通常 eval 是起点，因为它是速度和质量之间的良好折衷，同时在 Chrome 和 Firefox 浏览器中可以可靠地工作。下面我们介绍两个内连类型的例子。</p>
<div class="code-wrapper"><pre><code class="hljs stylus">注意：为了查看效果我们去掉 webpack<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span> 中的 mode 配置。</code></pre></div>



<h5 id="devtool-“eval”"><a href="#devtool-“eval”" class="headerlink" title="devtool: “eval”"></a>devtool: “eval”</h5><p>eval生成代码，其中每个模块都包装在一个eval函数中。并且都包含 &#x2F;&#x2F;# sourceURL，此选项会非常快的构建。</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript">(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;var __webpack_modules__=&#123;
  <span class="hljs-number">138</span>:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;
    <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;const divElement = document.createElement(&quot;div&quot;);\ndivElement.className = &quot;demo&quot;;\ndivElement.innerHTML = \&#x27;mini-css-extract-plugin\&#x27;;\ndocument.body.appendChild(divElement);\n\n//# sourceURL=webpack://6.1/./src/index.js?&#x27;</span>)
  &#125;
&#125;,__webpack_exports__=&#123;&#125;;__webpack_modules__[<span class="hljs-number">138</span>]()&#125;)();</code></pre></div>



<h5 id="devtool-“eval-source-map”"><a href="#devtool-“eval-source-map”" class="headerlink" title="devtool: “eval-source-map”"></a>devtool: “eval-source-map”</h5><p>每个模块使用 eval() 执行，并且 source map 转换为 DataUrl 后添加到 eval() 中。初始化 source map 时比较慢，但是会在重新构建时提供比较快的速度，并且生成实际的文件。</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript">(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
  &#123;var __webpack_modules__=&#123;
    <span class="hljs-number">138</span>: <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;
      <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;const divElement = document.createElement(&quot;div&quot;);\ndivElement.className = &quot;demo&quot;;\ndivElement.innerHTML = \&#x27;mini-css-extract-plugin\&#x27;;\ndocument.body.appendChild(divElement);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vNi4xLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZGl2RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5kaXZFbGVtZW50LmNsYXNzTmFtZSA9IFwiZGVtb1wiO1xuZGl2RWxlbWVudC5pbm5lckhUTUwgPSAnbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4nO1xuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXZFbGVtZW50KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///138\n&#x27;</span>)
  &#125;
&#125;,__webpack_exports__=&#123;&#125;;__webpack_modules__[<span class="hljs-number">138</span>]()&#125;)();</code></pre></div>



<h4 id="separate-source-map-类型"><a href="#separate-source-map-类型" class="headerlink" title="separate source map 类型"></a>separate source map 类型</h4><p>Webpack 提供了多种独立映射文件类型。我们常用的为 source-map 类型，source-map 类型可以生成单独的 map 文件，有了 source map 也就意味着任何人都可以通过浏览器调试工具看到工程源码，这对于安全性来说有了极大隐患。那么如何能保证线上问题可以追踪又能防止源码泄漏，Webpack 提供了 hidden-source-map 和 nosources-source-map 两种策略来提升 source map 的安全性。</p>
<h5 id="devtool-“hidden-source-map”"><a href="#devtool-“hidden-source-map”" class="headerlink" title="devtool: “hidden-source-map”"></a>devtool: “hidden-source-map”</h5><p>hidden-source-map 与 source-map 作用相同都会生成一个 map 文件，唯一区别是不会为 bundle 添加引用注释。我们在浏览器中直接打开工程，是看不到原文件的，生成的 map 文件只是作为我们追踪错误信息的依据。</p>
<div class="code-wrapper"><pre><code class="hljs dart">(()=&gt;&#123;<span class="hljs-keyword">const</span> e=<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);e.className=<span class="hljs-string">&quot;demo&quot;</span>,e.innerHTML=<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>,<span class="hljs-built_in">document</span>.body.appendChild(e)&#125;)();
警告：你不应将 source map 文件部署到 web 服务器。而是只将其用于错误报告工具。</code></pre></div>



<h5 id="devtool-“nosources-source-map”"><a href="#devtool-“nosources-source-map”" class="headerlink" title="devtool: “nosources-source-map”"></a>devtool: “nosources-source-map”</h5><p>nosources-source-map 创建的 source map 不包含 sourcesContent(源代码内容)。虽然在 bundle 中增加了 &#x2F;&#x2F;# sourceMappingURL，但是当我们在浏览器中打开源码文件时是看不到源码内容的。</p>
<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs dart">(()=&gt;&#123;<span class="hljs-keyword">const</span> e=<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);e.className=<span class="hljs-string">&quot;demo&quot;</span>,e.innerHTML=<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>,<span class="hljs-built_in">document</span>.body.appendChild(e)&#125;)();
<span class="hljs-comment">//# sourceMappingURL=index.js.map</span>
这仍然会暴露反编译后的文件名和结构，但它不会暴露原始代码。</code></pre></div>

<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132966-mPOfFh-2-1674980279528150.png" srcset="/img/loading.gif" lazyload alt="2.png"><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133154-IlbFXK-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p>Webpack 拥有非常强大的生态系统，社区中相关的工具也是数不胜数，这里我们介绍两个项目中常用的插件，可以节省开发效率和减少我们操作步骤。</p>
<h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>html-webpack-plugin 可以自动创建 html 文件，也支持使用 html 文件模版。html-webpack-plugin 会自动将所有必要的 css、javascript、manifest 和 favicon 文件注入到生成的 html 文件中。之前在 5.2 章节做过 html-webpack-plugin 的介绍，所以这里不在详细介绍。</p>
<p>安装 html-webpack-plugin</p>
<div class="code-wrapper"><pre><code class="hljs css">npm install <span class="hljs-selector-tag">html</span>-webpack-plugin <span class="hljs-attr">--save-dev</span></code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">const</span> <span class="hljs-variable">HtmlWebpackPlugin</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
...
  plugins: [
        ...
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>()
    ]
&#125;;</code></pre></div>



<h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>clean-webpack-plugin 插件用于在每次构建工程时清除上次构建生成的文件，有了这个插件我们再也不用手动清除构建目录了。</p>
<p>安装 clean-webpack-plugin</p>
<div class="code-wrapper"><pre><code class="hljs q">npm install clean-webpack-plugin --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
...
  <span class="hljs-attr">plugins</span>: [
        ...
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>()
    ]
&#125;;</code></pre></div>



<h2 id="使用-webpack-dev-server"><a href="#使用-webpack-dev-server" class="headerlink" title="使用 webpack-dev-server"></a>使用 webpack-dev-server</h2><p>在之前的案例中，我们一直都是更改代码后执行打包命令，然后手动去打包文件中打开 html 文件查看效果，这种方式在实际的项目发开中会增加很多额外的重复工作，并且打包后的内容需要发布到服务上才能被其他伙伴访问。为了提升开发效率，在构建代码并部署到生产环境之前，我们需要一个本地环境，用于运行我们开发的代码。这个环境相当于提供了一个简单的服务器，用于访问 webpack 构建好的静态文件，我们日常开发时可以使用它来调试前端代码。webpack-dev-server 可以很好的帮我们解决这个需求，webpack-dev-server 是 webpack 官方提供的一个工具，可以基于当前的 webpack 构建配置快速启动一个静态服务。当 mode 为 development 时，会具备 hot reload 的功能，即当源码文件变化时，会即时更新当前页面，以便我们实时看到效果。webpack-dev-server 仅应用于开发环境。下面简单介绍下 <a href="https://leetcode.cn/link/?target=https://github.com/webpack/webpack-dev-server#readme">webpack-dev-server</a> 的使用，详细配置可查看官网。</p>
<p>安装</p>
<div class="code-wrapper"><pre><code class="hljs axapta">npm install webpack-dev-<span class="hljs-keyword">server</span> -D</code></pre></div>

<p>package.json 中增加 scripts</p>
<div class="code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;
  <span class="hljs-string">...</span>
  <span class="hljs-string">&quot;serve&quot;</span>: <span class="hljs-string">&quot;webpack serve&quot;</span>
&#125;,</code></pre></div>

<p>配置成功后，命令行执行 npm run serve，项目启动成功并在控制台输出了网址，打开此网址即可运行我们现有代码。当我们修改 index.js 内容时页面会自动刷新。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133154-wZhRjN-3.png" srcset="/img/loading.gif" lazyload alt="3.png"></p>
<h2 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h2><p>当项目功能体量很大页面元素较多时，使用 webpack-dev-server 实现页面整体刷新会影响开发体验，这时我们会考虑使用模块热替换。</p>
<p>模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。HMR 功能会在应用程序运行过程中，替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：</p>
<ul>
<li>重新加载页面期间保留应用程序状态。</li>
<li>只更新变更部分内容，节省开发时间。</li>
<li>在源代码 CSS&#x2F;JS 内容产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。</li>
</ul>
<h3 id="使用-HMR"><a href="#使用-HMR" class="headerlink" title="使用 HMR"></a>使用 HMR</h3><p>HMR 是 Webpack 内置的插件，我们可以通过 webpack-dev-server 配置来开启 HMR。</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
    ...
    devServer: &#123;
        hot: <span class="hljs-literal">true</span>,
    &#125;
&#125;</code></pre></div>

<p>上面的配置产生的结果是 Webpack 为每个模块绑定一个 module.hot 对象，这个对象可以调用 HMR 的 API。通过这些 API 我们可以对特定模块开启或关闭热替换。</p>
<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;
  <span class="hljs-keyword">return</span> a + b;
&#125;;

<span class="hljs-keyword">const</span> addRes = <span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);
<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);
divElement.<span class="hljs-property">innerHTML</span> = addRes;
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);

<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>) &#123;
  <span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">accept</span>()
&#125;</code></pre></div>

<p>启动项目后可以在页面上看到结果 8，当修改 add 函数中的参数时，页面上 8 并没有清空，HMR 会使应用在当前浏览器环境下又执行来一遍 index.js (包括其依赖的模块)内容，但是页面本身并没有刷新。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133154-debqqW-4.png" srcset="/img/loading.gif" lazyload alt="4.png"></p>
<p>调用 HMR API 可以如上面例子中手动调用，我们还可以借助现成的工具去调用，如 react-hot-loader、vue-loader 等。喜欢的小伙伴可以自行研究。</p>
<h1 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h1><p>本章我们介绍了 Webpack 开发环境下的常用的配置和插件以及如何使用 HMR。篇幅有限只写了些项目中用到的，Webpack 周边实用插件很多，感兴趣的小伙伴儿可以选择一些去使用一下，这对于了解 Webpack 也会有很大帮助。</p>
<h3 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h3><h1 id="生产环境调优"><a href="#生产环境调优" class="headerlink" title="生产环境调优"></a>生产环境调优</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>在实际的项目中，我们经常会有区分环境的需求，如本地环境、测试环境、生产环境。不同的环境往往对应一些不同的配置，如 mode、环境变量等，如何通过 webpack 按照不同环境采用不同配置呢？一般有以下两种方式。</p>
<p>1、使用同一个配置文件，不同环境传入不同变量来控制配置</p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java">...
<span class="hljs-type">const</span> <span class="hljs-variable">NODE_ENV</span> <span class="hljs-operator">=</span> process.env.NODE_ENV;
<span class="hljs-type">const</span> <span class="hljs-variable">isDev</span> <span class="hljs-operator">=</span> NODE_ENV === <span class="hljs-string">&#x27;development&#x27;</span>;

<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
    mode: NODE_ENV,
    devtool: isDev ? <span class="hljs-string">&#x27;source-map&#x27;</span> : <span class="hljs-string">&#x27;inline-source-map&#x27;</span>,
    ...
&#125;</code></pre></div>

<p>package.json</p>
<div class="code-wrapper"><pre><code class="hljs awk">&#123;
  ...
  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;
    <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;NODE_ENV=development webpack&quot;</span>, <span class="hljs-regexp">//</span> 开发环境
    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;NODE_ENV=production webpack&quot;</span> <span class="hljs-regexp">//</span> 生产环境
  &#125;
&#125;</code></pre></div>

<p>上面的配置中，通过在 package.json 中修改 NPM Scripts，传入 NODE_ENV 变量。开发环境参数值为 development，生产环境参数值为 production。在 webpack 配置文件中使用 Node.js 的 process 对象获取传入的参数。执行 npm run dev 即执行开发环境配置，生成的打包文件中包含 source map 文件同时 index.js 中包含 source map 映射路径。执行 npm run build 同理执行生产环境配置，生成的打包文件中 index.js 文件不包含 source map 映射路径。至此我们成功的区分了不同环境。</p>
<p>2、为不同环境创建各自的配置文件</p>
<p>生产环境创建一个 prod.config.js 文件，开发环境配置一个 dev.config.js 文件，修改 package.json 中的 scripts，不同命令执行不同的配置文件。</p>
<p>prod.config.js</p>
<div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);

<span class="hljs-built_in">module</span>.exports = &#123;
  mode: <span class="hljs-string">&#x27;production&#x27;</span>,
  devtool: <span class="hljs-string">&#x27;hidden-source-map&#x27;</span>,
  entry: &#123;
    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
  &#125;,
  <span class="hljs-built_in">output</span>: &#123;
    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),
    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,
  &#125;,
&#125;</code></pre></div>

<p>dev.config.js</p>
<div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);

<span class="hljs-built_in">module</span>.exports = &#123;
  mode: <span class="hljs-string">&#x27;development&#x27;</span>,
  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>,
  entry: &#123;
    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
  &#125;,
  <span class="hljs-built_in">output</span>: &#123;
    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),
    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,
  &#125;,
&#125;</code></pre></div>

<p>package.json</p>
<div class="code-wrapper"><pre><code class="hljs awk">&#123;
  ...
  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;
    <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack --config=dev.config.js&quot;</span>, <span class="hljs-regexp">//</span> 开发环境
    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --config=prod.config.js&quot;</span> <span class="hljs-regexp">//</span> 生产环境
  &#125;
&#125;</code></pre></div>

<p>上面的两个配置文件中，项目入口出口都一样，只有打包模式和 source map 模式不同，分别执行 npm run dev 和 npm run build 可以看到生成文件内容不同。对于需要多种环境配置的文件中，我们可以将环境中共用的部分如入口、出口等配置提取出来放在一个公共配置中，将公共配置提取到 common.config.js 中，个性化配置放在不同环境对应的配置中，通过 webpack-merge 插件将配置组合起来。下面以生产环境配置为例。</p>
<p>prod.config.js</p>
<div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">commonConfig</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;./common.config.js&#x27;</span>);
<span class="hljs-keyword">const</span> &#123; merge &#125; = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);

module.exports = <span class="hljs-title function_ invoke__">merge</span>(commonConfig, &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>,
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;hidden-source-map&#x27;</span>
&#125;);</code></pre></div>

<p>common.config.js</p>
<div class="code-wrapper"><pre><code class="hljs lua">...
<span class="hljs-built_in">module</span>.exports = &#123;
  entry: &#123;
    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
  &#125;,
  <span class="hljs-built_in">output</span>: &#123;
    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),
    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,
  &#125;,
  ...
&#125;;</code></pre></div>

<p>执行打包命令后查看输出文件，可以看到输出内容与单独配置无异。</p>
<h2 id="区分环境变量"><a href="#区分环境变量" class="headerlink" title="区分环境变量"></a>区分环境变量</h2><p>通常我们需要为生产环境和本地环境添加不同的环境变量，在 Webpack 中可以使用 DefinePlugin 进行设置，在 5.1 章节我们已经对 DefinePlugin 配置做过详细的介绍，所以下面我们只加一个区分服务地址的配置。</p>
<p>prod.config.js</p>
<div class="code-wrapper"><pre><code class="hljs lasso"><span class="hljs-params">...</span>
const webpack = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);

module.exports = &#123;
   <span class="hljs-params">...</span>
    plugins: <span class="hljs-meta">[</span>
        <span class="hljs-params">...</span>
        <span class="hljs-literal">new</span> webpack.DefinePlugin(&#123;
            BASE_URL: <span class="hljs-string">&#x27;http://ip:8201&#x27;</span>
        &#125;)
    <span class="hljs-meta">]</span>
&#125;</code></pre></div>

<p>dev.config.js</p>
<div class="code-wrapper"><pre><code class="hljs lasso"><span class="hljs-params">...</span>
const webpack = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);

module.exports = &#123;
   <span class="hljs-params">...</span>
    plugins: <span class="hljs-meta">[</span>
        <span class="hljs-params">...</span>
        <span class="hljs-literal">new</span> webpack.DefinePlugin(&#123;
            BASE_URL: <span class="hljs-string">&#x27;http://localhost:8201&#x27;</span>
        &#125;)
    <span class="hljs-meta">]</span>
&#125;</code></pre></div>

<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs arcade">...
<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(BASE_URL)</code></pre></div>

<p>执行不同环境的打包命令，即可区分不同的服务地址。</p>
<h2 id="资源压缩"><a href="#资源压缩" class="headerlink" title="资源压缩"></a>资源压缩</h2><p>在将项目资源发布到线上环境前，我们通常会进行代码压缩，或者叫 uglify，意思是移除空格并混淆代码，一般在压缩后代码体积会变小同时代码变得不可读，在一定程度上增加了安全性。</p>
<h3 id="压缩-JavaScript"><a href="#压缩-JavaScript" class="headerlink" title="压缩 JavaScript"></a>压缩 JavaScript</h3><p>Webpack 5 中已经集成了 terser-webpack-plugin 来压缩我们的代码，当我们在 webapck.config.js 中 mode 设置为 production 时，打包后的代码会被压缩。如果想自定义添加压缩配置，我们需要安装 <a href="https://leetcode.cn/link/?target=https://www.npmjs.com/package/terser-webpack-plugin">terser-webpack-plugin</a>，下面以删除代码中 console.log 为例。</p>
<p>安装 terser-webpack-plugin</p>
<div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> terser-webpack-plugin -D</code></pre></div>

<p>prod.config.js</p>
<div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TerserPlugin</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;terser-webpack-plugin&#x27;</span>);
...
module.exports = <span class="hljs-title function_ invoke__">merge</span>(commonConfig, &#123;
  ...
  <span class="hljs-attr">optimization</span>: &#123;
    // 在不设置 mode 的情况下，minimize 设置为 <span class="hljs-literal">true</span> 也会开启压缩
    // <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">minimizer</span>: [
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>(&#123;
        <span class="hljs-attr">terserOptions</span>: &#123;
          <span class="hljs-attr">compress</span>: &#123;
            <span class="hljs-attr">pure_funcs</span>: [<span class="hljs-string">&#x27;console.log&#x27;</span>],
          &#125;,
        &#125;,
      &#125;),
    ],
  &#125;,
&#125;);</code></pre></div>

<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;
   <span class="hljs-keyword">return</span> a + b
&#125;
<span class="hljs-keyword">const</span> addRes = <span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>);
<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);
divElement.<span class="hljs-property">innerHTML</span> = addRes;
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(addRes);</code></pre></div>

<p>执行打包命令后，可以看到生成的 bundle 文件中已经移除了 console.log 代码。</p>
<h3 id="压缩-CSS"><a href="#压缩-CSS" class="headerlink" title="压缩 CSS"></a>压缩 CSS</h3><p>在压缩 CSS 文件之前，我们要先使用 MiniCssExtractPlugin 插件将样式文件提取出来，接着使用 <a href="https://leetcode.cn/link/?target=https://github.com/webpack-contrib/css-minimizer-webpack-plugin">css-minimizer-webpack-plugin</a> 插件进行压缩。</p>
<p>css-minimizer-webpack-plugin 插件开启压缩的配置方式也是传入到 minimizer 中，与 terser-webpack-plugin 类似，只是传入压缩插件本身的配置不同。</p>
<p>安装 css-minimizer-webpack-plugin</p>
<div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> css-minimizer-webpack-plugin -D</code></pre></div>

<p>prod.config.js</p>
<div class="code-wrapper"><pre><code class="hljs php">...
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MiniCssExtractPlugin</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CssMinimizerPlugin</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;css-minimizer-webpack-plugin&#x27;</span>);
module.exports = <span class="hljs-title function_ invoke__">merge</span>(commonConfig, &#123;
  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;hidden-source-map&#x27;</span>,
  <span class="hljs-attr">module</span>: &#123;
    <span class="hljs-attr">rules</span>: [
      &#123;
        <span class="hljs-attr">test</span>: /\.css$/i,
        <span class="hljs-attr">use</span>: [
          &#123;
            <span class="hljs-attr">loader</span>: MiniCssExtractPlugin.loader,
            <span class="hljs-attr">options</span>: &#123;
              <span class="hljs-attr">esModule</span>: <span class="hljs-literal">true</span>,
            &#125;,
          &#125;,
          <span class="hljs-string">&#x27;css-loader&#x27;</span>,
        ],
      &#125;,
    ],
  &#125;,
  <span class="hljs-attr">optimization</span>: &#123;
    <span class="hljs-attr">minimizer</span>: [
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>(),
    ],
  &#125;,
  plugins: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>()],
&#125;);</code></pre></div>

<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;
<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);
divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;demo&#x27;</span>;
divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;demo&#x27;</span>;
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div>

<p>index.css</p>
<div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;
    <span class="hljs-attribute">color</span>: red;
&#125;</code></pre></div>

<p>执行 npm run build，可以看到打包文件中的 index.css 文件内容已被压缩。</p>
<h2 id="资源体积监控"><a href="#资源体积监控" class="headerlink" title="资源体积监控"></a>资源体积监控</h2><p>在实际的项目开发中，webpack 打包的体积速度往往是我们比较关注的问题，我们可以通过打包后输出文件包的大小来分析每个模块的体积，但这种反向分析往往会花费很多时间。VS Code 中有一个插件 Import Cost 可以帮助我们持续监控引入模块（主要是node_module中的模块）的大小。它会为我们计算该模块压缩后及 gzip 后将占多大体积。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658308914-XbQYTe-1.png" srcset="/img/loading.gif" lazyload alt="1.png"></p>
<p>当我们发现某些包过大就可以采取一些措施，比如 lodash 中只引入使用到的子模块。</p>
<p>另外一个很有用的工具是 <a href="https://leetcode.cn/link/?target=https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a>，它能帮助我们分析 bundle 的构成，webpack-bundle-analyzer 可以帮我们生成一张 bundle 的模块组成结构图，每个模块所占的体积一目了然。</p>
<p>安装 webpack-bundle-analyzer</p>
<div class="code-wrapper"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>webpack-<span class="hljs-keyword">bundle-analyzer </span>-D</code></pre></div>

<p>prod.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java">...
<span class="hljs-type">const</span> <span class="hljs-variable">BundleAnalyzerPlugin</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&#x27;webpack-bundle-analyzer&#x27;</span>).BundleAnalyzerPlugin;
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = merge(commonConfig, &#123;
  ...
  plugins: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>()
  ]
&#125;);</code></pre></div>

<p>执行打包命令后，浏览器中会启动 bundle 组成结构图，包括各模块体积。</p>
<p>最后我们还可以自动化的对资源体积进行监控，<a href="https://leetcode.cn/link/?target=https://github.com/siddharthkp/bundlesize">bundlesize</a> 可以帮我们做到这一点。</p>
<p>安装 bundlesize</p>
<div class="code-wrapper"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span><span class="hljs-keyword">bundlesize </span>-D</code></pre></div>

<p>package.json</p>
<div class="code-wrapper"><pre><code class="hljs prolog">&#123;
  ...
  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;
    <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;bundlesize&quot;</span>,
    <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack --config dev.config.js&quot;</span>,
    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack  --config prod.config.js&quot;</span>
  &#125;,
  <span class="hljs-string">&quot;bundlesize&quot;</span>: [
    &#123;
      <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./dist/index.js&quot;</span>,
      <span class="hljs-string">&quot;maxSize&quot;</span>: <span class="hljs-string">&quot;1 kB&quot;</span>
    &#125;
  ],
&#125;</code></pre></div>

<p>执行 npm test 控制台中可以看到检测结果。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658308914-tVnWpa-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<h1 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h1><p>本章我们介绍了在生产环境下可以做哪些配置。我们介绍了使用配置文件区分环境、传入不同环境变量、如何开启压缩并且如何做自定义压缩、监控输出资源体积等方法。对于使用的插件都只是简单介绍了如何使用，详细的配置可以参照官网。</p>
<h3 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h3><h1 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h1><p>所谓 tree-shaking 就是 “摇树” 的意思，可以将应用程序想象成一棵树。绿色表示实际用到的 source code(源码) 和 library(库)，是树上活的树叶。灰色表示未引用代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。</p>
<div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">tree</span> shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-<span class="hljs-meta">code</span>)。它依赖于 ES2015 模块语法的静态结构特性，例如 <span class="hljs-meta">import</span> 和 <span class="hljs-meta">export</span>。这个术语和概念实际上是由 ES2015 模块打包工具 rollup 普及起来的。

<span class="hljs-symbol">webpack</span> <span class="hljs-number">2</span> 正式版本内置支持 ES2015 模块（也叫做 harmony modules）和未使用模块检测能力。新的 webpack <span class="hljs-number">4</span> 正式版本扩展了此检测能力，通过 package.json 的 <span class="hljs-string">&quot;sideEffects&quot;</span> 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 <span class="hljs-string">&quot;pure(纯正 ES2015 模块)&quot;</span>，由此可以安全地删除文件中未使用的部分。</code></pre></div>



<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>tree shaking 会在编译过程中将未使用的代码进行标记，在 uglify 时移除被标记的无效代码，在 mode 设置为 production 时，webpack 会开启压缩和 tree-shaking 等优化，下面的例子如果配置为生产模式，打包后未使用的引用会被移除掉。</p>
<p>1、将 mode 设置为 none（不使用任何打包优化），optimization 配置中增加 usedExports 。</p>
<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// add 只是导入没有使用</span>
<span class="hljs-keyword">import</span> &#123; add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./util.js&#x27;</span>;

<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);
divElement.<span class="hljs-property">innerHTML</span> = addRes;
divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;demo&#x27;</span>;
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div>

<p>util.js</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 导出 add 函数
<span class="hljs-keyword">export</span> const add = <span class="hljs-function"><span class="hljs-params">(a, b)</span> =&gt;</span> &#123;
   <span class="hljs-keyword">return</span> a + b
&#125;</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java">...
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  mode: <span class="hljs-string">&#x27;none&#x27;</span>, <span class="hljs-comment">// 不使用任何默认优化选项</span>
  optimization: &#123;
    <span class="hljs-comment">// 告诉 Webpack 去决定每一个模块所用到的导出</span>
    usedExports: <span class="hljs-literal">true</span>,
  &#125;,
&#125;;</code></pre></div>

<p>执行打包命令后，查看 dist&#x2F;index.js 中的代码。可以看到 index.js 中只做了导入但是没有调用的方法 add 被打了 unused harmony export 的注释。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133349-fQAuwK-1.png" srcset="/img/loading.gif" lazyload alt="1.png"><br>2、package.json 中增加 sideEffects: false</p>
<div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span></code></pre></div>

<p>webpack.config.js 中移除 optimization 配置，index.js 与 util.js 中内容不变，执行打包命令后，可以看到打包后的 index.js 中 add 函数已经被移除。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133349-VbRkfR-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<h2 id="sideEffects-与-usedExports"><a href="#sideEffects-与-usedExports" class="headerlink" title="sideEffects 与 usedExports"></a>sideEffects 与 usedExports</h2><p>在了解上面两个参数区别之前，我们先来看下函数的副作用。</p>
<div class="code-wrapper"><pre><code class="hljs">函数副作用是指函数在正常工作任务之外对外部环境所施加的影响。具体地说，函数副作用是指函数被调用，完成了函数既定的计算任务，但同时因为访问了外部数据，尤其是因为对外部数据进行了写操作，从而一定程度地改变了系统环境。</code></pre></div>

<p>在上面例子中我们在 index.js 中导入的 util.js 中导出了一个 add 函数，我们来看下这个函数。</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">export</span> const add = <span class="hljs-function"><span class="hljs-params">(a, b)</span> =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> a + b
&#125;</code></pre></div>

<p>add 函数中接收了 a 和 b 两个参数，函数体中返回了 a 与 b 的和，此函数返回的结果只依赖于传入的值并且没有其他影响，如修改全局变量等操作，则此函数即为无副作用函数。</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">export</span> const add = <span class="hljs-function"><span class="hljs-params">(a, b)</span> =&gt;</span> &#123;
  window.userName = <span class="hljs-string">&#x27;***&#x27;</span>
  <span class="hljs-keyword">return</span> a + b
&#125;</code></pre></div>

<p>上面的 add 函数除了返回了 a 与 b 的和的同时还修改了 window对象中属性的值，则此函数即为有副作用的函数。</p>
<p>简单了解了函数副作用，我们来看下 sideEffects 和 usedExports（更多被认为是 tree shaking）的两种不同的优化方式。</p>
<ul>
<li>usedExports 依赖于 terser 去检测语句中的副作用，对未使用的函数增加标记，之后交由压缩工具去移除死代码。</li>
</ul>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java">...
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  ...
  mode: <span class="hljs-string">&#x27;none&#x27;</span>, <span class="hljs-comment">// 不使用任何默认优化选项</span>
  optimization: &#123;
    <span class="hljs-comment">// 告诉 Webpack 去决定每一个模块所用到的导出</span>
    usedExports: <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// 开启压缩</span>
    minimize: <span class="hljs-literal">true</span>
  &#125;,
&#125;;</code></pre></div>

<p>index.js 与 util.js 内容保持不变，在 webpack.config.js 的 optimization 配置中增加参数 minimize 为 true，打包成功后查看输出文件，可以看到之前被打了 unused harmony export 注释的代码被移除掉了。</p>
<p>下面我们来写一个带有副作用的方法，看看 usedExports 会如何处理。</p>
<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./util.js&#x27;</span>;

<span class="hljs-keyword">const</span> divElement = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);
divElement.innerHTML = <span class="hljs-string">&#x27;demo&#x27;</span>;
divElement.className = <span class="hljs-string">&#x27;demo&#x27;</span>;
<span class="hljs-built_in">document</span>.body.appendChild(divElement);</code></pre></div>

<p>util.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">custom</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;custom&#x27;</span>);
&#125;;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;
  <span class="hljs-keyword">return</span> a + b;
&#125;;</code></pre></div>

<p>util.js 中修在 Array 原型链上增加了方法，所以是 util.js 是有副作用的，在 index.js 中我们不只导入 add 方法而是导入整个 util.js 文件，执行打包命令后可以查看 dist&#x2F;index.js 文件中 add 方法已被删除，有副作用的部分依然在打包文件中。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133349-ptzduw-3.png" srcset="/img/loading.gif" lazyload alt="3.png"></p>
<ul>
<li>sideEffects 更为有效 是因为它允许跳过整个模块&#x2F;文件和整个文件子树</li>
</ul>
<p>在一个纯粹的 ESM 模块世界中，很容易识别出哪些文件有副作用。然而，我们的项目无法达到这种纯度，所以，此时有必要提示 webpack compiler 哪些代码是“纯粹部分”。</p>
<p>通过 package.json 的 “sideEffects” 属性，来实现这种方式。如果所有代码都不包含副作用，我们就可以将 sideEffects 标记为 false，来告诉 webpack 它可以跳过安全检测删除未用到的 export。</p>
<p>依然使用上面包含副作用的代码。来看下增加 sideEffects: false 的效果。</p>
<p>package.json</p>
<div class="code-wrapper"><pre><code class="hljs jboss-cli">&#123;
  <span class="hljs-string">//</span> <span class="hljs-string">...</span>
  <span class="hljs-string">&quot;sideEffects&quot;</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-string">//</span> <span class="hljs-string">...</span>
&#125;</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-built_in">module</span>.exports = &#123;
  mode: <span class="hljs-string">&#x27;none&#x27;</span>,
  entry: &#123;
    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
  &#125;,
  <span class="hljs-built_in">output</span>: &#123;
    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),
    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,
  &#125;
&#125;;</code></pre></div>

<p>执行打包命令后查看 dist&#x2F;index.js 文件，可以看到包含副作用的代码也被移除，即 util.js 导入部分被全部移除。</p>
<p>项目中包含副作用的函数被移除在打包后会导致部分功能不可用，所以 sideEffects 支持传入参数，告知 webpack 传入的文件包含副作用不要移除。</p>
<p>上面的例子中修改 package.json 的配置，将包含副作用的文件传入进去。此数组支持简单的 glob 模式匹配相关文件。其内部使用了 glob-to-regexp（支持：*，**，{a,b}，[a-z]）。如果匹配模式为 *.css，且不包含 &#x2F;，将被视为 **&#x2F;*.css。</p>
<p>package.json</p>
<div class="code-wrapper"><pre><code class="hljs awk">&#123;
 <span class="hljs-regexp">//</span> ...
  <span class="hljs-string">&quot;sideEffects&quot;</span>: [<span class="hljs-string">&quot;./src/util.js&quot;</span> ], 
 <span class="hljs-regexp">//</span> ...
&#125;</code></pre></div>

<p>执行打包命令后查看输出文件，可以看到只有导入但是没使用的 add 函数和 Array 方法都被保留了下来。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133349-FHjQKm-4.png" srcset="/img/loading.gif" lazyload alt="4.png"></p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="tree-shaking-开启条件"><a href="#tree-shaking-开启条件" class="headerlink" title="tree shaking 开启条件"></a>tree shaking 开启条件</h2><p>tree shaking 需要使用 ES2015 模块语法（即 import 和 export）才能生效，有时我们会发现只引用了某个库中的一个方法，却把整个库都加载进来了，同时 bundle 的体积也并没有因为 tree shaking 而减少。这可能是该库不是使用 ESModule 模式导出的，所以在使用某个库时，我们尽量引入 es 版，按需加载，这样 tree shaking 才能将无用代码删除掉。</p>
<h1 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h1><p>为了利用 tree shaking 的优势， 我们必须</p>
<ul>
<li>使用 ES2015 模块语法（即 import 和 export）。</li>
<li>确保没有编译器将您的 ES2015 模块语法转换为 CommonJS 的（顺带一提，这是现在常用的 @babel&#x2F;preset-env 的默认行为，详细信息请参阅文档）。</li>
<li>在项目的 package.json 文件中，添加 “sideEffects” 属性。</li>
<li>使用 mode 为 “production” 的配置项以启用更多优化项，包括压缩代码与 tree shaking。</li>
</ul>
<h1 id="代码分离及懒加载"><a href="#代码分离及懒加载" class="headerlink" title="代码分离及懒加载"></a>代码分离及懒加载</h1><p>前端性能优化一直是围绕在每一个前端周围的话题，减少网络请求、减少加载 bundle 体积、外部资源放在 CDN 等等。对于性能优化 webpack 也提供了一些手段。下面让我们来了解下代码分离、缓存和懒加载。</p>
<h2 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h2><p>代码分离是 webpack 最引人注目的特性之一，试想如果项目中所有代码都打包到一个 bundle 中，那 bundle 的体积将会变大，这对首次访问页面来说，加载资源的请求时间会变长，将影响用户体验。所以前端性能优化的一个方向是将代码按照一定规则拆分到不同的 bundle 中，触发不同的功能加载不同的资源，这样除了减少资源体积外还能增快请求响应速度。不过拆分的粒度大小还是要看实际的项目需求，无限拆分资源包也会造成资源请求过多。所以对于代码分离我们要结合项目情况合理使用，这会极大影响加载时间。</p>
<p>常用的代码分离方法有三种：</p>
<ul>
<li><p>入口分离：使用 entry 配置手动地分离代码。</p>
</li>
<li><p>去重分离：使用 Entry dependencies 或者 SplitChunksPlugin 去重和分离 chunk。</p>
</li>
<li><p>动态导入：通过模块的内联函数调用来分离代码。</p>
</li>
</ul>
<h3 id="入口分离"><a href="#入口分离" class="headerlink" title="入口分离"></a>入口分离</h3><p>入口分离即从 webpack 入口文件配置处分离 bundle。这种分离方式根据项目的多个入口拆分出多个 bundle，这是所有分离方式中最简单的分离方式，不过这种方式也存在弊端即 输出的 bundle 会同时包含导入的三方依赖代码（重复代码），在后面的分离方式讲解中会解决这个问题。我们先来看看入口分离的例子。</p>
<p>src&#x2F;index.js</p>
<p>index.js 文件中引入依赖包 lodash 的 join 方法。创建 div 标签并将内容添加到 body 中。</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; join &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;
<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);
divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-title function_">join</span>([<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;index&#x27;</span>], <span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div>

<p>src&#x2F;main.js</p>
<p>main.js 文件中同样引入依赖包 lodash 的 join 方法。创建 div 标签并将内容添加到 body 中，只是展示内容与 index.js 不一致。</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; join &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;
<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);
divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-title function_">join</span>([<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>], <span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div>

<p>webpack.config.js</p>
<p>在 entry 配置中传入两个入口，chunk 的名字分别是 index 和 main。</p>
<div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);
...

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;
  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,
  <span class="hljs-attr">entry</span>: &#123;
    <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
    <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>
  &#125;,
  <span class="hljs-attr">output</span>: &#123;
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>,
  &#125;,
  <span class="hljs-attr">plugins</span>: [
    ...
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;
      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./index.html&#x27;</span>,
    &#125;),
  ],
&#125;;</code></pre></div>

<p>执行打包命令后，在 dist 文件夹下可以看到，同时输出了 mian.js 和 index.js 文件，通过配置 entry 实现了代码分离。我们分别打开 dist&#x2F;index.js 和 dist&#x2F;main.js 后可以看到两个 bundle 中都包含了 lodash 的源码。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133449-RzyRnm-1.png" srcset="/img/loading.gif" lazyload alt="1.png"></p>
<h3 id="去重分离"><a href="#去重分离" class="headerlink" title="去重分离"></a>去重分离</h3><p>在入口分离的基础上，我们继续优化将重复的部分单独分离出一个 bundle，在 entry 中配置 dependOn 选项，这样可以在多个 chunk 之间共享模块。</p>
<p>webpack.config.js</p>
<p>在 entry 配置中将两个入口文件按照对象的形式定义，除定义入口之外，增加了一个 dependOn 选项，传入的 vendor 为共享模块的 chunk 名称。</p>
<div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">const</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-type">const</span> <span class="hljs-variable">HtmlWebpackPlugin</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);
...

<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
 ...
 entry: &#123;
    index: &#123;
      <span class="hljs-keyword">import</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
      dependOn: <span class="hljs-string">&#x27;vendor&#x27;</span>,
    &#125;,
    main: &#123;
      <span class="hljs-keyword">import</span>: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,
      dependOn: <span class="hljs-string">&#x27;vendor&#x27;</span>,
    &#125;,
    vendor: <span class="hljs-string">&#x27;lodash&#x27;</span>
  &#125;,
&#125;;</code></pre></div>

<p>执行打包命令后，在 dist 文件夹下除了两个入口文件外还多了一个 vendor.js 文件，文件的内容即为 lodash 源码。HtmlWebpackPlugin 插件将三个 js 文件都注入到了 index.html 中。项目可以正常运行。</p>
<p>通过在入口配置 dependOn 属性，虽然可以实现公共代码抽离，但是还存在一个问题是，在我们的项目中会有很多公共代码，难道我们要手动的都添加到 dependOn 中吗？这将会增加非常多的工作量并且容易出错。这时我们可以考虑使用 webpack 的 SplitChunksPlugin 插件了。</p>
<h4 id="SplitChunksPlugin"><a href="#SplitChunksPlugin" class="headerlink" title="SplitChunksPlugin"></a>SplitChunksPlugin</h4><p><a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/plugins/split-chunks-plugin">SplitChunksPlugin</a> 插件不需要单独安装，是 webpack 提供的开箱即用的插件。我们通过 optimization 配置即可。</p>
<p>默认情况下，SplitChunksPlugin 它只会影响到按需加载的 chunks，不过我们可以通过传入 chunks 属性不同变量来决定影响哪些 chunk 。</p>
<p>webpack 将根据以下条件自动拆分 chunks：</p>
<ul>
<li>新的 chunk 可以被共享，或者模块来自于 node_modules 文件夹</li>
<li>新的 chunk 体积大于 20kb（在进行压缩和 gzip 之前的体积）</li>
<li>当按需加载 chunks 时，并行请求的最大数量小于或等于 30</li>
<li>当加载初始化页面时，并发请求的最大数量小于或等于 30</li>
</ul>
<p>我们使用 SplitChunksPlugin 来拆分下上个例子中的 lodash，关于 SplitChunksPlugin 的各项配置参数含义，感兴趣的伙伴可以查看<a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/plugins/split-chunks-plugin">官网</a></p>
<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs java">...

<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;
  entry: &#123;
    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,
    main: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,
  &#125;,
  optimization: &#123;
    splitChunks: &#123;
      <span class="hljs-comment">// 设置为 all 意味着 chunk 可以在异步和非异步 chunk 之间共享</span>
      chunks: <span class="hljs-string">&#x27;all&#x27;</span>,
    &#125;,
  &#125;,
  ...
&#125;;</code></pre></div>

<p>执行打包命令后，在 dist 文件夹下可以看到除了 index.js 和 main.js 外还输出了一个文件，打开文件可以看到内容正是 lodash。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133449-TQNPfm-2.png" srcset="/img/loading.gif" lazyload alt="2.png"></p>
<h2 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h2><p>动态导入也叫资源异步加载，当模块数量过多时，可以把一些暂时用不到的模块延迟加载，以此来减少用户初次加载页面的体积，后续模块等到恰当的时机再去加载，因此也把这种加载方式叫懒加载。</p>
<p>在 webpack 中提供了两种类似的技术来实现动态加载。import 函数及 require.ensure。require.ensure 是 Webpack 1 支持的异步加载方式，从 Webpack 2 开始引入了 import 函数，并且官方更推荐使用 import 函数的方式实现异步加载，因此下面我们只介绍 import 函数的使用。</p>
<p>通过 import 函数加载的模块会被异步的进行加载，并且返回一个 Primise 对象。</p>
<p>main.js</p>
<div class="code-wrapper"><pre><code class="hljs arcade">export const add = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;
  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a + b);
&#125;</code></pre></div>

<p>index.js</p>
<p>index 文件中通过 import 函数导入 main 文件内容并赋值给 addFunc，在 index 中通过 setTimeout 定时任务 2 秒钟后执行 addFunc 回调函数，在回调函数返回值中通过 ES6 的对象解构语法获取到 add 函数。</p>
<div class="code-wrapper"><pre><code class="hljs coffeescript">const addFunc = <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./main&#x27;</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;
  addFunc.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(&#123;add&#125;)</span> =&gt;</span> &#123;
    add(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>);
  &#125;);
&#125;, <span class="hljs-number">2000</span>);</code></pre></div>

<p>webpack.config.js</p>
<div class="code-wrapper"><pre><code class="hljs lua">...

<span class="hljs-built_in">module</span>.exports = &#123;
  mode: <span class="hljs-string">&#x27;development&#x27;</span>,
  entry: &#123;
    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>
  &#125;,
  <span class="hljs-built_in">output</span>: &#123;
    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),
    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,
  &#125;,
  ...
&#125;;</code></pre></div>

<p>通过 webpack.config.js 配置我们可以看到入口文件只有 index.js，执行打包命令后在生成的 dist 文件夹中可以看到除了入口文件 index.js 外，还生成了一个 src_main_js.js 的文件，内容即为 src&#x2F;main.js 中内容对应的编译后代码。</p>
<p>通过 import 函数异步加载文件也可以实现拆分代码的功能，这种方式在实际的项目开发中非常实用，非主页面加载的内容都可以通过 import 函数动态加载，在点击到对应页面时在加载相应资源。</p>
<p>上面的例子中还可以进一步优化下异步加载文件的 chunk 名称。其他配置不变，我们修改下 import 导入函数部分。</p>
<p>index.js</p>
<div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> addFunc = <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;main&quot; */</span> <span class="hljs-string">&#x27;./main&#x27;</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
  addFunc.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123;add&#125;</span>) =&gt;</span> &#123;
    <span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>);
  &#125;);
&#125;, <span class="hljs-number">2000</span>);</code></pre></div>

<p>通过在 import 函数中增加注释 &#x2F;* webpackChunkName: “main” *&#x2F; 其中的 main 即为生成的 chunk 名称。这样在项目中通过定义语义化的名称，可以增加代码的可读性。</p>
<p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133449-eDWOYE-3.png" srcset="/img/loading.gif" lazyload alt="3.png"></p>
<h1 id="总结-24"><a href="#总结-24" class="headerlink" title="总结"></a>总结</h1><p>上面的示例中，我们总结了代码分离的几种方式，分别是入口分离、去重分离、动态导入，其中的动态导入就是我们常说的懒加载。代码分离对于减少主包体积，优化项目加载速度，减少白屏时间来说将非常有用。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/leetcode/" class="category-chain-item">leetcode</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/webpack/">#webpack</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>webpack攻略</div>
      <div>http://serendipity0321.github.com/2023/01/29/webpack攻略/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年1月29日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/01/29/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/" title="面试的区别">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">面试的区别</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/28/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/" title="前端通关手册-React">
                        <span class="hidden-mobile">前端通关手册-React</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
