<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>面试的区别 | serendipity0321's blog</title><meta name="author" content="蓉"><meta name="copyright" content="蓉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 箭头函数和普通函数的区别a. 箭头函数和普通函数的样式不同，箭头函数语法更加简洁、清晰，箭头函数是&#x3D;&gt;定义函数,普通函数是function定义函数。   b. 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，定义的时候就确定并固定了。   c. 箭头函数不能作为构造函数使用，也不能使用new关键字(因为箭头函数没有自己的this，它的this其实是继承了外层执行环">
<meta property="og:type" content="article">
<meta property="og:title" content="面试的区别">
<meta property="og:url" content="http://serendipity0321.github.com/2023/01/29/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/index.html">
<meta property="og:site_name" content="serendipity0321&#39;s blog">
<meta property="og:description" content="1. 箭头函数和普通函数的区别a. 箭头函数和普通函数的样式不同，箭头函数语法更加简洁、清晰，箭头函数是&#x3D;&gt;定义函数,普通函数是function定义函数。   b. 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，定义的时候就确定并固定了。   c. 箭头函数不能作为构造函数使用，也不能使用new关键字(因为箭头函数没有自己的this，它的this其实是继承了外层执行环">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-01-29T03:14:58.000Z">
<meta property="article:modified_time" content="2023-02-17T14:02:13.857Z">
<meta property="article:author" content="蓉">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2022/10/08/k5M7H1NdmnZgtlY.png"><link rel="canonical" href="http://serendipity0321.github.com/2023/01/29/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 蓉","link":"链接: ","source":"来源: serendipity0321's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试的区别',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-17 22:02:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/10/02/SRY7qntDHQe5l9F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="serendipity0321's blog"><span class="site-name">serendipity0321's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试的区别</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-29T03:14:58.000Z" title="发表于 2023-01-29 11:14:58">2023-01-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-17T14:02:13.857Z" title="更新于 2023-02-17 22:02:13">2023-02-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试的区别"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-箭头函数和普通函数的区别"><a href="#1-箭头函数和普通函数的区别" class="headerlink" title="1. 箭头函数和普通函数的区别"></a>1. 箭头函数和普通函数的区别</h2><p>a. 箭头函数和普通函数的样式不同，箭头函数语法更加简洁、清晰，箭头函数是<code>=&gt;</code>定义函数,普通函数是<code>function</code>定义函数。  </p>
<p>b. 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，定义的时候就确定并固定了。  </p>
<p>c. 箭头函数不能作为构造函数使用，也不能使用new关键字(<code>因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的this，且this指向永远不会改变,作为构造函数其的this要是指向创建的新对象</code>)。  </p>
<p>d. 箭头函数没有自己的arguments。在箭头函数中访问arguments实际上获得的是外层局部（函数）执行环境中的值。  </p>
<p>e. call、apply、bind 并不会影响其 this 的指向。  </p>
<p>f. 箭头函数没有原型prototype。  </p>
<p>g. 箭头函数不能当作 Generator 函数，不能使用 yield 关键字。  </p>
<h2 id="2-var，let和const之间的区别"><a href="#2-var，let和const之间的区别" class="headerlink" title="2. var，let和const之间的区别"></a>2. var，let和const之间的区别</h2><p>从以下<code>三个方面</code>说。  </p>
<p><strong>变量提升方面</strong>：var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined。<br>let和const不存在变量提升问题(<code>注意这个‘问题’后缀，其实是有提升的，只不过是let和const具有一个暂时性死区的概念，即没有到其赋值时，之前就不能用</code>)，即它们所声明的变量一定要在声明后使用，否则报错。  </p>
<p><strong>块级作用域方面</strong>：var不存在块级作用域,let和const存在块级作用域  </p>
<p><strong>声明方面</strong>：var允许重复声明变量,let和const在同一作用域不允许重复声明变量。其中const声明一个只读的常量(因为如此，其声明时就一定要赋值，不然报错)。一旦声明，常量的值就不能改变。  </p>
<p><strong>如何使const声明的对象内属性不可变，只可读呢？</strong><br>如果const声明了一个对象，对象里的属性是可以改变的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;<span class="attr">name</span>:<span class="string">&#x27;蟹黄&#x27;</span>&#125;;</span><br><span class="line">obj.<span class="property">name</span>=<span class="string">&#x27;同学&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);<span class="comment">//同学</span></span><br></pre></td></tr></table></figure>

<p>因为const声明的obj只是保存着其对象的<strong>引用地址</strong>，只要地址不变，就不会出错。  </p>
<p>使用<code>Object.freeze(obj)</code> 冻结obj,就能使其内的属性不可变,但它有局限，就是obj对象中要是有属性是对象，该对象内属性还能改变，要全不可变，就需要使用递归等方式一层一层全部冻结。</p>
<h2 id="3-Bigint和Number的区别"><a href="#3-Bigint和Number的区别" class="headerlink" title="3. Bigint和Number的区别"></a>3. Bigint和Number的区别</h2><p>Number类型的数字<strong>有精度限制</strong>，数值的精度只能到 53 个二进制位（相当于 16 个十进制位, <code>正负9007199254740992</code>），大于这个范围的整数，就无法精确表示了。  </p>
<p>Bigint<strong>没有位数的限制，任何位数的整数都可以精确表示</strong>。但是其只能用于表示整数，且为了与Number进行区分，BigInt 类型的数据必须添加后缀n。BigInt 可以使用负号（-），但是不能使用正号（+）。  </p>
<p>另外number类型的数字和Bigint类型的数字<strong>不能</strong>混合计算。</p>
<p><code>12n+12;//报错</code></p>
<h2 id="4-基本数据类型和引用数据类型的区别"><a href="#4-基本数据类型和引用数据类型的区别" class="headerlink" title="4. 基本数据类型和引用数据类型的区别"></a>4. 基本数据类型和引用数据类型的区别</h2><p><strong>基本数据类型：</strong><br>a. 基本数据类型的值是不可变的(重新赋值属于改变属性名的指向了，而不是对值进行操作),这里你就可以联想到，<code>是不是所有关于字符串和数字的方法</code>都是带有<code>返回值</code>的，而不是改变原字符串或数字。<br>例如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">a.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//abc</span></span><br></pre></td></tr></table></figure>

<p>b. 基本数据类型不可以添加属性和方法，虽然不会报错，但也只是一瞬间转为了相应包装对象，操作完又转化回原基本数据类型，不会保存结果。  </p>
<p>c. 基本数据类型的赋值是简单赋值,基本数据类型的比较是值的比较。  </p>
<p>d. 基本数据类型是存放在栈区的  </p>
<p><strong>引用数据类型：</strong><br>a. 引用类型的值是可以改变的,例如对象就可以通过修改对象属性值更改对象。  </p>
<p>b. 引用类型可以添加属性和方法。  </p>
<p>c. 引用类型的赋值是对象引用,即声明的变量标识符，存储的只是对象的指针地址。  </p>
<p>d. 引用类型的比较是引用(<code>指针地址</code>)的比较。  </p>
<p>e. 引用类型是同时保存在栈区和堆区中的,栈区保存变量标识符和指向堆内存的地址。  </p>
<h2 id="5-defer和async的区别"><a href="#5-defer和async的区别" class="headerlink" title="5. defer和async的区别"></a>5. defer和async的区别</h2><p><code>大家应该都知道在script标签内有这两个属性async和defer，例如&lt;script src=&quot;./home.js&quot; async defer&gt;&lt;/script&gt;</code>  </p>
<p><strong>defer</strong>：中文意思是延迟。用途是表示脚本会被延迟到整个页面都解析完毕后再运行。因此，在<code>&lt;script&gt;</code>元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。<br>HTML5规范要求脚本按照它们出现的<code>先后顺序执行</code>，因此第一个延迟脚本会先于第二个延迟脚本执行,但执行脚本之间<code>存在依赖，需要有执行的先后顺序时</code>，就可以使用<code>defer</code>,延迟执行。我觉得把script脚本放在body底部和defer差不多。</p>
<p><strong>async</strong>：中文意思是异步，这个属性与defer类似，都用于改变处理脚本的行为。同样与defer类似，async只适用于外部脚本文件，并告诉浏览器立即下载文件。当页面继续进行解析时，脚本将被执行。与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。<br>指定async属性的目的是不让页面等待两个脚本下载和执行，从而<code>异步加载页面</code>其他内容,这使用于之间<code>互不依赖</code>的各脚本。</p>
<h2 id="看到这里，就能知道其的一些作用了"><a href="#看到这里，就能知道其的一些作用了" class="headerlink" title="看到这里，就能知道其的一些作用了"></a>看到这里，就能知道其的一些作用了</h2><p>当网页交给浏览器的HTML解析器转变成一系列的词语（Token）。解释器根据词语构建节点（Node），形成DOM树。因为JavaScript代码可能会修改DOM树的结构，所以节点是JavaScript代码的话，就需要停止当前DOM树的创建，直到JavaScript的资源加载并被JavaScript引擎执行后才继续DOM树的创建。<br>这里就会产生<strong>阻塞</strong>，出现<strong>白屏问题</strong>(白屏问题优化有很多方面，这里就脚本阻塞这一小点)，我们就可以使用<code>async和defer</code>属性来解决JavaScript脚本阻塞问题。  </p>
<p>当然最稳妥的办法还是把script标签放置在body的底部，没有兼容性问题，不会因此产生白屏问题，没有执行顺序问题。</p>
<p>最后总结：</p>
<ul>
<li>如果 async&#x3D;”async”：脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）</li>
<li>如果不使用 async 且 defer&#x3D;”defer”：脚本将在页面完成解析时执行</li>
<li>如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本</li>
</ul>
<h2 id="6-async-await对比promise的优缺点"><a href="#6-async-await对比promise的优缺点" class="headerlink" title="6. async await对比promise的优缺点"></a>6. async await对比promise的优缺点</h2><p><strong>async&#x2F;await优点</strong>：<br>a. 它做到了真正的串行的同步写法，代码阅读相对容易  </p>
<p>b. 对于条件语句和其他流程语句比较友好，可以直接写到判断条件里面  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(222)</span><br><span class="line">      &#125;, 2222)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">async function f() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      if ( await a() === 222) &#123;</span><br><span class="line">        console.log(&#x27;yes, it is!&#x27;) // 会打印</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>c. 处理复杂流程时，在代码清晰度方面有优势  </p>
<p><strong>async&#x2F;await缺点</strong>：<br>a. 无法处理promise返回的reject对象，要借助try…catch…  </p>
<p>b. 用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//promise</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">ajax1</span>(), <span class="title function_">ajax2</span>()])</span><br></pre></td></tr></table></figure>

<p>c. try…catch…内部的变量无法传递给下一个try…catch…,Promise和then&#x2F;catch内部定义的变量，能通过then链条的参数传递到下一个then&#x2F;catch，但是async&#x2F;await的try内部的变量，如果用let和const定义则无法传递到下一个try…catch…，只能在外层作用域先定义好。</p>
<p><strong>但async&#x2F;await确确实实是解决了promise一些问题的。更加灵活的处理异步</strong>  </p>
<p><strong>promise的一些问题：</strong><br>a. 一旦执行，无法中途取消，链式调用多个then中间不能随便跳出来  </p>
<p>b. 错误无法在外部被捕捉到，只能在内部进行预判处理，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部  </p>
<p>c. Promise内部如何执行，监测起来很难，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）  </p>
<h2 id="7-get和post的区别"><a href="#7-get和post的区别" class="headerlink" title="7. get和post的区别"></a>7. get和post的区别</h2><p>a. GET 是将参数写在 <code>URL 中 ?</code> 的后面，并用 <code>&amp;</code> 分隔不同参数；而 POST 是将信息存放在 <code>Message Body</code> 中传送，参数‘不会’显示在 URL 中(Restful规范中是这样，但post在有需要时可以把参数放URL里)。GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。  </p>
<p>b. GET请求提交的数据有长度限制（<strong>HTTP 协议本身没有限制 URL 及正文长度</strong>,对 URL 的限制大多是浏览器和服务器的原因），POST请求没有内容长度限制。  </p>
<p>c. GET请求返回的内容会被浏览器缓存起来。而每次提交POST请求，浏览器不会缓存POST请求返回的内容。  </p>
<p>d. GET对数据进行查询，POST主要对数据进行增删改！简单说，GET是只读，POST是写。  </p>
<p>e. 关于安全性，GET 请求方式从浏览器的 URL 地址就可以看到参数；所以post更安全，其实无论是 GET 还是 POST 其实<strong>都是不安全的</strong>，因为 HTTP 协议是明文传输，只要拦截封包便能轻易获取重要资讯。想要安全传输资料，必须使用 SSL&#x2F;TLS来加密封包，也就是 HTTPS。  </p>
<p><strong>那为什么推崇使用post来处理敏感数据呢？</strong><br>因为get的记录会保存在浏览器，上网日志中，而使用Post，因为数据不会记录存储在浏览器的记录和网址访问记录中，这样会有更大的<strong>安全性</strong>。  </p>
<p>f.<strong>一个误区</strong> 说GET产生一个TCP数据包；POST产生两个TCP数据包<br><strong>其说法</strong>：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。  </p>
<p>对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。  </p>
<p><strong>为其正名</strong>:上面所说的post会比get多一个tcp包其实不太严谨。多发的那个expect 100 continue header报文，是<code>由客户端对http的post和get的请求策略决定</code>的，目的是为了避免浪费资源，如带宽，数据传输消耗的时间等等。所以客户端会在发送header的时候添加expect 100去探探路，如果失败了就不用继续发送data，从而减少了资源的浪费。所以是否再发送一个包取决了客户端的实现策略，和get&#x2F;post并没什么关系。有的客户端比如fireFox就只发送一个包。  </p>
<h2 id="8-用框架和不用框架的区别，vue和react的区别"><a href="#8-用框架和不用框架的区别，vue和react的区别" class="headerlink" title="8. 用框架和不用框架的区别，vue和react的区别"></a>8. 用框架和不用框架的区别，vue和react的区别</h2><p><strong>首先说说用框架和不用框架的区别：（以使用框架的角度看）</strong><br>框架好处：<br>a. 使用框架工具写项目，在浏览器中代码依然是原生的HTML CSS JS。而框架帮开发者做了很多事情，开发者只关注业务逻辑就可以,极大的加快了开发速度。<br>例如前端框架根本上是解决了<code>UI 与状态同步问题</code>,<code>频繁操作 DOM 性能低下</code>.<code>中间步骤过多,易产生 bug且不易维护</code>,而且<code>心智要求较高不利于开发效率</code>的一系列阻碍  </p>
<p>b. <code>组件化</code>: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。  </p>
<p>c. <code>天然分层</code>: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。  </p>
<p>d. <code>生态</code>: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案  </p>
<p>e. 待补充。。。(<strong>希望评论区能提出宝贵见解</strong>)</p>
<p>框架缺点：<br>a. 代码臃肿，使用者使用框架的时候会将整个框架引入，而框架封装了很多功能和组件，使用者必须按照它的规则使用，而实际开发中很多功能和组件是用不到的。  </p>
<p>b. 框架迭代更新速度非常快，需要时间熟悉它。  </p>
<p>c. 待补充。。。(<strong>希望评论区能提出宝贵见解</strong>)</p>
<p><strong>说说Vue和React的区别：</strong><br>这里就说说其思想差异(毕竟面试时不一定就要把两个框架差异说清楚，理解核心就好)：  </p>
<p><code>react整体是函数式的思想</code>，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；  </p>
<p><code>vue的思想是响应式的</code>，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。  </p>
<p>其他的细节差异可以看看这篇文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904040564785159" title="https://juejin.cn/post/6844904040564785159">关于Vue和React的一些对比</a></p>
<h2 id="9-cookies和session的区别"><a href="#9-cookies和session的区别" class="headerlink" title="9. cookies和session的区别"></a>9. cookies和session的区别</h2><p>a. <code>存储位置不同:</code>cookie的数据信息存放在客户端浏览器上，session的数据信息存放在服务器上。  </p>
<p>b. <code>存储容量不同:</code>单个cookie保存的数据&lt;&#x3D;4KB，一个站点最多保存20个Cookie，而对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。  </p>
<p>c. <code>存储方式不同:</code>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。  </p>
<p>d. <code>隐私策略不同:</code>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的，而session存储在服务器上，对客户端是透明的，不存在敏感信息泄漏的风险。  </p>
<p>e. <code>有效期上不同:</code>开发可以通过设置cookie的属性，达到使cookie长期有效的效果。session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。  </p>
<p>f. <code>服务器压力不同:</code>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。  </p>
<p>g. <code>跨域支持上不同:</code>cookie支持跨域名访问(二级域名是可以共享cookie的)。session不支持跨域名访问。  </p>
<h2 id="10-宏任务和微任务有什么区别"><a href="#10-宏任务和微任务有什么区别" class="headerlink" title="10. 宏任务和微任务有什么区别"></a>10. 宏任务和微任务有什么区别</h2><p>微任务和宏任务皆为异步任务，它们都属于一个队列，主要<strong>区别在于他们的执行顺序，Event Loop的走向和取值</strong>。  </p>
<p><strong>宏任务和微任务的一些分配</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">         宏任务          浏览器         Node</span><br><span class="line">I/O      ✅✅</span><br><span class="line">setTimeout✅✅</span><br><span class="line">setInterval✅✅</span><br><span class="line">setImmediate    ❌✅</span><br><span class="line">requestAnimationFrame           ✅✅</span><br><span class="line"></span><br><span class="line">         微任务</span><br><span class="line">process.nextTick        ❌✅</span><br><span class="line">MutationObserver        ✅❌</span><br><span class="line">Promise.then catch finally              ✅✅</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>宏任务与微任务之间的执行顺序</strong>(同步任务-&gt;微任务-&gt;宏任务)<br>下面说说执行到宏任务后是怎么继续运行的<br>(这里声明下，整段js代码就是第一个大的宏任务，事件循环是由这第一个宏任务开始的，然后分出微任务，这里是为了理解微任务宏任务的执行区别就先跳过这第一层)  </p>
<p><code>说一个很有名的银行例子</code>：银行柜台前排着一条队伍，都是存钱的人，存钱属于宏任务，这条队伍就是宏任务队列，当一个‘宏大爷’被叫到了自己的号码，就上前去–被处理，处理存钱业务时，‘宏大爷’<strong>突然</strong>想给自己的存款办个微理财(<code>微任务</code>)，那么银行职员就将他的需求添加到自己的微任务队列，大爷就不用再排队了，直接在存钱宏任务进行完后就处理衍生出来的微任务理财，办理财时大爷又说办个信用卡，那就又排到微任务队列里。<strong>但要是</strong>在此次存钱时‘宏大爷’说他还要存钱，且是他老伴要存钱，也是<code>宏任务</code>，但不好意思，需要取号到宏任务队列的后面排队（这里就是在宏任务进行时产生微任务和宏任务的处理方式）。  </p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b68f33891a3e418696c2258e96441d7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image"></p>
<p>结合下面的题目理解理解（这里先不介绍node环境的事件循环的特殊地方，主要以浏览器环境，最好看看底下推荐的文章）：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    setTimeout(function () &#123;//宏任务1</span><br><span class="line">      console.log(&#x27;1&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    new Promise(function (resolve) &#123;</span><br><span class="line">      console.log(&#x27;2&#x27;);//同步任务1</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;).then(function () &#123;//微任务1</span><br><span class="line">      console.log(&#x27;3&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&#x27;4&#x27;);//同步任务2</span><br><span class="line">    setTimeout(function () &#123;//宏任务2</span><br><span class="line">      console.log(&#x27;5&#x27;);//宏任务2中的同步任务</span><br><span class="line">      new Promise(function (resolve) &#123;</span><br><span class="line">        console.log(&#x27;6&#x27;);//宏任务2中的同步任务</span><br><span class="line">        new Promise(function (resolve) &#123;//宏任务2中的微任务</span><br><span class="line">            console.log(&#x27;x1&#x27;);</span><br><span class="line">            resolve();</span><br><span class="line">          &#125;).then(function () &#123;</span><br><span class="line">            console.log(&#x27;X2&#x27;);</span><br><span class="line">          &#125;);</span><br><span class="line">        setTimeout(function () &#123;//宏任务2中的宏任务</span><br><span class="line">          console.log(&#x27;X3&#x27;);</span><br><span class="line">          new Promise(function (resolve) &#123;//宏任务2中的宏任务中的同步任务</span><br><span class="line">            console.log(&#x27;X4&#x27;);</span><br><span class="line">            resolve();</span><br><span class="line">          &#125;).then(function () &#123;//宏任务2中的宏任务中的微任务</span><br><span class="line">            console.log(&#x27;X5&#x27;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;).then(function () &#123;//宏任务2中的微任务</span><br><span class="line">        console.log(&#x27;7&#x27;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    setTimeout(function () &#123;//宏任务3</span><br><span class="line">      console.log(&#x27;8&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    //（对于这段代码node环境和浏览器环境输出一致）</span><br><span class="line">    //输出答案：2,4,3,1,5,6,x1,x2,7,8,x3,x4,x5</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面这个例子我为了测试，可能搞得有点长。。。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903657264136200#heading-3" title="https://juejin.cn/post/6844903657264136200#heading-3">更多eventloop详细可看这篇文章</a></p>
<h2 id="11-fetch-Ajax-axios区别"><a href="#11-fetch-Ajax-axios区别" class="headerlink" title="11. fetch,Ajax,axios区别"></a>11. fetch,Ajax,axios区别</h2><p>Ajax是什么：Ajax是（Asynchronous JavaScript and XML）的缩写。现在，允许浏览器与服务器通信而无须刷新当前页面的技术都被叫做Ajax。核心使用<code>XMLHttpRequest</code>对象。  </p>
<p>axios是什么：axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上<code>也是对原生XHR</code>的封装，只不过它是Promise的实现版本，符合最新的ES规范。  </p>
<p>fetch是什么：Fetch被称为下一代Ajax技术,采用Promise方式来处理数据。是一种简洁明了的API，比XMLHttpRequest更加简单易用。  </p>
<p>所以其主要区别是 axios、fetch请求后都支持Promise对象API，ajax只能用回调函数。  </p>
<p>具体了解可看此文章<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/89089088" title="https://zhuanlan.zhihu.com/p/89089088">一文秒懂 ajax, fetch, axios</a></p>
<h2 id="12-TCP和UDP的区别"><a href="#12-TCP和UDP的区别" class="headerlink" title="12. TCP和UDP的区别"></a>12. TCP和UDP的区别</h2><p>a. TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。  </p>
<p>b. TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠， 面向连接，不会丢失数据因此适合大数据量的交换。  </p>
<p>c. TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因 此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。  </p>
<p>d. TCP 只能是 1 对 1 的，而UDP 支持 1 对 1,1 对多。  </p>
<p>e. TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。  </p>
<p>f. TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。  </p>
<h2 id="13-js中的堆和栈-栈和队列有什么区别"><a href="#13-js中的堆和栈-栈和队列有什么区别" class="headerlink" title="13. js中的堆和栈,栈和队列有什么区别"></a>13. js中的堆和栈,栈和队列有什么区别</h2><p><strong>堆(heap)和栈(stack)的区别:</strong>  </p>
<p>堆：队列优先,<strong>先进先出</strong>；由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。  </p>
<p>栈：<strong>先进后出</strong>；动态分配的空间 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。  </p>
<p><strong>栈和队列的区别：</strong>  </p>
<p>a. 栈只允许在表尾一端进行插入和删除，队列只允许在表尾一端进行插入，在表头一端进行删除。  </p>
<p>b. 栈是先进后出，队列是先进先出。  </p>
<h2 id="14-WebSocket和HTTP有什么区别"><a href="#14-WebSocket和HTTP有什么区别" class="headerlink" title="14. WebSocket和HTTP有什么区别"></a>14. WebSocket和HTTP有什么区别</h2><p><strong>相同点</strong><br>a. 都是一样基于TCP的，都是可靠性传输协议。  </p>
<p>b. 都是应用层协议。  </p>
<p><strong>不同点</strong><br>a. WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。  </p>
<p>b. WebSocket是需要握手进行建立连接的(相对HTTP来说，WebSocket是一种持久化的协议。它会基于HTTP协议，来完成一部分握手，HTTP握手部分完成，协议升级为WebSocket)。  </p>
<p>可以学习这篇文章<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/74326818" title="https://zhuanlan.zhihu.com/p/74326818">WebSocket其实没那么难</a></p>
<h2 id="15-http和https的区别"><a href="#15-http和https的区别" class="headerlink" title="15. http和https的区别"></a>15. http和https的区别</h2><p>a. HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。  </p>
<p>b. 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而<strong>需要一定费用</strong>。  </p>
<p>c. HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。  </p>
<p>d. http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。  </p>
<p>e. HTTPS 其实就是建构在 SSL&#x2F;TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。  </p>
<h2 id="16-px-em-rem-vw-vh区别"><a href="#16-px-em-rem-vw-vh区别" class="headerlink" title="16. px,em,rem,vw,vh区别"></a>16. px,em,rem,vw,vh区别</h2><p>px: px就是pixel的缩写，意为像素。px就是一张图片最小的一个点，一张位图就是千千万万的这样的点构成的。  </p>
<p>em: <strong>参考物是父元素</strong>的font-size，具有继承的特点。如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。  </p>
<p>rem: css3新单位，<strong>相对于根元素html</strong>（网页）的font-size，不会像em那样，依赖于父元素的字体大小，而造成混乱。  </p>
<p>vw: css3新单位，viewpoint width的缩写，<strong>视窗宽度</strong>，1vw等于视窗宽度的1%。<br>举个例子：浏览器宽度1200px, 1 vw &#x3D; 1200px&#x2F;100 &#x3D; 12 px。  </p>
<p>vh: css3新单位，viewpoint height的缩写，<strong>视窗高度</strong>，1vh等于视窗高度的1%。<br>举个例子：浏览器高度900px, 1 vh &#x3D; 900px&#x2F;100 &#x3D; 9 px。  </p>
<h2 id="17-wepack中loader和plugin的区别"><a href="#17-wepack中loader和plugin的区别" class="headerlink" title="17. wepack中loader和plugin的区别"></a>17. wepack中loader和plugin的区别</h2><p><strong>什么是loader?</strong><br>loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中  </p>
<p><strong>什么是plugin？</strong><br>在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果。  </p>
<p><strong>区别：</strong>  </p>
<ul>
<li>对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程</li>
<li>plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务</li>
</ul>
<h2 id="18-bind-call-apply区别"><a href="#18-bind-call-apply区别" class="headerlink" title="18. bind call apply区别"></a>18. bind call apply区别</h2><p>a. 三者都可以改变函数的this对象指向。  </p>
<p>b. 三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。  </p>
<p>c. 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。  </p>
<p>d. bind 改变this指向后不会立即执行，而是返回一个永久改变this指向的函数便于稍后调用； apply, call则是立即调用  </p>
<h2 id="19-301-和-302-有什么区别"><a href="#19-301-和-302-有什么区别" class="headerlink" title="19. 301 和 302 有什么区别"></a>19. 301 和 302 有什么区别</h2><p><code>301 Moved Permanently:</code> 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应 当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也 是可缓存的。  </p>
<p><code>302 Found:</code> 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。  </p>
<p>字面上的区别就是 301 是永久重定向，而 302 是临时重定向。  </p>
<p>301 比较常用的场景是使用域名跳转。302 用来做临时跳转, 比如未登陆的用户访问用户中心被重定向到登录页面  </p>
<h2 id="20-进程线程的区别"><a href="#20-进程线程的区别" class="headerlink" title="20. 进程线程的区别"></a>20. 进程线程的区别</h2><p>a. <strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p>
<p>b. <strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>
<p>c. <strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<p>d. <strong>内存分配</strong>：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p>
<p>e. <strong>影响关系</strong>：因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程要比多线程健壮。  </p>
<p>还可看看：<br><a href="https://link.juejin.cn/?target=http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" title="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">阮一峰对进程线程的简单解释</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903908385488903" title="https://juejin.cn/post/6844903908385488903">深入理解Node.js 中的进程与线程</a></p>
<h2 id="21-JavaScript和typescript的区别"><a href="#21-JavaScript和typescript的区别" class="headerlink" title="21. JavaScript和typescript的区别"></a>21. JavaScript和typescript的区别</h2><p>a. TypeScript 从核心语言方面和类概念的模塑方面对 JavaScript 对象模型进行扩展。</p>
<p>b. JavaScript 代码可以在无需任何修改的情况下与 TypeScript 一同工作，同时可以使用编译器将 TypeScript 代码转换为 JavaScript。</p>
<p>c. TypeScript 通过类型注解提供编译时的静态类型检查。</p>
<p>d. TypeScript 中的数据要求带有明确的类型，JavaScript不要求。</p>
<p>e. TypeScript 为函数提供了缺省参数值。</p>
<p>f. TypeScript 引入了 JavaScript 中没有的“类”概念。</p>
<p>h. TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。</p>
<h2 id="22-localstorage、sessionstorage、cookie的区别"><a href="#22-localstorage、sessionstorage、cookie的区别" class="headerlink" title="22. localstorage、sessionstorage、cookie的区别"></a>22. localstorage、sessionstorage、cookie的区别</h2><p>a. 相同点是都是保存在浏览器端、且同源的</p>
<p>b. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p>
<p>c. 存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p>
<p>d. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</p>
<p>e. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</p>
<p>f. webStorage(<code>webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage</code>)支持事件通知机制，可以将数据更新的通知发送给监听者</p>
<p>h. webStorage的api接口使用更方便</p>
<h2 id="23-http-1-0-x2F-1-1-x2F-2-0的不同"><a href="#23-http-1-0-x2F-1-1-x2F-2-0的不同" class="headerlink" title="23. http 1.0&#x2F; 1.1&#x2F; 2.0的不同"></a>23. http 1.0&#x2F; 1.1&#x2F; 2.0的不同</h2><p><strong>http 1.0(构建可扩展性)</strong><br>HTTP原有的应用非常局限，浏览器和服务器迅速扩展使其用途更广：</p>
<p>a. 版本信息现在会随着每个请求发送（HTTP1.0 被追加到GET行）</p>
<p>b. 状态代码行也会在响应开始时发送，允许浏览器本身了解请求的成功或失败，并相应地调整其行为（如以特定方式更新或使用本地缓存）</p>
<p>c. 引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，并使协议非常灵活和可扩展。</p>
<p>d. Content-Type标头告诉客户端实际返回的内容的内容类型。在Content-Type标头帮助下，增加了传输除纯文本HTML文件外的其他类型文档的能力。</p>
<p><strong>http 1.1(标准化的协议)</strong><br>HTTP&#x2F;1.0的多种不同的实现运用起来有些混乱，HTTP1.1是第一个标准化版本，重点关注的是校正HTTP设计中的结构性缺陷：</p>
<p>a. 连接可以重复使用，节省了多次打开它的时间，以显示嵌入到单个原始文档中的资源。</p>
<p>b. 增加流水线操作，允许在第一个应答被完全发送之前发送第二个请求，以降低通信的延迟。</p>
<p>c. 支持响应分块。</p>
<p>d. 引入额外的缓存控制机制。</p>
<p>e. 引入内容协商，包括语言，编码，或类型，并允许客户端和服务器约定以最适当的内容进行交换。</p>
<p>f. 通过 Host 头，能够使不同的域名配置在同一个IP地址的服务器。</p>
<p>g. 安全性得到了提高</p>
<p><strong>http 2.0(为了更优异的表现)</strong><br>HTTP&#x2F;2在HTTP&#x2F;1.1有几处基本的不同:</p>
<p>HTTP2是二进制协议而不是文本协议。不再可读和无障碍的手动创建，改善的优化技术现在可被实施。</p>
<p>这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP&#x2F;1.x中顺序和阻塞的约束。</p>
<p>压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</p>
<p>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</p>
<p><a href="https://link.juejin.cn/?target=https://www.cnblogs.com/zytrue/p/8568181.html" title="https://www.cnblogs.com/zytrue/p/8568181.html">参考自这篇文章</a></p>
<h2 id="24-MongoDB和MySQL的区别"><a href="#24-MongoDB和MySQL的区别" class="headerlink" title="24. MongoDB和MySQL的区别"></a>24. MongoDB和MySQL的区别</h2><p>直接放上对比表格：  </p>
<table>
<thead>
<tr>
<th>数据库</th>
<th>MongoDB</th>
<th>MySQL</th>
</tr>
</thead>
<tbody><tr>
<td>数据库模型</td>
<td>非关系型</td>
<td>关系型</td>
</tr>
<tr>
<td>存储方式</td>
<td>以类JSON的文档的格式存储</td>
<td>不同引擎有不同的存储方式</td>
</tr>
<tr>
<td>查询语句</td>
<td>MongoDB查询方式（类似JavaScript的函数）</td>
<td>SQL语句</td>
</tr>
<tr>
<td>数据处理方式</td>
<td>基于内存，将热数据存放在物理内存中，从而达到高速读写</td>
<td>不同引擎有自己的特点</td>
</tr>
<tr>
<td>成熟度</td>
<td>新兴数据库，成熟度较低</td>
<td>成熟度高</td>
</tr>
<tr>
<td>广泛度</td>
<td>NoSQL数据库中，比较完善且开源，使用人数在不断增长</td>
<td>开源数据库，市场份额不断增长</td>
</tr>
<tr>
<td>事务性</td>
<td>仅支持单文档事务操作，弱一致性</td>
<td>支持事务操作</td>
</tr>
<tr>
<td>占用空间</td>
<td>占用空间大</td>
<td>占用空间小</td>
</tr>
<tr>
<td>join操作</td>
<td>MongoDB没有join</td>
<td>MySQL支持join</td>
</tr>
</tbody></table>
<p>希望各位看官指出其中的错误，我必改正！也请对其中的一些问题提出自己的一些看法。这里只是一些大概的总结，想要有最好的学习效果，还是对其中每有一个点进行系统的学习。</p>
<p>笔者最近也在准备面试和寻找前端实习岗位中！wx：xieHB-frontend-178,加个微信一起学习😜，也希望有大佬介绍个内推和提出学习意见，感谢。哈哈！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://serendipity0321.github.com">蓉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://serendipity0321.github.com/2023/01/29/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/">http://serendipity0321.github.com/2023/01/29/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://serendipity0321.github.com" target="_blank">serendipity0321's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/29/%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80CSS%E7%9F%A5%E8%AF%86%E7%82%B9/" title="巩固基础CSS知识点"><img class="cover" src="https://s2.loli.net/2023/02/19/4peNtadoWguhcU5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">巩固基础CSS知识点</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/29/webpack%E6%94%BB%E7%95%A5/" title="webpack攻略"><img class="cover" src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">webpack攻略</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/17/ES6%E9%9D%A2%E8%AF%95/" title="ES6面试"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="title">ES6面试</div></div></a></div><div><a href="/2023/02/17/React%E9%9D%A2%E8%AF%95%E9%A2%98/" title="React面试题"><img class="cover" src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="title">React面试题</div></div></a></div><div><a href="/2023/02/13/TypeScript%E9%9D%A2%E8%AF%95%E9%A2%98/" title="TypeScript面试题"><img class="cover" src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-13</div><div class="title">TypeScript面试题</div></div></a></div><div><a href="/2023/01/19/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" title="Vue面试题总结"><img class="cover" src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-19</div><div class="title">Vue面试题总结</div></div></a></div><div><a href="/2023/02/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/" title="前端面试之道"><img class="cover" src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-15</div><div class="title">前端面试之道</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/10/02/SRY7qntDHQe5l9F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">蓉</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/serendipity0321"><i class="fab fa-github"></i><span>Follow Meeee</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/serendipity0321" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:r1727439300@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">1. 箭头函数和普通函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-var%EF%BC%8Clet%E5%92%8Cconst%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">2. var，let和const之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Bigint%E5%92%8CNumber%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">3. Bigint和Number的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">4. 基本数据类型和引用数据类型的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-defer%E5%92%8Casync%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">5. defer和async的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E5%88%B0%E8%BF%99%E9%87%8C%EF%BC%8C%E5%B0%B1%E8%83%BD%E7%9F%A5%E9%81%93%E5%85%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%9C%E7%94%A8%E4%BA%86"><span class="toc-number">6.</span> <span class="toc-text">看到这里，就能知道其的一些作用了</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-async-await%E5%AF%B9%E6%AF%94promise%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">7.</span> <span class="toc-text">6. async await对比promise的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">7. get和post的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%94%A8%E6%A1%86%E6%9E%B6%E5%92%8C%E4%B8%8D%E7%94%A8%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Cvue%E5%92%8Creact%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">8. 用框架和不用框架的区别，vue和react的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-cookies%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">9. cookies和session的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">10. 宏任务和微任务有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-fetch-Ajax-axios%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">11. fetch,Ajax,axios区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">12. TCP和UDP的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-js%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">13. js中的堆和栈,栈和队列有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-WebSocket%E5%92%8CHTTP%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">14. WebSocket和HTTP有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">15. http和https的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-px-em-rem-vw-vh%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">16. px,em,rem,vw,vh区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-wepack%E4%B8%ADloader%E5%92%8Cplugin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">18.</span> <span class="toc-text">17. wepack中loader和plugin的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-bind-call-apply%E5%8C%BA%E5%88%AB"><span class="toc-number">19.</span> <span class="toc-text">18. bind call apply区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-301-%E5%92%8C-302-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">20.</span> <span class="toc-text">19. 301 和 302 有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">21.</span> <span class="toc-text">20. 进程线程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-JavaScript%E5%92%8Ctypescript%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">22.</span> <span class="toc-text">21. JavaScript和typescript的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-localstorage%E3%80%81sessionstorage%E3%80%81cookie%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">23.</span> <span class="toc-text">22. localstorage、sessionstorage、cookie的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-http-1-0-x2F-1-1-x2F-2-0%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">24.</span> <span class="toc-text">23. http 1.0&#x2F; 1.1&#x2F; 2.0的不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-MongoDB%E5%92%8CMySQL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">25.</span> <span class="toc-text">24. MongoDB和MySQL的区别</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/21/%E5%8F%96%E6%B6%88git%E4%BB%A3%E7%90%86/" title="取消git代理"><img src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="取消git代理"/></a><div class="content"><a class="title" href="/2023/02/21/%E5%8F%96%E6%B6%88git%E4%BB%A3%E7%90%86/" title="取消git代理">取消git代理</a><time datetime="2023-02-21T07:23:51.000Z" title="发表于 2023-02-21 15:23:51">2023-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/18/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/" title="程序员面试金典"><img src="https://s2.loli.net/2023/02/19/BcKRXY8anQwoAW5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="程序员面试金典"/></a><div class="content"><a class="title" href="/2023/02/18/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8/" title="程序员面试金典">程序员面试金典</a><time datetime="2023-02-18T14:05:52.000Z" title="发表于 2023-02-18 22:05:52">2023-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/17/React%E9%9D%A2%E8%AF%95%E9%A2%98/" title="React面试题"><img src="https://s2.loli.net/2022/12/31/qZrDP8nOQ4tGc6L.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React面试题"/></a><div class="content"><a class="title" href="/2023/02/17/React%E9%9D%A2%E8%AF%95%E9%A2%98/" title="React面试题">React面试题</a><time datetime="2023-02-17T08:17:41.000Z" title="发表于 2023-02-17 16:17:41">2023-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/17/ES6%E9%9D%A2%E8%AF%95/" title="ES6面试"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ES6面试"/></a><div class="content"><a class="title" href="/2023/02/17/ES6%E9%9D%A2%E8%AF%95/" title="ES6面试">ES6面试</a><time datetime="2023-02-17T02:20:30.000Z" title="发表于 2023-02-17 10:20:30">2023-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/" title="前端面试之道"><img src="https://s2.loli.net/2022/10/08/xzepUwCs3gKPWy2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面试之道"/></a><div class="content"><a class="title" href="/2023/02/15/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93/" title="前端面试之道">前端面试之道</a><time datetime="2023-02-15T14:06:38.000Z" title="发表于 2023-02-15 22:06:38">2023-02-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 蓉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>