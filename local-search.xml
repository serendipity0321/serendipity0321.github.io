<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>路由原理</title>
    <link href="/2023/02/03/%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/"/>
    <url>/2023/02/03/%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="安装指定路由版本"><a href="#安装指定路由版本" class="headerlink" title="安装指定路由版本"></a>安装指定路由版本</h2><div class="code-wrapper"><pre><code class="hljs angelscript">npm install react-router-<span class="hljs-symbol">dom@</span><span class="hljs-number">6</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node Webpack 性能优化</title>
    <link href="/2023/02/01/Node%20Webpack%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/02/01/Node%20Webpack%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Node"><a href="#一、Node" class="headerlink" title="一、Node"></a>一、Node</h1><h2 id="Node是什么"><a href="#Node是什么" class="headerlink" title="Node是什么?"></a>Node是什么?</h2><p>Node.js是一个基于 Chrome V8 引擎的<strong>JavaScript运行环境</strong>，这个环境就好比是服务器上的浏览器，但正是因为有了它才使得 js 变成了一门后台语言。</p><h2 id="Node解决了哪些问题"><a href="#Node解决了哪些问题" class="headerlink" title="Node解决了哪些问题?"></a>Node解决了哪些问题?</h2><p>Node在处理高并发,I&#x2F;O密集场景有明显的性能优势</p><ul><li>高并发,是指在同一时间并发访问服务器</li><li>I&#x2F;O密集指的是文件操作、网络操作、数据库,相对的有CPU密集,CPU密集指的是逻辑处理运算、压缩、解压、加密、解密</li></ul><blockquote><p>Web主要场景就是接收客户端的请求读取静态资源和渲染界面,所以Node非常适合Web应用的开发。</p></blockquote><h2 id="Node-的应用场景"><a href="#Node-的应用场景" class="headerlink" title="Node 的应用场景"></a>Node 的应用场景</h2><p>一般来说，node 主要应用于以下几个方面：</p><ul><li>自动化构建等工具</li><li>中间层</li><li>小项目</li></ul><p>第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一</p><h2 id="请介绍一下Node事件循环的流程"><a href="#请介绍一下Node事件循环的流程" class="headerlink" title="请介绍一下Node事件循环的流程"></a>请介绍一下Node事件循环的流程</h2><ul><li>在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们成为Tick。</li><li>每个Tick的过程就是查看是否有事件待处理。如果有就取出事件及其相关的回调函数。然后进入下一个循环，如果不再有事件处理，就退出进程。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/324dacf44f0243c4b85845503f94af74~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"></p><h3 id="4-2-浏览器和-Node-js-中的事件循环机制有什么区别？"><a href="#4-2-浏览器和-Node-js-中的事件循环机制有什么区别？" class="headerlink" title="4.2 浏览器和 Node.js 中的事件循环机制有什么区别？"></a>4.2 浏览器和 Node.js 中的事件循环机制有什么区别？</h3><p>Node.js中宏任务分成了几种类型，并且放在了不同的task queue(事件队列)里。不同的task queue在执行顺序上也有区别，微任务放在了每个task queue的末尾：</p><ul><li><code>setTimeout/setInterval</code> 属于 timers 类型；</li><li><code>setImmediate</code> 属于 check 类型；</li><li>socket 的 close 事件属于 close callbacks 类型；</li><li>其他 MacroTask 都属于 poll 类型。</li><li><code>process.nextTick</code> 本质上属于 MicroTask，但是它先于所有其他 MicroTask 执行；</li><li>所有 MicroTask 的执行时机在不同类型的 MacroTask 切换后。</li><li>idle&#x2F;prepare 仅供内部调用，我们可以忽略。</li><li>pending callbacks 不太常见，我们也可以忽略。</li></ul><h2 id="在每个tick的过程中，如何判断是否有事件需要处理呢？"><a href="#在每个tick的过程中，如何判断是否有事件需要处理呢？" class="headerlink" title="在每个tick的过程中，如何判断是否有事件需要处理呢？"></a>在每个tick的过程中，如何判断是否有事件需要处理呢？</h2><ul><li>每个事件循环中有一个或者多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。</li><li>在Node中，事件主要来源于网络请求、文件的I&#x2F;O等，这些事件对应的观察者有文件I&#x2F;O观察者，网络I&#x2F;O的观察者。</li><li>事件循环是一个典型的生产者&#x2F;消费者模型。异步I&#x2F;O，网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</li><li>在windows下，这个循环基于IOCP创建，在*nix下则基于多线程创建</li></ul><h2 id="请描述一下整个异步I-x2F-O的流程"><a href="#请描述一下整个异步I-x2F-O的流程" class="headerlink" title="请描述一下整个异步I&#x2F;O的流程"></a>请描述一下整个异步I&#x2F;O的流程</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f31bb3ab0e34b0a8fc27d9bf73a91e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"></p><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><h3 id="Express框架介绍"><a href="#Express框架介绍" class="headerlink" title="Express框架介绍"></a>Express框架介绍</h3><p>1.Express是NodeJS开发中一个非常重量级的第三方框架，它对于NodeJS服务端就相当于Jquery对于HTML客户端。</p><ul><li><strong>如果连Express都不会用，基本上都不好意思跟别人说你会NodeJS</strong></li></ul><p>2.Express官网是这样介绍自己的:基于 Node.js 平台，快速、开放、极简的 web 开发框架。</p><ul><li><p><em>Express一个非常重要的亮点就是它没有改变nodejs已有的特性，而是在它的基础上进行了拓展</em></p><ul><li><strong>也就是说，使用Express你既可以使用nodejs原生的任何API，也能使用Express的API</strong></li></ul></li></ul><h3 id="Express三大核心功能"><a href="#Express三大核心功能" class="headerlink" title="Express三大核心功能"></a>Express三大核心功能</h3><ul><li><p>1.托管静态资源</p><ul><li>第二天讲的nodejs实现静态服务器功能在express中只需要一行代码</li></ul></li><li><p>2.路由</p><ul><li>express自带路由功能,让Node服务端开发变得极其简单</li><li>express支持链式语法，可以让代码看起来更加简洁</li></ul></li><li><p>=&#x3D;3.中间件&#x3D;&#x3D;</p><ul><li><p>Express最为核心的技术和思想，万物皆中间件</p><ul><li>中间件虽然理解起来有点困难，但是使用起来非常方便，类似于<code>bootstrap插件</code>.</li></ul></li></ul></li></ul><h2 id="8-Node模块化规范"><a href="#8-Node模块化规范" class="headerlink" title="8. Node模块化规范"></a>8. Node模块化规范</h2><h3 id="8-1-什么是模块化-模块化有什么好处"><a href="#8-1-什么是模块化-模块化有什么好处" class="headerlink" title="8.1 什么是模块化? 模块化有什么好处?"></a>8.1 什么是模块化? 模块化有什么好处?</h3><ul><li><p>1.什么叫模块化？（模块 &#x3D;&#x3D; js文件）</p><ul><li><code>一个js文件</code>可以<code>引入另一个js文件中的数据</code>, 这种开发方式就叫做模块化开发</li></ul></li><li><p>2.模块化开发好处？</p><ul><li><p>（1）将功能分离出来</p><ul><li>一个js文件只负责处理一个功能，这样做的好处是业务逻辑清晰，便于维护</li></ul></li><li><p>（2）按需导入</p><ul><li>用到哪一个功能，就导入哪一个js文件。模块化开发是<code>渐进式框架</code>的共同特征。</li></ul></li><li><p>（3）避免变量污染</p><ul><li>一个js文件(模块),都是一个独立的作用域。 互不干扰，不用考虑变量名冲突问题。</li></ul></li></ul></li></ul><h3 id="8-2-模块化语法规范介绍"><a href="#8-2-模块化语法规范介绍" class="headerlink" title="8.2 模块化语法规范介绍"></a>8.2 模块化语法规范介绍</h3><p>任何一个语法，都需要遵循一定的规范。不同的平台需要遵循的规范不同。一般情况下，模块化语法规范主要有三种。</p><ul><li><p>CommonJS 规范：nodejs 默认支持的</p><ul><li>文档：<a href="https://link.juejin.cn/?target=http://javascript.ruanyifeng.com/nodejs/module.html%23toc1" title="http://javascript.ruanyifeng.com/nodejs/module.html#toc1">javascript.ruanyifeng.com&#x2F;nodejs&#x2F;modu…</a></li></ul></li><li><p>ES6规范：前端的ES6语法支持的规范</p><ul><li>文档：<a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/module" title="https://es6.ruanyifeng.com/#docs/module">es6.ruanyifeng.com&#x2F;#docs&#x2F;modul…</a></li></ul></li><li><p>CMD 和 AMD 模块化规范 ： ES6语法之前的模块化语法规范，现在已经几乎不用了</p></li></ul><h3 id="8-3-CommonJS规范实现模块化语法"><a href="#8-3-CommonJS规范实现模块化语法" class="headerlink" title="8.3 CommonJS规范实现模块化语法"></a>8.3 CommonJS规范实现模块化语法</h3><ul><li><p>CommonJS规范只有两句话</p><ul><li><p>1.模块必须要使用 <code>require()</code> 导入</p></li><li><p>2.模块必须要使用 <code>module.exports</code> 导出</p><ul><li>这两个语法都是nodejs环境自带的全局语法</li></ul></li></ul></li><li><p>exports与module.exports区别</p><ul><li><p>(1)如果分不清两者区别,就使用 <code>module.exports</code></p></li><li><p>(2)exports不能去修改堆地址，只能往堆地址里面加数据</p><ul><li><p>错误写法： exports &#x3D; { name:’张三’ }</p><ul><li>这样写是修改堆地址</li></ul></li><li><p>正确写法: exports.name &#x3D; ‘张三’</p><ul><li>这样写没有修改堆地址，而是往堆地址中加数据</li></ul></li></ul></li></ul></li></ul><h3 id="8-4-模块缓存机制"><a href="#8-4-模块缓存机制" class="headerlink" title="8.4 模块缓存机制"></a>8.4 模块缓存机制</h3><ul><li>1.当一个模块第一次会加载时，nodejs会执行里面的js代码，并且导出模块</li><li>2.nodejs会将导出的模块放入缓存中</li><li>3.当重复导入一个模块的时候，nodejs会先从缓存中读取模块。 如果缓存中有，就从缓存读取。缓存没有重复步骤1</li></ul><h3 id="8-5-nodejs三种模块及require-加载原理"><a href="#8-5-nodejs三种模块及require-加载原理" class="headerlink" title="8.5 nodejs三种模块及require()加载原理"></a>8.5 nodejs三种模块及require()加载原理</h3><ul><li><p>1.nodejs有三种模块</p><ul><li><p>第一种： 核心模块、内置模块</p><ul><li><p>nodejs作者写的，这些模块js文件会随着安装nodejs的时候一起安装。因此我们可以直接使用，而无需下载。</p><ul><li>例如： fs 、path、http都是核心模块</li></ul></li></ul></li><li><p>第二种：第三方模块</p><ul><li><p>npm官网上面的模块，这些都是大佬写的模块。需要下载后使用</p><ul><li>例如： express、cors、bod-parser</li></ul></li></ul></li><li><p>第三种：自定义模块</p><ul><li>我们自己写的js文件</li></ul></li></ul></li><li><p>2.require(‘文件路径’)加载原理</p><ul><li><p>(1)自定义模块：必须要写文件路径， <code>require()</code>会得到这个模块里面的 <code>module.exports</code> 对象</p></li><li><p>(2)第三方模块 ：写模块名。 nodejs会自动从你的node_module文件夹里面去找这个模块的名字，然后执行模块里面的<code>index.js</code>代码，得到里面的<code>module.exports</code></p><ul><li>如果当前目录没有module.exports就会从上级目录找，以此类推。一直找到你的磁盘根目录。 还找不到就会报错提示 模块不存在（有点类似于变量作用域就近原则）</li></ul></li><li><p>(3)核心模块：写模块名。 nodejs会自动从你的node安装包路径里面去找。</p></li></ul></li></ul><h3 id="8-6-require和import的区别"><a href="#8-6-require和import的区别" class="headerlink" title="8.6 require和import的区别"></a>8.6 require和import的区别</h3><ol><li>导入<code>require</code> 导出 <code>exports/module.exports</code> 是 <code>CommonJS</code> 的标准，通常适用范围如 <code>Node.js</code></li><li>import&#x2F;export<code>是</code>ES6` 的标准，通常适用范围如 React</li><li><code>require</code> 是<strong>赋值过程</strong>并且是<strong>运行时才执行</strong>，也就是_<strong>同步加载</strong>_</li><li><code>require</code> 可以理解为一个全局方法，因为它是一个方法所以意味着可以在任何地方执行。</li><li><code>import</code> 是<strong>解构过程</strong>并且是<strong>编译时执行</strong>，理解为_<strong>异步加载</strong>_</li><li><code>import</code> 会提升到整个模块的头部，具有置顶性，但是建议写在文件的顶部。</li></ol><h2 id="9-说说前端渲染和后端渲染，以及他们的优缺点"><a href="#9-说说前端渲染和后端渲染，以及他们的优缺点" class="headerlink" title="9. 说说前端渲染和后端渲染，以及他们的优缺点"></a>9. 说说前端渲染和后端渲染，以及他们的优缺点</h2><p><strong>前端渲染</strong></p><p>指的是后端返回JSON数据，前端利用预先写的html模板，循环读取JSON数据，拼接字符串（ES6的模板字符串特性大大减少了拼接字符串的的成本），并插入页面。</p><p><strong>后端渲染</strong></p><p>前端请求，后端用后台模板引擎直接生成html，前端接收到数据之后，直接插入页面。</p><p><strong>区别</strong></p><table><thead><tr><th></th><th>前端渲染</th><th>后端渲染</th></tr></thead><tbody><tr><td>页面呈现速度</td><td>主要受限于带宽和客户端机器的好坏，优化的好，可以逐步动态展开内容，感觉上会更快一点</td><td>快，受限于用户的带宽</td></tr><tr><td>流量消耗</td><td>多一点点（一个前端框架大概50KB）</td><td>少一点点（可以省去前端框架部分的代码）</td></tr><tr><td>可维护性</td><td>好，前后端分离，各施其职，代码一目明了</td><td>差（前后端东西放一起，不利于维护）</td></tr><tr><td>SEO友好度</td><td>差，大量使用Ajax，多数浏览器不能抓取Ajax数据</td><td>好</td></tr><tr><td>编码效率</td><td>高，前后端各自只做自己擅长的东西，后端最后只输出接口，不用管页面呈现，只要前后端人员能力不错，效率不会低</td><td>低（这个跟不同的团队不同，可能不对）</td></tr></tbody></table><h1 id="二、性能优化"><a href="#二、性能优化" class="headerlink" title="二、性能优化"></a>二、性能优化</h1><h2 id="2-什么是CND"><a href="#2-什么是CND" class="headerlink" title="2. 什么是CND"></a>2. 什么是CND</h2><h3 id="2-1-CDN的概念"><a href="#2-1-CDN的概念" class="headerlink" title="2.1 CDN的概念"></a>2.1 CDN的概念</h3><p>CDN（Content Delivery Network，<strong>内容分发网络</strong>）<strong>是指一种通过互联网互相连接的电脑网络系统</strong>，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p><h3 id="2-2-CDN的作用"><a href="#2-2-CDN的作用" class="headerlink" title="2.2 CDN的作用"></a>2.2 CDN的作用</h3><p>CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。<strong>使用CDN来加速这些资源的访问。</strong></p><h3 id="2-3-CDN的使用场景"><a href="#2-3-CDN的使用场景" class="headerlink" title="2.3 CDN的使用场景"></a>2.3 CDN的使用场景</h3><p><strong>使用第三方的CDN服务：</strong> 如果想要开源一些项目，可以使用第三方的CDN服务</p><p><strong>使用CDN进行静态资源的缓存：</strong> 将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上，完成一键部署。</p><p><strong>直播传送：</strong> 直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。</p><h2 id="3-什么是-懒加载-图片"><a href="#3-什么是-懒加载-图片" class="headerlink" title="3.什么是 懒加载(图片)"></a>3.什么是 懒加载(图片)</h2><h3 id="3-1-懒加载的概念"><a href="#3-1-懒加载的概念" class="headerlink" title="3.1 懒加载的概念"></a>3.1 懒加载的概念</h3><p>懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。</p><p>如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。</p><h3 id="3-2-懒加载的特点"><a href="#3-2-懒加载的特点" class="headerlink" title="3.2 懒加载的特点"></a>3.2 懒加载的特点</h3><p><strong>减少无用资源的加载</strong>：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。</p><p><strong>提升用户体验</strong>: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。</p><p><strong>防止加载过多图片而影响其他资源文件的加载</strong> ：会影响网站应用的正常使用。</p><h3 id="3-3-懒加载的实现原理"><a href="#3-3-懒加载的实现原理" class="headerlink" title="3.3 懒加载的实现原理"></a>3.3 懒加载的实现原理</h3><p>图片的加载是由<code>src</code>引起的，当对<code>src</code>赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的<code>data-xxx</code>属性来储存图片的路径，在需要加载图片的时候，将<code>data-xxx</code>中图片的路径赋值给<code>src</code>，这样就实现了图片的按需加载，即懒加载。</p><p>注意：<code>data-xxx</code> 中的<code>xxx</code>可以自定义，这里我们使用<code>data-src</code>来定义。</p><p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。</p><h4 id="3-32-Vue3实现图片懒加载"><a href="#3-32-Vue3实现图片懒加载" class="headerlink" title="3.32 Vue3实现图片懒加载"></a>3.32 Vue3实现图片懒加载</h4><p>导入vueuse插件，使用vueuse封装的useIntersectionObserver监听对应的DOM元素，通过里面的isIntersecting属性的布尔值判断来设置img的src</p><p>可以封装一个v-lazy的自定义指令来控制img的src</p><div class="code-wrapper"><pre><code class="hljs javascript">app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;lazy&#x27;</span>, &#123;      <span class="hljs-attr">mounted</span>: <span class="hljs-function">(<span class="hljs-params">el: HTMLImageElement, &#123; value &#125;</span>) =&gt;</span> &#123;              <span class="hljs-comment">// el:选中的元素,value:传过来的属性,这里是图片地址</span>        <span class="hljs-keyword">const</span> &#123; stop &#125; = <span class="hljs-title function_">useIntersectionObserver</span>(el, <span class="hljs-function">(<span class="hljs-params">[&#123; isIntersecting &#125;]</span>) =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (isIntersecting) &#123; <span class="hljs-comment">// 判断元素是否在可视区域</span>            <span class="hljs-comment">// 满足条件就停止监听</span>            <span class="hljs-title function_">stop</span>()            <span class="hljs-comment">// 给el元素设置src属性</span>            el.<span class="hljs-property">src</span> = value            el.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;              <span class="hljs-comment">// 如果图片加载失败就显示默认图片</span>              el.<span class="hljs-property">src</span> = defaultImg  <span class="hljs-comment">// 默认图片需要导入进来,不能直接写路径</span>            &#125;          &#125;        &#125;)      &#125;    &#125;)复制代码</code></pre></div><h4 id="3-33-列表数据懒加载-利用hooks抽取"><a href="#3-33-列表数据懒加载-利用hooks抽取" class="headerlink" title="3.33 列表数据懒加载 (利用hooks抽取)"></a>3.33 列表数据懒加载 (利用hooks抽取)</h4><p>在hooks里封装通用的数据懒加载api</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useLazyData</span>(<span class="hljs-params">callBack: () =&gt; <span class="hljs-keyword">void</span></span>) &#123;  <span class="hljs-comment">// 通过 ref 获得组件实例</span>  <span class="hljs-keyword">const</span> target = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)  <span class="hljs-keyword">const</span> &#123; stop &#125; = <span class="hljs-title function_">useIntersectionObserver</span>(    <span class="hljs-comment">// target这个参数是观察的目标dom容器，必须是dom容器，而且是vue3.0方式绑定的dom对象</span>    target,    <span class="hljs-comment">// isIntersecting 是否进入可视区域，true是进入 false是移出</span>    <span class="hljs-comment">// observerElement 被观察的dom</span>    <span class="hljs-function">(<span class="hljs-params">[&#123; isIntersecting &#125;]</span>) =&gt;</span> &#123;      <span class="hljs-comment">// 在此处可根据isIntersecting来判断，然后做业务</span>      <span class="hljs-keyword">if</span> (isIntersecting) &#123;        <span class="hljs-title function_">stop</span>()        <span class="hljs-title function_">callBack</span>()      &#125;    &#125;  )  <span class="hljs-keyword">return</span> target  <span class="hljs-comment">// 将响应对象作为返回值传递</span>&#125;复制代码</code></pre></div><p>在组件中使用</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> useStore <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span><span class="hljs-keyword">import</span> &#123; useLazyData &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/hooks&#x27;</span>;const &#123; home &#125; = useStore()const target = useLazyData(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> home.getHotList())复制代码</code></pre></div><h3 id="3-4-懒加载与预加载的区别"><a href="#3-4-懒加载与预加载的区别" class="headerlink" title="3.4 懒加载与预加载的区别"></a>3.4 懒加载与预加载的区别</h3><p>这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p><ul><li><strong>懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载</strong>，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。</li><li><strong>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。</strong> 通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</li></ul><h2 id="4-什么是回流-重排-与重绘"><a href="#4-什么是回流-重排-与重绘" class="headerlink" title="4. 什么是回流(重排)与重绘"></a>4. 什么是回流(重排)与重绘</h2><h3 id="4-1-什么是回流-重排-，哪些操作会导致回流"><a href="#4-1-什么是回流-重排-，哪些操作会导致回流" class="headerlink" title="4.1 什么是回流(重排)，哪些操作会导致回流"></a>4.1 什么是回流(重排)，哪些操作会导致回流</h3><p>当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为<strong>回流</strong>。</p><p>下面这些操作会导致回流：</p><ul><li>页面的首次渲染</li><li>浏览器的窗口大小发生变化</li><li>元素的内容发生变化</li><li>元素的尺寸或者位置发生变化</li><li>元素的字体大小发生变化</li><li>激活CSS伪类</li><li>查询某些属性或者调用某些方法</li><li>添加或者删除可见的DOM元素</li></ul><p>在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：</p><ul><li>全局范围：从根节点开始，对整个渲染树进行重新布局</li><li>局部范围：对渲染树的某部分或者一个渲染对象进行重新布局</li></ul><h3 id="4-2-什么是重绘，哪些操作会导致重绘"><a href="#4-2-什么是重绘，哪些操作会导致重绘" class="headerlink" title="4.2 什么是重绘，哪些操作会导致重绘"></a>4.2 什么是重绘，哪些操作会导致重绘</h3><p>当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是<strong>重绘</strong>。</p><p>下面这些操作会导致回流：</p><ul><li>color、background 相关属性：background-color、background-image 等</li><li>outline 相关属性：outline-color、outline-width 、text-decoration</li><li>border-radius、visibility、box-shadow</li></ul><p>注意： <strong>当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。</strong></p><h3 id="4-3-如何避免回流与重绘？"><a href="#4-3-如何避免回流与重绘？" class="headerlink" title="4.3 如何避免回流与重绘？"></a>4.3 如何避免回流与重绘？</h3><p><strong>减少回流与重绘的措施：</strong></p><ul><li>操作DOM时，尽量在低层级的DOM节点进行操作</li><li>不要使用<code>table</code>布局， 一个小的改动可能会使整个<code>table</code>进行重新布局</li><li>使用CSS的表达式</li><li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li><li>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li><li>避免频繁操作DOM，可以创建一个文档片段<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</li><li>将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li><li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</li></ul><h4 id="4-4-浏览器的渲染队列"><a href="#4-4-浏览器的渲染队列" class="headerlink" title="4.4 浏览器的渲染队列"></a>4.4 浏览器的渲染队列</h4><p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p><p><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p><h3 id="4-5-如何优化动画？"><a href="#4-5-如何优化动画？" class="headerlink" title="4.5 如何优化动画？"></a>4.5 如何优化动画？</h3><p>对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的<code>position</code>属性设置为<code>absolute</code>或者<code>fixed</code>，将动画脱离文档流，这样他的回流就不会影响到页面了。</p><h3 id="4-6-documentFragment-文档碎片-是什么？用它跟直接操作-DOM-的区别是什么？"><a href="#4-6-documentFragment-文档碎片-是什么？用它跟直接操作-DOM-的区别是什么？" class="headerlink" title="4.6 documentFragment (文档碎片)是什么？用它跟直接操作 DOM 的区别是什么？"></a>4.6 documentFragment (文档碎片)是什么？用它跟直接操作 DOM 的区别是什么？</h3><p>当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。DocumentFragment不是真实 DOM 树的一部分，它的变化<strong>不会触发 DOM 树的重新渲染</strong>，这样就<strong>大大提高了页面的性能</strong>。</p><h5 id="假如有-10000-个元素需要添加到页面上，你觉得怎么操作性能最好（考察文档碎片）"><a href="#假如有-10000-个元素需要添加到页面上，你觉得怎么操作性能最好（考察文档碎片）" class="headerlink" title="假如有 10000 个元素需要添加到页面上，你觉得怎么操作性能最好（考察文档碎片）"></a>假如有 10000 个元素需要添加到页面上，你觉得怎么操作性能最好（考察<code>文档碎片</code>）</h5><div class="code-wrapper"><pre><code class="hljs xquery"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml">     /* console.time(&#x27;耗时&#x27;)</span><span class="language-xml">    for (let i = 1; i &lt;= 1000; i++) </span><span class="language-xquery">&#123;</span><span class="language-xquery">     <span class="hljs-built_in"> document</span>.body.innerHTML =<span class="hljs-built_in"> document</span>.body.innerHTML + `<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$</span><span class="language-xquery">&#123;i&#125;</span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span>`    &#125;    console.timeEnd(<span class="hljs-string">&#x27;耗时&#x27;</span>) // <span class="hljs-number">1586.053955078125</span> ms */    /* console.time(<span class="hljs-string">&#x27;耗时&#x27;</span>)    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i++) &#123;      str += `<span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$</span></span></span><span class="language-xquery"><span class="language-xquery">&#123;i&#125;</span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span>`    &#125;   <span class="hljs-built_in"> document</span>.body.innerHTML = str    console.timeEnd(<span class="hljs-string">&#x27;耗时&#x27;</span>) // <span class="hljs-number">2.5810546875</span> ms */    /* console.time(<span class="hljs-string">&#x27;耗时&#x27;</span>)    const arr = []    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i++) &#123;      arr.push(`<span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$</span></span></span><span class="language-xquery"><span class="language-xquery">&#123;i&#125;</span></span><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span>`)    &#125;   <span class="hljs-built_in"> document</span>.body.innerHTML = arr.join(<span class="hljs-string">&#x27;&#x27;</span>)    console.timeEnd(<span class="hljs-string">&#x27;耗时&#x27;</span>) // <span class="hljs-number">2.883056640625</span> ms */    /* console.time(<span class="hljs-string">&#x27;耗时&#x27;</span>)    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i++) &#123;      const oDiv =<span class="hljs-built_in"> document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>)      // 更灵活      oDiv.innerHTML = i      oDiv.onclick = <span class="hljs-keyword">function</span> () &#123; &#125;      oDiv.style.backgroundColor = <span class="hljs-string">&#x27;red&#x27;</span>     <span class="hljs-built_in"> document</span>.body.appendChild(oDiv)    &#125;    console.timeEnd(<span class="hljs-string">&#x27;耗时&#x27;</span>) // <span class="hljs-number">7.409912109375</span> ms */     console.time(<span class="hljs-string">&#x27;耗时&#x27;</span>)    // 篮子，“文档碎片”    const oFrag =<span class="hljs-built_in"> document</span>.createDocumentFragment()    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i++) &#123;      const oDiv =<span class="hljs-built_in"> document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>)      oDiv.innerHTML = i      oFrag.appendChild(oDiv)    &#125;   <span class="hljs-built_in"> document</span>.body.appendChild(oFrag)    console.timeEnd(<span class="hljs-string">&#x27;耗时&#x27;</span>) // <span class="hljs-number">13.442138671875</span> ms&lt;/script&gt;复制代码</code></pre></div><h2 id="5-什么是节流与防抖"><a href="#5-什么是节流与防抖" class="headerlink" title="5. 什么是节流与防抖"></a>5. 什么是节流与防抖</h2><h3 id="5-1-对节流与防抖的理解"><a href="#5-1-对节流与防抖的理解" class="headerlink" title="5.1 对节流与防抖的理解"></a>5.1 对节流与防抖的理解</h3><ul><li>函数防抖是指<strong>事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</strong> 这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</li><li>函数节流是指规定一个单位时间，<strong>在这个单位时间内，只能有一次触发事件的回调函数执行</strong>，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</li></ul><h3 id="5-2-适用场景"><a href="#5-2-适用场景" class="headerlink" title="5.2 适用场景"></a>5.2 适用场景</h3><p><strong>防抖函数的应用场景：</strong></p><ul><li>按钮提交场景：防⽌多次提交按钮，<strong>只执⾏最后提交的⼀次</strong></li><li>服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce</li></ul><p><strong>节流函数的适⽤场景：</strong></p><ul><li>拖拽场景：<strong>固定时间内只执⾏⼀次</strong>，防⽌超⾼频次触发位置变动</li><li>缩放场景：监控浏览器resize</li><li>动画场景：避免短时间内多次触发动画引起性能问题</li></ul><h3 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h3><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-comment">// //防抖</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span><span class="hljs-params">(fn, date)</span> &#123;  let timer  <span class="hljs-comment">//声明接收定时器的变量</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...arg</span>)</span> &#123;  <span class="hljs-comment">// 获取参数</span>    timer &amp;&amp; clearTimeout(timer)  <span class="hljs-comment">// 清空定时器</span>    timer = setTimeout(() =&gt; &#123;  <span class="hljs-comment">//  生成新的定时器</span>      <span class="hljs-comment">//因为箭头函数里的this指向上层作用域的this,所以这里可以直接用this，不需要声明其他的变量来接收</span>      fn.apply(<span class="hljs-keyword">this</span>, arg) <span class="hljs-comment">// fn()</span>    &#125;, date)  &#125;&#125;<span class="hljs-comment">//--------------------------------</span><span class="hljs-comment">// 节流</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span><span class="hljs-params">(fn, data)</span> &#123;  let timer = +<span class="hljs-keyword">new</span> Date()  <span class="hljs-comment">// 声明初始时间</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...arg</span>)</span> &#123; <span class="hljs-comment">// 获取参数</span>    let newTimer = +<span class="hljs-keyword">new</span> Date()  <span class="hljs-comment">// 获取触发事件的时间</span>    <span class="hljs-keyword">if</span> (newTimer - timer &gt;= data) &#123;  <span class="hljs-comment">// 时间判断,是否满足条件</span>      fn.apply(<span class="hljs-keyword">this</span>, arg)  <span class="hljs-comment">// 调用需要执行的函数,修改this值,并且传入参数</span>      timer = +<span class="hljs-keyword">new</span> Date() <span class="hljs-comment">// 重置初始时间</span>    &#125;  &#125;&#125;<span class="hljs-comment">// --------------------------------</span>box.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, debounce(<span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> &#123;  <span class="hljs-keyword">if</span> (e.target.tagName === <span class="hljs-string">&#x27;BUTTON&#x27;</span>) &#123;    console.log(<span class="hljs-number">111</span>);  &#125;&#125;, <span class="hljs-number">2000</span>))复制代码</code></pre></div><h2 id="6-如何对项目中的图片进行优化？"><a href="#6-如何对项目中的图片进行优化？" class="headerlink" title="6. 如何对项目中的图片进行优化？"></a>6. 如何对项目中的图片进行优化？</h2><ol><li><p>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</p></li><li><p>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</p></li><li><p>小图使用 base64 格式</p></li><li><p>将多个图标文件整合到一张图片中（雪碧图）</p></li><li><p>选择正确的图片格式：</p><ul><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li><li>照片使用 JPEG</li></ul></li></ol><h2 id="7-webpack知识总结"><a href="#7-webpack知识总结" class="headerlink" title="7. webpack知识总结"></a>7. webpack知识总结</h2><h3 id="7-1-什么是webpack"><a href="#7-1-什么是webpack" class="headerlink" title="7.1.什么是webpack"></a>7.1.什么是webpack</h3><ul><li><em>静态模块打包工具</em></li></ul><h3 id="7-2-webpack作用"><a href="#7-2-webpack作用" class="headerlink" title="7.2.webpack作用"></a>7.2.webpack作用</h3><ul><li>分析、压缩、打包代码</li></ul><h3 id="7-3-webpack好处"><a href="#7-3-webpack好处" class="headerlink" title="7.3.webpack好处"></a>7.3.webpack好处</h3><ul><li>减少文件体积、减少文件数量</li><li>提高网页加载速度</li></ul><h3 id="7-4-webpack工作流程"><a href="#7-4-webpack工作流程" class="headerlink" title="7.4.webpack工作流程"></a>7.4.webpack工作流程</h3><ul><li>1.初始化参数：从配置文件读取与合并参数，得出最终的参数</li><li>2.开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，开始执行编译</li><li>3.确定入口：根据配置中的 entry 找出所有的入口文件</li><li>4.编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li>5.完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li><li>6.输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li>7。输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ul><h3 id="7-5-什么是loader，什么是Plugin"><a href="#7-5-什么是loader，什么是Plugin" class="headerlink" title="7.5.什么是loader，什么是Plugin"></a>7.5.什么是loader，什么是Plugin</h3><ul><li><p><code>loader</code>直译为”加载器”。webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</p><ul><li><p>说人话： loader就是用于解析文件的 （类似War3的游戏地图）</p><ul><li>例如：css-loader 、style-loader、image-loader</li></ul></li></ul></li><li><p><code>Plugin</code>直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果。</p><ul><li><p>说人话：插件就是拓展功能的 （类似游戏的作弊器）</p><ul><li>例如：html-webpack-plugin,</li></ul></li></ul></li><li><p>个人见解： 广义来说,loader属于插件的一种。</p><ul><li>插件范围很广 ： 只要不是webapck原生的功能，都可以理解为插件</li><li>loader ： 一种特殊的插件，主要是用在webpack编译环节，帮我们编译各种文件的</li></ul></li></ul><h3 id="7-6-有哪些常见的Loader？你用过哪些Loader？"><a href="#7-6-有哪些常见的Loader？你用过哪些Loader？" class="headerlink" title="7.6 有哪些常见的Loader？你用过哪些Loader？"></a>7.6 有哪些常见的Loader？你用过哪些Loader？</h3><p><code>raw-loader</code>：加载文件原始内容（utf-8）</p><p><code>file-loader</code>：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</p><p><code>url-loader</code>：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)</p><p><code>source-map-loader</code>：加载额外的 Source Map 文件，以方便断点调试</p><p><code>svg-inline-loader</code>：将压缩后的 SVG 内容注入代码中</p><p><code>image-loader</code>：加载并且压缩图片文件</p><p><code>json-loader</code> 加载 JSON 文件（默认包含）</p><p><code>handlebars-loader</code>: 将 Handlebars 模版编译成函数并返回</p><p><code>babel-loader</code>：把 ES6 转换成 ES5</p><p><code>ts-loader</code>: 将 TypeScript 转换成 JavaScript</p><p><code>awesome-typescript-loader</code>：将 TypeScript 转换成 JavaScript，性能优于 ts-loader</p><p><code>sass-loader</code>：将SCSS&#x2F;SASS代码转换成CSS</p><p><code>css-loader</code>：加载 CSS，支持模块化、压缩、文件导入等特性</p><p><code>style-loader</code>：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</p><p><code>postcss-loader</code>：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</p><p><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码</p><p><code>tslint-loader</code>：通过 TSLint检查 TypeScript 代码</p><h3 id="7-7-有哪些常见的Plugin？你用过哪些Plugin？"><a href="#7-7-有哪些常见的Plugin？你用过哪些Plugin？" class="headerlink" title="7.7 有哪些常见的Plugin？你用过哪些Plugin？"></a>7.7 有哪些常见的Plugin？你用过哪些Plugin？</h3><p><code>define-plugin</code>：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</p><p><code>ignore-plugin</code>：忽略部分文件</p><p><code>html-webpack-plugin</code>：简化 HTML 文件创建 (依赖于 html-loader)</p><p><code>web-webpack-plugin</code>：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用</p><p><code>uglifyjs-webpack-plugin</code>：不支持 ES6 压缩 (Webpack4 以前)</p><p><code>terser-webpack-plugin</code>: 支持压缩 ES6 (Webpack4)</p><p><code>webpack-parallel-uglify-plugin</code>: 多进程执行代码压缩，提升构建速度</p><p><code>mini-css-extract-plugin</code>: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)</p><p><code>serviceworker-webpack-plugin</code>：为网页应用增加离线缓存功能</p><p><code>clean-webpack-plugin</code>: 目录清理</p><p><code>ModuleConcatenationPlugin</code>: 开启 Scope Hoisting</p><p><code>speed-measure-webpack-plugin</code>: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)</p><p><code>webpack-bundle-analyzer</code>: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</p><h3 id="7-8-那你再说一说Loader和Plugin的区别？"><a href="#7-8-那你再说一说Loader和Plugin的区别？" class="headerlink" title="7.8 那你再说一说Loader和Plugin的区别？"></a>7.8 那你再说一说Loader和Plugin的区别？</h3><p><code>Loader</code> 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p><p><code>Plugin</code> 就是插件，基于事件流框架 <code>Tapable</code>，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><p><code>Loader</code> 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。</p><p><code>Plugin</code> 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入</p><h3 id="7-9-说一下-Webpack-的热更新原理吧"><a href="#7-9-说一下-Webpack-的热更新原理吧" class="headerlink" title="7.9 说一下 Webpack 的热更新原理吧"></a>7.9 说一下 Webpack 的热更新原理吧</h3><p><code>Webpack</code> 的热更新又称热替换（<code>Hot Module Replacement</code>），缩写为 <code>HMR</code>。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p><p>HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 <code>Websocket</code>，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 <code>Ajax</code> 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 <code>jsonp</code> 请求获取该chunk的增量更新。</p><p>后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 <code>HotModulePlugin</code> 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像<code>react-hot-loader</code> 和 <code>vue-loader</code> 都是借助这些 API 实现 HMR。</p><h3 id="7-10-代码分割的本质是什么？有什么意义呢？"><a href="#7-10-代码分割的本质是什么？有什么意义呢？" class="headerlink" title="7.10 代码分割的本质是什么？有什么意义呢？"></a>7.10 代码分割的本质是什么？有什么意义呢？</h3><p>代码分割的本质其实就是在<code>源代码直接上线</code>和<code>打包成唯一脚本main.bundle.js</code>这两种极端方案之间的一种更适合实际场景的中间状态。</p><p><strong>「用可接受的服务器性能压力增加来换取更好的用户体验。」</strong></p><p>源代码直接上线：虽然过程可控，但是http请求多，性能开销大。</p><p>打包成唯一脚本：一把梭完自己爽，服务器压力小，但是页面空白期长，用户体验不好。</p><h2 id="8-Webpack优化"><a href="#8-Webpack优化" class="headerlink" title="8. Webpack优化"></a>8. Webpack优化</h2><h3 id="8-1-如何提⾼webpack的打包速度"><a href="#8-1-如何提⾼webpack的打包速度" class="headerlink" title="8.1 如何提⾼webpack的打包速度?"></a>8.1 如何提⾼<strong>webpack</strong>的打包<strong>速度</strong>?</h3><p><strong>（1）优化 Loader</strong></p><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，<strong>转换代码越多，效率就越低</strong>。</p><p><strong>（2）HappyPack</strong></p><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p><p><strong>HappyPack 可以将 Loader 的同步执行转换为并行的</strong>，这样就能充分利用系统资源来加快打包效率了</p><p><strong>（3）DllPlugin</strong></p><p><strong>DllPlugin 可以将特定的类库提前打包然后引入</strong>。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。</p><p><strong>（4）代码压缩</strong></p><p>在 Webpack3 中，一般使用 <code>UglifyJS</code> 来压缩代码，但是这个是单线程运行的，为了加快效率，可以使用 <code>webpack-parallel-uglify-plugin</code> 来并行运行 <code>UglifyJS</code>，从而提高效率。</p><p>在 Webpack4 中，不需要以上这些操作了，只需要<strong>将 <code>mode</code> 设置为 <code>production</code></strong> 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 <code>console.log</code> 这类代码的功能。</p><h3 id="8-2-如何减少-Webpack-打包体积"><a href="#8-2-如何减少-Webpack-打包体积" class="headerlink" title="8.2 如何减少 Webpack 打包体积"></a>8.2 如何减少 Webpack 打包<strong>体积</strong></h3><p><strong>（1）按需加载</strong></p><p>在开发 SPA 项目的时候，项目中都会存在很多路由页面。如果将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，希望首页能加载的文件体积越小越好，<strong>这时候就可以使用按需加载，将每个路由页面单独打包为一个文件</strong>。当然不仅仅路由可以按需加载，对于 <code>loadash</code> 这种大型类库同样可以使用这个功能。</p><p><strong>（2）Scope Hoisting</strong></p><p><strong>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</strong></p><p><strong>（3）Tree Shaking</strong></p><p><strong>Tree Shaking 可以实现删除项目中未被引用的代码</strong>。可以通过在启动webpack时追加参数 –optimize-minimize 来实现</p><h3 id="8-3-如何⽤webpack来优化前端性能？"><a href="#8-3-如何⽤webpack来优化前端性能？" class="headerlink" title="8.3 如何⽤webpack来优化前端性能？"></a>8.3 如何⽤<strong>webpack</strong>来优化前端<strong>性能</strong>？</h3><p>⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。</p><ul><li><strong>压缩代码</strong>：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css</li><li><strong>利⽤CDN加速</strong>: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径</li><li><strong>Tree Shaking</strong>: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 –optimize-minimize 来实现</li><li><strong>Code Splitting (自动):</strong> 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存</li><li><strong>提取公共第三⽅库</strong>: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</li></ul><h3 id="8-4-如何提⾼webpack的构建速度？"><a href="#8-4-如何提⾼webpack的构建速度？" class="headerlink" title="8.4 如何提⾼webpack的构建速度？"></a>8.4 如何提⾼<strong>webpack</strong>的构建速度？</h3><ul><li>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码</li><li>通过 <strong>externals</strong> 配置来提取常⽤库</li><li>利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。</li><li>使⽤ Happypack 实现多线程加速编译</li><li>使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度</li><li>使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码</li></ul><h3 id="8-5-什么是长缓存？在Webpack中如何做到长缓存优化？"><a href="#8-5-什么是长缓存？在Webpack中如何做到长缓存优化？" class="headerlink" title="8.5 什么是长缓存？在Webpack中如何做到长缓存优化？"></a>8.5 什么是长缓存？在Webpack中如何做到长缓存优化？</h3><p>1、什么是长缓存</p><p>浏览器在用户访问页面的时候，为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或者更新，都需要浏览器去下载新的代码，最方便的更新方式就是引入新的文件名称，只下载新的代码块，不加载旧的代码块，这就是长缓存。</p><p>2、具体实现</p><p>在Webpack中，可以在output给出输出的文件制定chunkhash，并且分离经常更新的代码和框架代码，通NameModulesPlugin或者HashedModulesPlugin使再次打包文件名不变</p><h3 id="8-6-怎么实现Webpack的按需加载"><a href="#8-6-怎么实现Webpack的按需加载" class="headerlink" title="8.6 怎么实现Webpack的按需加载"></a>8.6 怎么实现Webpack的按需加载</h3><p>在Webpack中，import不仅仅是ES6module的模块导入方式，还是一个类似require的函数，我们可以通过import(‘module’)的方式引入一个模块，import()返回的是一个Promise对象；使用import（）方式就可以实现 Webpack的按需加载</p><h3 id="8-7-什么是神奇注释？"><a href="#8-7-什么是神奇注释？" class="headerlink" title="8.7 什么是神奇注释？"></a>8.7 什么是神奇注释？</h3><p>在import（）里可以添加一些注释，如定义该chunk的名称，要过滤的文件，指定引入的文件等等，这类带有特殊功能的注释被称为神器注释。</p><h2 id="9-什么是虚拟列表"><a href="#9-什么是虚拟列表" class="headerlink" title="9. 什么是虚拟列表"></a>9. 什么是虚拟列表</h2><p><code>虚拟列表</code>其实是按需显示的一种实现，即<strong>只对<code>可见区域</code>进行渲染，对<code>非可见区域</code>中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。</strong></p><p>假设有1万条记录需要同时渲染，我们屏幕的<code>可见区域</code>的高度为<code>500px</code>,而列表项的高度为<code>50px</code>，则此时我们在屏幕中最多只能看到10个列表项，那么在首次渲染的时候，我们只需加载10条即可。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b5c02be2a1541e989b41455ba0b9eab~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"></p><h3 id="虚拟列表如何实现"><a href="#虚拟列表如何实现" class="headerlink" title="虚拟列表如何实现"></a>虚拟列表如何实现</h3><p>虚拟列表的实现，实际上就是在首屏加载的时候，只加载<code>可视区域</code>内需要的列表项，当滚动发生时，动态通过计算获得<code>可视区域</code>内的列表项，并将<code>非可视区域</code>内存在的列表项删除。</p><ul><li>计算当前<code>可视区域</code>起始数据索引(<code>startIndex</code>)</li><li>计算当前<code>可视区域</code>结束数据索引(<code>endIndex</code>)</li><li>计算当前<code>可视区域的</code>数据，并渲染到页面中</li><li>计算<code>startIndex</code>对应的数据在整个列表中的偏移位置<code>startOffset</code>并设置到列表上</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/196ce5b45fe9472e8993a3349a78e33f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"></p><p>由于只是对<code>可视区域</code>内的列表项进行渲染，所以为了保持列表容器的高度并可正常的触发滚动，将Html结构设计成如下结构：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;infinite-list-container&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;infinite-list-phantom&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;infinite-list&quot;</span>&gt;</span>      <span class="hljs-comment">&lt;!-- item-1 --&gt;</span>      <span class="hljs-comment">&lt;!-- item-2 --&gt;</span>      <span class="hljs-comment">&lt;!-- ...... --&gt;</span>      <span class="hljs-comment">&lt;!-- item-n --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>复制代码</code></pre></div><ul><li><code>infinite-list-container</code> 为<code>可视区域</code>的容器</li><li><code>infinite-list-phantom</code> 为容器内的占位，高度为总列表高度，用于形成滚动条</li><li><code>infinite-list</code> 为列表项的<code>渲染区域</code></li></ul><p>接着，监听<code>infinite-list-container</code>的<code>scroll</code>事件，获取滚动位置<code>scrollTop</code></p><ul><li>假定<code>可视区域</code>高度固定，称之为<code>screenHeight</code></li><li>假定<code>列表每项</code>高度固定，称之为<code>itemSize</code></li><li>假定<code>列表数据</code>称之为<code>listData</code></li><li>假定<code>当前滚动位置</code>称之为<code>scrollTop</code></li></ul><p>则可推算出：</p><ul><li>列表总高度<code>listHeight</code> &#x3D; listData.length * itemSize</li><li>可显示的列表项数<code>visibleCount</code> &#x3D; Math.ceil(screenHeight &#x2F; itemSize)</li><li>数据的起始索引<code>startIndex</code> &#x3D; Math.floor(scrollTop &#x2F; itemSize)</li><li>数据的结束索引<code>endIndex</code> &#x3D; startIndex + visibleCount</li><li>列表显示数据为<code>visibleData</code> &#x3D; listData.slice(startIndex,endIndex)</li></ul><p>当滚动后，由于<code>渲染区域</code>相对于<code>可视区域</code>已经发生了偏移，此时我需要获取一个偏移量<code>startOffset</code>，通过样式控制将<code>渲染区域</code>偏移至<code>可视区域</code>中。</p><ul><li>偏移量<code>startOffset</code> &#x3D; scrollTop - (scrollTop % itemSize); 用来做transform的数据</li></ul><h3 id="监听scoll事件的优化"><a href="#监听scoll事件的优化" class="headerlink" title="监听scoll事件的优化"></a>监听scoll事件的优化</h3><p>我们使用<code>监听scroll事件</code>的方式来触发可视区域中数据的更新，当滚动发生后，scroll事件会频繁触发，很多时候会造成<code>重复计算</code>的问题，从性能上来说无疑存在浪费的情况。</p><p>可以使用<code>IntersectionObserver</code>替换监听scroll事件，<code>IntersectionObserver</code>可以监听目标元素是否出现在可视区域内，在监听的回调事件中执行可视区域数据的更新，并且<code>IntersectionObserver</code>的监听回调是异步触发，不随着目标元素的滚动而触发，性能消耗极低。</p><h2 id="10-前端工程化"><a href="#10-前端工程化" class="headerlink" title="10. 前端工程化"></a>10. 前端工程化</h2><h4 id="Babel的原理是什么？"><a href="#Babel的原理是什么？" class="headerlink" title="Babel的原理是什么？"></a>Babel的原理是什么？</h4><p><strong>Babel 的主要工作是对代码进行转译。</strong> (解决兼容, 解析执行一部分代码)</p><div class="code-wrapper"><pre><code class="hljs livescript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">1</span>    =&gt;  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>复制代码</code></pre></div><p>转译分为三阶段：</p><ul><li>解析（Parse），将代码解析⽣成抽象语法树 AST，也就是词法分析与语法分析的过程</li><li>转换（Transform），对语法树进⾏变换方面的⼀系列操作。通过 babel-traverse，进⾏遍历并作添加、更新、删除等操作</li><li>⽣成（Generate），通过 babel-generator 将变换后的 AST 转换为 JS 代码</li></ul><p>我们可以通过 AST Explorer 工具来查看 Babel 具体生成的 AST 节点。</p><h2 id="11-什么是单点登录？"><a href="#11-什么是单点登录？" class="headerlink" title="11. 什么是单点登录？"></a>11. 什么是单点登录？</h2><p>单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一</p><p>SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统</p><p>SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过<code>passport</code>，子系统本身将不参与登录操作</p><p>当一个系统成功登录以后，<code>passport</code>将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被<code>passport</code>授权以后，会建立一个局部会话，在一定时间内可以无需再次向<code>passport</code>发起认证</p><h2 id="12-大文件上传如何做分片上传、断点继传？"><a href="#12-大文件上传如何做分片上传、断点继传？" class="headerlink" title="12. 大文件上传如何做分片上传、断点继传？"></a>12. 大文件上传如何做分片上传、断点继传？</h2><h3 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h3><p>分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传</p><p>如下图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c63c2f9f5fca4708860bb7df241430a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"></p><p>上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件</p><p>大致流程如下：</p><ol><li>将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；</li><li>初始化一个分片上传任务，返回本次分片上传唯一标识；</li><li>然后借助 http 的可并发性，同时上传多个切片</li><li>发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件</li></ol><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分</p><p>每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度</p><p>一般实现方式有两种：</p><ul><li>服务器端返回，告知从哪开始</li><li>浏览器端自行处理</li></ul><p>上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可</p><p>如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可</p><p><strong>使用场景</strong></p><ul><li>大文件加速上传：当文件大小超过预期大小时，使用分片上传可实现并行上传多个 Part， 以加快上传速度</li><li>网络环境较差：建议使用分片上传。当出现上传失败的时候，仅需重传失败的Part</li><li>流式上传：可以在需要上传的文件大小还不确定的情况下开始上传。这种场景在视频监控等行业应用中比较常见</li></ul><h2 id="13-npm-run-dev的时候webpack做了什么事情"><a href="#13-npm-run-dev的时候webpack做了什么事情" class="headerlink" title="13. npm run dev的时候webpack做了什么事情"></a>13. npm run dev的时候webpack做了什么事情</h2><p>执行<strong>npm run dev</strong>时候最先执行的<strong>build&#x2F;dev-server.js</strong>文件，该文件主要完成下面几件事情：</p><p>1、检查node和npm的<strong>版本</strong>、引入相关<strong>插件</strong>和<strong>配置</strong></p><p>2、webpack对源码进行<strong>编译打包</strong>并返回compiler对象</p><p>3、<strong>创建express服务器</strong></p><p>4、<strong>配置开发中间件</strong>（webpack-dev-middleware）和<strong>热重载中间件</strong>（webpack-hot-middleware）</p><p>5、<strong>挂载代理服务和中间件</strong></p><p>6、配置静态资源</p><p>7、启动服务器监听特定端口（8080）</p><p>8、自动打开浏览器并打开特定网址（localhost:8080）</p>]]></content>
    
    
    
    <tags>
      
      <tag>Node</tag>
      
      <tag>Webpack</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SVG的理解</title>
    <link href="/2023/02/01/SVG%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2023/02/01/SVG%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>SVG 是一种基于 XML 语法的图像格式，全称是可缩放矢量图（Scalable Vector Graphics）。其他图像格式都是基于像素处理的，SVG 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。</p><p><img src="https://www.wangbase.com/blogimg/asset/201808/bg2018080601.jpg"></p><p>SVG 文件可以直接插入网页，成为 DOM 的一部分，然后用 JavaScript 和 CSS 进行操作。</p><blockquote><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">svg</span></span><span class="hljs-tag"><span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysvg&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;0 0 800 600&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">preserveAspectRatio</span>=<span class="hljs-string">&quot;xMidYMid meet&quot;</span></span><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mycircle&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;50&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></blockquote><p>上面是 SVG 代码直接插入网页的例子。</p><p>SVG 代码也可以写在一个独立文件中，然后用<code>&lt;img&gt;</code>、<code>&lt;object&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;iframe&gt;</code>等标签插入网页。</p><blockquote><div class="code-wrapper"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;circle.svg&quot;</span>&gt;&lt;object <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;object&quot;</span> <span class="hljs-attribute">data</span>=<span class="hljs-string">&quot;circle.svg&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;image/svg+xml&quot;</span>&gt;&lt;/object&gt;&lt;embed <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;embed&quot;</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;icon.svg&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;image/svg+xml&quot;</span>&gt;&lt;iframe <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;iframe&quot;</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;icon.svg&quot;</span>&gt;&lt;/iframe&gt;</code></pre></div></blockquote><p>CSS 也可以使用 SVG 文件。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.logo</span> &#123;<span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">icon.svg</span>);&#125;</code></pre></div></blockquote><p>SVG 文件还可以转为 BASE64 编码，然后作为 Data URI 写入网页。</p><blockquote><div class="code-wrapper"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;data:image/svg+xml;base64,[data]&quot;</span>&gt;</code></pre></div></blockquote><h2 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h2><h3 id="lt-svg-gt-标签"><a href="#lt-svg-gt-标签" class="headerlink" title="&lt;svg&gt;标签"></a><code>&lt;svg&gt;</code>标签</h3><p>SVG 代码都放在顶层标签<code>&lt;svg&gt;</code>之中。下面是一个例子。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;100%&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;100%&quot;</span>&gt;&lt;circle id<span class="hljs-operator">=</span><span class="hljs-string">&quot;mycircle&quot;</span> cx<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> cy<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> r<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> /&gt;&lt;/svg&gt;</code></pre></div></blockquote><p><code>&lt;svg&gt;</code>的<code>width</code>属性和<code>height</code>属性，指定了 SVG 图像在 HTML 元素中所占据的宽度和高度。除了相对单位，也可以采用绝对单位（单位：像素）。如果不指定这两个属性，SVG 图像默认大小是300像素（宽） x 150像素（高）。</p><p>如果只想展示 SVG 图像的一部分，就要指定<code>viewBox</code>属性。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;100&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;100&quot;</span> viewBox<span class="hljs-operator">=</span><span class="hljs-string">&quot;50 50 50 50&quot;</span>&gt;&lt;circle id<span class="hljs-operator">=</span><span class="hljs-string">&quot;mycircle&quot;</span> cx<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> cy<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> r<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> /&gt;&lt;/svg&gt;</code></pre></div></blockquote><p><code>&lt;viewBox&gt;</code>属性的值有四个数字，分别是左上角的横坐标和纵坐标、视口的宽度和高度。上面代码中，SVG 图像是100像素宽 x 100像素高，<code>viewBox</code>属性指定视口从<code>(50, 50)</code>这个点开始。所以，实际看到的是右下角的四分之一圆。</p><p>注意，视口必须适配所在的空间。上面代码中，视口的大小是 50 x 50，由于 SVG 图像的大小是 100 x 100，所以视口会放大去适配 SVG 图像的大小，即放大了四倍。</p><p>如果不指定<code>width</code>属性和<code>height</code>属性，只指定<code>viewBox</code>属性，则相当于只给定 SVG 图像的长宽比。这时，SVG 图像的默认大小将等于所在的 HTML 元素的大小。</p><h3 id="lt-circle-gt-标签"><a href="#lt-circle-gt-标签" class="headerlink" title="&lt;circle&gt;标签"></a><code>&lt;circle&gt;</code>标签</h3><p><code>&lt;circle&gt;</code>标签代表圆形。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;300&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;180&quot;</span>&gt;&lt;circle cx<span class="hljs-operator">=</span><span class="hljs-string">&quot;30&quot;</span>  cy<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> r<span class="hljs-operator">=</span><span class="hljs-string">&quot;25&quot;</span> /&gt;&lt;circle cx<span class="hljs-operator">=</span><span class="hljs-string">&quot;90&quot;</span>  cy<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> r<span class="hljs-operator">=</span><span class="hljs-string">&quot;25&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;red&quot;</span> /&gt;&lt;circle cx<span class="hljs-operator">=</span><span class="hljs-string">&quot;150&quot;</span> cy<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> r<span class="hljs-operator">=</span><span class="hljs-string">&quot;25&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;fancy&quot;</span> /&gt;&lt;/svg&gt;</code></pre></div></blockquote><p>上面的代码定义了三个圆。<code>&lt;circle&gt;</code>标签的<code>cx</code>、<code>cy</code>、<code>r</code>属性分别为横坐标、纵坐标和半径，单位为像素。坐标都是相对于<code>&lt;svg&gt;</code>画布的左上角原点。</p><p><code>class</code>属性用来指定对应的 CSS 类。</p><blockquote><div class="code-wrapper"><pre><code class="hljs processing">.<span class="hljs-property">red</span> &#123;<span class="hljs-built_in">fill</span>: <span class="hljs-built_in">red</span>;&#125;.<span class="hljs-property">fancy</span> &#123;<span class="hljs-built_in">fill</span>: none;<span class="hljs-built_in">stroke</span>: black;<span class="hljs-built_in">stroke</span>-<span class="hljs-built_in">width</span>: <span class="hljs-number">3</span>pt;&#125;</code></pre></div></blockquote><p>SVG 的 CSS 属性与网页元素有所不同。</p><blockquote><ul><li>fill：填充色</li><li>stroke：描边色</li><li>stroke-width：边框宽度</li></ul></blockquote><h3 id="lt-line-gt-标签"><a href="#lt-line-gt-标签" class="headerlink" title="&lt;line&gt;标签"></a><code>&lt;line&gt;</code>标签</h3><p><code>&lt;line&gt;</code>标签用来绘制直线。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;300&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;180&quot;</span>&gt;&lt;line x1<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> y1<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> x2<span class="hljs-operator">=</span><span class="hljs-string">&quot;200&quot;</span> y2<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> style<span class="hljs-operator">=</span><span class="hljs-string">&quot;stroke:rgb(0,0,0);stroke-width:5&quot;</span> /&gt;&lt;/svg&gt;</code></pre></div></blockquote><p>上面代码中，<code>&lt;line&gt;</code>标签的<code>x1</code>属性和<code>y1</code>属性，表示线段起点的横坐标和纵坐标；<code>x2</code>属性和<code>y2</code>属性，表示线段终点的横坐标和纵坐标；<code>style</code>属性表示线段的样式。</p><h3 id="lt-polyline-gt-标签"><a href="#lt-polyline-gt-标签" class="headerlink" title="&lt;polyline&gt;标签"></a><code>&lt;polyline&gt;</code>标签</h3><p><code>&lt;polyline&gt;</code>标签用于绘制一根折线。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;300&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;180&quot;</span>&gt;&lt;polyline points<span class="hljs-operator">=</span><span class="hljs-string">&quot;3,3 30,28 3,53&quot;</span> fill<span class="hljs-operator">=</span><span class="hljs-string">&quot;none&quot;</span> stroke<span class="hljs-operator">=</span><span class="hljs-string">&quot;black&quot;</span> /&gt;&lt;/svg&gt;</code></pre></div></blockquote><p><code>&lt;polyline&gt;</code>的<code>points</code>属性指定了每个端点的坐标，横坐标与纵坐标之间与逗号分隔，点与点之间用空格分隔。</p><h3 id="lt-rect-gt-标签"><a href="#lt-rect-gt-标签" class="headerlink" title="&lt;rect&gt;标签"></a><code>&lt;rect&gt;</code>标签</h3><p><code>&lt;rect&gt;</code>标签用于绘制矩形。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;300&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;180&quot;</span>&gt;&lt;rect x<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;100&quot;</span> width<span class="hljs-operator">=</span><span class="hljs-string">&quot;200&quot;</span> style<span class="hljs-operator">=</span><span class="hljs-string">&quot;stroke: #70d5dd; fill: #dd524b&quot;</span> /&gt;&lt;/svg&gt;</code></pre></div></blockquote><p><code>&lt;rect&gt;</code>的<code>x</code>属性和<code>y</code>属性，指定了矩形左上角端点的横坐标和纵坐标；<code>width</code>属性和<code>height</code>属性指定了矩形的宽度和高度（单位像素）。</p><h3 id="lt-ellipse-gt-标签"><a href="#lt-ellipse-gt-标签" class="headerlink" title="&lt;ellipse&gt;标签"></a><code>&lt;ellipse&gt;</code>标签</h3><p><code>&lt;ellipse&gt;</code>标签用于绘制椭圆。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;300&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;180&quot;</span>&gt;&lt;ellipse cx<span class="hljs-operator">=</span><span class="hljs-string">&quot;60&quot;</span> cy<span class="hljs-operator">=</span><span class="hljs-string">&quot;60&quot;</span> ry<span class="hljs-operator">=</span><span class="hljs-string">&quot;40&quot;</span> rx<span class="hljs-operator">=</span><span class="hljs-string">&quot;20&quot;</span> stroke<span class="hljs-operator">=</span><span class="hljs-string">&quot;black&quot;</span> stroke-width<span class="hljs-operator">=</span><span class="hljs-string">&quot;5&quot;</span> fill<span class="hljs-operator">=</span><span class="hljs-string">&quot;silver&quot;</span>/&gt;&lt;/svg&gt;</code></pre></div></blockquote><p><code>&lt;ellipse&gt;</code>的<code>cx</code>属性和<code>cy</code>属性，指定了椭圆中心的横坐标和纵坐标（单位像素）；<code>rx</code>属性和<code>ry</code>属性，指定了椭圆横向轴和纵向轴的半径（单位像素）。</p><h3 id="lt-polygon-gt-标签"><a href="#lt-polygon-gt-标签" class="headerlink" title="&lt;polygon&gt;标签"></a><code>&lt;polygon&gt;</code>标签</h3><p><code>&lt;polygon&gt;</code>标签用于绘制多边形。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;300&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;180&quot;</span>&gt;&lt;polygon fill<span class="hljs-operator">=</span><span class="hljs-string">&quot;green&quot;</span> stroke<span class="hljs-operator">=</span><span class="hljs-string">&quot;orange&quot;</span> stroke-width<span class="hljs-operator">=</span><span class="hljs-string">&quot;1&quot;</span> points<span class="hljs-operator">=</span><span class="hljs-string">&quot;0,0 100,0 100,100 0,100 0,0&quot;</span>/&gt;&lt;/svg&gt;</code></pre></div></blockquote><p><code>&lt;polygon&gt;</code>的<code>points</code>属性指定了每个端点的坐标，横坐标与纵坐标之间与逗号分隔，点与点之间用空格分隔。</p><h3 id="lt-path-gt-标签"><a href="#lt-path-gt-标签" class="headerlink" title="&lt;path&gt;标签"></a><code>&lt;path&gt;</code>标签</h3><p><code>&lt;path&gt;</code>标签用于制路径。</p><blockquote><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;180&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;</span></span><span class="hljs-string"><span class="hljs-tag">M 18,3</span></span><span class="hljs-string"><span class="hljs-tag">L 46,3</span></span><span class="hljs-string"><span class="hljs-tag">L 46,40</span></span><span class="hljs-string"><span class="hljs-tag">L 61,40</span></span><span class="hljs-string"><span class="hljs-tag">L 32,68</span></span><span class="hljs-string"><span class="hljs-tag">L 3,40</span></span><span class="hljs-string"><span class="hljs-tag">L 18,40</span></span><span class="hljs-string"><span class="hljs-tag">Z</span></span><span class="hljs-string"><span class="hljs-tag">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre></div></blockquote><p><code>&lt;path&gt;</code>的<code>d</code>属性表示绘制顺序，它的值是一个长字符串，每个字母表示一个绘制动作，后面跟着坐标。</p><blockquote><ul><li>M：移动到（moveto）</li><li>L：画直线到（lineto）</li><li>Z：闭合路径</li></ul></blockquote><h3 id="lt-text-gt-标签"><a href="#lt-text-gt-标签" class="headerlink" title="&lt;text&gt;标签"></a><code>&lt;text&gt;</code>标签</h3><p><code>&lt;text&gt;</code>标签用于绘制文本。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;300&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;180&quot;</span>&gt;&lt;text x<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;25&quot;</span>&gt;Hello World&lt;/text&gt;&lt;/svg&gt;</code></pre></div></blockquote><p><code>&lt;text&gt;</code>的<code>x</code>属性和<code>y</code>属性，表示文本区块基线（baseline）起点的横坐标和纵坐标。文字的样式可以用<code>class</code>或<code>style</code>属性指定。</p><h3 id="lt-use-gt-标签"><a href="#lt-use-gt-标签" class="headerlink" title="&lt;use&gt;标签"></a><code>&lt;use&gt;</code>标签</h3><p><code>&lt;use&gt;</code>标签用于复制一个形状。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg viewBox<span class="hljs-operator">=</span><span class="hljs-string">&quot;0 0 30 10&quot;</span> xmlns<span class="hljs-operator">=</span><span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;&lt;circle id<span class="hljs-operator">=</span><span class="hljs-string">&quot;myCircle&quot;</span> cx<span class="hljs-operator">=</span><span class="hljs-string">&quot;5&quot;</span> cy<span class="hljs-operator">=</span><span class="hljs-string">&quot;5&quot;</span> r<span class="hljs-operator">=</span><span class="hljs-string">&quot;4&quot;</span>/&gt;&lt;use href<span class="hljs-operator">=</span><span class="hljs-string">&quot;#myCircle&quot;</span> x<span class="hljs-operator">=</span><span class="hljs-string">&quot;10&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> fill<span class="hljs-operator">=</span><span class="hljs-string">&quot;blue&quot;</span> /&gt;&lt;use href<span class="hljs-operator">=</span><span class="hljs-string">&quot;#myCircle&quot;</span> x<span class="hljs-operator">=</span><span class="hljs-string">&quot;20&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> fill<span class="hljs-operator">=</span><span class="hljs-string">&quot;white&quot;</span> stroke<span class="hljs-operator">=</span><span class="hljs-string">&quot;blue&quot;</span> /&gt;&lt;/svg&gt;</code></pre></div></blockquote><p><code>&lt;use&gt;</code>的<code>href</code>属性指定所要复制的节点，<code>x</code>属性和<code>y</code>属性是<code>&lt;use&gt;</code>左上角的坐标。另外，还可以指定<code>width</code>和<code>height</code>坐标。</p><h3 id="lt-g-gt-标签"><a href="#lt-g-gt-标签" class="headerlink" title="&lt;g&gt;标签"></a><code>&lt;g&gt;</code>标签</h3><p><code>&lt;g&gt;</code>标签用于将多个形状组成一个组（group），方便复用。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;300&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;100&quot;</span>&gt;&lt;g id<span class="hljs-operator">=</span><span class="hljs-string">&quot;myCircle&quot;</span>&gt;&lt;text x<span class="hljs-operator">=</span><span class="hljs-string">&quot;25&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;20&quot;</span>&gt;圆形&lt;/text&gt;&lt;circle cx<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> cy<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> r<span class="hljs-operator">=</span><span class="hljs-string">&quot;20&quot;</span>/&gt;&lt;/g&gt;&lt;use href<span class="hljs-operator">=</span><span class="hljs-string">&quot;#myCircle&quot;</span> x<span class="hljs-operator">=</span><span class="hljs-string">&quot;100&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> fill<span class="hljs-operator">=</span><span class="hljs-string">&quot;blue&quot;</span> /&gt;&lt;use href<span class="hljs-operator">=</span><span class="hljs-string">&quot;#myCircle&quot;</span> x<span class="hljs-operator">=</span><span class="hljs-string">&quot;200&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> fill<span class="hljs-operator">=</span><span class="hljs-string">&quot;white&quot;</span> stroke<span class="hljs-operator">=</span><span class="hljs-string">&quot;blue&quot;</span> /&gt;&lt;/svg&gt;</code></pre></div></blockquote><h3 id="lt-defs-gt-标签"><a href="#lt-defs-gt-标签" class="headerlink" title="&lt;defs&gt;标签"></a><code>&lt;defs&gt;</code>标签</h3><p><code>&lt;defs&gt;</code>标签用于自定义形状，它内部的代码不会显示，仅供引用。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;300&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;100&quot;</span>&gt;&lt;defs&gt;&lt;g id<span class="hljs-operator">=</span><span class="hljs-string">&quot;myCircle&quot;</span>&gt;&lt;text x<span class="hljs-operator">=</span><span class="hljs-string">&quot;25&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;20&quot;</span>&gt;圆形&lt;/text&gt;&lt;circle cx<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> cy<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> r<span class="hljs-operator">=</span><span class="hljs-string">&quot;20&quot;</span>/&gt;&lt;/g&gt;&lt;/defs&gt;&lt;use href<span class="hljs-operator">=</span><span class="hljs-string">&quot;#myCircle&quot;</span> x<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> /&gt;&lt;use href<span class="hljs-operator">=</span><span class="hljs-string">&quot;#myCircle&quot;</span> x<span class="hljs-operator">=</span><span class="hljs-string">&quot;100&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> fill<span class="hljs-operator">=</span><span class="hljs-string">&quot;blue&quot;</span> /&gt;&lt;use href<span class="hljs-operator">=</span><span class="hljs-string">&quot;#myCircle&quot;</span> x<span class="hljs-operator">=</span><span class="hljs-string">&quot;200&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> fill<span class="hljs-operator">=</span><span class="hljs-string">&quot;white&quot;</span> stroke<span class="hljs-operator">=</span><span class="hljs-string">&quot;blue&quot;</span> /&gt;&lt;/svg&gt;</code></pre></div></blockquote><h3 id="lt-pattern-gt-标签"><a href="#lt-pattern-gt-标签" class="headerlink" title="&lt;pattern&gt;标签"></a><code>&lt;pattern&gt;</code>标签</h3><p><code>&lt;pattern&gt;</code>标签用于自定义一个形状，该形状可以被引用来平铺一个区域。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;500&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;500&quot;</span>&gt;&lt;defs&gt;&lt;pattern id<span class="hljs-operator">=</span><span class="hljs-string">&quot;dots&quot;</span> x<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> width<span class="hljs-operator">=</span><span class="hljs-string">&quot;100&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;100&quot;</span> patternUnits<span class="hljs-operator">=</span><span class="hljs-string">&quot;userSpaceOnUse&quot;</span>&gt;&lt;circle fill<span class="hljs-operator">=</span><span class="hljs-string">&quot;#bee9e8&quot;</span> cx<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> cy<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> r<span class="hljs-operator">=</span><span class="hljs-string">&quot;35&quot;</span> /&gt;&lt;/pattern&gt;&lt;/defs&gt;&lt;rect x<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> width<span class="hljs-operator">=</span><span class="hljs-string">&quot;100%&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;100%&quot;</span> fill<span class="hljs-operator">=</span><span class="hljs-string">&quot;url(#dots)&quot;</span> /&gt;&lt;/svg&gt;</code></pre></div></blockquote><p>上面代码中，<code>&lt;pattern&gt;</code>标签将一个圆形定义为<code>dots</code>模式。<code>patternUnits=&quot;userSpaceOnUse&quot;</code>表示<code>&lt;pattern&gt;</code>的宽度和长度是实际的像素值。然后，指定这个模式去填充下面的矩形。</p><h3 id="lt-image-gt-标签"><a href="#lt-image-gt-标签" class="headerlink" title="&lt;image&gt;标签"></a><code>&lt;image&gt;</code>标签</h3><p><code>&lt;image&gt;</code>标签用于插入图片文件。</p><blockquote><div class="code-wrapper"><pre><code class="hljs arduino">&lt;svg viewBox=<span class="hljs-string">&quot;0 0 100 100&quot;</span> width=<span class="hljs-string">&quot;100&quot;</span> height=<span class="hljs-string">&quot;100&quot;</span>&gt;&lt;image xlink:href=<span class="hljs-string">&quot;path/to/image.jpg&quot;</span>width=<span class="hljs-string">&quot;50%&quot;</span> height=<span class="hljs-string">&quot;50%&quot;</span>/&gt;&lt;/svg&gt;</code></pre></div></blockquote><p>上面代码中，<code>&lt;image&gt;</code>的<code>xlink:href</code>属性表示图像的来源。</p><h3 id="lt-animate-gt-标签"><a href="#lt-animate-gt-标签" class="headerlink" title="&lt;animate&gt;标签"></a><code>&lt;animate&gt;</code>标签</h3><p><code>&lt;animate&gt;</code>标签用于产生动画效果。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;500px&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;500px&quot;</span>&gt;&lt;rect x<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> width<span class="hljs-operator">=</span><span class="hljs-string">&quot;100&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;100&quot;</span> fill<span class="hljs-operator">=</span><span class="hljs-string">&quot;#feac5e&quot;</span>&gt;&lt;animate attributeName<span class="hljs-operator">=</span><span class="hljs-string">&quot;x&quot;</span> from<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> to<span class="hljs-operator">=</span><span class="hljs-string">&quot;500&quot;</span> dur<span class="hljs-operator">=</span><span class="hljs-string">&quot;2s&quot;</span> repeatCount<span class="hljs-operator">=</span><span class="hljs-string">&quot;indefinite&quot;</span> /&gt;&lt;/rect&gt;&lt;/svg&gt;</code></pre></div></blockquote><p>上面代码中，矩形会不断移动，产生动画效果。</p><p><code>&lt;animate&gt;</code>的属性含义如下。</p><blockquote><ul><li>attributeName：发生动画效果的属性名。</li><li>from：单次动画的初始值。</li><li>to：单次动画的结束值。</li><li>dur：单次动画的持续时间。</li><li>repeatCount：动画的循环模式。</li></ul></blockquote><p>可以在多个属性上面定义动画。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;animate attributeName<span class="hljs-operator">=</span><span class="hljs-string">&quot;x&quot;</span> from<span class="hljs-operator">=</span><span class="hljs-string">&quot;0&quot;</span> to<span class="hljs-operator">=</span><span class="hljs-string">&quot;500&quot;</span> dur<span class="hljs-operator">=</span><span class="hljs-string">&quot;2s&quot;</span> repeatCount<span class="hljs-operator">=</span><span class="hljs-string">&quot;indefinite&quot;</span> /&gt;&lt;animate attributeName<span class="hljs-operator">=</span><span class="hljs-string">&quot;width&quot;</span> to<span class="hljs-operator">=</span><span class="hljs-string">&quot;500&quot;</span> dur<span class="hljs-operator">=</span><span class="hljs-string">&quot;2s&quot;</span> repeatCount<span class="hljs-operator">=</span><span class="hljs-string">&quot;indefinite&quot;</span> /&gt;</code></pre></div></blockquote><h3 id="lt-animateTransform-gt-标签"><a href="#lt-animateTransform-gt-标签" class="headerlink" title="&lt;animateTransform&gt;标签"></a><code>&lt;animateTransform&gt;</code>标签</h3><p><code>&lt;animate&gt;</code>标签对 CSS 的<code>transform</code>属性不起作用，如果需要变形，就要使用<code>&lt;animateTransform&gt;</code>标签。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;500px&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;500px&quot;</span>&gt;&lt;rect x<span class="hljs-operator">=</span><span class="hljs-string">&quot;250&quot;</span> y<span class="hljs-operator">=</span><span class="hljs-string">&quot;250&quot;</span> width<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> fill<span class="hljs-operator">=</span><span class="hljs-string">&quot;#4bc0c8&quot;</span>&gt;&lt;animateTransform attributeName<span class="hljs-operator">=</span><span class="hljs-string">&quot;transform&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;rotate&quot;</span> begin<span class="hljs-operator">=</span><span class="hljs-string">&quot;0s&quot;</span> dur<span class="hljs-operator">=</span><span class="hljs-string">&quot;10s&quot;</span> from<span class="hljs-operator">=</span><span class="hljs-string">&quot;0 200 200&quot;</span> to<span class="hljs-operator">=</span><span class="hljs-string">&quot;360 400 400&quot;</span> repeatCount<span class="hljs-operator">=</span><span class="hljs-string">&quot;indefinite&quot;</span> /&gt;&lt;/rect&gt;&lt;/svg&gt;</code></pre></div></blockquote><p>上面代码中，<code>&lt;animateTransform&gt;</code>的效果为旋转（<code>rotate</code>），这时<code>from</code>和<code>to</code>属性值有三个数字，第一个数字是角度值，第二个值和第三个值是旋转中心的坐标。<code>from=&quot;0 200 200&quot;</code>表示开始时，角度为0，围绕<code>(200, 200)</code>开始旋转；<code>to=&quot;360 400 400&quot;</code>表示结束时，角度为360，围绕<code>(400, 400)</code>旋转。</p><h2 id="三、JavaScript-操作"><a href="#三、JavaScript-操作" class="headerlink" title="三、JavaScript 操作"></a>三、JavaScript 操作</h2><h3 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h3><p>如果 SVG 代码直接写在 HTML 网页之中，它就成为网页 DOM 的一部分，可以直接用 DOM 操作。</p><blockquote><div class="code-wrapper"><pre><code class="hljs abnf">&lt;svg<span class="hljs-attribute">id</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;mysvg&quot;</span><span class="hljs-attribute">xmlns</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span><span class="hljs-attribute">viewBox</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;0 0 800 600&quot;</span><span class="hljs-attribute">preserveAspectRatio</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;xMidYMid meet&quot;</span>&gt;&lt;circle id<span class="hljs-operator">=</span><span class="hljs-string">&quot;mycircle&quot;</span> cx<span class="hljs-operator">=</span><span class="hljs-string">&quot;400&quot;</span> cy<span class="hljs-operator">=</span><span class="hljs-string">&quot;300&quot;</span> r<span class="hljs-operator">=</span><span class="hljs-string">&quot;50&quot;</span> /&gt;&lt;svg&gt;</code></pre></div></blockquote><p>上面代码插入网页之后，就可以用 CSS 定制样式。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css">circle &#123;stroke-<span class="hljs-attribute">width</span>: <span class="hljs-number">5</span>;stroke: <span class="hljs-number">#f00</span>;fill: <span class="hljs-number">#ff0</span>;&#125;circle<span class="hljs-selector-pseudo">:hover</span> &#123;stroke: <span class="hljs-number">#090</span>;fill: <span class="hljs-number">#fff</span>;&#125;</code></pre></div></blockquote><p>然后，可以用 JavaScript 代码操作 SVG。</p><blockquote><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> mycircle = document.getElementById(<span class="hljs-string">&#x27;mycircle&#x27;</span>);mycircle.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;circle clicked - enlarging&#x27;</span>);mycircle.setAttribute(<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-number">60</span>);&#125;, <span class="hljs-literal">false</span>);</code></pre></div></blockquote><p>上面代码指定，如果点击图形，就改写<code>circle</code>元素的<code>r</code>属性。</p><h3 id="获取-SVG-DOM"><a href="#获取-SVG-DOM" class="headerlink" title="获取 SVG DOM"></a>获取 SVG DOM</h3><p>使用<code>&lt;object&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;embed&gt;</code>标签插入 SVG 文件，可以获取 SVG DOM。</p><blockquote><div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> svgObject = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;object&#x27;</span>).contentDocument;<span class="hljs-keyword">var</span> svgIframe = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;iframe&#x27;</span>).contentDocument;<span class="hljs-keyword">var</span> svgEmbed = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;embed&#x27;</span>).getSVGDocument();</code></pre></div></blockquote><p>注意，如果使用<code>&lt;img&gt;</code>标签插入 SVG 文件，就无法获取 SVG DOM。</p><h3 id="读取-SVG-源码"><a href="#读取-SVG-源码" class="headerlink" title="读取 SVG 源码"></a>读取 SVG 源码</h3><p>由于 SVG 文件就是一段 XML 文本，因此可以通过读取 XML 代码的方式，读取 SVG 源码。</p><blockquote><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;svg-container&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">svg</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:xlink</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/xlink&quot;</span></span><span class="hljs-tag"><span class="hljs-attr">xml:space</span>=<span class="hljs-string">&quot;preserve&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;440&quot;</span></span><span class="hljs-tag">  &gt;</span><span class="hljs-comment">&lt;!-- svg code --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></blockquote><p>使用<code>XMLSerializer</code>实例的<code>serializeToString()</code>方法，获取 SVG 元素的代码。</p><blockquote><div class="code-wrapper"><pre><code class="hljs reasonml">var svgString = <span class="hljs-keyword">new</span> <span class="hljs-constructor">XMLSerializer()</span>.serialize<span class="hljs-constructor">ToString(<span class="hljs-params">document</span>.<span class="hljs-params">querySelector</span>(&#x27;<span class="hljs-params">svg</span>&#x27;)</span>);</code></pre></div></blockquote><h3 id="SVG-图像转为-Canvas-图像"><a href="#SVG-图像转为-Canvas-图像" class="headerlink" title="SVG 图像转为 Canvas 图像"></a>SVG 图像转为 Canvas 图像</h3><p>首先，需要新建一个<code>Image</code>对象，将 SVG 图像指定到该<code>Image</code>对象的<code>src</code>属性。</p><blockquote><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<span class="hljs-keyword">var</span> svg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([svgString], &#123;type: <span class="hljs-string">&quot;image/svg+xml;charset=utf-8&quot;</span>&#125;);<span class="hljs-keyword">var</span> DOMURL = <span class="hljs-built_in">self</span>.URL || <span class="hljs-built_in">self</span>.webkitURL || <span class="hljs-built_in">self</span>;<span class="hljs-keyword">var</span> url = DOMURL.<span class="hljs-title function_ invoke__">createObjectURL</span>(svg);img.src = url;</code></pre></div></blockquote><p>然后，当图像加载完成后，再将它绘制到<code>&lt;canvas&gt;</code>元素。</p><blockquote><div class="code-wrapper"><pre><code class="hljs javascript">img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">var</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;canvas&#x27;</span>);<span class="hljs-keyword">var</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);ctx.<span class="hljs-title function_">drawImage</span>(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);&#125;;</code></pre></div></blockquote><h2 id="四、实例：折线图"><a href="#四、实例：折线图" class="headerlink" title="四、实例：折线图"></a>四、实例：折线图</h2><p>下面将一张数据表格画成折线图。</p><blockquote><div class="code-wrapper"><pre><code class="hljs subunit">Date |Amount-----|------2014<span class="hljs-string">-01</span><span class="hljs-string">-01</span> | $102014<span class="hljs-string">-02</span><span class="hljs-string">-01</span> | $202014<span class="hljs-string">-03</span><span class="hljs-string">-01</span> | $402014<span class="hljs-string">-04</span><span class="hljs-string">-01</span> | $80</code></pre></div></blockquote><p>上面的图形，可以画成一个坐标系，<code>Date</code>作为横轴，<code>Amount</code>作为纵轴，四行数据画成一个数据点。</p><blockquote><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;350&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;160&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;layer&quot;</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&quot;translate(60,10)&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;0&quot;</span>   <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;105&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;90&quot;</span>  <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;90&quot;</span>  /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;180&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;60&quot;</span>  /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;270&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;0&quot;</span>   /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;y axis&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&quot;120&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;-40&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;105&quot;</span> <span class="hljs-attr">dy</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span>$10<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;-40&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;0&quot;</span>   <span class="hljs-attr">dy</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span>$80<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">g</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;x axis&quot;</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">&quot;translate(0, 120)&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">line</span> <span class="hljs-attr">x1</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">y1</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">x2</span>=<span class="hljs-string">&quot;270&quot;</span> <span class="hljs-attr">y2</span>=<span class="hljs-string">&quot;0&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;-30&quot;</span>   <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span>January 2014<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;240&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span>April<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">g</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre></div></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS布局之Grid</title>
    <link href="/2023/02/01/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/"/>
    <url>/2023/02/01/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS-Grid-网格布局教程"><a href="#CSS-Grid-网格布局教程" class="headerlink" title="CSS Grid 网格布局教程"></a>CSS Grid 网格布局教程</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>网格布局（Grid）是最强大的 CSS 布局方案。</p><p>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/1_bg2019032501.png"></p><p>上图这样的布局，就是 Grid 布局的拿手好戏。</p><p>Grid 布局与 <a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局</a>有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。</p><p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。Grid 布局远比 Flex 布局强大。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>学习 Grid 布局之前，需要了解一些基本概念。</p><h3 id="2-1-容器和项目"><a href="#2-1-容器和项目" class="headerlink" title="2.1 容器和项目"></a>2.1 容器和项目</h3><p>采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。</p><blockquote><div class="code-wrapper"><pre><code class="hljs markup">&lt;div&gt;&lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</code></pre></div></blockquote><p>上面代码中，最外层的<code>&lt;div&gt;</code>元素就是容器，内层的三个<code>&lt;div&gt;</code>元素就是项目。</p><p>注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的<code>&lt;p&gt;</code>元素就不是项目。Grid 布局只对项目生效。</p><h3 id="2-2-行和列"><a href="#2-2-行和列" class="headerlink" title="2.2 行和列"></a>2.2 行和列</h3><p>容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/1_bg2019032502.png"></p><p>上图中，水平的深色区域就是”行”，垂直的深色区域就是”列”。</p><h3 id="2-3-单元格"><a href="#2-3-单元格" class="headerlink" title="2.3 单元格"></a>2.3 单元格</h3><p>行和列的交叉区域，称为”单元格”（cell）。</p><p>正常情况下，<code>n</code>行和<code>m</code>列会产生<code>n x m</code>个单元格。比如，3行3列会产生9个单元格。</p><h3 id="2-4-网格线"><a href="#2-4-网格线" class="headerlink" title="2.4 网格线"></a>2.4 网格线</h3><p>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</p><p>正常情况下，<code>n</code>行有<code>n + 1</code>根水平网格线，<code>m</code>列有<code>m + 1</code>根垂直网格线，比如三行就有四根水平网格线。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/1_bg2019032503.png"></p><p>上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。</p><h2 id="三、容器属性"><a href="#三、容器属性" class="headerlink" title="三、容器属性"></a>三、容器属性</h2><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。</p><h3 id="3-1-display-属性"><a href="#3-1-display-属性" class="headerlink" title="3.1 display 属性"></a>3.1 display 属性</h3><p><code>display: grid</code>指定一个容器采用网格布局。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">display</span>: grid;&#125;</code></pre></div></blockquote><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032504.png"></p><p>上图是<code>display: grid</code>的<a href="https://jsbin.com/guvivum/edit?html,css,output">效果</a>。</p><p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">display</span>: inline-grid;&#125;</code></pre></div></blockquote><p>上面代码指定<code>div</code>是一个行内元素，该元素内部采用网格布局。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032505.png"></p><p>上图是<code>display: inline-grid</code>的<a href="https://jsbin.com/qatitav/edit?html,css,output">效果</a>。</p><blockquote><p>注意，设为网格布局以后，容器子元素（项目）的<code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置都将失效。</p></blockquote><h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><p>grid-template-columns 属性，<br>grid-template-rows 属性</p><p>容器指定了网格布局以后，接着就要划分行和列。<code>grid-template-columns</code>属性定义每一列的列宽，<code>grid-template-rows</code>属性定义每一行的行高。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">display</span>: grid;<span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;&#125;</code></pre></div></blockquote><p><a href="https://jsbin.com/qiginur/edit?css,output">上面代码</a>指定了一个三行三列的网格，列宽和行高都是<code>100px</code>。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032506.png"></p><p>除了使用绝对单位，也可以使用百分比。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">display</span>: grid;<span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span>;<span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span>;&#125;</code></pre></div></blockquote><p><strong>（1）repeat()</strong></p><p>有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用<code>repeat()</code>函数，简化重复的值。上面的代码用<code>repeat()</code>改写如下。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">display</span>: grid;<span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);<span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);&#125;</code></pre></div></blockquote><p><code>repeat()</code>接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。</p><p><code>repeat()</code>重复某种模式也是可以的。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">2</span>, <span class="hljs-number">100px</span> <span class="hljs-number">20px</span> <span class="hljs-number">80px</span>);</code></pre></div></blockquote><p><a href="https://jsbin.com/cokohu/edit?css,output">上面代码</a>定义了6列，第一列和第四列的宽度为<code>100px</code>，第二列和第五列为<code>20px</code>，第三列和第六列为<code>80px</code>。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032507.png"></p><p><strong>（2）auto-fill 关键字</strong></p><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用<code>auto-fill</code>关键字表示自动填充。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">display</span>: grid;<span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-number">100px</span>);&#125;</code></pre></div></blockquote><p><a href="https://jsbin.com/himoku/edit?css,output">上面代码</a>表示每列宽度<code>100px</code>，然后自动填充，直到容器不能放置更多的列。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032508.png"></p><p><strong>（3）fr 关键字</strong></p><p>为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">display</span>: grid;<span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;&#125;</code></pre></div></blockquote><p><a href="https://jsbin.com/hadexek/edit?html,css,output">上面代码</a>表示两个相同宽度的列。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/1_bg2019032509.png"></p><p><code>fr</code>可以与绝对长度的单位结合使用，这时会非常方便。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">display</span>: grid;<span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">150px</span> <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr;&#125;</code></pre></div></blockquote><p><a href="https://jsbin.com/remowec/edit?html,css,output">上面代码</a>表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032510.png"></p><p><strong>（4）minmax()</strong></p><p><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr <span class="hljs-built_in">minmax</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">1</span>fr);</code></pre></div></blockquote><p>上面代码中，<code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</p><p><strong>（5）auto 关键字</strong></p><p><code>auto</code>关键字表示由浏览器自己决定长度。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> auto <span class="hljs-number">100px</span>;</code></pre></div></blockquote><p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了<code>min-width</code>，且这个值大于最大宽度。</p><p><strong>（6）网格线的名称</strong></p><p><code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">display</span>: grid;<span class="hljs-attribute">grid-template-columns</span>: [c1] <span class="hljs-number">100px</span> [c2] <span class="hljs-number">100px</span> [c3] auto [c4];<span class="hljs-attribute">grid-template-rows</span>: [r1] <span class="hljs-number">100px</span> [r2] <span class="hljs-number">100px</span> [r3] auto [r4];&#125;</code></pre></div></blockquote><p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。</p><p>网格布局允许同一根线有多个名字，比如<code>[fifth-line row-5]</code>。</p><p><strong>（7）布局实例</strong></p><p><code>grid-template-columns</code>属性对于网页布局非常有用。两栏式布局只需要一行代码。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<span class="hljs-attribute">display</span>: grid;<span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">70%</span> <span class="hljs-number">30%</span>;&#125;</code></pre></div></blockquote><p>上面代码将左边栏设为70%，右边栏设为30%。</p><p>传统的十二网格布局，写起来也很容易。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">12</span>, <span class="hljs-number">1</span>fr);</code></pre></div></blockquote><h3 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h3><p>grid-row-gap 属性，<br>grid-column-gap 属性，<br>grid-gap 属性</p><p><code>grid-row-gap</code>属性设置行与行的间隔（行间距），<code>grid-column-gap</code>属性设置列与列的间隔（列间距）。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">grid-row</span>-<span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;<span class="hljs-attribute">grid-column</span>-<span class="hljs-attribute">gap</span>: <span class="hljs-number">20px</span>;&#125;</code></pre></div></blockquote><p><a href="https://jsbin.com/mezufab/edit?css,output">上面代码</a>中，<code>grid-row-gap</code>用于设置行间距，<code>grid-column-gap</code>用于设置列间距。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032511.png"></p><p><code>grid-gap</code>属性是<code>grid-column-gap</code>和<code>grid-row-gap</code>的合并简写形式，语法如下。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">grid-gap</span>: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</code></pre></div></blockquote><p>因此，上面一段 CSS 代码等同于下面的代码。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span> <span class="hljs-number">20px</span>;&#125;</code></pre></div></blockquote><p>如果<code>grid-gap</code>省略了第二个值，浏览器认为第二个值等于第一个值。</p><blockquote><p>根据最新标准，上面三个属性名的<code>grid-</code>前缀已经删除，<code>grid-column-gap</code>和<code>grid-row-gap</code>写成<code>column-gap</code>和<code>row-gap</code>，<code>grid-gap</code>写成<code>gap</code>。</p></blockquote><h3 id="3-4-grid-template-areas-属性"><a href="#3-4-grid-template-areas-属性" class="headerlink" title="3.4 grid-template-areas 属性"></a>3.4 grid-template-areas 属性</h3><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">display</span>: grid;<span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">&#x27;a b c&#x27;</span>                 <span class="hljs-string">&#x27;d e f&#x27;</span>                 <span class="hljs-string">&#x27;g h i&#x27;</span>;&#125;</code></pre></div></blockquote><p>上面代码先划分出9个单元格，然后将其定名为<code>a</code>到<code>i</code>的九个区域，分别对应这九个单元格。</p><p>多个单元格合并成一个区域的写法如下。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">&#x27;a a a&#x27;</span>               <span class="hljs-string">&#x27;b b b&#x27;</span>               <span class="hljs-string">&#x27;c c c&#x27;</span>;</code></pre></div></blockquote><p>上面代码将9个单元格分成<code>a</code>、<code>b</code>、<code>c</code>三个区域。</p><p>下面是一个布局实例。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">&quot;header header header&quot;</span>               <span class="hljs-string">&quot;main main sidebar&quot;</span>               <span class="hljs-string">&quot;footer footer footer&quot;</span>;</code></pre></div></blockquote><p>上面代码中，顶部是页眉区域<code>header</code>，底部是页脚区域<code>footer</code>，中间部分则为<code>main</code>和<code>sidebar</code>。</p><p>如果某些区域不需要利用，则使用”点”（<code>.</code>）表示。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">&#x27;a . c&#x27;</span>               <span class="hljs-string">&#x27;d . f&#x27;</span>               <span class="hljs-string">&#x27;g . i&#x27;</span>;</code></pre></div></blockquote><p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p><blockquote><p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><p>比如，区域名为<code>header</code>，则起始位置的水平网格线和垂直网格线叫做<code>header-start</code>，终止位置的水平网格线和垂直网格线叫做<code>header-end</code>。</p></blockquote><h3 id="3-5-grid-auto-flow-属性"><a href="#3-5-grid-auto-flow-属性" class="headerlink" title="3.5 grid-auto-flow 属性"></a>3.5 grid-auto-flow 属性</h3><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032506.png"></p><p>这个顺序由<code>grid-auto-flow</code>属性决定，默认值是<code>row</code>，即”先行后列”。也可以将它设成<code>column</code>，变成”先列后行”。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">grid-auto-flow</span>: column;</code></pre></div></blockquote><p><a href="https://jsbin.com/xutokec/edit?css,output">上面代码</a>设置了<code>column</code>以后，放置顺序就变成了下图。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032512.png"></p><p><code>grid-auto-flow</code>属性除了设置成<code>row</code>和<code>column</code>，还可以设成<code>row dense</code>和<code>column dense</code>。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。</p><p><a href="https://jsbin.com/wapejok/edit?css,output">下面的例子</a>让1号项目和2号项目各占据两个单元格，然后在默认的<code>grid-auto-flow: row</code>情况下，会产生下面这样的布局。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032513.png"></p><p>上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。</p><p>现在修改设置，设为<code>row dense</code>，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">grid-auto-flow</span>: row dense;</code></pre></div></blockquote><p><a href="https://jsbin.com/helewuy/edit?css,output">上面代码</a>的效果如下。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032514.png"></p><p>上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。</p><p>如果将设置改为<code>column dense</code>，表示”先列后行”，并且尽量填满空格。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">grid-auto-flow</span>: column dense;</code></pre></div></blockquote><p><a href="https://jsbin.com/pupoduc/1/edit?html,css,output">上面代码</a>的效果如下。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032515.png"></p><p>上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列。</p><h3 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h3><p>justify-items 属性，<br>align-items 属性，<br>place-items 属性</p><p><code>justify-items</code>属性设置单元格内容的水平位置（左中右），<code>align-items</code>属性设置单元格内容的垂直位置（上中下）。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;justify-items: start | end | center | stretch;<span class="hljs-attribute">align-items</span>: start | end | center | stretch;&#125;</code></pre></div></blockquote><p>这两个属性的写法完全相同，都可以取下面这些值。</p><blockquote><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul></blockquote><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;justify-items: start;&#125;</code></pre></div></blockquote><p><a href="https://jsbin.com/gijeqej/edit?css,output">上面代码</a>表示，单元格的内容左对齐，效果如下图。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032516.png"></p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">align-items</span>: start;&#125;</code></pre></div></blockquote><p><a href="https://jsbin.com/tecawur/edit?css,output">上面代码</a>表示，单元格的内容头部对齐，效果如下图。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032517.png"></p><p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css">place-items: &lt;align-items&gt; &lt;justify-items&gt;;</code></pre></div></blockquote><p>下面是一个例子。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css">place-items: start end;</code></pre></div></blockquote><p>如果省略第二个值，则浏览器认为与第一个值相等。</p><h3 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h3><p>justify-content 属性，<br>align-content 属性，<br>place-content 属性</p><p><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code>属性是整个内容区域的垂直位置（上中下）。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">justify-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;<span class="hljs-attribute">align-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;  &#125;</code></pre></div></blockquote><p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以<code>justify-content</code>属性为例，<code>align-content</code>属性的图完全一样，只是将水平方向改成垂直方向。）</p><blockquote><ul><li>start - 对齐容器的起始边框。</li></ul></blockquote><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032519.png"></p><blockquote><ul><li>end - 对齐容器的结束边框。</li></ul></blockquote><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032518.png"></p><blockquote><ul><li>center - 容器内部居中。</li></ul></blockquote><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032520.png"></p><blockquote><ul><li>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</li></ul></blockquote><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032521.png"></p><blockquote><ul><li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li></ul></blockquote><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032522.png"></p><blockquote><ul><li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</li></ul></blockquote><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032523.png"></p><blockquote><ul><li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li></ul></blockquote><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032524.png"></p><p><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css">place-<span class="hljs-attribute">content</span>: &lt;align-content&gt; &lt;justify-content&gt;</code></pre></div></blockquote><p>下面是一个例子。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css">place-<span class="hljs-attribute">content</span>: space-around space-evenly;</code></pre></div></blockquote><p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p><h3 id="3-8"><a href="#3-8" class="headerlink" title="3.8"></a>3.8</h3><p>grid-auto-columns 属性，<br>grid-auto-rows 属性</p><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p><p><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><p><a href="https://jsbin.com/sayuric/edit?css,output">下面的例子</a>里面，划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<span class="hljs-attribute">display</span>: grid;<span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">50px</span>; &#125;</code></pre></div></blockquote><p>上面代码指定新增的行高统一为50px（原始的行高为100px）。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032525.png"></p><h3 id="3-9"><a href="#3-9" class="headerlink" title="3.9"></a>3.9</h3><p>grid-template 属性，<br>grid 属性</p><p><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</p><p><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</p><p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p><h2 id="四、项目属性"><a href="#四、项目属性" class="headerlink" title="四、项目属性"></a>四、项目属性</h2><p>下面这些属性定义在项目上面。</p><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><p>grid-column-start 属性，<br>grid-column-end 属性，<br>grid-row-start 属性，<br>grid-row-end 属性</p><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><blockquote><ul><li><code>grid-column-start</code>属性：左边框所在的垂直网格线</li><li><code>grid-column-end</code>属性：右边框所在的垂直网格线</li><li><code>grid-row-start</code>属性：上边框所在的水平网格线</li><li><code>grid-row-end</code>属性：下边框所在的水平网格线</li></ul></blockquote><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">2</span>;<span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">4</span>;&#125;</code></pre></div></blockquote><p><a href="https://jsbin.com/yukobuf/edit?css,output">上面代码</a>指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032526.png"></p><p>上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p><p>除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的<code>grid-auto-flow</code>属性决定，这个属性的默认值是<code>row</code>，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成<code>column</code>、<code>row dense</code>和<code>column dense</code>，看看其他项目的位置发生了怎样的变化。</p><p><a href="https://jsbin.com/nagobey/edit?html,css,output">下面的例子</a>是指定四个边框位置的效果。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;<span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">3</span>;<span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">2</span>;<span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">4</span>;&#125;</code></pre></div></blockquote><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032527.png"></p><p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">grid-column-start</span>: header-start;<span class="hljs-attribute">grid-column-end</span>: header-end;&#125;</code></pre></div></blockquote><p>上面代码中，左边框和右边框的位置，都指定为网格线的名字。</p><p>这四个属性的值还可以使用<code>span</code>关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">grid-column-start</span>: span <span class="hljs-number">2</span>;&#125;</code></pre></div></blockquote><p><a href="https://jsbin.com/hehumay/edit?html,css,output">上面代码</a>表示，1号项目的左边框距离右边框跨越2个网格。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032528.png"></p><p>这与<a href="https://jsbin.com/mujihib/edit?html,css,output">下面的代码</a>效果完全一样。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">grid-column-end</span>: span <span class="hljs-number">2</span>;&#125;</code></pre></div></blockquote><p>使用这四个属性，如果产生了项目的重叠，则使用<code>z-index</code>属性指定项目的重叠顺序。</p><h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><p>grid-column 属性，<br>grid-row 属性</p><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<span class="hljs-attribute">grid-column</span>: &lt;start-line&gt; / &lt;end-line&gt;;<span class="hljs-attribute">grid-row</span>: &lt;start-line&gt; / &lt;end-line&gt;;&#125;</code></pre></div></blockquote><p>下面是一个例子。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">2</span>;&#125;<span class="hljs-comment">/* 等同于 */</span><span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;<span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">3</span>;<span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>;<span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">2</span>;&#125;</code></pre></div></blockquote><p>上面代码中，项目<code>item-1</code>占据第一行，从第一根列线到第三根列线。</p><p>这两个属性之中，也可以使用<code>span</code>关键字，表示跨越多少个网格。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">background</span>: <span class="hljs-number">#b03532</span>;<span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;&#125;<span class="hljs-comment">/* 等同于 */</span><span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">background</span>: <span class="hljs-number">#b03532</span>;<span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / span <span class="hljs-number">2</span>;<span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / span <span class="hljs-number">2</span>;&#125;</code></pre></div></blockquote><p><a href="https://jsbin.com/volugow/edit?html,css,output">上面代码</a>中，项目<code>item-1</code>占据的区域，包括第一行 + 第二行、第一列 + 第二列。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032529.png"></p><p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span>;<span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>;&#125;</code></pre></div></blockquote><p>上面代码中，项目<code>item-1</code>占据左上角第一个网格。</p><h3 id="4-3-grid-area-属性"><a href="#4-3-grid-area-属性" class="headerlink" title="4.3 grid-area 属性"></a>4.3 grid-area 属性</h3><p><code>grid-area</code>属性指定项目放在哪一个区域。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">grid-area</span>: e;&#125;</code></pre></div></blockquote><p><a href="https://jsbin.com/qokexob/edit?css,output">上面代码</a>中，1号项目位于<code>e</code>区域，效果如下图。</p><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032530.png"></p><p><code>grid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<span class="hljs-attribute">grid-area</span>: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;&#125;</code></pre></div></blockquote><p>下面是一个<a href="https://jsbin.com/duyafez/edit?css,output">例子</a>。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<span class="hljs-attribute">grid-area</span>: <span class="hljs-number">1</span> / <span class="hljs-number">1</span> / <span class="hljs-number">3</span> / <span class="hljs-number">3</span>;&#125;</code></pre></div></blockquote><h3 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h3><p>justify-self 属性，<br>align-self 属性，<br>place-self 属性</p><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p><p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;justify-self: start | end | center | stretch;<span class="hljs-attribute">align-self</span>: start | end | center | stretch;&#125;</code></pre></div></blockquote><p>这两个属性都可以取下面四个值。</p><blockquote><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul></blockquote><p>下面是<code>justify-self: start</code>的例子。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span>  &#123;justify-self: start;&#125;</code></pre></div></blockquote><p><img src="/../imgs/CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/bg2019032532.png"></p><p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css">place-self: &lt;align-self&gt; &lt;justify-self&gt;;</code></pre></div></blockquote><p>下面是一个例子。</p><blockquote><div class="code-wrapper"><pre><code class="hljs css">place-self: center center;</code></pre></div></blockquote><p>如果省略第二个值，<code>place-self</code>属性会认为这两个值相等。</p><h2 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h2><ul><li><a href="https://css-tricks.com/snippets/css/complete-guide-grid/">A Complete Guide to Grid</a>, by Chris House</li><li><a href="https://webdesign.tutsplus.com/series/understanding-the-css-grid-layout-module--cms-1079">Understanding the CSS Grid Layout Module</a>, by Ian Yates</li><li><a href="https://webdesign.tutsplus.com/tutorials/how-to-build-an-off-canvas-navigation-with-css-grid--cms-28191">How to Build an Off-Canvas Navigation With CSS Grid</a>, Ian Yates</li><li><a href="https://code.tutsplus.com/tutorials/introduction-to-css-grid-layout-with-examples--cms-25392">Introduction to the CSS Grid Layout With Examples</a>, Dogacan Bilgili</li><li><a href="http://learncssgrid.com/">Learn CSS Grid</a>, Jonathan Suh</li><li><a href="https://blog.theodo.fr/2018/03/stop-using-bootstrap-layout-thanks-to-css-grid/">How I stopped using Bootstrap’s layout thanks to CSS Grid</a>, Cédric Kui</li></ul><p>（完）</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>Grid</tag>
      
      <tag>Layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 精选算法 200 题</title>
    <link href="/2023/01/31/LeetCode%20%E7%B2%BE%E9%80%89%E7%AE%97%E6%B3%95%20200%20%E9%A2%98/"/>
    <url>/2023/01/31/LeetCode%20%E7%B2%BE%E9%80%89%E7%AE%97%E6%B3%95%20200%20%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ol><li><p>上下翻转二叉树</p><p>给你一个二叉树的根节点 <code>root</code> ，请你将此二叉树上下翻转，并返回新的根节点。</p><p>你可以按下面的步骤翻转一棵二叉树：</p><ol><li><p>原来的左子节点变成新的根节点</p></li><li><p>原来的根节点变成新的右子节点</p></li><li><p>原来的右子节点变成新的左子节点</p><p> <img src="/../imgs/LeetCode%20%E7%B2%BE%E9%80%89%E7%AE%97%E6%B3%95%20200%20%E9%A2%98/image-20230131181539687.png" alt="image-20230131181539687"></p></li></ol></li></ol><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> upsideDownBinaryTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;    <span class="hljs-keyword">if</span> (root &amp;&amp; root.<span class="hljs-property">left</span> === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(root, <span class="hljs-literal">null</span>);&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">node, pre</span>) &#123;    <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> pre;    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">left</span> === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> pre;    <span class="hljs-keyword">const</span> currNode = &#123;        <span class="hljs-attr">val</span>: node.<span class="hljs-property">left</span>.<span class="hljs-property">val</span>,        <span class="hljs-attr">left</span>: node.<span class="hljs-property">right</span> ? <span class="hljs-title function_">generateTree</span>(node.<span class="hljs-property">right</span>.<span class="hljs-property">val</span>) : <span class="hljs-literal">null</span>,        <span class="hljs-attr">right</span>: pre ? pre : <span class="hljs-title function_">generateTree</span>(node.<span class="hljs-property">val</span>)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(node.<span class="hljs-property">left</span>, currNode);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">generateTree</span>(<span class="hljs-params">val</span>) &#123;    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-attr">val</span>: val,        <span class="hljs-attr">left</span>: <span class="hljs-literal">null</span>,        <span class="hljs-attr">right</span>: <span class="hljs-literal">null</span>    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>力扣刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能优化</title>
    <link href="/2023/01/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/01/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>1、当后端一次性返回10万条数据, 前端要怎么处理?</p><ol><li><p>懒加载+分页：</p><p>一般用于做长列表优化，类似于表格的分页功能,，具体思路就是用户每次只加载能看见的数据，当滚动到底部时再去加载下一页的数据。</p></li><li><p>虚拟滚动技术：</p><p>虚拟滚动技术也可以用来优化长列表，其核心思路就是每次只渲染可视区域的列表数，当滚动后动态的追加元素并通过顶部padding来撑起整个滚动内容，实现思路也非常简单。</p></li><li></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/01/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/01/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="1-计算机网络的各层协议及作用？"><a href="#1-计算机网络的各层协议及作用？" class="headerlink" title="1. 计算机网络的各层协议及作用？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_1-%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e7%9a%84%e5%90%84%e5%b1%82%e5%8d%8f%e8%ae%ae%e5%8f%8a%e4%bd%9c%e7%94%a8%ef%bc%9f">1. 计算机网络的各层协议及作用？</a></h2><p>计算机网络体系可以大致分为一下三种，OSI七层模型、TCP&#x2F;IP四层模型和五层模型。</p><ul><li>OSI七层模型：大而全，但是比较复杂、而且是先有了理论模型，没有实际应用。</li><li>TCP&#x2F;IP四层模型：是由实际应用发展总结出来的，从实质上讲，TCP&#x2F;IP只有最上面三层，最下面一层没有什么具体内容，TCP&#x2F;IP参考模型没有真正描述这一层的实现。</li><li>五层模型：五层模型只出现在计算机网络教学过程中，这是对七层模型和四层模型的一个折中，既简洁又能将概念阐述清楚。</li></ul><p><img src="http://blog-img.coolsen.cn/img/image-20210519165421341.png" alt="计算机网络体系结构"></p><p>七层网络体系结构各层的主要功能：</p><ul><li><p><strong>应用层</strong>：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等。</p></li><li><p><strong>表示层</strong>：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。</p></li><li><p><strong>会话层</strong>：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。</p></li><li><p><strong>运输层</strong>：有时也译为传输层，向主机进程提供通用的数据传输服务。该层主要有以下两种协议：</p><ul><li>TCP：提供面向连接的、可靠的数据传输服务；</li><li>UDP：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。</li></ul></li><li><p><strong>网络层</strong>：选择合适的路由和交换结点，确保数据及时传送。主要包括IP协议。</p></li><li><p><strong>数据链路层</strong>：数据链路层通常简称为链路层。将网络层传下来的IP数据包组装成帧，并再相邻节点的链路上传送帧。</p></li><li><p><strong>物理层</strong>：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。</p></li></ul><h2 id="2-TCP和UDP的区别？"><a href="#2-TCP和UDP的区别？" class="headerlink" title="2. TCP和UDP的区别？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_2-tcp%e5%92%8cudp%e7%9a%84%e5%8c%ba%e5%88%ab%ef%bc%9f">2. TCP和UDP的区别？</a></h2><p><strong>对比如下</strong>：</p><table><thead><tr><th></th><th align="center">UDP</th><th align="center">TCP</th></tr></thead><tbody><tr><td>是否连接</td><td align="center">无连接</td><td align="center">面向连接</td></tr><tr><td>是否可靠</td><td align="center">不可靠传输，不使用流量控制和拥塞控制</td><td align="center">可靠传输，使用流量控制和拥塞控制</td></tr><tr><td>是否有序</td><td align="center">无序</td><td align="center">有序，消息在传输过程中可能会乱序，TCP 会重新排序</td></tr><tr><td>传输速度</td><td align="center">快</td><td align="center">慢</td></tr><tr><td>连接对象个数</td><td align="center">支持一对一，一对多，多对一和多对多交互通信</td><td align="center">只能是一对一通信</td></tr><tr><td>传输方式</td><td align="center">面向报文</td><td align="center">面向字节流</td></tr><tr><td>首部开销</td><td align="center">首部开销小，仅8字节</td><td align="center">首部最小20字节，最大60字节</td></tr><tr><td>适用场景</td><td align="center">适用于实时应用（IP电话、视频会议、直播等）</td><td align="center">适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><p><strong>总结</strong>：</p><p>TCP 用于在传输层有必要实现可靠传输的情况，UDP 用于对高速传输和实时性有较高要求的通信。TCP 和 UDP 应该根据应用目的按需使用。</p><h2 id="3-UDP-和-TCP-对应的应用场景是什么？"><a href="#3-UDP-和-TCP-对应的应用场景是什么？" class="headerlink" title="3. UDP 和 TCP 对应的应用场景是什么？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_3-udp-%e5%92%8c-tcp-%e5%af%b9%e5%ba%94%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f">3. UDP 和 TCP 对应的应用场景是什么？</a></h2><p>TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li>FTP文件传输</li><li>HTTP &#x2F; HTTPS</li></ul><p>UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 DNS 、SNMP等</li><li>视频、音频等多媒体通信</li><li>广播通信</li></ul><p><img src="http://blog-img.coolsen.cn/img/image-20210519180008296.png" alt="image-20210519180008296"></p><h2 id="4-详细介绍一下-TCP-的三次握手机制？"><a href="#4-详细介绍一下-TCP-的三次握手机制？" class="headerlink" title="4. 详细介绍一下 TCP 的三次握手机制？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_4-%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b-tcp-%e7%9a%84%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e6%9c%ba%e5%88%b6%ef%bc%9f">4. 详细介绍一下 TCP 的三次握手机制？</a></h2><p><img src="http://blog-img.coolsen.cn/img/image-20210520161056918.png"></p><blockquote><p>图片来自：<a href="https://juejin.cn/post/6844904005315854343">https://juejin.cn/post/6844904005315854343</a></p></blockquote><p>三次握手机制：</p><ul><li><p>第一次握手：客户端请求建立连接，向服务端发送一个<strong>同步报文</strong>（SYN&#x3D;1），同时选择一个随机数 seq &#x3D; x 作为<strong>初始序列号</strong>，并进入SYN_SENT状态，等待服务器确认。</p></li><li><p>第二次握手：：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送<strong>同步确认报文</strong>（SYN&#x3D;1，ACK&#x3D;1），确认号为 ack &#x3D; x + 1，同时选择一个随机数 seq &#x3D; y 作为初始序列号，此时服务器进入SYN_RECV状态。</p></li><li><p>第三次握手：客户端收到服务端的确认后，向服务端发送一个<strong>确认报文</strong>（ACK&#x3D;1），确认号为 ack &#x3D; y + 1，序列号为 seq &#x3D; x + 1，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p></li></ul><p>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p><h2 id="5-为什么需要三次握手，而不是两次？"><a href="#5-为什么需要三次握手，而不是两次？" class="headerlink" title="5. 为什么需要三次握手，而不是两次？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_5-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%ef%bc%8c%e8%80%8c%e4%b8%8d%e6%98%af%e4%b8%a4%e6%ac%a1%ef%bc%9f">5. 为什么需要三次握手，而不是两次？</a></h2><p>主要有三个原因：</p><ol><li><p>防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费。</p><p>在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段。</p><p>客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。</p><p>此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费。</p></li><li><p>三次握手才能让双方均确认自己和对方的发送和接收能力都正常。</p><p>第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和对方的发送能力正常；</p><p>第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；</p><p>第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；</p><p>可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了。</p></li><li><p>告知对方自己的初始序号值，并确认收到对方的初始序号值。</p><p>TCP 实现了可靠的数据传输，原因之一就是 TCP 报文段中维护了序号字段和确认序号字段，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值得基础递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。</p></li></ol><h2 id="6-为什么要三次握手，而不是四次？"><a href="#6-为什么要三次握手，而不是四次？" class="headerlink" title="6. 为什么要三次握手，而不是四次？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_6-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%ef%bc%8c%e8%80%8c%e4%b8%8d%e6%98%af%e5%9b%9b%e6%ac%a1%ef%bc%9f">6. 为什么要三次握手，而不是四次？</a></h2><p>因为三次握手已经可以确认双方的发送接收能力正常，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。</p><ul><li>第一次握手：服务端确认“自己收、客户端发”报文功能正常。</li><li>第二次握手：客户端确认“自己发、自己收、服务端收、客户端发”报文功能正常，客户端认为连接已建立。</li><li>第三次握手：服务端确认“自己发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信。</li></ul><h2 id="7-什么是-SYN洪泛攻击？如何防范？"><a href="#7-什么是-SYN洪泛攻击？如何防范？" class="headerlink" title="7. 什么是 SYN洪泛攻击？如何防范？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_7-%e4%bb%80%e4%b9%88%e6%98%af-syn%e6%b4%aa%e6%b3%9b%e6%94%bb%e5%87%bb%ef%bc%9f%e5%a6%82%e4%bd%95%e9%98%b2%e8%8c%83%ef%bc%9f">7. 什么是 SYN洪泛攻击？如何防范？</a></h2><p>SYN洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。</p><p>原理：</p><ul><li>在三次握手过程中，服务器发送 <code>[SYN/ACK]</code> 包（第二个包）之后、收到客户端的 <code>[ACK]</code> 包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 <code>SYN_RECV</code>（等待客户端响应）状态。如果接收到客户端的 <code>[ACK]</code>，则 TCP 连接成功，如果未接受到，则会<strong>不断重发请求</strong>直至成功。</li><li>SYN 攻击的攻击者在短时间内<strong>伪造大量不存在的 IP 地址</strong>，向服务器不断地发送 <code>[SYN]</code> 包，服务器回复 <code>[SYN/ACK]</code> 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。</li><li>这些伪造的 <code>[SYN]</code> 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。</li></ul><p>检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。</p><p>防范：</p><ul><li>通过防火墙、路由器等过滤网关防护。</li><li>通过加固 TCP&#x2F;IP 协议栈防范，如增加最大半连接数，缩短超时时间。</li><li>SYN cookies技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。</li></ul><h2 id="8-三次握手连接阶段，最后一次ACK包丢失，会发生什么？"><a href="#8-三次握手连接阶段，最后一次ACK包丢失，会发生什么？" class="headerlink" title="8. 三次握手连接阶段，最后一次ACK包丢失，会发生什么？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_8-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e8%bf%9e%e6%8e%a5%e9%98%b6%e6%ae%b5%ef%bc%8c%e6%9c%80%e5%90%8e%e4%b8%80%e6%ac%a1ack%e5%8c%85%e4%b8%a2%e5%a4%b1%ef%bc%8c%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88%ef%bc%9f">8. 三次握手连接阶段，最后一次ACK包丢失，会发生什么？</a></h2><p><strong>服务端：</strong></p><ul><li>第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。</li><li>如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。</li></ul><p><strong>客户端：</strong></p><p>客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，标示复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。</p><h2 id="9-详细介绍一下-TCP-的四次挥手过程？"><a href="#9-详细介绍一下-TCP-的四次挥手过程？" class="headerlink" title="9. 详细介绍一下 TCP 的四次挥手过程？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_9-%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b-tcp-%e7%9a%84%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e8%bf%87%e7%a8%8b%ef%bc%9f">9. 详细介绍一下 TCP 的四次挥手过程？</a></h2><p><img src="http://blog-img.coolsen.cn/img/image-20210520180127547.png"></p><blockquote><p>图片来源：<a href="https://juejin.im/post/5ddd1f30e51d4532c42c5abe">https://juejin.im/post/5ddd1f30e51d4532c42c5abe</a></p></blockquote><ul><li><p>第一次挥手：客户端向服务端发送连接释放报文（FIN&#x3D;1，ACK&#x3D;1），主动关闭连接，同时等待服务端的确认。</p><ul><li>序列号 seq &#x3D; u，即客户端上次发送的报文的最后一个字节的序号 + 1</li><li>确认号 ack &#x3D; k, 即服务端上次发送的报文的最后一个字节的序号 + 1</li></ul></li><li><p>第二次挥手：服务端收到连接释放报文后，立即发出<strong>确认报文</strong>（ACK&#x3D;1），序列号 seq &#x3D; k，确认号 ack &#x3D; u + 1。</p><p>这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。</p></li><li><p>第三次挥手：服务端向客户端发送连接释放报文（FIN&#x3D;1，ACK&#x3D;1），主动关闭连接，同时等待 A 的确认。</p><ul><li>序列号 seq &#x3D; w，即服务端上次发送的报文的最后一个字节的序号 + 1。</li><li>确认号 ack &#x3D; u + 1，与第二次挥手相同，因为这段时间客户端没有发送数据</li></ul></li><li><p>第四次挥手：客户端收到服务端的连接释放报文后，立即发出<strong>确认报文</strong>（ACK&#x3D;1），序列号 seq &#x3D; u + 1，确认号为 ack &#x3D; w + 1。</p><p>此时，客户端就进入了 <code>TIME-WAIT</code> 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入 <code>CLOSED</code> 状态。而服务端只要收到客户端发出的确认，就立即进入 <code>CLOSED</code> 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。</p></li></ul><h2 id="10-为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#10-为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="10. 为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_10-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%9e%e6%8e%a5%e7%9a%84%e6%97%b6%e5%80%99%e6%98%af%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%ef%bc%8c%e5%85%b3%e9%97%ad%e7%9a%84%e6%97%b6%e5%80%99%e5%8d%b4%e6%98%af%e5%9b%9b%e6%ac%a1%e6%8f%a1%e6%89%8b%ef%bc%9f">10. 为什么连接的时候是三次握手，关闭的时候却是四次握手？</a></h2><p>服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段.</p><p>接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接。服务器的<strong>ACK和FIN一般都会分开发送</strong>，从而导致多了一次，因此一共需要四次挥手。</p><h2 id="11-为什么客户端的-TIME-WAIT-状态必须等待-2MSL-？"><a href="#11-为什么客户端的-TIME-WAIT-状态必须等待-2MSL-？" class="headerlink" title="11. 为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_11-%e4%b8%ba%e4%bb%80%e4%b9%88%e5%ae%a2%e6%88%b7%e7%ab%af%e7%9a%84-time-wait-%e7%8a%b6%e6%80%81%e5%bf%85%e9%a1%bb%e7%ad%89%e5%be%85-2msl-%ef%bc%9f">11. 为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？</a></h2><p>主要有两个原因：</p><ol><li><p>确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。</p><p>第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN&#x2F;ACK 报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN&#x2F;ACK 报文的确认，就无法正常断开连接。</p><p>MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN&#x2F;ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。</p><p>如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。</p></li><li><p>防止已失效的连接请求报文段出现在之后的连接中。</p><p>TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。</p></li></ol><h2 id="12-如果已经建立了连接，但是客户端出现故障了怎么办？"><a href="#12-如果已经建立了连接，但是客户端出现故障了怎么办？" class="headerlink" title="12. 如果已经建立了连接，但是客户端出现故障了怎么办？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_12-%e5%a6%82%e6%9e%9c%e5%b7%b2%e7%bb%8f%e5%bb%ba%e7%ab%8b%e4%ba%86%e8%bf%9e%e6%8e%a5%ef%bc%8c%e4%bd%86%e6%98%af%e5%ae%a2%e6%88%b7%e7%ab%af%e5%87%ba%e7%8e%b0%e6%95%85%e9%9a%9c%e4%ba%86%e6%80%8e%e4%b9%88%e5%8a%9e%ef%bc%9f">12. 如果已经建立了连接，但是客户端出现故障了怎么办？</a></h2><p>或者说，如果三次握手阶段、四次挥手阶段的包丢失了怎么办？如“服务端重发 FIN丢失”的问题。</p><p>简而言之，通过<strong>定时器 + 超时重试机制</strong>，尝试获取确认，直到最后会自动断开连接。</p><p>具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，以Linux服务器为例，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 秒（默认）发送一个探测报文段，若一共发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。</p><blockquote><p>附：Linux服务器系统内核参数配置</p></blockquote><ol><li>tcp_keepalive_time，在TCP保活打开的情况下，最后一次数据交换到TCP发送第一个保活探测包的间隔，即允许的持续空闲时长，或者说每次正常发送心跳的周期，默认值为7200s（2h）。</li><li>tcp_keepalive_probes 在tcp_keepalive_time之后，没有接收到对方确认，<strong>继续发送保活探测包次数，默认值为9（次）</strong>。</li><li>tcp_keepalive_intvl，在tcp_keepalive_time之后，没有接收到对方确认，继续发送保活探测包的发送频率，默认值为75s。 发送频率tcp_keepalive_intvl乘以发送次数tcp_keepalive_probes，就得到了从开始探测到放弃探测确定连接断开的时间； 举例：若设置，服务器在客户端连接空闲的时候，每90秒发送一次保活探测包到客户端，若没有及时收到客户端的TCP Keepalive ACK确认，将继续等待15秒*2&#x3D;30秒。总之可以在90s+30s&#x3D;120秒（两分钟）时间内可检测到连接失效与否。</li></ol><p>可以参考TCP保活机制：<a href="https://blog.51cto.com/u_15346415/3674622">https://blog.51cto.com/u_15346415&#x2F;3674622</a></p><h2 id="13-TIME-WAIT-状态过多会产生什么后果？怎样处理？"><a href="#13-TIME-WAIT-状态过多会产生什么后果？怎样处理？" class="headerlink" title="13. TIME-WAIT 状态过多会产生什么后果？怎样处理？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_13-time-wait-%e7%8a%b6%e6%80%81%e8%bf%87%e5%a4%9a%e4%bc%9a%e4%ba%a7%e7%94%9f%e4%bb%80%e4%b9%88%e5%90%8e%e6%9e%9c%ef%bc%9f%e6%80%8e%e6%a0%b7%e5%a4%84%e7%90%86%ef%bc%9f">13. TIME-WAIT 状态过多会产生什么后果？怎样处理？</a></h2><p>从服务器来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，严重消耗着服务器的资源，此时部分客户端就会显示连接不上。</p><p>从客户端来讲，客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。</p><p><strong>解决办法：</strong></p><ul><li><p>服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，此套接字选项告诉内核，即使此端口正忙（处于 TIME_WAIT状态），也请继续并重用它。</p></li><li><p>调整系统内核参数，修改&#x2F;etc&#x2F;sysctl.conf文件，即修改<code>net.ipv4.tcp_tw_reuse 和 tcp_timestamps</code></p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">net</span>.ipv4.tcp_tw_reuse = <span class="hljs-number">1</span> 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为<span class="hljs-number">0</span>，表示关闭；<span class="hljs-attribute">net</span>.ipv4.tcp_tw_recycle = <span class="hljs-number">1</span> 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为<span class="hljs-number">0</span>，表示关闭。</code></pre></div></li><li><p>强制关闭，发送 RST 包越过TIME_WAIT状态，直接进入CLOSED状态。</p></li></ul><h2 id="14-TIME-WAIT-是服务器端的状态-还是客户端的状态"><a href="#14-TIME-WAIT-是服务器端的状态-还是客户端的状态" class="headerlink" title="14. TIME_WAIT 是服务器端的状态?还是客户端的状态?"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_14-time_wait-%e6%98%af%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%af%e7%9a%84%e7%8a%b6%e6%80%81%e8%bf%98%e6%98%af%e5%ae%a2%e6%88%b7%e7%ab%af%e7%9a%84%e7%8a%b6%e6%80%81">14. TIME_WAIT 是服务器端的状态?还是客户端的状态?</a></h2><p>TIME_WAIT 是主动断开连接的一方会进入的状态，一般情况下，都是客户端所处的状态;服务器端一般设置不主动关闭连接。</p><p>TIME_WAIT 需要等待 2MSL，在大量短连接的情况下，TIME_WAIT会太多，这也会消耗很多系统资源。对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题。</p><h2 id="15-TCP协议如何保证可靠性？"><a href="#15-TCP协议如何保证可靠性？" class="headerlink" title="15. TCP协议如何保证可靠性？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_15-tcp%e5%8d%8f%e8%ae%ae%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%af%e9%9d%a0%e6%80%a7%ef%bc%9f">15. TCP协议如何保证可靠性？</a></h2><p>TCP主要提供了检验和、序列号&#x2F;确认应答、超时重传、滑动窗口、拥塞控制和 流量控制等方法实现了可靠性传输。</p><ul><li><p>检验和：通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。</p></li><li><p>序列号&#x2F;确认应答：</p><p>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。</p><p>TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文，这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p></li><li><p>滑动窗口：滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。</p></li><li><p>超时重传：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。</p></li><li><p>拥塞控制：在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。</p></li><li><p>流量控制：如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与TCP协议报头中的窗口大小有关。</p></li></ul><h2 id="16-详细讲一下TCP的滑动窗口？"><a href="#16-详细讲一下TCP的滑动窗口？" class="headerlink" title="16. 详细讲一下TCP的滑动窗口？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_16-%e8%af%a6%e7%bb%86%e8%ae%b2%e4%b8%80%e4%b8%8btcp%e7%9a%84%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%ef%bc%9f">16. 详细讲一下TCP的滑动窗口？</a></h2><p>在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。</p><p>为了避免这种情况，TCP引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。</p><p><img src="http://blog-img.coolsen.cn/img/image-20210520214432214.png"></p><p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。</p><p>滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p><p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p><h2 id="17-详细讲一下拥塞控制？"><a href="#17-详细讲一下拥塞控制？" class="headerlink" title="17. 详细讲一下拥塞控制？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_17-%e8%af%a6%e7%bb%86%e8%ae%b2%e4%b8%80%e4%b8%8b%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%ef%bc%9f">17. 详细讲一下拥塞控制？</a></h2><p>TCP 一共使用了四种算法来实现拥塞控制：</p><ul><li><p>慢开始 (slow-start)；</p></li><li><p>拥塞避免 (congestion avoidance)；</p></li><li><p>快速重传 (fast retransmit)；</p></li><li><p>快速恢复 (fast recovery)。</p></li></ul><p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。当cwndssthresh时，改用拥塞避免算法。</p><p><strong>慢开始：</strong>不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。</p><p><strong>拥塞避免：</strong>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。</p><p><strong>快重传：</strong>我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在<strong>收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。</strong>快重传规定：发送方只要<strong>一连收到三个</strong>重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p><p><img src="http://blog-img.coolsen.cn/img/image-20210520214123058.png"></p><p><strong>快恢复：</strong>主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞），但<strong>接下来并不执行慢开始算法</strong>，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。</p><p><img src="http://blog-img.coolsen.cn/img/image-20210520214146324.png"></p><h2 id="18-HTTP常见的状态码有哪些？"><a href="#18-HTTP常见的状态码有哪些？" class="headerlink" title="18. HTTP常见的状态码有哪些？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_18-http%e5%b8%b8%e8%a7%81%e7%9a%84%e7%8a%b6%e6%80%81%e7%a0%81%e6%9c%89%e5%93%aa%e4%ba%9b%ef%bc%9f">18. HTTP常见的状态码有哪些？</a></h2><p>常见状态码：</p><ul><li>200：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</li><li>301 ： (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。</li><li>302：(临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>400 ：客户端请求有语法错误，不能被服务器所理解。</li><li>403 ：服务器收到请求，但是拒绝提供服务。</li><li>404 ：(未找到) 服务器找不到请求的网页。</li><li>500： (服务器内部错误) 服务器遇到错误，无法完成请求。</li></ul><p>状态码开头代表类型：</p><p><img src="http://blog-img.coolsen.cn/img/image-20210525114439748.png"></p><h2 id="19-状态码301和302的区别是什么？"><a href="#19-状态码301和302的区别是什么？" class="headerlink" title="19. 状态码301和302的区别是什么？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_19-%e7%8a%b6%e6%80%81%e7%a0%81301%e5%92%8c302%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f">19. 状态码301和302的区别是什么？</a></h2><p><strong>共同点</strong>：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（<strong>用户看到的效果就是他输入的地址A瞬间变成了另一个地址B</strong>）。 <strong>不同点</strong>：301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO中302好于301。</p><p><strong>补充，重定向原因</strong>：</p><ol><li>网站调整（如改变网页目录结构）；</li><li>网页被移到一个新地址；</li><li>网页扩展名改变(如应用需要把.php改成.Html或.shtml)。</li></ol><h2 id="20-HTTP-常用的请求方式？"><a href="#20-HTTP-常用的请求方式？" class="headerlink" title="20. HTTP 常用的请求方式？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_20-http-%e5%b8%b8%e7%94%a8%e7%9a%84%e8%af%b7%e6%b1%82%e6%96%b9%e5%bc%8f%ef%bc%9f">20. HTTP 常用的请求方式？</a></h2><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td></tr><tr><td>POST</td><td>传输实体主体</td></tr><tr><td>PUT</td><td>上传文件</td></tr><tr><td>DELETE</td><td>删除文件</td></tr><tr><td>HEAD</td><td>和GET方法类似，但只返回报文首部，不返回报文实体主体部分</td></tr><tr><td>PATCH</td><td>对资源进行部分修改</td></tr><tr><td>OPTIONS</td><td>查询指定的URL支持的方法</td></tr><tr><td>CONNECT</td><td>要求用隧道协议连接代理</td></tr><tr><td>TRACE</td><td>服务器会将通信路径返回给客户端</td></tr></tbody></table><p>为了方便记忆，可以将PUT、DELETE、POST、GET理解为客户端对服务端的增删改查。</p><ul><li>PUT：上传文件，向服务器添加数据，可以看作增</li><li>DELETE：删除文件</li><li>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</li><li>GET：获取资源，查询服务器资源</li></ul><h2 id="21-GET请求和POST请求的区别？"><a href="#21-GET请求和POST请求的区别？" class="headerlink" title="21. GET请求和POST请求的区别？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_21-get%e8%af%b7%e6%b1%82%e5%92%8cpost%e8%af%b7%e6%b1%82%e7%9a%84%e5%8c%ba%e5%88%ab%ef%bc%9f">21. GET请求和POST请求的区别？</a></h2><p><strong>使用上的区别</strong>：</p><ul><li><p>GET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。</p></li><li><p>GET方式提交的数据有长度限制，则POST的数据则可以非常大”，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。</p></li><li><p>POST比GET安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。</p></li></ul><p><strong>本质区别</strong></p><p>GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别。</p><p>幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p><h2 id="22-解释一下HTTP长连接和短连接？"><a href="#22-解释一下HTTP长连接和短连接？" class="headerlink" title="22. 解释一下HTTP长连接和短连接？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_22-%e8%a7%a3%e9%87%8a%e4%b8%80%e4%b8%8bhttp%e9%95%bf%e8%bf%9e%e6%8e%a5%e5%92%8c%e7%9f%ad%e8%bf%9e%e6%8e%a5%ef%bc%9f">22. 解释一下HTTP长连接和短连接？</a></h2><p><strong>在HTTP&#x2F;1.0中，默认使用的是短连接</strong>。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p><p>但从 <strong>HTTP&#x2F;1.1起，默认使用长连接</strong>，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：<code>Connection:keep-alive</code></p><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p><p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p><h2 id="23-HTTP请求报文和响应报文的格式？"><a href="#23-HTTP请求报文和响应报文的格式？" class="headerlink" title="23. HTTP请求报文和响应报文的格式？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_23-http%e8%af%b7%e6%b1%82%e6%8a%a5%e6%96%87%e5%92%8c%e5%93%8d%e5%ba%94%e6%8a%a5%e6%96%87%e7%9a%84%e6%a0%bc%e5%bc%8f%ef%bc%9f">23. HTTP请求报文和响应报文的格式？</a></h2><p><strong>请求报文格式</strong>：</p><ol><li>请求行（请求方法+URI协议+版本）</li><li>请求头部</li><li>空行</li><li>请求主体</li></ol><div class="code-wrapper"><pre><code class="hljs ruby"><span class="hljs-variable constant_">GET</span>/sample.jspHTTP/<span class="hljs-number">1.1</span> 请求行<span class="hljs-title class_">Accept</span><span class="hljs-symbol">:image/gif</span>.image/jpeg, 请求头部<span class="hljs-title class_">Accept</span>-<span class="hljs-title class_">Language</span><span class="hljs-symbol">:zh-cn</span><span class="hljs-title class_">Connection</span><span class="hljs-symbol">:Keep-Alive</span><span class="hljs-title class_">Host</span><span class="hljs-symbol">:localhost</span><span class="hljs-title class_">User</span>-<span class="hljs-title class_">Agent</span><span class="hljs-symbol">:Mozila/</span><span class="hljs-number">4.0</span>(compatible;<span class="hljs-variable constant_">MSIE5</span>.<span class="hljs-number">01</span>;<span class="hljs-title class_">Window</span> <span class="hljs-variable constant_">NT5</span>.<span class="hljs-number">0</span>)<span class="hljs-title class_">Accept</span>-<span class="hljs-title class_">Encoding</span><span class="hljs-symbol">:gzip</span>,deflateusername=jinqiao&amp;password=<span class="hljs-number">1234</span> 请求主体</code></pre></div><p><strong>响应报文</strong>：</p><ol><li>状态行（版本+状态码+原因短语）</li><li>响应首部</li><li>空行</li><li>响应主体</li></ol><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">200</span> OK<span class="hljs-attribute">Server</span>:Apache Tomcat/<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">12</span><span class="hljs-attribute">Date</span>:Mon,<span class="hljs-number">6</span>Oct2003 <span class="hljs-number">13</span>:<span class="hljs-number">23</span>:<span class="hljs-number">42</span> GMT<span class="hljs-attribute">Content</span>-Length:<span class="hljs-number">112</span><span class="hljs-section">&lt;html&gt;</span>    <span class="hljs-section">&lt;head&gt;</span>        <span class="hljs-section">&lt;title&gt;</span><span class="hljs-attribute">HTTP</span>响应示例&lt;title&gt;    <span class="hljs-section">&lt;/head&gt;</span>    <span class="hljs-section">&lt;body&gt;</span>        <span class="hljs-attribute">Hello</span> HTTP!    <span class="hljs-section">&lt;/body&gt;</span><span class="hljs-section">&lt;/html&gt;</span></code></pre></div><h2 id="24-HTTP1-0和HTTP1-1的区别"><a href="#24-HTTP1-0和HTTP1-1的区别" class="headerlink" title="24. HTTP1.0和HTTP1.1的区别?"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_24-http10%e5%92%8chttp11%e7%9a%84%e5%8c%ba%e5%88%ab">24. HTTP1.0和HTTP1.1的区别?</a></h2><ul><li><p><strong>长连接</strong>：HTTP 1.1支持长连接（Persistent Connection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启<code>Connection： keep-alive</code>，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p></li><li><p><strong>缓存处理</strong>：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略。</p></li><li><p><strong>带宽优化及网络连接的使用</strong>：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p></li><li><p><strong>错误通知的管理</strong>：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p></li><li><p><strong>Host头处理</strong>：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p></li></ul><h2 id="25-HTTP1-1和-HTTP2-0的区别？"><a href="#25-HTTP1-1和-HTTP2-0的区别？" class="headerlink" title="25. HTTP1.1和 HTTP2.0的区别？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_25-http11%e5%92%8c-http20%e7%9a%84%e5%8c%ba%e5%88%ab%ef%bc%9f">25. HTTP1.1和 HTTP2.0的区别？</a></h2><p>HTTP2.0相比HTTP1.1支持的特性：</p><ul><li><p><strong>新的二进制格式</strong>：HTTP1.1的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p></li><li><p><strong>多路复用</strong>，即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p></li><li><p><strong>头部压缩</strong>，HTTP1.1的头部（header）带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p></li><li><p><strong>服务端推送</strong>：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。</p></li></ul><h2 id="26-HTTP-与-HTTPS-的区别？"><a href="#26-HTTP-与-HTTPS-的区别？" class="headerlink" title="26. HTTP 与 HTTPS 的区别？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_26-http-%e4%b8%8e-https-%e7%9a%84%e5%8c%ba%e5%88%ab%ef%bc%9f">26. HTTP 与 HTTPS 的区别？</a></h2><table><thead><tr><th></th><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>端口</td><td>80</td><td>443</td></tr><tr><td>安全性</td><td>无加密，安全性较差</td><td>有加密机制，安全性较高</td></tr><tr><td>资源消耗</td><td>较少</td><td>由于加密处理，资源消耗更多</td></tr><tr><td>是否需要证书</td><td>不需要</td><td>需要</td></tr><tr><td>协议</td><td>运行在TCP协议之上</td><td>运行在SSL协议之上，SSL运行在TCP协议之上</td></tr></tbody></table><h2 id="27-HTTPS-的优缺点"><a href="#27-HTTPS-的优缺点" class="headerlink" title="27. HTTPS 的优缺点?"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_27-https-%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9">27. HTTPS 的优缺点?</a></h2><p><strong>优点</strong>：</p><ul><li><p>安全性：</p><ul><li><p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></li><li><p>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p></li><li><p>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p></li></ul></li><li><p>SEO方面：谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p></li></ul><p><strong>缺点</strong>：</p><ul><li>在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。</li><li>HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</li><li>在现有的证书机制下，中间人攻击依然有可能发生。</li><li>HTTPS 需要更多的服务器资源，也会导致成本的升高。</li></ul><h2 id="28-讲一讲HTTPS-的原理？"><a href="#28-讲一讲HTTPS-的原理？" class="headerlink" title="28. 讲一讲HTTPS 的原理？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_28-%e8%ae%b2%e4%b8%80%e8%ae%b2https-%e7%9a%84%e5%8e%9f%e7%90%86%ef%bc%9f">28. 讲一讲HTTPS 的原理？</a></h2><p><img src="http://blog-img.coolsen.cn/img/image-20210525160006424.png"></p><blockquote><p>图片来源：<a href="https://segmentfault.com/a/1190000021494676">https://segmentfault.com/a/1190000021494676</a></p></blockquote><p>加密流程按图中的序号分为：</p><ol><li><p>客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。</p></li><li><p>采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。</p></li><li><p>服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。</p></li><li><p>客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。</p></li><li><p>客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。</p></li><li><p>服务器在收到随机码 KEY 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。</p></li><li><p>服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。</p></li><li><p>双方使用对称加密愉快地传输所有数据。</p></li></ol><h2 id="29-在浏览器中输入www-baidu-com后执行的全部过程？"><a href="#29-在浏览器中输入www-baidu-com后执行的全部过程？" class="headerlink" title="29. 在浏览器中输入www.baidu.com后执行的全部过程？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_29-%e5%9c%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e4%b8%ad%e8%be%93%e5%85%a5wwwbaiducom%e5%90%8e%e6%89%a7%e8%a1%8c%e7%9a%84%e5%85%a8%e9%83%a8%e8%bf%87%e7%a8%8b%ef%bc%9f">29. 在浏览器中输入</a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_1-%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e7%9a%84%e5%90%84%e5%b1%82%e5%8d%8f%e8%ae%ae%e5%8f%8a%e4%bd%9c%e7%94%a8%ef%bc%9fhttp://www.baidu.com%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%85%A8%E9%83%A8%E8%BF%87%E7%A8%8B%EF%BC%9F">www.baidu.com后执行的全部过程？</a></h2><ol><li><p>域名解析（域名 <a href="http://www.baidu.com/">www.baidu.com</a> 变为 ip 地址）。</p><p><strong>浏览器搜索自己的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索<strong>操作系统的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索操作系统的<strong>hosts文件</strong>（维护一张域名与IP的对应表）。</p><p>若都没有，则找 tcp&#x2F;ip 参数中设置的首选 dns 服务器，即<strong>本地 dns 服务器</strong>（递归查询），<strong>本地域名服务器查询自己的dns缓存</strong>，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。</p></li><li><p>发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 <strong>80</strong> 端口发起 tcp 的连接。</p></li><li><p>建立 tcp 连接后发起 http 请求。</p></li><li><p>服务器响应 http 请求，客户端得到 html 代码。服务器 web 应用程序收到 http 请求后，就开始处理请求，处理之后就返回给浏览器 html 文件。</p></li><li><p>浏览器解析 html 代码，并请求 html 中的资源。</p></li><li><p>浏览器对页面进行渲染，并呈现给用户。</p></li></ol><p>附一张形象的图片：<img src="http://blog-img.coolsen.cn/img/image-20210525172545204.png"></p><h2 id="30-什么是-Cookie-和-Session"><a href="#30-什么是-Cookie-和-Session" class="headerlink" title="30. 什么是 Cookie 和 Session ?"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_30-%e4%bb%80%e4%b9%88%e6%98%af-cookie-%e5%92%8c-session-">30. 什么是 Cookie 和 Session ?</a></h2><p><strong>什么是 Cookie</strong></p><p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p><p>Cookie 主要用于以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><p><strong>什么是 Session</strong></p><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p><h2 id="31-Cookie-和-Session-是如何配合的呢？"><a href="#31-Cookie-和-Session-是如何配合的呢？" class="headerlink" title="31. Cookie 和 Session 是如何配合的呢？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_31-cookie-%e5%92%8c-session-%e6%98%af%e5%a6%82%e4%bd%95%e9%85%8d%e5%90%88%e7%9a%84%e5%91%a2%ef%bc%9f">31. Cookie 和 Session 是如何配合的呢？</a></h2><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p><p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p><p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p><h2 id="32-Cookie和Session的区别？"><a href="#32-Cookie和Session的区别？" class="headerlink" title="32. Cookie和Session的区别？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_32-cookie%e5%92%8csession%e7%9a%84%e5%8c%ba%e5%88%ab%ef%bc%9f">32. Cookie和Session的区别？</a></h2><ul><li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li><li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li><li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li><li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li><li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li></ul><h2 id="33-如何考虑分布式-Session-问题？"><a href="#33-如何考虑分布式-Session-问题？" class="headerlink" title="33. 如何考虑分布式 Session 问题？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_33-%e5%a6%82%e4%bd%95%e8%80%83%e8%99%91%e5%88%86%e5%b8%83%e5%bc%8f-session-%e9%97%ae%e9%a2%98%ef%bc%9f">33. 如何考虑分布式 Session 问题？</a></h2><p>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</p><p>分布式 Session 一般会有以下几种解决方案：</p><ul><li><p><strong>客户端存储</strong>：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息</p></li><li><p><strong>Nginx ip_hash 策略</strong>：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</p></li><li><p><strong>Session 复制</strong>：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</p></li><li><p><strong>共享 Session</strong>：服务端无状态话，将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。</p></li></ul><p>建议采用共享 Session的方案。</p><h2 id="34-什么是DDos攻击？"><a href="#34-什么是DDos攻击？" class="headerlink" title="34. 什么是DDos攻击？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_34-%e4%bb%80%e4%b9%88%e6%98%afddos%e6%94%bb%e5%87%bb%ef%bc%9f">34. 什么是DDos攻击？</a></h2><p>DDos全称Distributed Denial of Service，分布式拒绝服务攻击。最基本的DOS攻击过程如下：</p><ol><li>客户端向服务端发送请求链接数据包。</li><li>服务端向客户端发送确认数据包。</li><li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认</li></ol><p>DDoS则是采用分布式的方法，通过在网络上占领多台“肉鸡”，用多台计算机发起攻击。</p><p>DOS攻击现在基本没啥作用了，因为服务器的性能都很好，而且是多台服务器共同作用，1V1的模式黑客无法占上风。对于DDOS攻击，预防方法有：</p><ul><li><strong>减少SYN timeout时间</strong>。在握手的第三步，服务器会等待30秒-120秒的时间，减少这个等待时间就能释放更多的资源。</li><li><strong>限制同时打开的SYN半连接数目。</strong></li></ul><h2 id="35-什么是XSS攻击？"><a href="#35-什么是XSS攻击？" class="headerlink" title="35. 什么是XSS攻击？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_35-%e4%bb%80%e4%b9%88%e6%98%afxss%e6%94%bb%e5%87%bb%ef%bc%9f">35. 什么是XSS攻击？</a></h2><p>XSS也称 cross-site scripting，<strong>跨站脚本</strong>。这种攻击是<strong>由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的</strong>。比如一个存在XSS漏洞的论坛，用户发帖时就可以引入<strong>带有＜script＞标签的代码</strong>，导致恶意代码的执行。</p><p>预防措施有：</p><ul><li>前端：过滤。</li><li>后端：转义，比如go自带的处理器就具有转义功能。</li></ul><h2 id="36-SQL注入是什么，如何避免SQL注入？"><a href="#36-SQL注入是什么，如何避免SQL注入？" class="headerlink" title="36. SQL注入是什么，如何避免SQL注入？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_36-sql%e6%b3%a8%e5%85%a5%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%8c%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8dsql%e6%b3%a8%e5%85%a5%ef%bc%9f">36. SQL注入是什么，如何避免SQL注入？</a></h2><p>SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的 SQL 语句就会被数据库服务器误认为是正常的 SQL 语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。</p><p><strong>SQL注入的原理主要有以下 4 点</strong></p><ul><li>恶意拼接查询</li><li>利用注释执行非法命令</li><li>传入非法参数</li><li>添加额外条件</li></ul><p><strong>避免SQL注入的一些方法</strong>：</p><ul><li>限制数据库权限，给用户提供仅仅能够满足其工作的最低权限。</li><li>对进入数据库的特殊字符（’”\尖括号&amp;*;等）转义处理。</li><li>提供参数化查询接口，不要直接使用原生SQL。</li></ul><h2 id="37-负载均衡算法有哪些？"><a href="#37-负载均衡算法有哪些？" class="headerlink" title="37. 负载均衡算法有哪些？"></a><a href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_37-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e7%ae%97%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b%ef%bc%9f">37. 负载均衡算法有哪些？</a></h2><p>多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。</p><ul><li>轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势。</li><li>随机法：随机获取一台，和轮询类似。</li><li>哈希法：通过ip地址哈希化来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie。</li><li>加权轮询：根据服务器性能不同加权。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>HTTP</tag>
      
      <tag>HTTPS</tag>
      
      <tag>TCP</tag>
      
      <tag>UDP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微前端</title>
    <link href="/2023/01/29/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    <url>/2023/01/29/%E5%BE%AE%E5%89%8D%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<p>微前端介绍</p><span id="more"></span><blockquote><p><strong>什么是微前端？</strong><br>微前端是一种多个团队通过独立发布功能的方式，来共同构建现代化 web 应用的技术手段及方法策略。</p></blockquote><p>不同于单纯的前端框架&#x2F;工具，微前端是一套架构体系，这个概念最早在2016年底由 ThoughtWorks 提出。 微前端是一种类似于后端微服务的架构，它将微服务的理念应用于浏览器端，将 Web 应用从整个的「单体应用」转变为多个小型前端应用的「聚合体」。</p><p>各个前端应用「原子化」，可以独立运行、开发、部署，从而满足业务的快速变化，以及分布式、多团队并行开发的需求。</p><blockquote><p>微前端的特点</p><ul><li><strong>技术栈无关</strong> 主框架不限制接入应用的技术栈，子应用可自主选择技术栈</li><li><strong>独立开发&#x2F;部署</strong> 各个团队之间仓库独立，单独部署，互不依赖</li><li><strong>增量升级</strong> 当一个应用庞大之后，技术升级或重构相当麻烦，而微应用具备渐进式升级的特性</li><li><strong>独立运行时</strong> 微应用之间运行时互不依赖，有独立的状态管理</li><li><strong>提升效率</strong> 应用越庞大，越难以维护，协作效率越低下。微应用可以很好拆分，提升效率</li></ul></blockquote><p><strong>解决问题的理念有了，那要通过怎样的技术去实现呢？</strong></p><ol><li><strong>iframe</strong> 最早也是最熟悉的解决方案就是通过iframe，因为它可以独立运行另一个项目，这种方案的优势：</li></ol><ul><li>非常简单，无需任何改造</li><li>完美隔离，JS、CSS 都是独立的运行环境</li><li>不限制使用，页面上可以放多个 <code>iframe</code> 来组合业务</li></ul><p>当然也是逃不过事务的两面性，有优点就有缺点：</p><ul><li>无法保持路由状态，刷新后路由状态就丢失（这点也不是完全不能解决，可以讲路由作为参数拼接在链接后，刷新时去参数进行页面跳转）</li><li>完全的隔离导致与子应用的交互变得极其困难</li><li><code>iframe</code> 中的弹窗无法突破其本身</li><li>整个应用全量资源加载，加载太慢</li></ul><p>既然有这么明显的问题，那就会有新的方案被创造出来</p><ol><li><strong>基于</strong> <strong><code>single-spa</code></strong> <strong>路由劫持方案</strong></li></ol><p><code>single-spa</code> 通过劫持路由的方式来做子应用之间的切换，但接入方式需要融合自身的路由，有一定的局限性。</p><p><code>qiankun</code> 孵化自蚂蚁金融科技基于微前端架构的云产品统一接入平台。它对 <code>single-spa</code> 做了一层封装。主要解决了 <code>single-spa</code> 的一些痛点和不足。通过 <code>import-html-entry</code> 包解析 <code>HTML</code> 获取资源路径，然后对资源进行解析、加载。</p><p>通过对执行环境的修改，它实现了 <code>JS 沙箱</code>、<code>样式隔离</code> 等特性。<br>接下来我就好好的讲讲<code>qiankun</code>是怎么落地到生产项目的，中间遇到过哪些坑。</p><h3 id="qiankun"><a href="#qiankun" class="headerlink" title="qiankun"></a>qiankun</h3><p>qiankun官网 <a href="https://link.juejin.cn/?target=https://qiankun.umijs.org/zh/guide">qiankun.umijs.org&#x2F;zh&#x2F;guide</a></p><p>按照官方文档快速搞起来<br><strong>主应用</strong></p><ol><li>安装</li></ol><div class="code-wrapper"><pre><code class="hljs sh">$ yarn add qiankun <span class="hljs-comment"># 或者 npm i qiankun -S</span></code></pre></div><ol><li>在主应用注册微应用 main.js</li></ol><p>放在main.js的尾部</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; registerMicroApps, start &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qiankun&#x27;</span>;<span class="hljs-title function_">registerMicroApps</span>([  &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;vue app&#x27;</span>,    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;//localhost:7100&#x27;</span>,    <span class="hljs-attr">container</span>: <span class="hljs-string">&#x27;#container-vue&#x27;</span>,    <span class="hljs-attr">activeRule</span>: <span class="hljs-string">&#x27;/micro-vue&#x27;</span>,    <span class="hljs-comment">// 传递给子应用的参数</span>    <span class="hljs-attr">props</span>: &#123;      <span class="hljs-attr">routerBase</span>: <span class="hljs-string">&#x27;/micro-vue&#x27;</span>,    &#125;  &#125;,  &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;micro-clouds&#x27;</span>,    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;//localhost:7000&#x27;</span>,    <span class="hljs-attr">activeRule</span>: <span class="hljs-string">&#x27;/micro-clouds&#x27;</span>,    <span class="hljs-attr">container</span>: <span class="hljs-string">&#x27;#subapp2&#x27;</span>, <span class="hljs-comment">// 子应用挂载的div</span>    <span class="hljs-comment">// 传递给子应用的参数</span>    <span class="hljs-attr">props</span>: &#123;      <span class="hljs-attr">routerBase</span>: <span class="hljs-string">&#x27;/micro-clouds&#x27;</span>,    &#125;  &#125;]);<span class="hljs-comment">// 启动微应用</span><span class="hljs-title function_">start</span>();</code></pre></div><p>当微应用信息注册完之后，一旦浏览器的 url 发生变化，便会自动触发 qiankun 的匹配逻辑，所有 activeRule 规则匹配上的微应用就会被插入到指定的 container 中，同时依次调用微应用暴露出的生命周期钩子。</p><p>如果微应用不是直接跟路由关联的时候，你也可以选择手动加载微应用的方式：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; loadMicroApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qiankun&#x27;</span>;<span class="hljs-title function_">loadMicroApp</span>(&#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;micro-clouds&#x27;</span>,  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;//localhost:7000&#x27;</span>,  <span class="hljs-attr">activeRule</span>: <span class="hljs-string">&#x27;/micro-clouds&#x27;</span>,  <span class="hljs-attr">container</span>: <span class="hljs-string">&#x27;#subapp2&#x27;</span>, <span class="hljs-comment">// 子应用挂载的div</span>  <span class="hljs-comment">// 传递给子应用的参数</span>  <span class="hljs-attr">props</span>: &#123;    <span class="hljs-attr">routerBase</span>: <span class="hljs-string">&#x27;/micro-clouds&#x27;</span>,  &#125;&#125;);</code></pre></div><p><strong>微应用</strong><br>main.js</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./public-path&#x27;</span>;<span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/App.vue&#x27;</span><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router&#x27;</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span><span class="hljs-keyword">let</span> instance = <span class="hljs-literal">null</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">props = &#123;&#125;</span>) &#123;  <span class="hljs-keyword">const</span> &#123; container, routerBase &#125; = props;  <span class="hljs-comment">// 实例化vue</span>  instance = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);  <span class="hljs-comment">// 路由挂载</span>  <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;    <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;routerBase&#125;</span>`</span>),    routes  &#125;);  instance.<span class="hljs-title function_">use</span>(router);  instance.<span class="hljs-title function_">use</span>(store);  instance.<span class="hljs-title function_">mount</span>(container ? container.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#app&quot;</span>) : <span class="hljs-string">&quot;#app&quot;</span>);&#125;<span class="hljs-comment">// eslint-disable-next-line no-underscore-dangle</span><span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-property">__POWERED_BY_QIANKUN__</span>) &#123;  <span class="hljs-title function_">render</span>(&#123; <span class="hljs-attr">container</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-attr">routerBase</span>: <span class="hljs-string">&quot;/micro-clouds&quot;</span> &#125;);&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[vue] vue app bootstraped&#x27;</span>);&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mount</span>(<span class="hljs-params">props</span>) &#123;  <span class="hljs-keyword">await</span> <span class="hljs-title function_">render</span>(props);&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">unmount</span>(<span class="hljs-params"></span>) &#123;  instance.<span class="hljs-title function_">unmount</span>();&#125;</code></pre></div><p>public-path.js</p><div class="code-wrapper"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">__POWERED_BY_QIANKUN__</span>) &#123;    <span class="hljs-comment">// eslint-disable-next-line</span>    __webpack_public_path__ = <span class="hljs-variable language_">window</span>.<span class="hljs-property">__INJECTED_PUBLIC_PATH_BY_QIANKUN__</span>    <span class="hljs-comment">// __webpack_public_path__ = `$&#123;process.env.BASE_URL&#125;/`</span>  &#125;&#125;)()</code></pre></div><p>到这里我们就把主应用和微应用融合起来了，涉及的代码量也就百八十行，至于跳转可以自己在主应用加几个按钮通过<code>history.pushState(null, item.activeRule, item.activeRule)</code></p><p><img src="/../imgs/%E5%BE%AE%E5%89%8D%E7%AB%AF/d72b7c899e104645a0f372007e60cf92tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="image.png"></p><p>这个是我当时模仿的demo： <a href="https://link.juejin.cn/?target=https://github.com/fengxianqi/qiankun-example">github.com&#x2F;fengxianqi&#x2F;…</a></p><p>其实跑通以上demo还是挺简单的，我一开始也是看着qiankun官网，在网上找了个demo比划比划，很简单嘛！如果我这边文章只分享到这里那完全没有必要去分享了，往后看才是实际生产项目的搭法。</p><h3 id="qiankun-vue3-搭建生产项目"><a href="#qiankun-vue3-搭建生产项目" class="headerlink" title="qiankun + vue3 搭建生产项目"></a>qiankun + vue3 搭建生产项目</h3><p>通过上面的demo例子抛转引玉，应该对微前端是怎么跑起来的有了大致的认识。我当时也以为搞定了上面的demo就可以直接用在生产项目了。没料到实际用起来和demo完全是两回事，下面请听我一一解析这当中遇到的坑。</p><h4 id="1-路由"><a href="#1-路由" class="headerlink" title="1. 路由"></a>1. 路由</h4><p>由于demo项目没有用<code>vue-router</code>，直接是通过<code>history.pushState</code>跳转，一切看来都是那么的没有，没有告警没有报红。但在实际的vue项目中，路由的改变，<code>vue-router</code>是会自动去匹配路由的，当匹配到子路由在当前router中没有配置时就会报警报红，如果直接跳转又没法运用到<code>vue-router</code>中的能力，怎么融合路由才能达到要求呢？</p><p>答案是通过一个<code>component</code>组件来承载，它可以使<code>qiankun</code>的代码与基座项目极大的降低耦合，代码可维护性增强，最重要的是可以统一将微应用路由归并到这个组件路由来，相当于接入微前端就像增加了一个普通组件这么简单。</p><p><strong>主应用配置</strong></p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">src</span>/router/index<span class="hljs-selector-class">.js</span>&#123;    path: <span class="hljs-string">&#x27;/:micro(micro-vue|micro-clouds):endPath(.*)&#x27;</span>,    name: <span class="hljs-string">&#x27;MicroApp&#x27;</span>,    meta: &#123; title: <span class="hljs-string">&#x27;微前端应用&#x27;</span> &#125;,    component: () =&gt; <span class="hljs-built_in">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;qiankun&quot; */</span><span class="hljs-string">&#x27;@/views/qiankun/MicroApp.vue&#x27;</span>) &#125;,</code></pre></div><p>通过正则匹配路由，只要是微应用的路由都可以匹配进来，当然需要事先定义好微应用的路由前缀，比如<code>micro-xxx</code>，增加微应用就在这里<code>(micro-vue|micro-clouds)</code>加一个匹配前缀。</p><p>新建<code>MicroApp.vue</code>组件<br><code>src/views/qiankun/MicroApp.vue</code></p><div class="code-wrapper"><pre><code class="hljs js">&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;layout-container micro-container&quot;</span> <span class="hljs-attr">v-loading</span>=<span class="hljs-string">&quot;$store.state.app.isLoadingMicro&quot;</span></span></span><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">element-loading-text</span>=<span class="hljs-string">&quot;Loading...&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;subapp1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;subapp2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&lt;/template&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">  onMounted, watch, reactive, onUnmounted</span></span><span class="language-javascript"><span class="language-xml">&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; loadMicroApp, addGlobalUncaughtErrorHandler &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qiankun&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; microApps, registerApps &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/views/qiankun/micro-app&#x27;</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;MicroApp&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> microList = <span class="hljs-title function_">reactive</span>(&#123;&#125;)</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">elementLink</span>: <span class="hljs-literal">null</span></span></span><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">activationHandleChange</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">path</span>) =&gt; &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> activeRules = microApps.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">app</span>) =&gt;</span> app.<span class="hljs-property">activeRule</span>)</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> isMicro = activeRules.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">rule</span>) =&gt;</span> path.<span class="hljs-title function_">startsWith</span>(rule))</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">if</span> (!isMicro) <span class="hljs-keyword">return</span></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> microItem = microApps.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">app</span>) =&gt;</span> path.<span class="hljs-title function_">startsWith</span>(app.<span class="hljs-property">activeRule</span>.<span class="hljs-title function_">toString</span>()))</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">if</span> (!microItem) <span class="hljs-keyword">return</span></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 如果已经加载过一次，则无需再次加载</span></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> current = microList[microItem.<span class="hljs-property">activeRule</span>.<span class="hljs-title function_">toString</span>()]</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">if</span> (current) <span class="hljs-keyword">return</span></span></span><span class="language-javascript"><span class="language-xml"></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 缓存当前子应用</span></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">const</span> micro = <span class="hljs-title function_">loadMicroApp</span>(&#123; ...microItem &#125;)</span></span><span class="language-javascript"><span class="language-xml">      microList[microItem.<span class="hljs-property">activeRule</span>.<span class="hljs-title function_">toString</span>()] = micro</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">try</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">await</span> micro.<span class="hljs-property">mountPromise</span></span></span><span class="language-javascript"><span class="language-xml">      &#125; <span class="hljs-keyword">catch</span> (e) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;=======&#x27;</span>, e)</span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// qiankun全局异常捕获</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">addGlobalUncaughtErrorHandler</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event))</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 监测路由变化</span></span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">watch</span>(<span class="hljs-function">() =&gt;</span> route.<span class="hljs-property">path</span>, <span class="hljs-keyword">async</span> (newValue) =&gt; &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">activationHandleChange</span>(newValue)</span></span><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><span class="language-javascript"><span class="language-xml">    </span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">onMounted</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">qiankunStarted</span>) <span class="hljs-keyword">return</span></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">window</span>.<span class="hljs-property">qiankunStarted</span> = <span class="hljs-literal">true</span></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">registerApps</span>()</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">activationHandleChange</span>(route.<span class="hljs-property">path</span>)</span></span><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">window</span>.<span class="hljs-property">qiankunStarted</span> = <span class="hljs-literal">false</span></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 离开微应用路由时会卸载开启的微应用</span></span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(microList).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">mic</span>) =&gt;</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">        mic.<span class="hljs-title function_">unmount</span>()</span></span><span class="language-javascript"><span class="language-xml">      &#125;)</span></span><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.micro-container</span>&#123;</span></span><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">var</span>(--system-container-main-background);</span></span><span class="language-css"><span class="language-xml">&#125;</span></span><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>src/views/qiankun/micro-app.<span class="hljs-property">js</span><span class="hljs-keyword">import</span> &#123; registerMicroApps, start &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qiankun&#x27;</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span><span class="hljs-keyword">import</span> utils <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/assets/js/utils&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> microApps = [  &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;micro-clouds&#x27;</span>,    <span class="hljs-attr">entry</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">VUE_APP_CLOUDS</span>,    <span class="hljs-attr">activeRule</span>: <span class="hljs-string">&#x27;/micro-clouds&#x27;</span>,    <span class="hljs-attr">container</span>: <span class="hljs-string">&#x27;#subapp2&#x27;</span>, <span class="hljs-comment">// 子应用挂载的div</span>    <span class="hljs-attr">props</span>: &#123;      <span class="hljs-attr">routerBase</span>: <span class="hljs-string">&#x27;/micro-clouds&#x27;</span>,      <span class="hljs-attr">mainStore</span>: store,      <span class="hljs-attr">user</span>: utils.<span class="hljs-title function_">getStorage</span>(<span class="hljs-string">&#x27;user&#x27;</span>)    &#125;  &#125;]<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">registerApps</span> = (<span class="hljs-params"></span>) =&gt; &#123;  <span class="hljs-title function_">registerMicroApps</span>(microApps, &#123;    <span class="hljs-attr">beforeLoad</span>: <span class="hljs-function">(<span class="hljs-params">app</span>) =&gt;</span> &#123;      store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;app/loadingMicro&#x27;</span>, <span class="hljs-literal">true</span>)      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;before load app.name====&gt;&gt;&gt;&gt;&gt;&#x27;</span>, app.<span class="hljs-property">name</span>)    &#125;,    <span class="hljs-attr">beforeMount</span>: [      <span class="hljs-function">(<span class="hljs-params">app</span>) =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[LifeCycle] before mount %c%s&#x27;</span>, <span class="hljs-string">&#x27;color: green;&#x27;</span>, app.<span class="hljs-property">name</span>)      &#125;    ],    <span class="hljs-attr">afterMount</span>: [      <span class="hljs-function">(<span class="hljs-params">app</span>) =&gt;</span> &#123;        store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;app/loadingMicro&#x27;</span>, <span class="hljs-literal">false</span>)        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[LifeCycle] after mount %c%s&#x27;</span>, <span class="hljs-string">&#x27;color: green;&#x27;</span>, app.<span class="hljs-property">name</span>)      &#125;    ],    <span class="hljs-attr">afterUnmount</span>: [      <span class="hljs-function">(<span class="hljs-params">app</span>) =&gt;</span> &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[LifeCycle] after unmount %c%s&#x27;</span>, <span class="hljs-string">&#x27;color: green;&#x27;</span>, app.<span class="hljs-property">name</span>)      &#125;    ]  &#125;)  <span class="hljs-title function_">start</span>(&#123;    <span class="hljs-attr">sandbox</span>: &#123;      <span class="hljs-comment">// 默认开启预加载</span>      <span class="hljs-attr">prefetch</span>: <span class="hljs-string">&#x27;all&#x27;</span>,      <span class="hljs-comment">// qiankun提供的样式隔离方法（严格模式）</span>      <span class="hljs-attr">strictStyleIsolation</span>: <span class="hljs-literal">true</span>,      <span class="hljs-attr">experimentalStyleIsolation</span>: <span class="hljs-literal">true</span>    &#125;  &#125;)&#125;</code></pre></div><p><strong>微应用配置</strong><br><code>mian.js</code></p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./public-path&#x27;</span>;<span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">ElementPlus</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">NProgress</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/assets/js/nprogress&#x27;</span>;<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">ELIcons</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@element-plus/icons-vue&#x27;</span><span class="hljs-keyword">import</span> zhCn <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus/es/locale/lang/zh-cn&#x27;</span><span class="hljs-keyword">import</span> draggable <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuedraggable&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-plus/dist/index.css&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;normalize.css&#x27;</span> <span class="hljs-comment">// css初始化</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@/assets/style/common.scss&#x27;</span> <span class="hljs-comment">// 公共css</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@/assets/style/iconfont.css&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/App.vue&#x27;</span><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router&#x27;</span><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span><span class="hljs-keyword">let</span> instance = <span class="hljs-literal">null</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">props = &#123;&#125;</span>) &#123;  <span class="hljs-keyword">const</span> &#123; container, routerBase &#125; = props;    instance = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);  <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;    <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;routerBase&#125;</span>`</span>),    routes  &#125;);  instance.<span class="hljs-title function_">use</span>(router);  instance.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementPlus</span>, &#123;    <span class="hljs-attr">locale</span>: zhCn  &#125;);  instance.<span class="hljs-title function_">use</span>(store);  instance.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;draggable&#x27;</span>, draggable)  <span class="hljs-comment">/* eslint-disable */</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, component] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(<span class="hljs-title class_">ELIcons</span>)) &#123;    instance.<span class="hljs-title function_">component</span>(key, component);  &#125;  instance.<span class="hljs-title function_">mount</span>(container ? container.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#app&quot;</span>) : <span class="hljs-string">&quot;#app&quot;</span>);  <span class="hljs-comment">// eslint-disable-next-line no-underscore-dangle</span>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">__POWERED_BY_QIANKUN__</span>) &#123;    router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> matched = to.<span class="hljs-property">matched</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> &#123;          ...item,          <span class="hljs-attr">path</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;routerBase&#125;</span><span class="hljs-subst">$&#123;item.path&#125;</span>`</span>,          <span class="hljs-attr">redirect</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;routerBase&#125;</span><span class="hljs-subst">$&#123;item.path&#125;</span>`</span>,        &#125;;      &#125;)      props.<span class="hljs-property">mainStore</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&quot;app/getMicroBreadcrumb&quot;</span>, [        ...matched      ]);    &#125;);  &#125;  router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">async</span> (to, <span class="hljs-keyword">from</span>, next) =&gt; &#123;    <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">start</span>();    <span class="hljs-keyword">if</span> (store.<span class="hljs-property">getters</span>[<span class="hljs-string">&quot;user/isLogin&quot;</span>]) &#123;      <span class="hljs-title function_">next</span>();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (store.<span class="hljs-property">state</span>.<span class="hljs-property">app</span>.<span class="hljs-property">whiteList</span>.<span class="hljs-title function_">includes</span>(to.<span class="hljs-property">path</span>)) &#123;      <span class="hljs-comment">// 白名单页面</span>      <span class="hljs-title function_">next</span>();    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-title function_">next</span>(<span class="hljs-string">&quot;/login&quot;</span>); <span class="hljs-comment">// 全部重定向到登录页</span>    &#125;  &#125;);  router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> keepAliveComponentsName = store.<span class="hljs-property">getters</span>[<span class="hljs-string">&quot;keepAlive/keepAliveComponentsName&quot;</span>] || [];    <span class="hljs-keyword">const</span> &#123; name &#125; = to.<span class="hljs-property">matched</span>[to.<span class="hljs-property">matched</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>].<span class="hljs-property">components</span>.<span class="hljs-property">default</span>;    <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span> &amp;&amp; to.<span class="hljs-property">meta</span>.<span class="hljs-property">cache</span> &amp;&amp; name &amp;&amp; !keepAliveComponentsName.<span class="hljs-title function_">includes</span>(name)) &#123;      store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;keepAlive/addKeepAliveComponentsName&quot;</span>, name);    &#125;    <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>();  &#125;);&#125;<span class="hljs-comment">// eslint-disable-next-line no-underscore-dangle</span><span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-property">__POWERED_BY_QIANKUN__</span>) &#123;  <span class="hljs-title function_">render</span>(&#123; <span class="hljs-attr">container</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-attr">routerBase</span>: <span class="hljs-string">&quot;/micro-clouds&quot;</span> &#125;);&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bootstrap</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[vue] vue app bootstraped&#x27;</span>);&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mount</span>(<span class="hljs-params">props</span>) &#123;  <span class="hljs-comment">// 标记当前启动形式为微服务启动</span>  store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;app/microChange&quot;</span>, <span class="hljs-literal">true</span>);  <span class="hljs-keyword">await</span> <span class="hljs-title function_">render</span>(props);&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">unmount</span>(<span class="hljs-params"></span>) &#123;  instance.<span class="hljs-title function_">unmount</span>();&#125;public-path.<span class="hljs-property">js</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">__POWERED_BY_QIANKUN__</span>) &#123;    __webpack_public_path__ = <span class="hljs-variable language_">window</span>.<span class="hljs-property">__INJECTED_PUBLIC_PATH_BY_QIANKUN__</span>;  &#125;&#125;());vue.<span class="hljs-property">config</span>.<span class="hljs-property">js</span><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">publicPath</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;development&#x27;</span> ? <span class="hljs-string">&#x27;/&#x27;</span> : <span class="hljs-string">&#x27;/micro-clouds&#x27;</span>,  <span class="hljs-attr">configureWebpack</span>: &#123;    <span class="hljs-attr">output</span>: &#123;      <span class="hljs-attr">library</span>: <span class="hljs-string">&#x27;micro-clouds-[name]&#x27;</span>,      <span class="hljs-attr">libraryTarget</span>: <span class="hljs-string">&#x27;umd&#x27;</span>,      <span class="hljs-attr">jsonpFunction</span>: <span class="hljs-string">&#x27;webpackJsonp_[name]&#x27;</span>    &#125;,  &#125;,  <span class="hljs-attr">devServer</span>: &#123;    <span class="hljs-attr">port</span>: <span class="hljs-number">4003</span>,    <span class="hljs-attr">disableHostCheck</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">headers</span>: &#123;      <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-comment">// 主应用获取子应用时跨域响应头</span>    &#125;,    <span class="hljs-attr">proxy</span>: &#123;      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;        <span class="hljs-attr">target</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">VUE_APP_TEST</span>,        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">pathRewrite</span>: &#123;          <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>        &#125;      &#125;    &#125;  &#125;&#125;</code></pre></div><p>到这为止，一个完整的微前端架构就搭建好了，下面来介绍各个细节的交互是怎么处理的。</p><h4 id="2-父子应用耦合以及单独使用"><a href="#2-父子应用耦合以及单独使用" class="headerlink" title="2. 父子应用耦合以及单独使用"></a>2. 父子应用耦合以及单独使用</h4><p>简单讲就是为了满足更多更灵活的使用要求，咱们设计要能满足主应用与微应用耦合在一起使用，也可以子应用单独使用，不仅满足了用户的需求，还可以方便开发人员调试。（联调子应用时子应用一定是能独立启动的，并且有自己的登录、菜单功能，说白了就是一个完整的系统）</p><p>为了区分微前端运行还是单独运行，我们需要在子应用中插入微前端标识。</p><div class="code-wrapper"><pre><code class="hljs js"># 单独启动子应用时会通过这里来启动项目<span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">window</span>.<span class="hljs-property">__POWERED_BY_QIANKUN__</span>) &#123;  <span class="hljs-title function_">render</span>(&#123; <span class="hljs-attr">container</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-attr">routerBase</span>: <span class="hljs-string">&quot;/micro-clouds&quot;</span> &#125;);&#125;# 这是子应用中微前端的钩子函数，如果是通过微前端启动，就通过这里来启动项目<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mount</span>(<span class="hljs-params">props</span>) &#123;  <span class="hljs-comment">// 标记当前启动形式为微服务启动</span>  store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;app/microChange&quot;</span>, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// props是主应用传过来的参数</span>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">render</span>(props);&#125;</code></pre></div><p>区分好了之后，就需要将子应用中的菜单、头部状态栏隐藏，只留下内容区，连内容区周围的间隙都要去掉，因为主应用内容区也有间隙，避免样式冲突。</p><p><img src="/../imgs/%E5%BE%AE%E5%89%8D%E7%AB%AF/cd0fda56a473404986f7e1de0cc0e7f3tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="截屏2022-06-29 下午12.19.13.png"></p><h4 id="3-父子应用通信"><a href="#3-父子应用通信" class="headerlink" title="3. 父子应用通信"></a>3. 父子应用通信</h4><p>原则上应该尽可能得降低父子应用之间的耦合，以免子应用单独使用时无法正常运行，也会增加维护成本。但是像登录信息的传递是有必要的，父应用登录了将登录信息传到子应用，避免子应用检测到无登录状态跳转到登录页面。</p><div class="code-wrapper"><pre><code class="hljs js"># 主应用<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> microApps = [  &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;micro-clouds&#x27;</span>,    <span class="hljs-attr">entry</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">VUE_APP_CLOUDS</span>,    <span class="hljs-attr">activeRule</span>: <span class="hljs-string">&#x27;/micro-clouds&#x27;</span>,    <span class="hljs-attr">container</span>: <span class="hljs-string">&#x27;#subapp2&#x27;</span>, <span class="hljs-comment">// 子应用挂载的div</span>    <span class="hljs-attr">props</span>: &#123;      <span class="hljs-attr">routerBase</span>: <span class="hljs-string">&#x27;/micro-clouds&#x27;</span>,      <span class="hljs-comment">// 父应用的store传递给子应用</span>      <span class="hljs-attr">mainStore</span>: store,      <span class="hljs-comment">// 父应用传递给子应用的登录信息</span>      <span class="hljs-attr">user</span>: utils.<span class="hljs-title function_">getStorage</span>(<span class="hljs-string">&#x27;user&#x27;</span>)    &#125;  &#125;]# 子应用接受父应用传过来的登录信息并写入storage中<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mount</span>(<span class="hljs-params">props</span>) &#123;  <span class="hljs-comment">// 父级传过来的登录信息写进子系统缓存中</span>  utils.<span class="hljs-title function_">setStorage</span>(<span class="hljs-string">&quot;user&quot;</span>, props.<span class="hljs-property">user</span>);  <span class="hljs-comment">// 标记当前启动形式为微服务启动</span>  store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&quot;app/microChange&quot;</span>, <span class="hljs-literal">true</span>);  <span class="hljs-keyword">await</span> <span class="hljs-title function_">render</span>(props);&#125;</code></pre></div><h4 id="4-面包屑怎么融合父子应用中的路由"><a href="#4-面包屑怎么融合父子应用中的路由" class="headerlink" title="4. 面包屑怎么融合父子应用中的路由"></a>4. 面包屑怎么融合父子应用中的路由</h4><p>现在的后台应用基本都有面包屑要么就是有一个tabs标签栏，在非微前端应用中，是一个非常简单的问题，直接<code>to.matched</code>就能查找出当前的路由嵌套关系，面包屑遍历出来就OK。但是在微前端中怎么知道子应用中的路由嵌套关系，那么就涉及父子应用的通信，当子应用监听到路由变化时上报子应用的<code>to.match</code>给父应用。由于这里涉及到主子应用的<code>to.match</code>切换，当打开的是主应用的页面就用主应用的<code>to.match</code>，打开的是子应用的页面就用子应用的<code>to.match</code>，所以我这里统一用<code>vuex</code>来处理</p><div class="code-wrapper"><pre><code class="hljs js"># 主应用vuex<span class="hljs-keyword">const</span> actions = &#123;    <span class="hljs-comment">// 处理父应用的to.match</span>    <span class="hljs-title function_">getBreadcrumb</span>(<span class="hljs-params">&#123; commit &#125;, matched</span>) &#123;        <span class="hljs-keyword">const</span> levelList = matched.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> item.<span class="hljs-property">meta</span> &amp;&amp; item.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span> &amp;&amp; item.<span class="hljs-property">meta</span>.<span class="hljs-property">breadcrumb</span> !== <span class="hljs-literal">false</span>);        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setBreadcrumb&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(levelList)));    &#125;,    <span class="hljs-comment">// 处理微应用的to.match</span>    <span class="hljs-title function_">getMicroBreadcrumb</span>(<span class="hljs-params">&#123; commit &#125;, matchedList</span>) &#123;        <span class="hljs-keyword">const</span> microLevel = matchedList.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">ele</span>) =&gt;</span> ele.<span class="hljs-property">meta</span> &amp;&amp; ele.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span> &amp;&amp; ele.<span class="hljs-property">meta</span>.<span class="hljs-property">breadcrumb</span> !== <span class="hljs-literal">false</span>);        <span class="hljs-comment">/*</span><span class="hljs-comment">         * 为了解决这个告警采用 JSON.parse(JSON.stringify(microLevel))   vue3.0需要注意的地方</span><span class="hljs-comment">         * runtime-core.esm-bundler.js:198 [Vue warn]: Avoid app logic that relies on enumerating keys on a component instance.</span><span class="hljs-comment">         * The keys will be empty in production mode to avoid performance overhead.</span><span class="hljs-comment">         */</span>        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setMicroBreadcrumb&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(microLevel)));  &#125;&#125;# 主应用面包屑组件中<span class="hljs-keyword">const</span> <span class="hljs-title function_">getBreadcrumb</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;  <span class="hljs-comment">// 判断是微应用就去微应用上报的to.match</span>  <span class="hljs-keyword">if</span> (route.<span class="hljs-property">path</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/micro&#x27;</span>)) &#123;    <span class="hljs-comment">// 这里需要做一个vuex异步处理，否则取不到子应用上报的to.match</span>    store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (mutation.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;app/setMicroBreadcrumb&#x27;</span>) &#123;        levelList.<span class="hljs-property">value</span> = store.<span class="hljs-property">state</span>.<span class="hljs-property">app</span>.<span class="hljs-property">microBreadcrumbs</span>      &#125;    &#125;)  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">await</span> store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;app/getBreadcrumb&#x27;</span>, route.<span class="hljs-property">matched</span>)    levelList.<span class="hljs-property">value</span> = store.<span class="hljs-property">state</span>.<span class="hljs-property">app</span>.<span class="hljs-property">breadcrumbs</span>  &#125;&#125;# 子应用上报to.<span class="hljs-property">match</span>给父应用# 子应用main.<span class="hljs-property">js</span># 好好回想一下，在父应用中传递给子应用的props中就有一个<span class="hljs-string">`mainStore`</span>，这个就是父应用的store，可以直接在子应用中使用<span class="hljs-string">`props.mainStore.dispatch(&quot;app/getMicroBreadcrumb&quot;, [ ...matched ]);`</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">props = &#123;&#125;</span>) &#123;    ...    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">__POWERED_BY_QIANKUN__</span>) &#123;        router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to</span>) =&gt;</span> &#123;          <span class="hljs-comment">// 你可能发现这里为啥要改造`path、redirect`，路径前面拼接了一个`routerBase`</span>          <span class="hljs-comment">// 是因为在父应用中，如果子应用路由不带子应用的前缀标识路由是没法跳转进子应用页面的!!!</span>          <span class="hljs-keyword">const</span> matched = to.<span class="hljs-property">matched</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;            <span class="hljs-keyword">return</span> &#123;              ...item,              <span class="hljs-attr">path</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;routerBase&#125;</span><span class="hljs-subst">$&#123;item.path&#125;</span>`</span>,              <span class="hljs-attr">redirect</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;routerBase&#125;</span><span class="hljs-subst">$&#123;item.path&#125;</span>`</span>,            &#125;;          &#125;)          props.<span class="hljs-property">mainStore</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&quot;app/getMicroBreadcrumb&quot;</span>, [            ...matched          ]);        &#125;);    &#125;    ...&#125;</code></pre></div><p>到这里基本上配置完成了，后面是一些遇到的样式bug，一定要实践，光看可能效果不大</p><h4 id="5-父子应用中样式冲突的问题"><a href="#5-父子应用中样式冲突的问题" class="headerlink" title="5. 父子应用中样式冲突的问题"></a>5. 父子应用中样式冲突的问题</h4><p><img src="/../imgs/%E5%BE%AE%E5%89%8D%E7%AB%AF/523aefbbc2eb4185abacac1284dd32d3tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="截屏2022-06-29 下午2.45.44.png"></p><p>当在父应用打开子应用时出现样式问题，正常在<code>vue + element-plus</code>的项目中，是这么引组件的样式</p><p><img src="/../imgs/%E5%BE%AE%E5%89%8D%E7%AB%AF/a2ac96c03b4f4e26949d909e08a5d689tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="截屏2022-06-29 下午2.52.36.png"> 通过审查元素发现这个弹窗的dom节点的class样式少了一些属性，也就是光有class少了样式值，所以导致样式问题。目测是import引入样式的没法作用到子应用节点，改成在<code>public/index.html</code>通过link的方式引用</p><p><img src="/../imgs/%E5%BE%AE%E5%89%8D%E7%AB%AF/231d5ee6b248446d80b01d06621c2bbetplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="截屏2022-06-29 下午2.58.35.png"></p><p>成功解决样式问题，需要注意的是当遇到样式问题时可以从 引入方式、append-to-body属性（element-plus组件）着手排查。</p><p>配置完整个微前端架构，看似百八十行代码，其实遇到的问题还是蛮多的，跟撸个demo完全是两回事，网上可查的资料又少，官方文档只是介绍了那几个api的使用，干完这票确实提升不少，值得去尝试，我认为这是构架师必备技能。</p><h4 id="6-qiankun加载子应用的协议会转成http的问题"><a href="#6-qiankun加载子应用的协议会转成http的问题" class="headerlink" title="6. qiankun加载子应用的协议会转成http的问题"></a>6. qiankun加载子应用的协议会转成http的问题</h4><p>前面由于都是在本地以及测试环境验证过，因为都是http协议所以没有暴露出这个问题。当到沙盒以及生产环境时，子应用页面加载不出来，我也没有改动代码，测试和生产是同一份代码，一直报这个错误</p><p><img src="/../imgs/%E5%BE%AE%E5%89%8D%E7%AB%AF/5fa57a448c1f4606af23b4514cecdee8tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="截屏2022-07-19 下午6.18.03.png"></p><p>也就是主应用是 <code>https</code> 协议，子应用是<code>http</code>协议，导致了这个问题。现在问题清楚了，又有另外一个疑问，我的主应用指向子应用的路由是 <code>https</code> 啊，为什么被改成了 <code>http</code>，这个问题我不太清楚是不是<code>qiankun</code>这家伙干的，官方也没说。</p><p>解决办法：</p><p>public&#x2F;index.html 头部加上这个</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;upgrade-insecure-requests&quot;</span>&gt;</span></code></pre></div><p>如果是统一加上这个，测试环境和本地环境又不行了，得区分开发，怎么办？</p><p>我们都知道，打包后生成的<code>index.html</code>是由 <code>html-webpack-plugin</code> 插件生成的，沿着这条线索找，插件文档果然有<code>meta</code>这个配置项<a href="https://link.juejin.cn/?target=https://github.com/jantimon/html-webpack-plugin%23configuration">github.com&#x2F;jantimon&#x2F;ht…</a></p><p>那么在<code>vue-cli</code>生成的项目中没有单独使用<code>html-webpack-plugin</code>，而是在 <code>vue.config.js</code>里的pages入口这里配置，具体代码：</p><div class="code-wrapper"><pre><code class="hljs css">pages: &#123;    index: &#123;      entry: <span class="hljs-string">&#x27;src/main.js&#x27;</span>,      template: <span class="hljs-string">&#x27;public/index.html&#x27;</span>,      filename: <span class="hljs-string">&#x27;index.html&#x27;</span>,      title: <span class="hljs-string">&#x27;采贝中台&#x27;</span>,      meta: process.env.NODE_ENV === <span class="hljs-string">&#x27;development&#x27;</span> || process.env.NODE_ENV === <span class="hljs-string">&#x27;test&#x27;</span>      ? &#123;&#125;      : &#123;        &#x27;<span class="hljs-attribute">Content</span>-Security-Policy&#x27;: &#123; &#x27;http-equiv&#x27;: <span class="hljs-string">&#x27;Content-Security-Policy&#x27;</span>, content: <span class="hljs-string">&#x27;upgrade-insecure-requests&#x27;</span> &#125;      &#125;    &#125;&#125;,</code></pre></div><p>完美解决！</p><h3 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h3><p>部署方式很多种，我这里只介绍我在项目中的实践。</p><p><img src="/../imgs/%E5%BE%AE%E5%89%8D%E7%AB%AF/3e9100e7d27846afbb68b7525f1cd979tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="image.png"></p><p>主应用：<a href="https://link.juejin.cn/?target=http://main.xxx.com/home">main.xxx.com&#x2F;home</a><br>子应用A: <a href="https://link.juejin.cn/?target=http://clouds.xxx.com/projectA/home">clouds.xxx.com&#x2F;projectA&#x2F;ho…</a><br>子应用B: <a href="https://link.juejin.cn/?target=http://clouds.xxx.com/projectB/home">clouds.xxx.com&#x2F;projectB&#x2F;ho…</a><br>子应用C: <a href="https://link.juejin.cn/?target=http://clouds.xxx.com/projectC/home">clouds.xxx.com&#x2F;projectC&#x2F;ho…</a></p><p>现在的部署都流行CICD，docker + k8s，所以我采用的是每个项目都单独部署一个docker，最后通过 <code>域名 + 项目前缀</code>进入项目，nginx配置如下：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-comment"># 主应用</span><span class="hljs-section">location</span> / &#123;    <span class="hljs-attribute">root</span>      /usr/share/nginx/html;    <span class="hljs-attribute">index</span>     index.html;  <span class="hljs-comment"># 入口文件</span>    <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;&#125;<span class="hljs-comment"># 子应用</span><span class="hljs-section">location</span> /micro-projectA &#123;    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin *;    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&#x27;GET&#x27;</span>;    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;</span>;    <span class="hljs-attribute">alias</span>     /usr/share/nginx/html;    <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /micro-projectA/index.html;&#125;<span class="hljs-section">location</span> / &#123;    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin *;    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&#x27;GET&#x27;</span>;    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;</span>;    <span class="hljs-attribute">root</span> /usr/share/nginx/html;    <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;&#125;</code></pre></div><p>具体阿里云云效流水线搭建、部署、域名、负载均衡等相关的操作可以翻开我其他文章来看</p><p><a href="https://juejin.cn/post/7034419195639136269">记一次gitlab仓库迁移阿里云云效以及相关的流水线改造全过程</a><br><a href="https://juejin.cn/post/7023635481225068580">来屡屡前端包部署以及nginx配置</a></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="https://link.juejin.cn/?target=https://gitee.com/spring_zou/vue-qiankun">gitee.com&#x2F;spring_zou&#x2F;…</a></p><p>分类：</p><p><a href="https://juejin.cn/frontend">前端</a></p><p>标签：</p><p><a href="https://juejin.cn/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1">微服务</a><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>微前端</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件循环机制</title>
    <link href="/2023/01/29/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/01/29/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="深入理解js事件循环机制"><a href="#深入理解js事件循环机制" class="headerlink" title="深入理解js事件循环机制"></a>深入理解js事件循环机制</h1><h3 id="同步任务和异步任务（微任务和宏任务）"><a href="#同步任务和异步任务（微任务和宏任务）" class="headerlink" title="同步任务和异步任务（微任务和宏任务）"></a>同步任务和异步任务（微任务和宏任务）</h3><p><strong>JavaScript是一门单线程语言</strong></p><p><strong>分为同步任务和异步任务</strong></p><p><strong>同步任务</strong>是指在主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。</p><p><strong>异步任务</strong>指的是，不进入主线程、而进入”任务队列”的任务；只有等主线程任务全部执行完毕，”任务队列”的任务才会进入主线程执行。</p><p><strong>异步任务</strong>分为宏任务和微任务</p><p>new promise()、console.log()属于同步任务</p><table><thead><tr><th></th><th>宏任务（macrotask）</th><th>微任务（microtask）</th></tr></thead><tbody><tr><td>谁发起的</td><td>宿主（Node、浏览器）</td><td>JS引擎</td></tr><tr><td>具体事件</td><td>1. script (可以理解为外层同步代码) 2. setTimeout&#x2F;setInterval 3. UI rendering&#x2F;UI事件 4. postMessage，MessageChannel 5. setImmediate，I&#x2F;O（Node.js）</td><td>1. Promise 2. MutaionObserver 3. Object.observe（已废弃；Proxy 对象替代） 4. process.nextTick（Node.js）</td></tr><tr><td>谁先运行</td><td>后运行</td><td>先运行</td></tr><tr><td>会触发新一轮Tick吗</td><td>会</td><td>不会</td></tr></tbody></table><p><img src="/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6.assets/f12b37f78c7444cd81302963b816d813tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="img"></p><h3 id="执行过程-同步任务-—-gt-微任务-—-gt-宏任务"><a href="#执行过程-同步任务-—-gt-微任务-—-gt-宏任务" class="headerlink" title="执行过程: 同步任务 —&gt; 微任务 —&gt; 宏任务"></a>执行过程: 同步任务 —&gt; 微任务 —&gt; 宏任务</h3><ol><li>先执行所有同步任务，碰到异步任务放到任务队列中</li><li>同步任务执行完毕，开始执行当前所有的异步任务</li><li>先执行任务队列里面所有的微任务</li><li>然后执行一个宏任务</li><li>然后再执行所有的微任务</li><li>再执行一个宏任务，再执行所有的微任务·······依次类推到执行结束。</li></ol><p>3-6的这个循环称为事件循环Event Loop</p><p>事件循环是JavaScript实现异步的一种方法，也是JavaScript的执行机制</p><h2 id="async-x2F-await-（重点）"><a href="#async-x2F-await-（重点）" class="headerlink" title="async&#x2F;await （重点）"></a>async&#x2F;await （重点）</h2><h4 id="async-x2F-await-底层依然是-Promise，所以是微任务，只是-await-比较特殊。"><a href="#async-x2F-await-底层依然是-Promise，所以是微任务，只是-await-比较特殊。" class="headerlink" title="async&#x2F;await 底层依然是 Promise，所以是微任务，只是 await 比较特殊。"></a>async&#x2F;await 底层依然是 Promise，所以是微任务，只是 await 比较特殊。</h4><p><strong>async</strong></p><p>当我们在函数前使用async的时候，使得该函数返回的是一个Promise对象</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>   <span class="hljs-comment">// async的函数会在这里帮我们隐士使用Promise.resolve(1)</span>&#125;<span class="hljs-comment">// 等价于下面的代码</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)   &#125;)&#125;<span class="hljs-comment">// 可见async只是一个语法糖，只是帮助我们返回一个Promise而已</span></code></pre></div><p><strong>await</strong></p><p>await表示等待，是右侧「表达式」的结果，这个表达式的计算结果可以是 Promise 对象的值或者一个函数的值（换句话说，就是没有特殊限定）。并且只能在带有async的内部使用</p><p>使用await时，会从右往左执行，当遇到await时， ★★★★★会阻塞函数内部处于它后面的代码，去执行该函数外部的同步代码，当外部同步代码执行完毕，再回到该函数内部执行剩余的代码★★★★★, 并且当await执行完毕之后，会先处理微任务队列的代码</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);    <span class="hljs-comment">//2</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>);    &#125;)    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>);        <span class="hljs-title function_">resolve</span>();    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;5&#x27;</span>)    &#125;)&#125;)<span class="hljs-comment">//3</span>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;6&#x27;</span>);&#125;)<span class="hljs-comment">//4</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;7&#x27;</span>);    <span class="hljs-title function_">resolve</span>();&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;8&#x27;</span>)&#125;)<span class="hljs-comment">//5</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;9&#x27;</span>);    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;10&#x27;</span>);    &#125;)    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;11&#x27;</span>);        <span class="hljs-title function_">resolve</span>();    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;12&#x27;</span>)    &#125;)&#125;)<span class="hljs-comment">// 先执行1 输出1</span><span class="hljs-comment">// 执行到2，把setTimeout放入异步的任务队列中（宏任务）</span><span class="hljs-comment">// 执行到3，把process.nextTick放入异步任务队列中（微任务）</span><span class="hljs-comment">// 执行到4，上面提到promise里面是同步任务，所以输出7，再将then放入异步任务队列中（微任务）</span><span class="hljs-comment">// 执行到5，同2</span><span class="hljs-comment">// 上面的同步任务全部完成，开始进行异步任务</span><span class="hljs-comment">// 先执行微任务，发现里面有两个微任务，分别是3，4压入的，所以输出6 8</span><span class="hljs-comment">// 再执行一个宏任务，也就是第一个setTimeout</span><span class="hljs-comment">// 先输出2，把process.nextTick放入微任务中，再如上promise先输出4，再将then放入微任务中</span><span class="hljs-comment">// 再执行所以微任务输出输出3 5</span><span class="hljs-comment">// 同样的，再执行一个宏任务setTImeout2，输出9 11 在执行微任务输出10 12</span><span class="hljs-comment">// 所以最好的顺序为：1 7 6 8 2 4 3 5 9 11 10 12</span>复制代码<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;async1 start&#x27;</span> )    <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>()    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;async1 end&#x27;</span> )&#125;<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;async2&#x27;</span> )&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;script start&#x27;</span> )<span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;setTimeout&#x27;</span> )&#125;, <span class="hljs-number">0</span> )<span class="hljs-title function_">async1</span>();<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params"> resolve </span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;promise1&#x27;</span> )    <span class="hljs-title function_">resolve</span>();&#125; ).<span class="hljs-title function_">then</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;promise2&#x27;</span> )&#125; )<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&#x27;script end&#x27;</span> )<span class="hljs-comment">// 首先执行同步代码，console.log( &#x27;script start&#x27; )</span><span class="hljs-comment">// 遇到setTimeout,会被推入宏任务队列</span><span class="hljs-comment">// 执行async1(), 它也是同步的，只是返回值是Promise，在内部首先执行console.log( &#x27;async1 start&#x27; )</span><span class="hljs-comment">// 然后执行async2(), 然后会打印console.log( &#x27;async2&#x27; )</span><span class="hljs-comment">// 从右到左会执行, 当遇到await的时候，阻塞后面的代码，去外部执行同步代码</span><span class="hljs-comment">// 进入new Promise,打印console.log( &#x27;promise1&#x27; )</span><span class="hljs-comment">// 将.then放入事件循环的微任务队列</span><span class="hljs-comment">// 继续执行，打印console.log( &#x27;script end&#x27; )</span><span class="hljs-comment">// 外部同步代码执行完毕，接着回到async1()内部, 继续执行 await async2() 后面的代码，执行 console.log( &#x27;async1 end&#x27; ) ，所以打印出 async1 end 。（个人理解：async/await本质上也是Promise，也是属于微任务的，所以当遇到await的时候，await后面的代码被阻塞了，应该也是被放到微任务队列了，当同步代码执行完毕之后，然后去执行微任务队列的代码，执行微任务队列的代码的时候，也是按照被压入微任务队列的顺序执行的）</span><span class="hljs-comment">// 执行微任务队列的代码, 打印 console.log( &#x27;promise2&#x27; )</span><span class="hljs-comment">// 进入第二次事件循环，执行宏任务队列, 打印console.log( &#x27;setTimeout&#x27; )</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 执行结果为：</span><span class="hljs-comment"> * script start</span><span class="hljs-comment"> * async1 start</span><span class="hljs-comment"> * async2</span><span class="hljs-comment"> * promise1</span><span class="hljs-comment"> * script end</span><span class="hljs-comment"> * async1 end</span><span class="hljs-comment"> * promise2</span><span class="hljs-comment"> * setTimeout</span><span class="hljs-comment"> */</span>复制代码<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;        <span class="hljs-title function_">resolve</span>();    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;XXX&quot;</span>)    &#125;)    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)&#125;<span class="hljs-title function_">fn</span>();<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>)    <span class="hljs-title function_">resolve</span>();&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>)<span class="hljs-comment">// 执行结果为：1 2 3 6 8 XXX 4 7</span><span class="hljs-comment">/*</span><span class="hljs-comment">前面的 1 2 3 6 8 不再解析，重点是后面的 XXX 4 7，由此可见 await console.log(3) 之后的代码 console.log(4) 是被放入到微任务队列了，</span><span class="hljs-comment">代码 console.log(&quot;XXX&quot;) 也是被压入微任务队列了，console.log(&quot;XXX&quot;)  是在 console.log(4) 之前，</span><span class="hljs-comment">所以当同步任务执行完毕之后，执行微任务队列代码的时候，优先打印出来的是 XXX ，然后才是 4 。</span><span class="hljs-comment">*/</span>复制代码<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;await之后的：&quot;</span>,<span class="hljs-number">11</span>)    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;await之后的：&quot;</span>,<span class="hljs-number">22</span>)    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;await之后的：&quot;</span>,<span class="hljs-number">33</span>)    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;await之后的：&quot;</span>,<span class="hljs-number">44</span>)&#125;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)&#125;,<span class="hljs-number">0</span>)<span class="hljs-title function_">fn</span>();<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>)    <span class="hljs-title function_">resolve</span>();&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>)<span class="hljs-comment">/**</span><span class="hljs-comment"> * 执行结果为：</span><span class="hljs-comment"> * 1</span><span class="hljs-comment"> * 2</span><span class="hljs-comment"> * 3</span><span class="hljs-comment"> * 6</span><span class="hljs-comment"> * 8</span><span class="hljs-comment"> * 4</span><span class="hljs-comment"> * 7</span><span class="hljs-comment"> * await之后的： 11</span><span class="hljs-comment"> * await之后的： 22</span><span class="hljs-comment"> * await之后的： 33</span><span class="hljs-comment"> * await之后的： 44</span><span class="hljs-comment"> * 5</span><span class="hljs-comment"> */</span><span class="hljs-comment">/*</span><span class="hljs-comment">由此可见，代码执行的时候，只要碰见 await ，都会执行完当前的 await 之后，</span><span class="hljs-comment">把 await 后面的代码放到微任务队列里面。但是定时器里面的 5 是最后打印出来的，</span><span class="hljs-comment">可见当不断碰见 await ，把 await 之后的代码不断的放到微任务队列里面的时候，</span><span class="hljs-comment">代码执行顺序是会把微任务队列执行完毕，才会去执行宏任务队列里面的代码。</span><span class="hljs-comment">*/</span>复制代码<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">0</span>);  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">4</span>)   <span class="hljs-comment">// 顺延2位  如果是return 4 则打印 0、1、4、2、3、5、6、7</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)) <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>);&#125;)<span class="hljs-comment">/*</span><span class="hljs-comment">此题主要注意的是原生的Promise的then方法中，如果返回的是一个普通值，则返回的值会被立即调用并赋值给resolve函数，</span><span class="hljs-comment">如果返回的是一个thenable，则then方法将会被放入到微队列中执行，</span><span class="hljs-comment">如果返回的是一个Promise.resolve，则会再加一次微任务队列。</span><span class="hljs-comment">即微任务后移，Promise.resolve本身是执行then方法，而then方法本身是在微任务队列中执行，</span><span class="hljs-comment">同时return Promise.resolve时是将resolve调用的返回值 作为上级then中resolve的参数传递，</span><span class="hljs-comment">调用外层then方法时本身是在微队列里面，所以函数的执行顺序是要在微队列中下移两次。</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span>复制代码</code></pre></div><h3 id="根据w3c的最新解释"><a href="#根据w3c的最新解释" class="headerlink" title="根据w3c的最新解释"></a>根据w3c的最新解释</h3><ul><li>每个任务都有一个任务类型 , 同一个类型的任务必须在一个队列也就是一共有多个队列 , 不同类型的任务可以分属不同的队列,在一个次事件循环中,浏览器可以根据实际情况从不同的队列中区出任务执行</li><li>浏览器必须准备好一个微队列 , 微队列中的任务优先所有其他任务执行他里面的东西 所有都要给我等 连绘制任务 都要等 就是最高优先级了</li></ul><p>随着浏览器的复杂度急剧提升 W3C不再使用宏队列的说法</p><p><strong>在目前chrome的实现中 至少包含了下面的队列</strong></p><ul><li>延时队列 : 用于存放计时器到达后的回调任务 , 优先级中</li><li>交互列队 : 用于存放用户操作后产生的事件处理任务 , 优先级高</li><li>微队列 : 用户存放需要最快执行的任务 优先级最高</li></ul><p>添加任务到微队列的主要方式主要是使用 Promise、MutationObserver</p><div class="code-wrapper"><pre><code class="hljs scss">例如：<span class="hljs-comment">// 立即把一个函数添加到微队列</span>Promise<span class="hljs-selector-class">.resolve</span>()<span class="hljs-selector-class">.then</span>(函数)复制代码</code></pre></div><p><strong>任务有优先级吗？</strong></p><ul><li>任务没有优先级，在消息队列中先进先出</li><li>但<strong>消息队列是有优先级的</strong></li></ul><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">// 立刻把一个函数添加到微队列 最高执行</span>promise<span class="hljs-selector-class">.resolve</span>()<span class="hljs-selector-class">.then</span>(函数)<span class="hljs-built_in">setTimeOut</span>(()=&gt;&#123; <span class="hljs-comment">// 第三步执行延时队列中的任务</span>  console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">1</span>);&#125;,<span class="hljs-number">0</span>)promise<span class="hljs-selector-class">.resolve</span>()<span class="hljs-selector-class">.then</span>(()=&gt;&#123; <span class="hljs-comment">// 第二步执行微队列中的任务</span>  console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">2</span>);&#125;)console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 第一步先执行全局js</span><span class="hljs-comment">// 3 2 1</span>复制代码</code></pre></div><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h3 id="1、如何理解-JS-的异步？"><a href="#1、如何理解-JS-的异步？" class="headerlink" title="1、如何理解 JS 的异步？"></a>1、如何理解 JS 的异步？</h3><p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p><p>而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p><p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p><p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p><p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p><h3 id="2、-阐述一下js的事件循环"><a href="#2、-阐述一下js的事件循环" class="headerlink" title="2、 阐述一下js的事件循环"></a>2、 阐述一下js的事件循环</h3><p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p><p>在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p><p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p><p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p><h3 id="3、JS-中的计时器能做到精确计时吗？为什么？"><a href="#3、JS-中的计时器能做到精确计时吗？为什么？" class="headerlink" title="3、JS 中的计时器能做到精确计时吗？为什么？"></a>3、JS 中的计时器能做到精确计时吗？为什么？</h3><p>不行，因为：</p><ol><li>计算机硬件没有原子钟，无法做到精确计时</li><li>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li><li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差</li><li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>事件循环</tag>
      
      <tag>宏任务</tag>
      
      <tag>微任务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试总结-浏览器原理</title>
    <link href="/2023/01/29/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/"/>
    <url>/2023/01/29/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="面试总结————浏览器原理篇"><a href="#面试总结————浏览器原理篇" class="headerlink" title="面试总结————浏览器原理篇"></a>面试总结————浏览器原理篇</h1><h1 id="一、HTTP"><a href="#一、HTTP" class="headerlink" title="一、HTTP"></a>一、HTTP</h1><h2 id="1-GET和POST的请求的区别"><a href="#1-GET和POST的请求的区别" class="headerlink" title="1. GET和POST的请求的区别"></a>1. GET和POST的请求的区别</h2><p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p><ul><li><strong>应用场景：</strong> (GET 请求是一个<strong>幂等</strong>的请求)一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。(而 Post 不是一个<strong>幂等</strong>的请求)一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。（<strong>幂等是指一个请求方法执行多次和仅执行一次的效果完全相同</strong>）</li><li><strong>是否缓存：</strong> 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li><li><strong>传参方式不同：</strong> Get 通过查询字符串传参，Post 通过请求体传参。</li><li><strong>安全性：</strong> Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。</li><li><strong>请求长度：</strong> 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</li><li><strong>参数类型：</strong> get参数只允许ASCII字符，post 的参数传递支持更多的数据类型(如文件、图片)。</li></ul><h2 id="2-POST和PUT请求的区别"><a href="#2-POST和PUT请求的区别" class="headerlink" title="2. POST和PUT请求的区别"></a>2. POST和PUT请求的区别</h2><p>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时<strong>更新数据</strong>）</p><p>POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是<strong>创建数据</strong>）</p><h3 id="为什么post请求会发送两次请求"><a href="#为什么post请求会发送两次请求" class="headerlink" title="为什么post请求会发送两次请求?"></a>为什么post请求会发送两次请求?</h3><ul><li>1.第一次请求为<code>options</code>预检请求，状态码为:204<ul><li>作用：<ul><li>作用1: 询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求</li><li>作用2: 检测服务器是否为同源请求,是否支持跨域</li></ul></li></ul></li><li>2.第二次为真正的<code>post</code>请求</li></ul><h2 id="3-常见的HTTP请求头和响应头"><a href="#3-常见的HTTP请求头和响应头" class="headerlink" title="3. 常见的HTTP请求头和响应头"></a>3. 常见的HTTP请求头和响应头</h2><h3 id="HTTP-Request-Header"><a href="#HTTP-Request-Header" class="headerlink" title="HTTP Request Header"></a>HTTP Request Header</h3><ul><li>Accept:浏览器能够处理的内容类型</li><li>Accept-Charset:浏览器能够显示的字符集</li><li>Accept-Encoding：浏览器能够处理的压缩编码</li><li>Accept-Language：浏览器当前设置的语言</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cookie：当前页面设置的任何Cookie</li><li>Host：发出请求的页面所在的域</li><li>Referer：发出请求的页面的URL</li><li>User-Agent：浏览器的用户代理字符串</li></ul><h3 id="HTTP-Responses-Header"><a href="#HTTP-Responses-Header" class="headerlink" title="HTTP Responses Header"></a>HTTP Responses Header</h3><ul><li>Date：表示消息发送的时间，时间的描述格式由rfc822定义</li><li>server:服务器名称</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cache-Control：控制HTTP缓存</li><li>content-type:表示后面的文档属于什么MIME类型</li></ul><h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><p><strong>常见的 Content-Type 属性值有以下四种：</strong></p><p>（1）<code>application/x-www-form-urlencoded</code>：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1&#x3D;val1&amp;key2&#x3D;val2 的方式进行编码，key 和 val 都进行了 URL转码。</p><p>（2）<code>multipart/form-data</code>：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p><p>（3）<code>application/json</code>：服务器消息主体是序列化后的 JSON 字符串。</p><p>（4）<code>text/xml</code>：该种方式主要用来提交 XML 格式的数据。</p><h2 id="4-HTTP状态码304是多好还是少好"><a href="#4-HTTP状态码304是多好还是少好" class="headerlink" title="4. HTTP状态码304是多好还是少好"></a>4. HTTP状态码304是多好还是少好</h2><p><strong>为什么会有304</strong></p><p>服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。</p><p>状态码304不应该认为是一种错误，而是对客户端<strong>有缓存情况下</strong>服务端的一种响应。</p><p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。</p><p><strong>产生较多304状态码的原因：</strong></p><ul><li>页面更新周期长或不更新</li><li>纯静态页面或强制生成静态html</li></ul><p><strong>304状态码出现过多会造成以下问题：</strong></p><ul><li>网站快照停止；</li><li>收录减少；</li><li>权重下降。</li></ul><h2 id="5-常见的HTTP请求方法"><a href="#5-常见的HTTP请求方法" class="headerlink" title="5. 常见的HTTP请求方法"></a>5. 常见的HTTP请求方法</h2><ul><li><code>GET</code>: 向服务器获取数据；</li><li><code>POST</code>：发送数据给服务器，通常会造成服务器资源的新增修改；</li><li><code>PUT</code>：用于全量修改目标资源(看接口，也可以用于添加)；</li><li><code>PATCH</code>：用于对资源进行部分修改</li><li><code>DELETE</code>：用于删除指定的资源；</li><li><code>HEAD</code>：获取报文首部，与GET相比，不返回报文主体部分；使用场景是比如下载一个大文件前，先获取其大小再决定是否要下载，以此可以节约宽带资源</li><li><code>OPTIONS</code>：(浏览器自动执行)、询问支持的请求方法，用来跨域请求、预检请求、判断目标是否安全；</li><li><code>CONNECT</code>：要求在与代理服务器通信时建立<strong>管道</strong>，使用<strong>管道</strong>进行TCP通信；(把服务器作为跳板，让服务器代替用户去访问其他网页，之后把数据原原本本的返回给用户)</li><li><code>TRACE</code>: 该方法会让服务器原样返回任意客户端请求的信息内容，主要⽤于测试或诊断。</li></ul><h2 id="6-说说Ajax组成部分"><a href="#6-说说Ajax组成部分" class="headerlink" title="6. 说说Ajax组成部分"></a>6. 说说Ajax组成部分</h2><p>Ajax(阿贾克斯)：全称 <code>Asynchronous Javascript And XML(异步的js与xml)</code></p><ul><li>说人话： <strong>用js发送异步的网络请求</strong></li><li>A : Asynchronous 异步</li><li>J：Javascript</li><li>A ：And</li><li>X : XML 与 XMLHttpRequest<ul><li>XML ： 解决跨平台数据传输。<ul><li>在JSON没有出来以前, 网络传输主要以XML格式数据为主。 后来JSON问世，逐渐取代XML。 但是由于ajax技术出来的比json早，因此xml这个称呼一直保留至今</li></ul></li></ul></li></ul><h2 id="7-请介绍一下XMLHTTPRequest对象"><a href="#7-请介绍一下XMLHTTPRequest对象" class="headerlink" title="7. 请介绍一下XMLHTTPRequest对象"></a>7. 请介绍一下XMLHTTPRequest对象</h2><p><strong>Ajax的核心是XMLHTTPRequest</strong>。它是一种支持异步请求的技术。 XMLHTTPRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。可以在页面加载以后进行页面的局部更新</p><p><strong>使用方法</strong></p><p><strong>1.实例化ajax对象</strong></p><p><strong>2. open()</strong> ：创建HTTP请求 第一个参数是指定提交方式(post、get) 第二个参数是指定要提交的地址是哪 第三个参数是指定是异步还是同步(true表示异步，false表示同步) 第四和第五参数在HTTP认证的时候会用到。是可选的</p><p><strong>3.设置请求头</strong></p><p><strong>setRequestHeader</strong>(Stringheader,Stringvalue) <strong>（使用post方式才会使用到，get方法并不需要调用该方法）</strong></p><p><strong>4.发送请求</strong></p><p><strong>send(content)</strong> ：发送请求给服务器 如果是get方式，并不需要填写参数，或填写null 如果是post方式，把要提交的参数写上去</p><p><strong>5. 注册回调函数</strong></p><div class="code-wrapper"><pre><code class="hljs javascript"> <span class="hljs-comment">/* 1.ajax： 在页面不刷新的情况下向服务器请求数据</span><span class="hljs-comment">           2.XMLHttpRequest ： http请求对象，负责实现ajax技术（小黄人）</span><span class="hljs-comment">                （1）创建XMLHttpRequest对象</span><span class="hljs-comment">                        * 小黄人，相当于黄袍加身的跑腿外卖小哥哥</span><span class="hljs-comment">                （2）设置请求</span><span class="hljs-comment">                        * 告诉小黄人服务器地址</span><span class="hljs-comment">                （3）发送请求</span><span class="hljs-comment">                        * 小黄人出发去指定地址取外卖（数据）</span><span class="hljs-comment">                            * 2G网速：走路去的</span><span class="hljs-comment">                            * 3G网速：骑膜拜去的</span><span class="hljs-comment">                            * WIFI : 骑电动车去的</span><span class="hljs-comment">                            * 4G   ： 骑小牛牌电动车去的</span><span class="hljs-comment">                （4）注册回调函数</span><span class="hljs-comment">                        * 小黄人把取回的外卖送到你家门口</span><span class="hljs-comment">        </span><span class="hljs-comment">         */</span><span class="hljs-comment">//(1).实例化ajax对象</span>      <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()      <span class="hljs-comment">//(2).设置请求方法和地址</span>      xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;http://www.liulongbin.top:3009/api/login&quot;</span>)      <span class="hljs-comment">//(3).设置请求头（post请求才需要设置）</span>      xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>)      <span class="hljs-comment">//(4).发送请求 ： 参数格式  &#x27;key=value&#x27;</span>      xhr.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;username=admin&amp;password=123456&quot;</span>)      <span class="hljs-comment">//(5).注册回调函数</span>      <span class="hljs-comment">// xhr.onload = function() &#123;&#125;;</span>      xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">//onreadystatechange会触发多次，一般需要判断xhr.readState == 4 才获取响应数据</span>        <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>) &#123;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)        &#125;      &#125;</code></pre></div><h3 id="7-2-onreadstatechange事件"><a href="#7-2-onreadstatechange事件" class="headerlink" title="7.2. onreadstatechange事件"></a>7.2. onreadstatechange事件</h3><div class="code-wrapper"><pre><code class="hljs javascript">*/ <span class="hljs-number">1.</span> onload事件 ：  接收服务器响应的数（一次请求，只会执行一次）  */      <span class="hljs-number">2.</span> onreadystatechang事件 : 作用与onload事件一致（一次请求，会执行多次）  */          面试点： <span class="hljs-title class_">XMLHttpRequest</span>对象的状态码 （xhr.<span class="hljs-property">readyState</span>）   */             <span class="hljs-number">0</span>: 请求未建立  (创建了xhr对象，但是还没调用open)   */             <span class="hljs-number">1</span>: 服务器连接已建立    */             <span class="hljs-number">2.</span> 请求已接收  (send之后,服务器已经接收了请求)   */             <span class="hljs-number">3.</span> 请求处理中    */             <span class="hljs-number">4.</span> 请求已完成，且响应已就绪 （ <span class="hljs-number">4</span>状态码等同于onload事件 ）              <span class="hljs-comment">//(1).实例化ajax对象</span>      <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">readyState</span>) <span class="hljs-comment">//0</span>      <span class="hljs-comment">//(2).设置请求方法和地址</span>      xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;http://www.liulongbin.top:3009/api/login&quot;</span>)        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">readyState</span>) <span class="hljs-comment">//1</span>      <span class="hljs-comment">//(3).设置请求头（post请求才需要设置）</span>      xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>)      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">readyState</span>) <span class="hljs-comment">//1</span>      <span class="hljs-comment">//(4).发送请求 ： 参数格式  &#x27;key=value&#x27;</span>      xhr.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;username=admin&amp;password=123456&quot;</span>)        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">readyState</span>) <span class="hljs-comment">//1</span>      <span class="hljs-comment">//(5).注册回调函数</span>      <span class="hljs-comment">//a. onload 是新式浏览器才支持的</span>      <span class="hljs-comment">//b. 如果要兼容更早的浏览器，可以使用 onreadystatechange</span>      <span class="hljs-comment">//c. onreadystatechange触发时机 ： xhr.readState状态变化</span>      <span class="hljs-comment">// xhr.onload = function() &#123;&#125;;</span>      xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">readyState</span>) <span class="hljs-comment">//2,3,4</span>        <span class="hljs-comment">//onreadystatechange会触发多次，一般需要判断xhr.readState == 4 才获取响应数据</span>        <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>) &#123;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)        &#125;      &#125;</code></pre></div><h3 id="7-3-如何上传文件（上传图片）"><a href="#7-3-如何上传文件（上传图片）" class="headerlink" title="7.3 如何上传文件（上传图片）"></a>7.3 如何上传文件（上传图片）</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/*文件上传思路总结 </span><span class="hljs-comment">   1. 给file表单注册onchange事件 </span><span class="hljs-comment">     * 当用户选择图片之后执行</span><span class="hljs-comment">   2. 获取用户选择的图片 </span><span class="hljs-comment">     * this.files[0]</span><span class="hljs-comment">   3. 创建FormData对象 </span><span class="hljs-comment">     * 只有FormData才可以上传文件</span><span class="hljs-comment">   4. 将图片添加到FormData对象中 </span><span class="hljs-comment">     * fd.append(&#x27;参数名&#x27;, this.files[0])</span><span class="hljs-comment">   5. 发送ajax请求</span><span class="hljs-comment">     * 文件上传请求方法一定是post, 且请求参数为 FormData对象</span><span class="hljs-comment">   */</span>     <span class="hljs-comment">//1. file类型表单自带一个选择文件点击按钮，当用户选择文件之后就会触发onchange事件</span>   <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#iptFile&quot;</span>).<span class="hljs-property">onchange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-comment">//this : file表单</span>     <span class="hljs-comment">//(1)获取用户选择的文件</span>     <span class="hljs-keyword">let</span> file = <span class="hljs-variable language_">this</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]     <span class="hljs-comment">// 非空判断，如果内容为undefined，给出提示</span>     <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">undefined</span>) &#123;       <span class="hljs-keyword">return</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;请选择上传文件！&quot;</span>)     &#125;     <span class="hljs-comment">//(2)创建FormData对象， 只有FormData对象才可以上传文件</span>     <span class="hljs-keyword">let</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()     <span class="hljs-comment">//(3)添加文件</span>     fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;avatar&quot;</span>, file)     <span class="hljs-comment">//(4)发送ajax请求, 参数为 FormData对象</span>     <span class="hljs-title function_">axios</span>(&#123;       <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,       <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://www.liulongbin.top:3009/api/upload/avatar&quot;</span>,       <span class="hljs-attr">data</span>: fd     &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123; data: res &#125;</span>) =&gt;</span> &#123;       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)       <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> != <span class="hljs-number">200</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-title function_">alert</span>(res.<span class="hljs-property">message</span>)       &#125;       <span class="hljs-comment">// 成功后提示，修改图片路径</span>       <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;恭喜您，上传头像成功！&quot;</span>)       <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;img&quot;</span>).<span class="hljs-property">src</span> = <span class="hljs-string">`http://www.liulongbin.top:3009<span class="hljs-subst">$&#123;res.url&#125;</span>`</span>     &#125;)   &#125;</code></pre></div><h3 id="7-4-如何自定义上传文件按钮"><a href="#7-4-如何自定义上传文件按钮" class="headerlink" title="7.4 如何自定义上传文件按钮"></a>7.4 如何自定义上传文件按钮</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/*自定义文件上传按钮思路</span><span class="hljs-comment">  (1)隐藏file表单</span><span class="hljs-comment">  (2)给自定义按钮添加一个点击事件</span><span class="hljs-comment">  (3)点击按钮的时候，触发 file表单的点击 </span><span class="hljs-comment">   */</span><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#btnChoose&#x27;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-comment">/* </span><span class="hljs-comment">    dom对象.onclick()  :  只能触发你自己注册的onclick事件，没注册触发不了</span><span class="hljs-comment">    dom对象.click() : 模拟鼠标点击。 触发注册的onclick事件 + 默认点击事件</span><span class="hljs-comment">    */</span>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#iptFile&#x27;</span>).<span class="hljs-title function_">click</span>()&#125;</code></pre></div><h3 id="7-5-ajax请求如何取消"><a href="#7-5-ajax请求如何取消" class="headerlink" title="7.5 ajax请求如何取消"></a>7.5 ajax请求如何取消</h3><p><strong>1. 原生xhr取消请求</strong></p><div class="code-wrapper"><pre><code class="hljs ini">var <span class="hljs-attr">xhr</span> = new XMLHttpRequest()<span class="hljs-comment">;</span>xhr.abort()<span class="hljs-comment">;</span></code></pre></div><p><strong>2.axios取消请求</strong></p><p><strong>1.使用 CancelToken.source 工厂方法创建 cancel token</strong></p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CancelToken</span> = axios.CancelToken;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">source</span> = CancelToken.<span class="hljs-title function_ invoke__">source</span>();axios.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&#x27;/user/123&#x27;</span>, &#123;    <span class="hljs-attr">cancelToken</span>: source.token&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thrown</span>) </span>&#123;    <span class="hljs-keyword">if</span> (axios.<span class="hljs-title function_ invoke__">isCancel</span>(thrown)) &#123;        console.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">&#x27;Request canceled&#x27;</span>, thrown.message);    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 处理错误</span>    &#125;&#125;);axios.<span class="hljs-title function_ invoke__">post</span>(<span class="hljs-string">&#x27;/user/123&#x27;</span>, &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>&#125;, &#123;    <span class="hljs-attr">cancelToken</span>: source.token&#125;)<span class="hljs-comment">// 取消请求（message 参数是可选的）</span>source.<span class="hljs-title function_ invoke__">cancel</span>(<span class="hljs-string">&#x27;canceled by the user.&#x27;</span>);</code></pre></div><p><strong>2.传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token</strong></p><div class="code-wrapper"><pre><code class="hljs ini">const <span class="hljs-attr">CancelToken</span> = axios.CancelToken<span class="hljs-comment">;</span>let cancel<span class="hljs-comment">;</span>axios.get(&#x27;/user/12345&#x27;, &#123;  cancelToken: new CancelToken(function executor(c) &#123;    // executor 函数接收一个 cancel 函数作为参数    <span class="hljs-attr">cancel</span> = c<span class="hljs-comment">;</span>  &#125;)&#125;)<span class="hljs-comment">;</span>// cancel the requestcancel()<span class="hljs-comment">;</span></code></pre></div><h3 id="7-6取消ajax请求有什么意义"><a href="#7-6取消ajax请求有什么意义" class="headerlink" title="7.6取消ajax请求有什么意义"></a>7.6取消ajax请求有什么意义</h3><p><strong>取消ajax请求的意义</strong></p><ol><li>已发出的请求可能仍然会到达后端</li><li>取消后续的回调处理，避免多余的回调处理，以及特殊情况，先发出的后返回，导致回调中的数据错误覆盖</li><li>取消loading效果，以及该请求的其他交互效果，特别是在单页应用中，A页面跳转到B页面之后，A页面的请求应该取消，否则回调中的一些处理可能影响B页面</li><li>超时处理，错误处理等都省去了，节约资源</li></ol><h2 id="8-OPTIONS请求方法及使用场景"><a href="#8-OPTIONS请求方法及使用场景" class="headerlink" title="8. OPTIONS请求方法及使用场景"></a>8. OPTIONS请求方法及使用场景</h2><p>OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。(浏览器自动执行)</p><p>OPTIONS方法是用于请求获得由<code>Request-URI</code>标识的资源在请求&#x2F;响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</p><p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p><ul><li>获取服务器支持的所有HTTP请求方法；</li><li>用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送<strong>嗅探</strong>请求，以判断是否有对指定资源的访问权限。</li></ul><h2 id="9-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？"><a href="#9-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？" class="headerlink" title="9. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？"></a>9. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</h2><ul><li><strong>连接方面</strong>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li><li><strong>资源请求方面</strong>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>http1.1</strong> 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li><li>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</li></ul><h2 id="10-HTTP-1-1-和-HTTP-2-0-的区别"><a href="#10-HTTP-1-1-和-HTTP-2-0-的区别" class="headerlink" title="10.HTTP 1.1 和 HTTP 2.0 的区别"></a>10.HTTP 1.1 和 HTTP 2.0 的区别</h2><ul><li><strong>二进制协议</strong>：HTTP&#x2F;2 是一个二进制协议。在 HTTP&#x2F;1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP&#x2F;2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li><li><strong>多路复用：</strong> HTTP&#x2F;2 实现了多路复用，HTTP&#x2F;2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题。</li><li><strong>数据流：</strong> HTTP&#x2F;2 使用了数据流的概念，因为 HTTP&#x2F;2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP&#x2F;2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li><li><strong>头信息压缩：</strong> HTTP&#x2F;2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li><li><strong>服务器推送：</strong> HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li></ul><h2 id="11-什么是队头堵塞"><a href="#11-什么是队头堵塞" class="headerlink" title="11. 什么是队头堵塞"></a>11. <strong>什么是队头堵塞</strong></h2><p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p><h3 id="11-2-队头阻塞的解决方案："><a href="#11-2-队头阻塞的解决方案：" class="headerlink" title="11.2 队头阻塞的解决方案："></a>11.2 <strong>队头阻塞的解决方案：</strong></h3><p>（1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。 （2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。</p><h2 id="12-HTTP和HTTPS协议的区别"><a href="#12-HTTP和HTTPS协议的区别" class="headerlink" title="12. HTTP和HTTPS协议的区别"></a>12. HTTP和HTTPS协议的区别</h2><p>HTTP和HTTPS协议的主要区别如下：</p><ul><li>HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；</li><li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li><li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</li><li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li></ul><h2 id="13-GET方法URL长度限制的原因"><a href="#13-GET方法URL长度限制的原因" class="headerlink" title="13. GET方法URL长度限制的原因"></a>13. GET方法URL长度限制的原因</h2><p>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的<strong>浏览器</strong>及<strong>服务器</strong>对它的限制。 IE对URL长度的限制是<strong>2083</strong>字节(2K+35)。由于IE浏览器对URL长度的允许值是<strong>最小的</strong>，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">GET</span>的长度值 <span class="hljs-operator">=</span> URL（<span class="hljs-number">2083</span>）<span class="hljs-operator">-</span> （你的Domain<span class="hljs-operator">+</span>Path）<span class="hljs-number">-2</span>（<span class="hljs-number">2</span>是<span class="hljs-keyword">get</span>请求中?<span class="hljs-operator">=</span>两个字符的长度）</code></pre></div><p>下面看一下主流浏览器对get方法中url的长度限制范围：</p><ul><li>Microsoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为<strong>2083</strong>个字符，如果超过这个数字，提交按钮没有任何反应。</li><li>Firefox (Browser)：对于Firefox浏览器URL的长度限制为 <strong>65,536</strong> 个字符。</li><li>Safari (Browser)：URL最大长度限制为 <strong>80,000</strong> 个字符。</li><li>Opera (Browser)：URL最大长度限制为 <strong>190,000</strong> 个字符。</li><li>Google (chrome)：URL最大长度限制为 <strong>8182</strong> 个字符。</li></ul><p>主流的服务器对get方法中url的长度限制范围：</p><ul><li>Apache (Server)：能接受最大url长度为<strong>8192</strong>个字符。</li><li>Microsoft Internet Information Server(IIS)：能接受最大url的长度为<strong>16384</strong>个字符。</li></ul><p>根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。</p><h2 id="14-一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#14-一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="14.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>14.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h2><p>（1）<strong>解析URL：</strong> <strong>首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径</strong>。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p><p>（2）<strong>缓存判断：</strong> <strong>浏览器会判断所请求的资源是否在缓存里</strong>，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p><p>（3）<strong>DNS解析：</strong> 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会<strong>判断本地是否有该域名的 IP 地址的缓存</strong>，如果有则使用，<strong>如果没有则向本地 DNS 服务器发起请求</strong>。<strong>本地 DNS 服务器也会先检查是否存在缓存</strong>，如果<strong>没有就会先向根域名服务器发起请求</strong>，获得负责的顶级域名服务器的地址后，<strong>再向顶级域名服务器请求</strong>，然后获得负责的权威域名服务器的地址后，<strong>再向权威域名服务器发起请求</strong>，<strong>最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户</strong>。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p><p>（4）<strong>获取MAC地址（选说）</strong> 当浏览器得到 IP 地址后，<strong>数据传输还需要知道目的主机 MAC 地址</strong>，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</p><p>（5）<strong>TCP三次握手：</strong> ，<strong>确认客户端与服务器的接收与发送能力</strong>，下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</p><p>（6）<strong>HTTPS握手（选说）：</strong> <strong>如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程</strong>。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</p><p>（7）<strong>发送HTTP请求</strong></p><p><strong>服务器处理请求,返回HTTP报文</strong>(响应)(文件)</p><p>（8）<strong>页面渲染：</strong> 浏览器首先会根据 html 文件(响应) <strong>建 DOM 树</strong>，根据解析到的 css 文件构<strong>建 CSSOM 树</strong>，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。<strong>当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树</strong>。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</p><p>（9）<strong>TCP四次挥手：</strong> <strong>最后一步是 TCP 断开连接的四次挥手过程</strong>。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</p><h2 id="15-页面有多张图片，HTTP是怎样的加载表现？"><a href="#15-页面有多张图片，HTTP是怎样的加载表现？" class="headerlink" title="15.页面有多张图片，HTTP是怎样的加载表现？"></a>15.页面有多张图片，HTTP是怎样的加载表现？</h2><p>在<code>HTTP 1</code>下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用<strong>多域名部署</strong>解决。这样可以提高同时请求的数目，加快页面图片的获取速度。</p><p>在<code>HTTP 2</code>下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。</p><h2 id="16-HTTP2的头部压缩算法是怎样的？"><a href="#16-HTTP2的头部压缩算法是怎样的？" class="headerlink" title="16. HTTP2的头部压缩算法是怎样的？"></a>16. HTTP2的头部压缩算法是怎样的？</h2><p>HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p><p>具体来说:</p><ul><li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；</li><li>首部表在HTTP&#x2F;2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；</li><li>每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ul><h2 id="17-HTTP请求报文的是什么样的？"><a href="#17-HTTP请求报文的是什么样的？" class="headerlink" title="17. HTTP请求报文的是什么样的？"></a>17. HTTP请求报文的是什么样的？</h2><p>请求报⽂有4部分组成:</p><ul><li>请求⾏</li><li>请求头部</li><li>空⾏</li><li>请求体</li></ul><p><strong>其中：</strong></p><p>（1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET &#x2F;index.html HTTP&#x2F;1.1。</p><p>（2）请求头部:请求头部由关键字&#x2F;值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔</p><ul><li>User-Agent：产⽣请求的浏览器类型。</li><li>Accept：客户端可识别的内容类型列表。</li><li>Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。</li></ul><p>（3）请求体: post put等请求携带的数据</p><h2 id="18-HTTP响应报文的是什么样的？"><a href="#18-HTTP响应报文的是什么样的？" class="headerlink" title="18. HTTP响应报文的是什么样的？"></a>18. HTTP响应报文的是什么样的？</h2><p>请求报⽂有4部分组成:</p><ul><li>响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP&#x2F;1.1 200 OK</li><li>响应头：响应部⾸组成</li><li>空⾏</li><li>响应体：服务器响应的数据</li></ul><h2 id="19-HTTP协议的优点和缺点"><a href="#19-HTTP协议的优点和缺点" class="headerlink" title="19. HTTP协议的优点和缺点"></a>19. HTTP协议的优点和缺点</h2><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。</p><p>HTTP协议具有以下<strong>优点</strong>：</p><ul><li>支持客户端&#x2F;服务器模式</li><li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li><li><strong>无连接</strong>：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</li><li><strong>无状态</strong>：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。</li><li><strong>灵活</strong>：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li></ul><p>HTTP协议具有以下<strong>缺点</strong>：</p><ul><li><strong>无状态：</strong> HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</li><li><strong>明文传输：</strong> 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。</li><li><strong>不安全</strong></li></ul><p>（1）通信使用明文（不加密），内容可能会被窃听； （2）不验证通信方的身份，因此有可能遭遇伪装； （3）无法证明报文的完整性，所以有可能已遭篡改；</p><h2 id="20-说一下HTTP-3-0"><a href="#20-说一下HTTP-3-0" class="headerlink" title="20. 说一下HTTP 3.0"></a>20. 说一下HTTP 3.0</h2><p>HTTP3.0，也称作HTTP over QUIC。HTTP3.0的核心是QUIC(读音quick)协议，由Google在 2015年提出的SPDY v3演化而来的新协议，传统的HTTP协议是基于传输层TCP的协议，而QUIC是基于传输层UDP上的协议，可以定义成:HTTP3.0基于UDP的安全可靠的HTTP2.0协议。</p><h2 id="21-HTTP的两种连接模式"><a href="#21-HTTP的两种连接模式" class="headerlink" title="21. HTTP的两种连接模式"></a>21. HTTP的两种连接模式</h2><p>HTTP 协议是基于 TCP&#x2F;IP，并且使用了<strong>请求-应答</strong>的通信模式。</p><p><strong>HTTP协议有两种连接模式，一种是持续连接，一种非持续连接</strong>。 （1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。 （2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。</p><h2 id="22-URL有哪些组成部分"><a href="#22-URL有哪些组成部分" class="headerlink" title="22. URL有哪些组成部分"></a>22. URL有哪些组成部分</h2><p>以下面的URL为例<a href="http://www.aspxfans.com:8080/news/index?ID=246188#name">www.aspxfans.com:8080/news/index?ID=246188#name</a></p><p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p><ul><li><strong>协议部分</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“&#x2F;&#x2F;”为分隔符；</li><li><strong>域名部分</strong>：该URL的域名部分为<a href="http://www.aspxfans.com.一个url中,也可以使用ip地址作为域名使用/">www.aspxfans.com。一个URL中，也可以使用IP地址作为域名使用</a></li><li><strong>端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</li><li><strong>虚拟目录部分</strong>：从域名后的第一个“&#x2F;”开始到最后一个“&#x2F;”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“&#x2F;news&#x2F;”；</li><li><strong>文件名部分</strong>：从域名后的最后一个“&#x2F;”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“&#x2F;”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“&#x2F;”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li><li><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；</li><li><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID&#x3D;5&amp;ID&#x3D;24618&amp;page&#x3D;1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li></ul><h2 id="23-与缓存相关的HTTP请求头有哪些"><a href="#23-与缓存相关的HTTP请求头有哪些" class="headerlink" title="23.与缓存相关的HTTP请求头有哪些"></a>23.与缓存相关的HTTP请求头有哪些</h2><p>强缓存：</p><ul><li>Expires</li><li>Cache-Control</li></ul><p>协商缓存：</p><ul><li>Etag、If-None-Match</li><li>Last-Modified、If-Modified-Since</li></ul><h2 id="24-强缓存和协商缓存"><a href="#24-强缓存和协商缓存" class="headerlink" title="24. 强缓存和协商缓存"></a>24. 强缓存和协商缓存</h2><p><strong>1.强缓存：</strong> 不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache两种（灰色表示缓存）。</p><p><strong>2.协商缓存：</strong> 向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；</p><blockquote><p>共同点：都是从客户端缓存中读取资源； 区别是强缓存不会发请求，协商缓存会发请求。</p></blockquote><h2 id="25-HTTP的keep-alive有什么作用？"><a href="#25-HTTP的keep-alive有什么作用？" class="headerlink" title="25. HTTP的keep-alive有什么作用？"></a>25. HTTP的keep-alive有什么作用？</h2><p><strong>http1.0默认关闭，需要手动开启。http1.1后默认开启</strong></p><p><strong>作用：</strong> 使客户端到服务器端的链接持续有效(<strong>长连接</strong>)，当出现对服务器的后续请求时，keep-Alive功能避免了建立或者重新建立链接。</p><p><strong>使用方法：</strong> 在请求头中加上Connection：keep-alive。</p><p><strong>优点：</strong></p><ul><li>较少的CPU和内存的占用(因为要打开的连接数变少了，复用了连接)</li><li>减少了后续请求的延迟(无需再进行握手)</li></ul><p><strong>缺点：</strong> 本来可以释放的资源仍旧被占用。有的请求已经结束了，但是还一直连接着。</p><p><strong>解决方法：</strong> 服务器设置过期时间和请求次数，超过这个时间或者次数就断掉连接。</p><h2 id="26-OSI的七层模型是什么？"><a href="#26-OSI的七层模型是什么？" class="headerlink" title="26. OSI的七层模型是什么？"></a>26. OSI的七层模型是什么？</h2><p>ISO于1978年开发的一套标准架构ISO模型，被引用来说明数据通信协议的结构和功能。</p><p>OSI在功能上可以划分为两组：</p><p>网络群组：物理层、数据链路层、网络层</p><p>使用者群组：传输层、会话层、表示层、应用层</p><table><thead><tr><th><code>OSI</code>七层网络模型</th><th><code>TCP/IP</code>四层概念模型</th><th>对应网络协议</th></tr></thead><tbody><tr><td>7：应用层</td><td>应用层</td><td><code>HTTP</code>、<code>RTSP</code> <code>TFTP（简单文本传输协议）、</code>FTP<code>、</code> NFS<code>（数域筛法，数据加密）、</code>WAIS&#96;（广域信息查询系统）</td></tr><tr><td>6：表示层</td><td>应用层</td><td><code>Telnet</code>（internet远程登陆服务的标准协议）、<code>Rlogin</code>、<code>SNMP</code>（网络管理协议）、Gopher</td></tr><tr><td>5：会话层</td><td>应用层</td><td><code>SMTP</code>（简单邮件传输协议）、<code>DNS</code>（域名系统）</td></tr><tr><td>4：传输层</td><td>传输层</td><td><code>TCP</code>（传输控制协议）、<code>UDP</code>（用户数据报协议））</td></tr><tr><td>3：网络层</td><td>网际层</td><td><code>ARP</code>（地域解析协议）、<code>RARP</code>、<code>AKP</code>、<code>UUCP</code>（Unix to Unix copy）</td></tr><tr><td>2：数据链路层</td><td>数据链路层</td><td><code>FDDI</code>（光纤分布式数据接口）、<code>Ethernet、Arpanet、PDN</code>（公用数据网）、<code>SLIP</code>（串行线路网际协议）<code>PPP</code>（点对点协议，通过拨号或专线方建立点对点连接发送数据）</td></tr><tr><td>1：物理层</td><td>物理层</td><td><code>SMTP</code>（简单邮件传输协议）、<code>DNS</code>（域名系统）</td></tr></tbody></table><p>其中高层（7、6、5、4层）定义了应用程序的功能，下面三层（3、2、1层）主要面向通过网络的端到端的数据流</p><h1 id="二、HTTPS"><a href="#二、HTTPS" class="headerlink" title="二、HTTPS"></a>二、HTTPS</h1><h2 id="1-什么是HTTPS协议？"><a href="#1-什么是HTTPS协议？" class="headerlink" title="1. 什么是HTTPS协议？"></a>1. 什么是HTTPS协议？</h2><p><code>超文本传输安全协议</code>（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。<strong>HTTPS经由HTTP进行通信，利用SSL&#x2F;TLS来加密数据包。</strong> HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 <img src="/../imgs/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/7fc896a61f7d4810811b2d47b2170e02tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="img"> HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS&#x2F;SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p><p>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong>。</p><h2 id="2-TLS-x2F-SSL的工作原理"><a href="#2-TLS-x2F-SSL的工作原理" class="headerlink" title="2. TLS&#x2F;SSL的工作原理"></a>2. TLS&#x2F;SSL的工作原理</h2><p><strong>TLS</strong>全称<strong>安全传输层协议</strong>（Transport Layer Security）及其前身<strong>安全套接层</strong>（Secure Sockets Layer，缩写作<strong>SSL</strong>） 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p><p>TLS&#x2F;SSL的功能实现主要依赖三类基本算法：<strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。这三类算法的作用如下：</p><ul><li>散列算法用来验证信息的完整性</li><li>对称加密算法采用协商的秘钥对数据加密</li><li>非对称加密实现身份认证和秘钥协商</li></ul><p><img src="/../imgs/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/4c3d5b4b78c549d6b94fbff32a652cf1tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="微信图片_20221001151505.png"></p><h2 id="3-对称加密、非对称加密是什么，有什么区别？"><a href="#3-对称加密、非对称加密是什么，有什么区别？" class="headerlink" title="3. 对称加密、非对称加密是什么，有什么区别？"></a>3. 对称加密、非对称加密是什么，有什么区别？</h2><p><strong>对称加密和非对称加密是安全传输层里的加密算法</strong></p><p><strong>对称加密</strong></p><ul><li><p>对称加密的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，</p><p>这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难</p><p><strong>通信的双⽅都使⽤同⼀个秘钥进⾏加密, 解密。</strong> ⽐如，两个人事先约定的暗号，就属于对称加密。</p></li></ul><p><img src="/../imgs/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/72a94610b5ac436aa830861a9e15c712tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="img"></p><p><strong>优点:</strong></p><p>计算量小、加密速度快、加密效率高。</p><p><strong>缺点:</strong></p><p><strong>在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。</strong></p><p><strong>如果一方的秘钥被泄露，那么加密信息也就不安全了</strong></p><p>最不安全的地方, 就在于第一开始, 互相约定密钥的时候!!! 传递密钥!</p><p>使用场景：本地数据加密、https 通信、网络传输等</p><p><strong>非对称加密</strong></p><p>通信的双方使用不同的秘钥进行加密解密，即秘钥对（私钥 + 公钥）。</p><p>特征: 私钥可以解密公钥加密的内容, 公钥可以解密私钥加密的内容</p><p><img src="/../imgs/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/c14f578ba3554a119031472df5cf3935tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="img"></p><p>非对称加密的特点是：</p><ul><li>优点：非对称加密与对称加密相比其安全性更好</li><li><strong>缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</strong></li></ul><p>使用场景：https 会话前期、CA 数字证书、信息加密、登录认证等</p><h2 id="4-数字证书是什么？"><a href="#4-数字证书是什么？" class="headerlink" title="4. 数字证书是什么？"></a>4. 数字证书是什么？</h2><p>使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为<strong>数字证书</strong>。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p><h3 id="4-2-数字证书的作用"><a href="#4-2-数字证书的作用" class="headerlink" title="4.2 数字证书的作用"></a>4.2 数字证书的作用</h3><p>现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用<strong>数字证书</strong>。</p><h3 id="4-3-数字签名是什么？"><a href="#4-3-数字签名是什么？" class="headerlink" title="4.3 数字签名是什么？"></a>4.3 数字签名是什么？</h3><p>数字签名就是先用CA自带的Hash算法来计算出证书内容的一个摘要，然后使用CA私钥进行加密，组成数字签名。</p><p>当别人把他的数字证书发过来时，接收方用同样的算法再次生成摘要，用CA公钥解密后得到CA生成的摘要，两者进行对比后，就能确定中间是否被人篡改。这样就能最大程度的保证通信的安全了。</p><h2 id="5-HTTPS通信（握手）过程"><a href="#5-HTTPS通信（握手）过程" class="headerlink" title="5. HTTPS通信（握手）过程"></a>5. HTTPS通信（握手）过程</h2><p>HTTPS的通信过程如下：</p><ol><li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li><li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li><li>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li><li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li><li>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</li></ol><h2 id="6-HTTPS的优缺点"><a href="#6-HTTPS的优缺点" class="headerlink" title="6. HTTPS的优缺点"></a>6. HTTPS的优缺点</h2><p>HTTPS的<strong>优点</strong>如下：</p><ul><li>使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；</li><li>使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；</li></ul><p>HTTPS的<strong>缺点</strong>如下：</p><ul><li>HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；</li><li>HTTPS协议握手阶段比较费时，增加页面的加载时间；</li><li>SSL证书是收费的，功能越强大的证书费用越高；</li><li>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；</li><li>SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。</li></ul><h2 id="7-HTTPS是如何保证安全的？"><a href="#7-HTTPS是如何保证安全的？" class="headerlink" title="7. HTTPS是如何保证安全的？"></a>7. <strong>HTTPS</strong>是如何保证安全的？</h2><p>结合<strong>对称加密</strong>和<strong>非对称加密</strong>两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。</p><p>这个时候还需要⼀个安全的<strong>第三⽅颁发证书</strong>（CA），证明身份的身份，防⽌被中间⼈攻击。</p><p>为了防止中间人篡改证书，需要用到<strong>数字签名</strong>这个技术</p><p><em>数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。</em></p><h2 id="8-HTTP状态码分别代表什么意思？"><a href="#8-HTTP状态码分别代表什么意思？" class="headerlink" title="8.HTTP状态码分别代表什么意思？"></a>8.HTTP状态码分别代表什么意思？</h2><table><thead><tr><th><strong>类别</strong></th><th><strong>原因</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>1xx</td><td>Informational(信息性状态码)</td><td>接受的请求正在处理</td></tr><tr><td>2xx</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作一完成请求</td></tr><tr><td>4xx</td><td>Client Error (客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><p><strong>（1）2XX 成功</strong></p><ul><li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li><li>201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立。通常是在POST请求，或者是某些PUT请求之后创建了内容，进行的返回的响应。</li><li>202 Accepted 请求服务器已接受，但是尚未处理，不保证完成请求。适合异步任务或者说需要处理时间比较长的请求，避免HTTP链接一直占用。</li><li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li><li>206 Partial Content，进行的是范围请求，表示服务器已经成功处理了部分GET请求，响应头中会包含获取的内容范围(常用于分段下载)</li></ul><p><strong>（2）3XX 重定向</strong></p><ul><li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li><li>302 found，临时性重定向，表示资源临时被分配了新的 URL，支持搜索引擎优化</li><li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li><li>304 not modified，自从上次请求后，请求的网页内容未修改过。服务器返回此响应时，不会返回网页内容。(<strong>协商缓存</strong>)</li><li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul><p><strong>（3）4XX 客户端错误</strong></p><ul><li>400 bad request，请求报文存在语法错误(传参格式不正确)</li><li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息(没有权限)</li><li>403 forbidden，表示对请求资源的访问被服务器拒绝</li><li>404 not found，表示在服务器上没有找到请求的资源</li><li>408 Request Timeout 客户端请求超时</li><li>409 Confict 请求的资源可能引起冲突</li></ul><p><strong>（4）5XX 服务器错误</strong></p><ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误</li><li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><h2 id="9-同样是重定向，307，303，302的区别？"><a href="#9-同样是重定向，307，303，302的区别？" class="headerlink" title="9. 同样是重定向，307，303，302的区别？"></a>9. 同样是重定向，<strong>307</strong>，<strong>303</strong>，<strong>302</strong>的区别？</h2><p><strong>302</strong>是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。</p><p><strong>303</strong>明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。</p><p><strong>307</strong>会遵照浏览器标准，不会从post变为get。</p><h2 id="10-DNS-协议是什么"><a href="#10-DNS-协议是什么" class="headerlink" title="10. DNS 协议是什么"></a>10. DNS 协议是什么</h2><p><strong>概念</strong>： DNS 是<strong>域名系统</strong> (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><p><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。</p><h2 id="11-DNS完整的查询过程"><a href="#11-DNS完整的查询过程" class="headerlink" title="11. DNS完整的查询过程"></a>11. DNS完整的查询过程</h2><p>DNS服务器解析域名的过程：</p><ul><li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li><li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li><li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li><li>本地DNS服务器将返回结果返回给浏览器</li></ul><h2 id="12-简述一下TCP的三次握手"><a href="#12-简述一下TCP的三次握手" class="headerlink" title="12. 简述一下TCP的三次握手"></a>12. 简述一下TCP的三次握手</h2><p><strong>第一次握手：</strong> 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</p><p><strong>第二次握手：</strong> 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p><p><strong>第三次握手：</strong> 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p><h2 id="13-TCP什么要三次握手呢？两次不行吗？"><a href="#13-TCP什么要三次握手呢？两次不行吗？" class="headerlink" title="13. TCP什么要三次握手呢？两次不行吗？"></a>13. <strong>TCP什么要三次握手呢？两次不行吗？</strong></h2><ul><li>为了确认双方的接收能力和发送能力都正常</li><li>如果是用两次握手，则会出现下面这种情况：</li></ul><p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p><h2 id="14-简述一下TCP的四次挥手"><a href="#14-简述一下TCP的四次挥手" class="headerlink" title="14. 简述一下TCP的四次挥手"></a>14. 简述一下TCP的四次挥手</h2><p><strong>第一次挥手：</strong> 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</p><p><strong>第二次挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</p><p><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</p><p><strong>第四次挥手：</strong> 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</p><h2 id="15-TCP为什么需要四次挥手呢？"><a href="#15-TCP为什么需要四次挥手呢？" class="headerlink" title="15. TCP为什么需要四次挥手呢？"></a>15. TCP<strong>为什么需要四次挥手呢？</strong></h2><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。</p><h2 id="16-TCP粘包是怎么回事，如何处理"><a href="#16-TCP粘包是怎么回事，如何处理" class="headerlink" title="16. TCP粘包是怎么回事，如何处理?"></a>16. TCP粘包是怎么回事，如何处理?</h2><p>默认情况下, TCP 连接会启⽤<strong>延迟传送算法</strong> (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能.</p><p>如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包.</p><p>⽽对于处理粘包的问题, 常⻅的解决⽅案有:</p><p><strong>多次发送之前间隔⼀个等待时间</strong>：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.</p><p><strong>关闭 Nagle 算法</strong>：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)</p><p><strong>进⾏封包&#x2F;拆包：</strong> 封包&#x2F;拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前&#x2F;后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。</p><h2 id="17-token是什么？"><a href="#17-token是什么？" class="headerlink" title="17. token是什么？"></a>17. token是什么？</h2><ol><li><p>token也可以称做<strong>令牌</strong>，一般由 <code>uid+time+sign(签名)+[固定参数]</code> 组成</p><div class="code-wrapper"><pre><code class="hljs json">uid<span class="hljs-punctuation">:</span> 用户唯一身份标识time<span class="hljs-punctuation">:</span> 当前时间的时间戳sign<span class="hljs-punctuation">:</span> 签名<span class="hljs-punctuation">,</span> 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接固定参数(可选)<span class="hljs-punctuation">:</span> 将一些常用的固定参数加入到 token 中是为了避免重复查库</code></pre></div></li><li><p>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中</p></li><li><p>token 的认证流程</p><div class="code-wrapper"><pre><code class="hljs json">用户登录，成功后服务器返回Token给客户端。客户端收到数据后保存在客户端客户端再次访问服务器，将token放入headers中 或者每次的请求 参数中服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</code></pre></div></li><li><p>token可以抵抗csrf，cookie+session不行</p></li><li><p>session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session</p></li><li><p>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做JWT(Json Web Token)</p></li></ol><h2 id="18-token是怎么加密的"><a href="#18-token是怎么加密的" class="headerlink" title="18. token是怎么加密的"></a>18. token是怎么加密的</h2><ol><li>需要一个secret（随机数）</li><li>后端利用secret和加密算法(如：HMAC-SHA256)对payload(如账号密码)生成一个字符串(token)，返回前端</li><li>前端每次request在header中带上token</li><li>后端用同样的算法解密</li></ol><h2 id="19-cookie和token都放在header中，为什么会劫持cookie，不会劫持token"><a href="#19-cookie和token都放在header中，为什么会劫持cookie，不会劫持token" class="headerlink" title="19. cookie和token都放在header中，为什么会劫持cookie，不会劫持token"></a>19. cookie和token都放在header中，为什么会劫持cookie，不会劫持token</h2><ul><li><strong>cookie</strong>: 登陆后后端生成一个sessionid放在cookie中返回给客户端, 并且服务端一直记录着这个 sessionid, 客户端以后每次请求都会带上这个sessionid, 服务端通过这个sessionid来验证身份之类的操作。所以别人拿到了cookie就相当于拿到了sessionid ,就可以完全替代你。同时浏览器会自动携带cookie</li><li>token: 同样是登录后服务端返回一个token，客户端保存起来，在以后http请求里手动的加入到请求头里，服务端根据token 进行身份的校验。浏览器不会自动携带token，所以不会劫持 token。</li></ul><h2 id="20-token过期后，页面如何实现无感刷新"><a href="#20-token过期后，页面如何实现无感刷新" class="headerlink" title="20. token过期后，页面如何实现无感刷新?"></a>20. token过期后，页面如何实现无感刷新?</h2><p><strong>什么是无感刷新</strong></p><p>后台返回的token是有时效性的，时间到了，你在交互后台的时候，后台会判断你的token是否过期（安全需要），如果过期了就会逼迫你重新登陆！</p><p><strong>token无感刷新其本质是为了优化用户体验,当token过期时不需要用户跳回登录页重新登录,而是当token失效时,进行拦截,发送刷新token的ajax,获取最新的token进行覆盖,让用户感受不到token已经过期</strong></p><p><strong>实现无感刷新</strong></p><p>1、后端返回过期时间，前端判断token过期时间,去调用刷新token接口。</p><p>缺点：需要后端额外提供一个Token过期时间的字段；使用了本地时间判断，若本地时间篡改，特别是本地时间比服务器时间慢时，拦截会失败。</p><p>2、写个定时器，定时刷新Token接口。缺点：浪费资源,消耗性能,不建议采用。</p><p>3、在响应拦截器中拦截，判断Token 返回过期后，调用刷新token接口。</p><h2 id="21-介绍下304过程"><a href="#21-介绍下304过程" class="headerlink" title="21. 介绍下304过程"></a>21. 介绍下304过程</h2><ul><li>a. 浏览器请求资源时首先命中资源的Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control: max-age指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。</li><li>b. 强缓存失效，进入协商缓存阶段，首先验证ETagETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的If-None-Match值来判断是否命中缓存。</li><li>c. 协商缓存Last-Modify&#x2F;If-Modify-Since阶段，客户端第一次请求资源时，服务服返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存</li></ul><h1 id="三、浏览器安全"><a href="#三、浏览器安全" class="headerlink" title="三、浏览器安全"></a>三、浏览器安全</h1><h2 id="1-有哪些可能引起前端安全的问题"><a href="#1-有哪些可能引起前端安全的问题" class="headerlink" title="1. 有哪些可能引起前端安全的问题?"></a>1. 有哪些可能引起前端安全的问题?</h2><ul><li><strong>跨站脚本</strong> (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript &#x2F; CSS &#x2F; Flash 等；</li><li><strong>iframe的滥⽤</strong>: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；</li><li><strong>跨站点请求伪造</strong>（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击</li><li><strong>恶意第三⽅库</strong>: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。</li></ul><h2 id="2-网络劫持有哪几种，如何防范？"><a href="#2-网络劫持有哪几种，如何防范？" class="headerlink" title="2. 网络劫持有哪几种，如何防范？"></a>2. 网络劫持有哪几种，如何防范？</h2><p>⽹络劫持分为两种:</p><p>（1）<strong>DNS劫持</strong>: (输⼊京东被强制跳转到淘宝这就属于dns劫持)</p><ul><li>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li><li>302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容</li></ul><p>（2）<strong>HTTP劫持</strong>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)</p><p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p><h2 id="3-进程与线程的概念"><a href="#3-进程与线程的概念" class="headerlink" title="3. 进程与线程的概念"></a>3. 进程与线程的概念</h2><p>从本质上说，进程和线程都是 CPU 工作时间片的一个描述：</p><ul><li>进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</li><li>线程是进程中的更小单位，描述了执行一段指令所需的时间。</li></ul><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p><h2 id="4-进程和线程的区别"><a href="#4-进程和线程的区别" class="headerlink" title="4. 进程和线程的区别"></a>4. 进程和线程的区别</h2><ul><li>进程可以看做独立应用，线程不能</li><li><strong>资源</strong>：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。</li><li><strong>通信方面</strong>：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。</li><li><strong>调度</strong>：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li><li><strong>系统开销</strong>：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I&#x2F;O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。</li></ul><h2 id="5-如何实现浏览器内多个标签页之间的通信"><a href="#5-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="5. 如何实现浏览器内多个标签页之间的通信?"></a>5. 如何实现浏览器内多个标签页之间的通信?</h2><p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：</p><ul><li><strong>使用 websocket 协议</strong>，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</li><li><strong>使用 ShareWorker 的方式</strong>，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</li><li><strong>使用 localStorage 的方式</strong>，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</li><li><strong>使用 postMessage 方法</strong>，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。</li></ul><h2 id="6-为什么需要浏览器缓存？"><a href="#6-为什么需要浏览器缓存？" class="headerlink" title="6. 为什么需要浏览器缓存？"></a>6. 为什么需要浏览器缓存？</h2><p>对于浏览器的缓存，主要针对的是前端的静态资源，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。</p><p>所谓的<strong>浏览器缓存</strong>指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。</p><h3 id="浏览器缓存的优点"><a href="#浏览器缓存的优点" class="headerlink" title="浏览器缓存的优点"></a>浏览器缓存的优点</h3><p>使用浏览器缓存，有以下优点：</p><ul><li>减少了服务器的负担，提高了网站的性能</li><li>加快了客户端网页的加载速度</li><li>减少了多余网络数据传输</li></ul><h2 id="7-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？"><a href="#7-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？" class="headerlink" title="7. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？"></a>7. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h2><ul><li><strong>点击刷新按钮或者按 F5：</strong> 浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</li><li><strong>用户按 Ctrl+F5（强制刷新）：</strong> 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</li><li><strong>地址栏回车</strong>： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</li></ul><h2 id="8-浏览器渲染过程中遇到-JS-文件如何处理？"><a href="#8-浏览器渲染过程中遇到-JS-文件如何处理？" class="headerlink" title="8. 浏览器渲染过程中遇到 JS 文件如何处理？"></a>8. 浏览器渲染过程中遇到 JS 文件如何处理？</h2><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。</p><p>也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 <code>defer</code> 或者 <code>async</code> 属性。</p><h2 id="9-什么是文档的预解析？"><a href="#9-什么是文档的预解析？" class="headerlink" title="9. 什么是文档的预解析？"></a>9. 什么是文档的预解析？</h2><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p><h2 id="10-CSS-如何阻塞文档解析？"><a href="#10-CSS-如何阻塞文档解析？" class="headerlink" title="10. CSS 如何阻塞文档解析？"></a>10. CSS 如何阻塞文档解析？</h2><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。</p><p>所以<strong>如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。</strong> 也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p><h2 id="11-浏览器本地存储的方式"><a href="#11-浏览器本地存储的方式" class="headerlink" title="11.浏览器本地存储的方式"></a>11.浏览器本地存储的方式</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。<strong>Cookie的大小只有4kb</strong>，它是一种纯文本文件，<strong>每次发起HTTP请求都会携带Cookie。</strong></p><p><strong>Cookie的特性：</strong></p><ul><li>Cookie一旦创建成功，名称就无法修改</li><li>Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</li><li>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</li><li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li><li>Cookie在请求一个新的页面的时候都会被发送过去</li></ul><p><strong>如果需要域名之间跨域共享Cookie，有两种方法：</strong></p><ol><li>使用Nginx反向代理</li><li>在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId</li></ol><h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h3><p>LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。</p><p><strong>LocalStorage的优点：</strong></p><ul><li>在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息</li><li>LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</li><li>仅储存在本地，不像Cookie那样每次HTTP请求都会被携带</li></ul><p><strong>LocalStorage的缺点：</strong></p><ul><li>存在浏览器兼容问题，IE8以下版本的浏览器不支持</li><li>如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</li><li>LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问</li></ul><h3 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h3><p>SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。</p><p><strong>SessionStorage与LocalStorage对比：</strong></p><ul><li>SessionStorage和LocalStorage都在<strong>本地进行数据存储</strong>；</li><li>SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage<strong>只有在同一浏览器的同一窗口下才能够共享</strong>；</li><li>LocalStorage和SessionStorage<strong>都不能被爬虫爬取</strong>；</li></ul><h2 id="12-Cookie、LocalStorage、SessionStorage区别"><a href="#12-Cookie、LocalStorage、SessionStorage区别" class="headerlink" title="12. Cookie、LocalStorage、SessionStorage区别"></a>12. Cookie、LocalStorage、SessionStorage区别</h2><p><strong>cookie：</strong> 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</p><p><strong>sessionStorage：</strong> html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</p><p><strong>localStorage：</strong> html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</p><h2 id="13-什么是同源策略，什么是跨域"><a href="#13-什么是同源策略，什么是跨域" class="headerlink" title="13.什么是同源策略，什么是跨域"></a>13.什么是同源策略，什么是跨域</h2><p><strong>同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。</strong></p><p><strong>同源政策主要限制了三个方面：</strong></p><ul><li>当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li><li>当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li><li>当前域下 ajax 无法发送跨域请求。</li></ul><p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p><p><strong>什么是跨域</strong></p><p>指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的,是浏览器对 javascript 施加的安全限制，防止他人恶意攻击网站</p><p><strong>跨域问题其实就是浏览器的同源策略造成的。</strong></p><h2 id="14-如何解决跨越问题"><a href="#14-如何解决跨越问题" class="headerlink" title="14. 如何解决跨越问题"></a>14. 如何解决跨越问题</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><strong>CORS</strong></h3><p>CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现<strong>CORS的关键就是服务器，只要服务器实现了CORS请求</strong>，就可以跨源通信了。</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a><strong>JSONP</strong></h3><p><strong>jsonp</strong>的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据</p><p><strong>优点</strong></p><ul><li>实现简单</li><li>兼容性好, 可用于解决主流浏览器的跨域数据访问的问题。</li></ul><p><strong>缺点</strong></p><ul><li>只支持 GET 请求 ( 因为</li><li>存在被 XSS 攻击的可能, 缺乏安全性保证</li><li>需要服务端配合改造</li></ul><h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a><strong>postMessage</strong></h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p>用法：postMessage(data,origin)方法接受两个参数：</p><ul><li><strong>data</strong>： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li><li><strong>origin</strong>： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”&#x2F;“。</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="Node中间件代理-proxy正向代理-两次跨域"><a href="#Node中间件代理-proxy正向代理-两次跨域" class="headerlink" title="Node中间件代理(proxy正向代理)(两次跨域)"></a><strong>Node中间件代理(proxy正向代理)(两次跨域)</strong></h3><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong> 代理服务器，需要做以下几个步骤：</p><ul><li>接受客户端请求 。</li><li>将请求 转发给服务器。</li><li>拿到服务器 响应 数据。</li></ul><h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a><strong>nginx反向代理</strong></h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><h2 id="15-正向代理和反向代理的区别"><a href="#15-正向代理和反向代理的区别" class="headerlink" title="15. 正向代理和反向代理的区别"></a>15. 正向代理和反向代理的区别</h2><ul><li><strong>正向代理：</strong></li></ul><p>客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。</p><ul><li><strong>反向代理：</strong></li></ul><p>服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。</p><p>： <img src="/../imgs/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/ea0a97dea4ab411fb9c20b0856b64c54tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="img"></p><h2 id="16-前端安全了解吗，说一下-XSS-和-CSRF，以及怎么规避"><a href="#16-前端安全了解吗，说一下-XSS-和-CSRF，以及怎么规避" class="headerlink" title="16. 前端安全了解吗，说一下 XSS 和 CSRF，以及怎么规避"></a>16. 前端安全了解吗，说一下 XSS 和 CSRF，以及怎么规避</h2><p><strong>XSS</strong>：<code>跨域脚本攻击</code></p><p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p><p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p><p>攻击者可以通过这种攻击方式可以进行以下操作：</p><ul><li>获取页面的数据，如DOM、cookie、localStorage；</li><li>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li><li>破坏页面结构；</li><li>流量劫持（将链接指向某网站）；</li></ul><p><strong>防御方法</strong></p><p>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</p><p><strong>CSRF</strong>：<code>跨站请求伪造</code></p><p>CSRF 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p><p>CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></p><p><strong>CSRF 攻击可以使用以下方法来防护：</strong></p><ul><li><strong>进行同源检测</strong>，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。</li><li><strong>使用 CSRF Token 进行验证</strong>，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。</li><li><strong>对 Cookie 进行双重验证</strong>，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。</li><li><strong>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用</strong>，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li></ul><h3 id="什么是中间人攻击？"><a href="#什么是中间人攻击？" class="headerlink" title="什么是中间人攻击？"></a>什么是中间人攻击？</h3><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。</p><p>攻击过程如下:</p><ul><li>客户端发送请求到服务端，请求被中间⼈截获</li><li>服务器向客户端发送公钥</li><li>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端</li><li>客户端收到伪造的公钥后，⽣成加密hash值发给服务器</li><li>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器</li><li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</li></ul><h2 id="17-浏览器是如何进行界面渲染的？"><a href="#17-浏览器是如何进行界面渲染的？" class="headerlink" title="17. 浏览器是如何进行界面渲染的？"></a>17. 浏览器是如何进行界面渲染的？</h2><p>不同的渲染引擎的具体做法稍有差异，但是大体流程都是差不多的，下面以 chrome渲染引擎 的 渲染流程来说明：</p><ol><li>获取 HTML ⽂件并进⾏解析，生成一棵 DOM 树（DOM Tree）</li><li>解析 HTML 的同时也会解析 CSS，⽣成样式规则（Style Rules）</li><li>根据 DOM 树和样式规则，生成一棵渲染树（Render Tree）</li><li>进行布局（Layout）(重排)，即为每个节点分配⼀个在屏幕上应显示的确切坐标位置</li><li>进⾏绘制（Paint）(重绘)，遍历渲染树节点，调⽤ GPU(图形处理器) 将元素呈现出来</li></ol><h2 id="18-前端如何实现即时通讯？websocket"><a href="#18-前端如何实现即时通讯？websocket" class="headerlink" title="18. 前端如何实现即时通讯？websocket"></a>18. 前端如何实现即时通讯？websocket</h2><div class="code-wrapper"><pre><code class="hljs erlang-repl">严格意义上: HTTP协议只能做到客户端请求服务器, 服务器做出响应, 做不到让服务器主动给客户端推送消息!</code></pre></div><p><strong>那么如果服务器数据更新了, 想要即时通知到客户端怎么办呢 ? (即时通信需求)</strong></p><p>即时通信需求: 服务器数据一有更新, 希望推送给到浏览器</p><p>提问的回答重心:</p><ol><li>即时通信有哪些方案?</li><li>为什么使用了其中某一个方案! websocket</li></ol><p>基于Web的前端，存在以下几种可实现即时通讯的方式：</p><ul><li><p>短轮询 (历史方案)</p><p>开个定时器, 每隔一段时间发请求 (实时性不强，影响性能)</p></li><li><p>Comet - ajax长轮询(历史方案)</p><p>发送一个请求, 服务器只要数据不更新, 就一直阻塞 (服务器压力过大)</p></li><li><p>SSE</p><p>(利用了http协议, 流数据的传输, 并不是严格意义的双向通信, 无法复用连接)</p></li><li><p>WebSocket (主流)</p><p>性能和效率都高!</p></li></ul><h2 id="19-说一下websocket"><a href="#19-说一下websocket" class="headerlink" title="19. 说一下websocket"></a>19. 说一下websocket</h2><p><strong>websocket是一种网络通信协议</strong>，是HTML5开始提供的一种在单个TCP连接上进行全双工通信的协议，这个对比着HTTP协议来说，HTTP协议是一种无状态的、无连接的、单向的应用层协议，通信请求只能由客户端发起，服务端对请求做出应答处理。</p><p><strong>HTTP协议无法实现服务器主动向客户端发起消息</strong>，websocket连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。websocket只需要建立一次连接，就可以一直保持连接状态</p><h2 id="19-2-什么是轮询"><a href="#19-2-什么是轮询" class="headerlink" title="19.2 什么是轮询"></a>19.2 什么是轮询</h2><p><strong>轮询：隔一段时间进行一次查询或者询问</strong></p><p>轮询分为长轮询和短轮询，长轮询是基于短轮询的一个优化结果。</p><p><strong>短轮询：</strong></p><p>通过客户端定期轮询来询问服务端是否有新的信息产生，如果有则返回，没有就不响应， 缺点：也是显而易见，轮询间隔大了则信息不够实时，轮询间隔过小又会消耗过多的流量，增加服务器的负担。</p><p><strong>长轮询：</strong></p><p>是需要服务端进行更改来进行支持，客户端向服务端发送请求时，如果此时服务端没有新的信息产生，并不立刻返回，而是<code>Hold</code>住一段时间等有新的信息或者超时再返回，客户端收到服务器的应答后继续轮询。可以看到长轮询比短轮询可以减少大量无用的请求，并且客户端接收取新消息也会实时不少。减少<code>http</code>请求对性能的优化是很有利的，所以他是短轮询上的一个优化 缺点：终归来讲还是一个<code>http</code>请求，只是进行了变化而已，而且如果客户端不请求，服务端有数据的话，也会一直累积在那，不能实现实时的双向通信</p><p>此时的<code>webSocket</code>也就<strong>应需而生</strong>了</p><h2 id="20-前端怎么做SEO优化"><a href="#20-前端怎么做SEO优化" class="headerlink" title="20. 前端怎么做SEO优化"></a>20. 前端怎么做SEO优化</h2><p><strong>什么是SEO</strong></p><p>SEO(Search Engine Optimization)，即搜索引擎优化。SEO是随着搜索引擎的出现而来的，两者是相互促进，互利共生的关系。SEO的存在就是为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。而优化的目的就是为了提升网站在搜索引擎中的权重，增加对搜索引擎的友好度，使得用户在访问网站时能排在前面。</p><p><strong>为什么要做SEO</strong></p><p>提高网站的权重，增强搜索引擎友好度，以达到提高排名，增加流量，改善（潜在）用户体验，促进销售的作用。</p><p><strong>前端怎么做SEO优化</strong></p><ol><li>网站结构布局优化: 尽量简单<ul><li>控制首页链接数量</li><li>网页层级不要太深</li><li>控制页面大小, 减少HTTP请求, 提高网站的加载速度</li><li>尽量使用语义化标签</li><li>利用浏览器缓存</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
      <tag>HTTPS</tag>
      
      <tag>跨域</tag>
      
      <tag>浏览器</tag>
      
      <tag>TCP/IP</tag>
      
      <tag>DNS</tag>
      
      <tag>三次握手</tag>
      
      <tag>四次挥手</tag>
      
      <tag>token</tag>
      
      <tag>进程</tag>
      
      <tag>线程</tag>
      
      <tag>Cookie</tag>
      
      <tag>SEO优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对微服务的理解</title>
    <link href="/2023/01/29/%E5%AF%B9%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2023/01/29/%E5%AF%B9%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务是什么？"><a href="#微服务是什么？" class="headerlink" title="微服务是什么？"></a>微服务是什么？</h1><p>微服务（microservice）是一种软件架构，正得到越来越多的关注。</p><p>但是，它到底是什么意思？什么样的架构可以叫做微服务？</p><p>网上的文章虽然很多，但是都太复杂，初学者不容易看懂。我认为，这个概念其实非常简单，可以很通俗地说明白。</p><p><img src="https://cdn.beekka.com/blogimg/asset/220204/bg2022042801.webp"></p><h1 id="单体软件"><a href="#单体软件" class="headerlink" title="单体软件"></a>单体软件</h1><p>要理解微服务，首先需要理解软件架构的演变。</p><p>早期的软件，所有功能都写在一起，这称为<strong>单体架构</strong>（monolithic software）。</p><p><img src="https://cdn.beekka.com/blogimg/asset/220204/bg2022042802.webp"></p><p>整个软件就是单一的整体，彷佛一体化的机器。</p><p>可以想到，软件的功能越多，单体架构就会越复杂，很多缺点也随之暴露出来。</p><blockquote><p>（1）所有功能耦合在一起，互相影响，最终难以管理。</p><p>（2）哪怕只修改一行代码，整个软件就要重新构建和部署，成本非常高。</p><p>（3）因为软件做成了一个整体，不可能每个功能单独开发和测试，只能整体开发和测试，导致必须采用瀑布式开发模型。</p></blockquote><p>以上三个原因的详细分析，可以参考我以前的文章<a href="https://www.ruanyifeng.com/blog/2021/05/scaling-problem.html">《软件工程的最大难题》</a>。</p><p><img src="https://cdn.beekka.com/blogimg/asset/220204/bg2022042803.webp"></p><p>总之，单体架构的大型软件，不仅开发速度慢，而且会形成难以维护和升级的复杂代码，成为程序员的沉重负担。</p><h1 id="面向服务架构"><a href="#面向服务架构" class="headerlink" title="面向服务架构"></a>面向服务架构</h1><p>为了解决上面这些问题，很早就有人提出来，必须打破代码的耦合，拆分单体架构，将软件拆分成一个个独立的功能单元。</p><p>大概在20多年前，随着互联网的出现，功能单元可以用远程”服务”的形式提供，就诞生出了”面向服务架构”（service-oriented architecture，简称 SOA）。</p><p><img src="https://cdn.beekka.com/blogimg/asset/220204/bg2022042804.webp"></p><p>所谓服务（service），就是在后台不间断运行、提供某种功能的一个程序。最常见的服务就是 Web 服务，通过80端口向外界提供网页访问。</p><p>“面向服务架构”就是把一个大型的单体程序，拆分成一个个独立服务，也就是较小的程序。每个服务都是一个独立的功能单元，承担不同的功能，服务之间通过通信协议连在一起。</p><p><img src="https://cdn.beekka.com/blogimg/asset/220204/bg2022042805.webp"></p><p>这种架构有很多优点。</p><blockquote><p>（1）每种服务功能单一，相当于一个小型软件，便于开发和测试。</p><p>（2）各个服务独立运行，简化了架构，提高了可靠性。</p><p>（3）鼓励和支持代码重用，同一个服务可以用于多种目的。</p><p>（4）不同服务可以单独开发和部署，便于升级。</p><p>（5）扩展性好，可以容易地加机器、加功能，承受高负载。</p><p>（6）不容易出现单点故障。即使一个服务失败了，不会影响到其他服务。</p></blockquote><p>跟单体架构不一样，面向服务架构是语言不敏感的，不同服务可以使用不同的语言和工具开发，可能需要部署在不同的系统和环境。</p><p>这意味着，<strong>面向服务架构默认运行在不同服务器上</strong>，每台服务器提供一种服务，多台服务器共同组成一个完整的网络应用。</p><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><p>2014年，<a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker</a> 出现了，彻底改变了软件开发的面貌。它让程序运行在容器中，每个容器可以分别设定运行环境，并且只占用很少的系统资源。</p><p><img src="https://cdn.beekka.com/blogimg/asset/220204/bg2022042806.webp"></p><p>显而易见，可以用容器来实现”面向服务架构”，每个服务不再占用一台服务器，而是占用一个容器。</p><p>这样就不需要多台服务器了，最简单的情况下，本机运行多个容器，只用一台服务器就实现了面向服务架构，这在以前是做不到的。这种实现方式就叫做微服务。</p><p><img src="https://cdn.beekka.com/blogimg/asset/220204/bg2022042807.webp"></p><p>简单说，<strong>微服务就是采用容器技术的面向服务架构</strong>。它依然使用”服务”作为功能单元，但是变成了轻量级实现，不需要新增服务器，只需要新建容器（一个进程），所以才叫做”微服务”。</p><p><strong>一个微服务就是一个独立的<a href="https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">进程</a>。</strong> 这个进程可以运行在本机，也可以运行在别的服务器，或者在云端（比如云服务和云函数 FaaS）。</p><p>它的特点与面向服务架构是一样的，但因为更轻量级，所以功能的解耦和服务化可以做得更彻底。而且，它可以标准化，同样的容器不管在哪里运行，结果都是一样的，所以市场上有很多 SaaS 产品，提供标准化的微服务。</p><p>正是由于微服务这些突出的优点，这几年才会变得如此流行。它和容器技术、云服务一起，一定会在未来的软件开发中，扮演越来越重要的角色。</p>]]></content>
    
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>巩固基础CSS知识点</title>
    <link href="/2023/01/29/%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80CSS%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2023/01/29/%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80CSS%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>文中篇概念性的内容也蛮多，小编一如既往的做了分割线，记忆力好的童鞋请自行忽略。</p><hr><h3 id="1-🤨标准的CSS盒子模型及其和低版本的IE盒子模型的区别？"><a href="#1-🤨标准的CSS盒子模型及其和低版本的IE盒子模型的区别？" class="headerlink" title="1.🤨标准的CSS盒子模型及其和低版本的IE盒子模型的区别？"></a>1.🤨标准的CSS盒子模型及其和低版本的IE盒子模型的区别？</h3><p>标准（W3C）盒子模型：<code>width</code> &#x3D; 内容宽度<code>（content） + border + padding + margin</code></p><p>低版本IE盒子模型： <code>width</code> &#x3D; 内容宽度<code>（content + border + padding）+ margin</code></p><p>图片展示:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/30/172633c783abc1eb~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/30/17263443113eb879~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><p>区别： 标准盒子模型盒子的<code>height</code>和<code>width</code>是<code>content</code>（内容）的宽高，而IE盒子模型盒子的宽高则包括<code>content+padding+border</code>部分。</p><h3 id="2-几种解决IE6存在的bug的方法"><a href="#2-几种解决IE6存在的bug的方法" class="headerlink" title="2.几种解决IE6存在的bug的方法"></a>2.几种解决IE6存在的bug的方法</h3><ul><li>由<code>float</code>引起的双边距的问题，使用<code>display</code>解决；</li><li>由<code>float</code>引起的3像素问题，使用<code>display: inline -3px</code>;</li><li>使用正确的书写顺序<code>link visited hover active</code>，解决超链接<code>hover</code>点击失效问题；</li><li>对于<code>IE</code> 的<code>z-index</code>问题，通过给父元素增加<code>position: relative</code>解决；</li><li>使用<code>!important</code>解决<code>Min-height</code>最小高度问题；</li><li>使用<code>iframe</code>解决<code>select</code>在<code>IE6</code>下的覆盖问题；</li><li>使用<code>over: hidden</code>, <code>zoom: 0.08</code>, <code>line-height: 1px</code>解决定义1px左右的容器宽度问题；</li></ul><p>🍀<strong>注意</strong>：有关<code>IE6</code>支不支持<code>!important</code>的问题，对于单个类是支持的。例如：</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-class">.content</span> &#123; <span class="hljs-attribute">color</span>: pink !importent &#125;;<span class="hljs-selector-class">.content</span> &#123; <span class="hljs-attribute">color</span>: orange &#125;;<span class="hljs-comment">// 这里IE6及以上，FF，google等都将显示粉红色</span>复制代码</code></pre></div><p>但是，当一个样式内部有多个相同属性的时候。例如：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.content</span> &#123; <span class="hljs-attribute">color</span>: pink !importent; <span class="hljs-attribute">color</span>: orange &#125;;// IE7及以上，FF, google显示粉红色，而IE6将显示橙色（原因是一个样式内重复设置了属性，后面的就会覆盖掉之前的）复制代码</code></pre></div><h3 id="3-CSS选择符有哪些？哪些属性可以继承？"><a href="#3-CSS选择符有哪些？哪些属性可以继承？" class="headerlink" title="3.CSS选择符有哪些？哪些属性可以继承？"></a>3.CSS选择符有哪些？哪些属性可以继承？</h3><p>常见的选择符有一下：</p><p><code>id</code>选择器（<code>#content</code>），类选择器（<code>.content</code>）, 标签选择器（<code>div</code>, <code>p</code>, <code>span</code>等）, 相邻选择器（<code>h1+p</code>）, 子选择器（<code>ul&gt;li</code>）, 后代选择器（<code>li a</code>）， 通配符选择器（<code>*</code>）, 属性选择器（<code>a[rel = &quot;external&quot;]</code>）， 伪类选择器（<code>a:hover</code>, <code>li:nth-child</code>）</p><p>可继承的样式属性： <code>font-size</code>, <code>font-family</code>, <code>color</code>, <code>ul</code>, <code>li</code>, <code>dl</code>, <code>dd</code>, <code>dt</code>;</p><p>不可继承的样式属性： <code>border</code>, <code>padding</code>, <code>margin</code>, <code>width</code>, <code>height</code>；</p><h3 id="4-CSS优先级算法如何计算？"><a href="#4-CSS优先级算法如何计算？" class="headerlink" title="4.CSS优先级算法如何计算？"></a>4.CSS优先级算法如何计算？</h3><ul><li>考虑到就近原则，同权重情况下样式定义以最近者为准</li><li>载入的样式按照最后的定位为准</li></ul><p>优先级排序：</p><p>同权重情况下： 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）</p><p><code>!important &gt; # &gt; . &gt; tag</code></p><p>🍀<strong>注意</strong>： <code>!important</code> 比 内联优先级高</p><h3 id="5-CSS3新增伪类有那些？"><a href="#5-CSS3新增伪类有那些？" class="headerlink" title="5.CSS3新增伪类有那些？"></a>5.CSS3新增伪类有那些？</h3><ul><li><p><code>:root</code> 选择文档的根元素，等同于<code>html</code>元素</p></li><li><p><code>:empty</code> 选择没有子元素的元素</p></li><li><p><code>:target</code> 选取当前活动的目标元素</p></li><li><p><code>:not(selector)</code> 选择除 <code>selector</code> 元素意外的元素</p></li><li><p><code>:enabled</code> 选择可用的表单元素</p></li><li><p><code>:disabled</code> 选择禁用的表单元素</p></li><li><p><code>:checked</code> 选择被选中的表单元素</p></li><li><p><code>:nth-child(n)</code> 匹配父元素下指定子元素，在所有子元素中排序第<code>n</code></p></li><li><p><code>nth-last-child(n)</code> 匹配父元素下指定子元素，在所有子元素中排序第<code>n</code>，从后向前数</p></li><li><p><code>:nth-child(odd)</code></p></li><li><p><code>:nth-child(even)</code></p></li><li><p><code>:nth-child(3n+1)</code></p></li><li><p><code>:first-child</code></p></li><li><p><code>:last-child</code></p></li><li><p><code>:only-child</code></p></li><li><p><code>:nth-of-type(n)</code> 匹配父元素下指定子元素，在同类子元素中排序第<code>n</code></p></li><li><p><code>:nth-last-of-type(n)</code> 匹配父元素下指定子元素，在同类子元素中排序第<code>n</code>，从后向前数</p></li><li><p><code>:nth-of-type(odd)</code></p></li><li><p><code>:nth-of-type(even)</code></p></li><li><p><code>:nth-of-type(3n+1)</code></p></li><li><p><code>:first-of-type</code></p></li><li><p><code>:last-of-type</code></p></li><li><p><code>:only-of-type</code></p></li><li><p><code>::selection</code> 选择被用户选取的元素部分（伪元素）</p></li><li><p><code>:first-line</code> 选择元素中的第一行（伪元素）</p></li><li><p><code>:first-letter</code> 选择元素中的第一个字符（伪元素）</p></li><li><p><code>:after</code> 在元素在该元素之后添加内容（伪元素）</p></li><li><p><code>:before</code> 在元素在该元素之前添加内容（伪元素）</p></li></ul><h3 id="6-如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"><a href="#6-如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？" class="headerlink" title="6.如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"></a>6.如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</h3><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><div class="code-wrapper"><pre><code class="hljs css">// 方式<span class="hljs-number">1</span>： 使用<span class="hljs-attribute">margin</span>： <span class="hljs-number">0</span> auto居中css:     * &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">background</span>: pink;    &#125;// 方式<span class="hljs-number">2</span>： 使用 定位 + <span class="hljs-attribute">left</span> 居中css:     * &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;    <span class="hljs-selector-class">.content</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">background</span>: pink;        <span class="hljs-attribute">position</span>: absolute;        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);    &#125;    <span class="hljs-selector-tag">html</span>:   &lt;div class=<span class="hljs-string">&quot;content&quot;</span>&gt;&lt;/div&gt;复制代码</code></pre></div><h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><div class="code-wrapper"><pre><code class="hljs css">    <span class="hljs-number">1</span>.已知父元素高度情况下方法<span class="hljs-number">1</span>：css:     * &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;    <span class="hljs-selector-class">.content</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">600px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;    &#125;    <span class="hljs-selector-class">.content-one</span> &#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">background</span>: pink;        <span class="hljs-attribute">position</span>: relative;    // 父元素无定位，子元素直接用相对定位        <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">50%</span>);    &#125;<span class="hljs-selector-tag">html</span>:     &lt;div class=<span class="hljs-string">&quot;content&quot;</span>&gt;       &lt;div class=<span class="hljs-string">&quot;content-one&quot;</span>&gt;&lt;/div&gt;    &lt;/div&gt;方法<span class="hljs-number">2</span>：css: * &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.content</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">600px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;    <span class="hljs-attribute">position</span>: relative;     // 给父元素定位，子绝父相&#125;<span class="hljs-selector-class">.content-one</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">background</span>: pink;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">50%</span>);&#125;<span class="hljs-selector-tag">html</span>:     &lt;div class=<span class="hljs-string">&quot;content&quot;</span>&gt;       &lt;div class=<span class="hljs-string">&quot;content-one&quot;</span>&gt;&lt;/div&gt;    &lt;/div&gt;复制代码</code></pre></div><h4 id="如何让绝对定位的div居中"><a href="#如何让绝对定位的div居中" class="headerlink" title="如何让绝对定位的div居中"></a>如何让绝对定位的div居中</h4><div class="code-wrapper"><pre><code class="hljs css">css:     * &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;        <span class="hljs-attribute">position</span>: absolute;        <span class="hljs-attribute">width</span>: <span class="hljs-number">1500px</span>;        <span class="hljs-attribute">background</span>: pink;        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;    &#125;<span class="hljs-selector-tag">html</span>:     &lt;div class=<span class="hljs-string">&quot;content&quot;</span>&gt;&lt;/div&gt;复制代码</code></pre></div><h3 id="7-display有哪些值？他们的作用是什么？"><a href="#7-display有哪些值？他们的作用是什么？" class="headerlink" title="7.display有哪些值？他们的作用是什么？"></a>7.display有哪些值？他们的作用是什么？</h3><table><thead><tr><th>值</th><th>作用</th></tr></thead><tbody><tr><td>none</td><td>使用后元素将不会显示</td></tr><tr><td>grid</td><td>定义一个容器属性为网格布局</td></tr><tr><td>flex</td><td>定义一个弹性布局</td></tr><tr><td>block</td><td>使用后元素将变为块级元素显示，元素前后带有换行符</td></tr><tr><td>inline</td><td>display默认值。使用后原色变为行内元素显示，前后无换行符</td></tr><tr><td>list-item</td><td>使用后元素作为列表显示</td></tr><tr><td>run-in</td><td>使用后元素会根据上下文作为块级元素或行内元素显示</td></tr><tr><td>table</td><td>使用后将作为块级表格来显示（类似<code>&lt;table&gt;</code>），前后带有换行符</td></tr><tr><td>inline-table</td><td>使用后元素将作为内联表格显示（类似<code>&lt;table&gt;</code>），前后没有换行符</td></tr><tr><td>table-row-group</td><td>元素将作为一个或多个行的分组来显示（类似<code>&lt;tbody&gt;</code>）</td></tr><tr><td>table-hewder-group</td><td>元素将作为一个或多个行的分组来表示（类似<code>&lt;thead&gt;</code>）</td></tr><tr><td>table-footer-group</td><td>元素将作为一个或多个行分组显示（类似<code>&lt;tfoot&gt;</code>）</td></tr><tr><td>table-row</td><td>元素将作为一个表格行显示（类似<code>&lt;tr&gt;</code>）</td></tr><tr><td>table-column-group</td><td>元素将作为一个或多个列的分组显示（类似<code>&lt;colgroup&gt;</code>）</td></tr><tr><td>table-column</td><td>元素将作为一个单元格列显示（类似<code>&lt;col&gt;</code>）</td></tr><tr><td>table-cell</td><td>元素将作为一个表格单元格显示（类似<code>&lt;td&gt;和&lt;th&gt;</code>）</td></tr><tr><td>table-caption</td><td>元素将作为一个表格标题显示（类似<code>&lt;caption&gt;</code>）</td></tr><tr><td>inherit</td><td>规定应该从父元素集成display属性的值</td></tr></tbody></table><p>其中，常用的有：<code>block</code>， <code>inline-block</code>， <code>none</code>， <code>table</code>， <code>line</code>。</p><h3 id="8-position的值relative和absolute定位原点？"><a href="#8-position的值relative和absolute定位原点？" class="headerlink" title="8.position的值relative和absolute定位原点？"></a>8.position的值relative和absolute定位原点？</h3><p>首先，使用<code>position</code>的时候，应该记住一个规律是‘<strong>子绝父相</strong>’。</p><p><code>relative</code>（相对定位）： 生成相对定位的元素，定位原点是元素本身所在的位置；</p><p><code>absolute</code>（绝对定位）：生成绝对定位的元素，定位原点是离自己这一级元素最近的一级<code>position</code>设置为<code>absolute</code>或者<code>relative</code>的父元素的左上角为原点的。</p><p><code>fixed</code> （老IE不支持）：生成绝对定位的元素，相对于浏览器窗口进行定位。</p><p><code>static</code>：默认值。没有定位，元素出现在正常的流中（忽略 <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>、<code>z-index</code> 声明）。</p><p><code>inherit</code>：规定从父元素继承 <code>position</code> 属性的值。</p><p><strong>更新一个属性</strong></p><p><code>sticky</code>: (新增元素，目前兼容性可能不是那么的好)，可以设置 position:sticky 同时给一个 (top,bottom,right,left) 之一即可。</p><p><strong>注意</strong>：</p><ul><li>使用<code>sticky</code>时，必须指定top、bottom、left、right4个值之一，不然只会处于相对定位；</li><li><code>sticky</code>只在其父元素内其效果，且保证父元素的高度要高于<code>sticky</code>的高度；</li><li>父元素不能<code>overflow:hidden</code>或者<code>overflow:auto</code>等属性。</li></ul><h3 id="9-CSS3有哪些新特性？"><a href="#9-CSS3有哪些新特性？" class="headerlink" title="9.CSS3有哪些新特性？"></a>9.CSS3有哪些新特性？</h3><p>关于<code>CSS</code>新增的特性，有以下：</p><ul><li>选择器;</li><li>圆角<code>（border-raduis）</code>;</li><li>多列布局<code>（multi-column layout）</code>;</li><li>阴影<code>（shadow）</code>和反射<code>（reflect）</code>;</li><li>文字特效<code>（text-shadow）</code>;</li><li>文字渲染<code>（text-decoration</code>）;</li><li>线性渐变<code>（gradient）</code>;</li><li>旋转<code>（rotate</code>）&#x2F;缩放<code>（scale）</code>&#x2F;倾斜<code>（skew）</code>&#x2F;移动<code>（translate）</code>;</li><li>媒体查询<code>（@media）</code>;</li><li><code>RGBA</code>和透明度 ;</li><li><code>@font-face</code>属性;</li><li>多背景图 ;</li><li>盒子大小;</li><li>语音;</li></ul><p>大致想到这么多，有遗漏的可以留言指出，小编看到会加上。</p><h3 id="10-用纯CSS创建一个三角形的原理是什么？"><a href="#10-用纯CSS创建一个三角形的原理是什么？" class="headerlink" title="10.用纯CSS创建一个三角形的原理是什么？"></a>10.用纯CSS创建一个三角形的原理是什么？</h3><h4 id="方法一：隐藏上，左，右三条边，颜色设定为（transparent）"><a href="#方法一：隐藏上，左，右三条边，颜色设定为（transparent）" class="headerlink" title="方法一：隐藏上，左，右三条边，颜色设定为（transparent）"></a>方法一：隐藏上，左，右三条边，颜色设定为（transparent）</h4><div class="code-wrapper"><pre><code class="hljs css">css:     * &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;        <span class="hljs-attribute">border-width</span>: <span class="hljs-number">20px</span>;        <span class="hljs-attribute">border-style</span>: solid;        <span class="hljs-attribute">border-color</span>: transparent transparent pink transparent;  // 对应上右下左，此处为 下 粉色    &#125;<span class="hljs-selector-tag">html</span>:     &lt;div class=<span class="hljs-string">&quot;content&quot;</span>&gt;&lt;/div&gt;复制代码</code></pre></div><h4 id="方法二：-采用的是均分原理"><a href="#方法二：-采用的是均分原理" class="headerlink" title="方法二： 采用的是均分原理"></a>方法二： 采用的是均分原理</h4><p>实现步骤： 1.首先保证元素是块级元素；2.设置元素的边框；3.不需要显示的边框使用透明色。</p><div class="code-wrapper"><pre><code class="hljs css">css:     * &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-attribute">width</span>:<span class="hljs-number">0</span>;        <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;        <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> auto;        <span class="hljs-attribute">border</span>:<span class="hljs-number">50px</span> solid transparent;        <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid pink;    &#125;<span class="hljs-selector-tag">html</span>:     &lt;div class=<span class="hljs-string">&quot;content&quot;</span>&gt;&lt;/div&gt;复制代码</code></pre></div><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/172820401d58cdf8~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="11-🤨什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"><a href="#11-🤨什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？" class="headerlink" title="11.🤨什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"></a>11.🤨什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h3><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。</p><p>关于兼容： 页面头部必须有mate声明的<code>viewport</code>。</p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;’viewport’&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;”width=device-width,&quot;</span> <span class="hljs-attribute">initial-scale</span>=<span class="hljs-string">&quot;1.&quot;</span> <span class="hljs-attribute">maximum-scale</span>=<span class="hljs-string">&quot;1,user-scalable=no”&quot;</span>/&gt;复制代码</code></pre></div><h3 id="12-为什么要初始化CSS样式？"><a href="#12-为什么要初始化CSS样式？" class="headerlink" title="12.为什么要初始化CSS样式？"></a>12.为什么要初始化CSS样式？</h3><p>因为浏览器的兼容问题，不同浏览器对标签的默认值是不同的，如果没有对浏览器的<code>CSS</code>初始化，会造成相同页面在不同浏览器的显示存在差异。</p><h3 id="13-浮动原理以及为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"><a href="#13-浮动原理以及为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？" class="headerlink" title="13.浮动原理以及为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"></a>13.浮动原理以及为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</h3><p>非IE浏览器下，容器不设定高度且子元素浮动时，容器高度不能被内容撑开。此时，内容会溢出到容器外面而影响布局。此类现象被称为浮动（溢出）。</p><p>原理：</p><ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）；</li><li>浮动元素碰到包含它的边框或其他浮动元素的边框停留。</li></ul><p>浮动元素碰到包含他的边框或者浮动元素的边框停留。由于浮动元素不在文档流之中，文档流的块级框会表现的就像浮动框不存在一样。浮动元素会漂浮在文档流的块级框之上。</p><p>浮动会带来的问题：</p><ul><li>父级元素的高度将会无法被撑开，会影响与父级元素同级的元素</li><li>与浮动元素同级的非浮动元素（内联元素）会跟随其后</li><li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li></ul><p>清除方式：</p><ul><li>父级盒子定义高度<code>（height）</code>;</li><li>最后一个浮动元素后面加一个<code>div</code>空标签，并且添加样式<code>clear: both</code>;</li><li>包含浮动元素的父级标签添加样式<code>overflow</code>为<code>hidden/both</code>;</li><li>父级<code>div</code>定义<code>zoom</code>;</li></ul><h3 id="14-CSS优化、提高性能的方法有哪些？"><a href="#14-CSS优化、提高性能的方法有哪些？" class="headerlink" title="14.CSS优化、提高性能的方法有哪些？"></a>14.CSS优化、提高性能的方法有哪些？</h3><ul><li>多个<code>css</code>可合并，并尽量减少<code>http</code>请求</li><li>属性值为0时，不加单位</li><li>将<code>css</code>文件放在页面最上面</li><li>避免后代选择符，过度约束和链式选择符</li><li>使用紧凑的语法</li><li>避免不必要的重复</li><li>使用语义化命名，便于维护</li><li>尽量少的使用<code>!impotrant</code>，可以选择其他选择器</li><li>精简规则，尽可能合并不同类的重复规则</li><li>遵守盒子模型规则</li></ul><h3 id="15-CSS预处理器-x2F-后处理器是什么？为什么要使用它们？"><a href="#15-CSS预处理器-x2F-后处理器是什么？为什么要使用它们？" class="headerlink" title="15.CSS预处理器&#x2F;后处理器是什么？为什么要使用它们？"></a>15.CSS预处理器&#x2F;后处理器是什么？为什么要使用它们？</h3><p>预处理器，如：<code>less</code>，<code>sass</code>，<code>stylus</code>,用来预编译<code>sass</code>或者<code>less</code>，增加了<code>css</code>代码的复用性，还有层级，<code>mixin</code>， 变量，循环， 函数等，对编写以及开发UI组件都极为方便。</p><p>后处理器， 如： <code>postCss</code>,通常被视为在完成的样式表中根据<code>css</code>规范处理<code>css</code>，让其更加有效。目前最常做的是给<code>css</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><p><code>css</code>预处理器为<code>css</code>增加一些编程特性，无需考虑浏览器的兼容问题，我们可以在<code>CSS</code>中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让我们的<code>css</code>更加的简洁，增加适应性以及可读性，可维护性等。</p><p>其它<code>css</code>预处理器语言：<code>Sass（Scss</code>）, <code>Less</code>, <code>Stylus</code>, <code>Turbine</code>, <code>Swithch css</code>, <code>CSS Cacheer</code>, <code>DT Css</code>。</p><p>使用原因：</p><ul><li>结构清晰， 便于扩展</li><li>可以很方便的屏蔽浏览器私有语法的差异</li><li>可以轻松实现多重继承</li><li>完美的兼容了<code>CSS</code>代码，可以应用到老项目中</li></ul><h3 id="16-before-和-after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用"><a href="#16-before-和-after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用" class="headerlink" title="16.::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用"></a>16.::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用</h3><p>（1）、冒号(<code>:</code>)用于<code>CSS3</code>伪类，双冒号(<code>::</code>)用于<code>CSS3</code>伪元素。</p><p>（2）、<code>::before</code>就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于<code>dom</code>之中，只存在在页面之中。</p><p>🍀<strong>注意：</strong> <code>:before</code> 和 <code>:after</code> 这两个伪元素，是在<code>CSS2.1</code>里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着<code>Web</code>的进化，在<code>CSS3</code>的规范里，伪元素的语法被修改成使用双冒号，成为<code>::before ::after</code>。</p><h3 id="17-让页面里的字体变清晰，变细用CSS怎么做？"><a href="#17-让页面里的字体变清晰，变细用CSS怎么做？" class="headerlink" title="17.让页面里的字体变清晰，变细用CSS怎么做？"></a>17.让页面里的字体变清晰，变细用CSS怎么做？</h3><p><code>-webkit-font-smoothing</code> 在 <code>window</code> 系统下没有起作用，但是在 <code>IOS</code> 设备上起作用 <code>-webkit-font-smoothing：antialiased</code> 是最佳的，灰度平滑。</p><h3 id="18-如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><a href="#18-如果需要手动写动画，你认为最小时间间隔是多久，为什么？" class="headerlink" title="18. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>18. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h3><p>多数显示器默认频率是<code>60Hz</code>，即1秒刷新60次，所以理论上最小间隔为<code>1/60＊1000ms ＝ 16.7ms</code>。</p><h3 id="19-rgba-和-opacity-的透明效果有什么不同？"><a href="#19-rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="19. rgba() 和 opacity 的透明效果有什么不同？"></a>19. rgba() 和 opacity 的透明效果有什么不同？</h3><p><code>opacity</code> 作用于元素以及元素内的所有内容（包括文字）的透明度；</p><p><code>rgba()</code> 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果；</p><h3 id="20-css-属性-content-有什么作用？"><a href="#20-css-属性-content-有什么作用？" class="headerlink" title="20.css 属性 content 有什么作用？"></a>20.css 属性 content 有什么作用？</h3><p><code>content</code> 属性专门应用在 <code>before/after</code> 伪元素上，用于插入额外内容或样式。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/17282046671bd2f1~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="21-🧐请解释一下-CSS3-的-Flexbox（弹性盒布局模型）以及适用场景？"><a href="#21-🧐请解释一下-CSS3-的-Flexbox（弹性盒布局模型）以及适用场景？" class="headerlink" title="21.🧐请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？"></a>21.🧐请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？</h3><blockquote><p>概念： <code>Flex</code>是<code>Flexible Box</code>的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。采用<code>Flex</code>布局的元素，称为<code>Flex</code>容器<code>（flex container）</code>，简称”容器”。它的所有子元素自动成为容器成员，称为<code>Flex</code>项目<code>（flex item）</code>，简称”项目”。</p></blockquote><p>适用场景： 任何一个容器都可以指定为<code>Flex</code>布局。<code>Flexbox</code> 用于不同尺寸屏幕中创建可自动扩展和收缩布局。</p><h3 id="22-display-inline-block-什么时候会显示间隙？"><a href="#22-display-inline-block-什么时候会显示间隙？" class="headerlink" title="22.display:inline-block 什么时候会显示间隙？"></a>22.display:inline-block 什么时候会显示间隙？</h3><ul><li>有空格时候会有间隙， 可以删除空格解决；</li><li><code>margin</code>正值的时候， 可以让<code>margin</code>使用负值解决；</li><li>使用<code>font-size</code>时候，可通过设置<code>font-size:0</code>、<code>letter-spacing</code>、<code>word-spacing</code>解决；</li></ul><h3 id="23-png、jpg、-jpeg、-bmp、gif-这些图片格式解释一下，分别什么时候用。有没有了解过webp？"><a href="#23-png、jpg、-jpeg、-bmp、gif-这些图片格式解释一下，分别什么时候用。有没有了解过webp？" class="headerlink" title="23. png、jpg、 jpeg、 bmp、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？"></a>23. png、jpg、 jpeg、 bmp、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</h3><p>（1）、<code>png</code>-便携式网络图片<code>（Portable Network Graphics）</code>,是一种无损数据压缩位图文件格式。优点是：压缩比高，色彩好。 大多数地方都可以用。</p><p>（2）、<code>jpg</code>是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在<code>www</code>上，被用来储存和传输照片的格式。</p><p>（3）、<code>gif</code>是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果。</p><p>（4）、<code>bmp</code>的优点： 高质量图片；缺点： 体积太大； 适用场景： <code>windows</code>桌面壁纸；</p><p>（4）、<code>webp</code>格式是谷歌在2010年推出的图片格式，压缩率只有<code>jpg</code>的2&#x2F;3，大小比<code>png</code>小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和<code>opera</code>支持。</p><h3 id="24-在CSS样式中常使用-px、em-在表现上有什么区别？"><a href="#24-在CSS样式中常使用-px、em-在表现上有什么区别？" class="headerlink" title="24. 在CSS样式中常使用 px、em 在表现上有什么区别？"></a>24. 在CSS样式中常使用 px、em 在表现上有什么区别？</h3><p><code>px</code>相对于显示器屏幕分辨率，无法用浏览器字体放大功能。</p><p><code>em</code>值不是固定的，会继承父级的字体大小： <code>em = 像素值 / 父级font-size</code>。</p><h3 id="25-一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度问题怎么解决？"><a href="#25-一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度问题怎么解决？" class="headerlink" title="25.一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度问题怎么解决？"></a>25.一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度问题怎么解决？</h3><p>方案一： <code>.content &#123; height: calc(100%-100px); &#125;</code></p><p>方案二：<code>.container &#123; position:relative; &#125; .content &#123; position: absolute; top: 100px; bottom: 0; &#125;</code></p><p>方案三：<code>.container &#123; display:flex; flex-direction:column; &#125; .content &#123; flex:1; &#125;</code></p><h3 id="26-overflow-scroll-时不能平滑滚动的问题怎么处理？"><a href="#26-overflow-scroll-时不能平滑滚动的问题怎么处理？" class="headerlink" title="26.overflow: scroll 时不能平滑滚动的问题怎么处理？"></a>26.overflow: scroll 时不能平滑滚动的问题怎么处理？</h3><p>监听滚轮事件，然后滚动到一定距离时用 <code>jquery</code> 的 <code>animate</code> 实现平滑效果。</p><h3 id="27-transform、animation和animation-duration的区别？"><a href="#27-transform、animation和animation-duration的区别？" class="headerlink" title="27.transform、animation和animation-duration的区别？"></a>27.transform、animation和animation-duration的区别？</h3><ul><li><code>Transform</code>: 它和<code>width</code>、<code>left</code>一样，定义了元素很多静态样式实现变形、旋转、缩放、移位及透视等功能，通过一系列功能的组合我们可以实现很炫酷的静态效果（非动画)。</li><li><code>Animation</code>: 作用于元素本身而不是样式属性,属于关键帧动画的范畴，它本身被用来替代一些纯粹表现的<code>javascript</code>代码而实现动画,可以通过<code>keyframe</code>显式控制当前帧的属性值。</li><li><code>animation-duration</code>：规定完成动画所花费的时间，以秒或毫秒计。</li></ul><h3 id="28-对-line-height-是如何理解的？"><a href="#28-对-line-height-是如何理解的？" class="headerlink" title="28.对 line-height 是如何理解的？"></a>28.对 line-height 是如何理解的？</h3><p><code>line-height</code>指的是一行字的高度，包含了字间距，实际上是下一行基线到上一行基线的距离。如果一个标签没有定义<code>height</code>属性，那么其最终表现的高度是由<code>line-height</code>决定的。一个容器没有设置高度，那么撑开容器的高度的是<code>line-height</code>,而不是容器内部的文字内容。把<code>line-height</code>值设置为<code>height</code>一样大小的值可以实现单行文字的垂直居中。<code>line-height</code>和<code>height</code>都能撑开一个高度，<code>height</code>会触发<code>haslayout</code>，而<code>line-height</code>不会。</p><h3 id="29-抽离样式模块怎么写？述其思路。"><a href="#29-抽离样式模块怎么写？述其思路。" class="headerlink" title="29.抽离样式模块怎么写？述其思路。"></a>29.抽离样式模块怎么写？述其思路。</h3><p>可将<code>css</code>拆分成两部分： 公共<code>CSS</code>和业务<code>CSS</code>。</p><p>网站的配色，字体，交互提取出为公共的<code>CSS</code>。这部分的<code>CSS</code>命名不应涉及具体的业务。对于业务<code>CSS</code>，需要有统一的命名，使用公共的前缀。</p><h3 id="30-在网页中的应该使用奇数还是偶数的字体？"><a href="#30-在网页中的应该使用奇数还是偶数的字体？" class="headerlink" title="30.在网页中的应该使用奇数还是偶数的字体？"></a>30.在网页中的应该使用奇数还是偶数的字体？</h3><p>在网页中的应该使用“偶数”字体：</p><p>偶数字号相对更容易和 <code>web</code> 设计的其他部分构成比例关系，使用奇数号字体时文本段落无法对齐，宋体的中文网页排布中使用最多的就是 <code>12</code> 和 <code>14</code>。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/1728204b7a73d69c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="31-🤥什么是外边距重叠？-重叠的结果是什么？"><a href="#31-🤥什么是外边距重叠？-重叠的结果是什么？" class="headerlink" title="31. 🤥什么是外边距重叠？ 重叠的结果是什么？"></a>31. 🤥什么是外边距重叠？ 重叠的结果是什么？</h3><p>首先，外边距重叠就是 <code>margin-collapse</code>。相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。 这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距。</p><p>折叠结果遵循下列计算原则：</p><ul><li>两个相邻的外面边距是正数时，折叠结果就是他们之中的较大值；</li><li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值；</li><li>两个外边距一正一负时，折叠结果是两者的相加的和；</li></ul><h3 id="32-display-none-与-visibility-hidden-有什么区别？"><a href="#32-display-none-与-visibility-hidden-有什么区别？" class="headerlink" title="32.display: none; 与 visibility: hidden; 有什么区别？"></a>32.display: none; 与 visibility: hidden; 有什么区别？</h3><p>联系： 这两个属性的值都可以让元素变得不可见；</p><p>区别：</p><ul><li><strong>从占据空间角度看</strong>：<code>display: none;</code>会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden;</code>不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见；</li><li><strong>从继承方面角度看</strong>：<code>display: none;</code>是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；<code>visibility:hidden;</code>是继承属性，子孙节点消失由于继承了<code>hidden</code>，通过设置<code>visibility: visible;</code>可以让子孙节点显式；</li><li><strong>从重绘和重排角度看</strong>：修改常规流中元素的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘 读屏器不会读取<code>display: none;</code>元素内容；会读取<code>visibility: hidden</code>元素内容；</li></ul><h3 id="33-css-hack原理及常用hack有哪些？"><a href="#33-css-hack原理及常用hack有哪些？" class="headerlink" title="33.css hack原理及常用hack有哪些？"></a>33.css hack原理及常用hack有哪些？</h3><p>原理： 利用不同浏览器对<code>CSS</code>的支持和解析结果不一样编写针对特定浏览器的样式。</p><p>常见的<code>hack</code>有： <strong>属性hack</strong>、<strong>选择器hack</strong>、<strong>IE条件注释</strong>。</p><h3 id="34-link-与-import-的区别？"><a href="#34-link-与-import-的区别？" class="headerlink" title="34.link 与 @import 的区别？"></a>34.link 与 @import 的区别？</h3><ul><li><code>link</code> 是<code>HTML</code>方式， <code>@import</code> 是<code>CSS</code>方式；</li><li><code>link</code>最大限度支持并行下载，<code>@import</code> 过多嵌套导致串行下载，出现<code>FOUC</code>；</li><li><code>link</code> 可以通过 <code>rel=&quot;alternate stylesheet&quot;</code> 指定候选样式；</li><li>浏览器对 <code>link</code> 支持早于<code>@import</code> ，可以使用 <code>@import</code>对老浏览器隐藏样式；</li><li><code>@import</code>必须在样式规则之前，可以在css文件中引用其他文件；</li></ul><p>总的来说： <code>link</code>优于<code>@import</code>。</p><h3 id="35-什么是-FOUC-Flash-of-Unstyled-Content-？-如何来避免-FOUC？"><a href="#35-什么是-FOUC-Flash-of-Unstyled-Content-？-如何来避免-FOUC？" class="headerlink" title="35.什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？"></a>35.什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？</h3><p>当使用<code>@import</code>导入<code>CSS</code>时，会导致某些页面在<code>IE</code>出现奇怪的现象： 没有样式的页面内容显示瞬间闪烁，这种现象被称为“文档样式暂时失效”，简称<code>FOUC</code>。</p><p>产生原因： 当样式表晚于结构性html加载时，加载到此样式表时，页面将会停止之前的渲染。等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。</p><p>解决办法： 只要在<code>&lt;head&gt;</code>之间加入一个<code>&lt;link&gt;</code>或者<code>&lt;script&gt;``&lt;/script&gt;</code>元素即可。</p><h3 id="36-display-float-position有什么关系？"><a href="#36-display-float-position有什么关系？" class="headerlink" title="36.display,float,position有什么关系？"></a>36.display,float,position有什么关系？</h3><ul><li>如果 <code>display</code> 为<code>none</code>，那么<code>position</code>和<code>float</code>都不起作用，元素不显示；</li><li>如果<code>position</code>值为<code>absolute</code>或者<code>fixed</code>，元素绝对定位，<code>float</code>的计算值为<code>none</code>，<code>display</code>根据下面的表格进行调整；</li><li>如果<code>float</code>不是<code>none</code>，框是浮动的，<code>display</code>根据下表进行调整；</li><li>其他情况下<code>display</code>的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整 <code>display</code>；</li></ul><h3 id="37-外边距折叠-collapsing-margins"><a href="#37-外边距折叠-collapsing-margins" class="headerlink" title="37.外边距折叠(collapsing margins)"></a>37.外边距折叠(collapsing margins)</h3><p>毗邻的两个或多个<code>margin</code>会合并成一个<code>margin</code>，叫做外边距折叠。规则如下：</p><ul><li>两个或多个毗邻的普通流中的块元素垂直方向上的<code>margin</code>会折叠；</li><li>浮动元素或<code>inline-block</code>元素或绝对定位元素的<code>margin</code>不会和垂直方向上的其他元素的<code>margin</code>折叠；</li><li>创建了块级格式化上下文的元素，不会和它的子元素发生<code>margin</code>折叠；</li><li>元素自身的<code>margin-bottom</code>和<code>margin-top</code>相邻时也会折叠；</li></ul><h3 id="38-有哪几种隐藏元素的方法？"><a href="#38-有哪几种隐藏元素的方法？" class="headerlink" title="38.有哪几种隐藏元素的方法？"></a>38.有哪几种隐藏元素的方法？</h3><ul><li><code>visibility: hidden;</code> 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在；</li><li><code>opacity: 0;``CSS3</code>属性，设置0可以使一个元素完全透明；</li><li><code>position: absolute;</code> 设置一个很大的 left 负值定位，使元素定位在可见区域之外；</li><li><code>display: none;</code> 元素会变得不可见，并且不会再占用文档的空间；</li><li><code>transform: scale(0);</code> 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留；</li><li><code>&lt;div hidden=&quot;hidden&quot;&gt;</code> <code>HTML5</code>属性,效果和<code>display:none;</code>相同，但这个属性用于记录一个元素的状态；</li><li><code>height: 0;</code> 将元素高度设为 0 ，并消除边框；</li><li><code>filter: blur(0);</code> <code>CSS3</code>属性，括号内的数值越大，图像高斯模糊的程度越大，到达一定程度可使图像消失<code>（此处感谢小伙伴支持）</code>；</li></ul><h3 id="39-li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#39-li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="39.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>39.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3><p><code>li</code>排列受到中间空白(回车&#x2F;空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔。解决办法：</p><ul><li>在<code>ul</code>中用<code>font-size：0</code>（谷歌不支持）；可以使用<code>letter-space：-3px;</code></li><li>设置<code>float：left；</code></li></ul><h3 id="40-浏览器是怎样解析CSS选择器的？"><a href="#40-浏览器是怎样解析CSS选择器的？" class="headerlink" title="40.浏览器是怎样解析CSS选择器的？"></a>40.浏览器是怎样解析CSS选择器的？</h3><p>浏览器解析<code>CSS</code>是从上到下，从右到左解析的，这样会提高查找选择器所对应的元素的效率（至于原因，有兴趣的童鞋可以自行去了解）。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/1728204cd6ce8aa0~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="41-🤭全屏滚动的原理是什么？用到了CSS的哪些属性？"><a href="#41-🤭全屏滚动的原理是什么？用到了CSS的哪些属性？" class="headerlink" title="41.🤭全屏滚动的原理是什么？用到了CSS的哪些属性？"></a>41.🤭全屏滚动的原理是什么？用到了CSS的哪些属性？</h3><p>全屏滚动有点类似于轮播，整体的元素一直排列下去，假设有<code>5</code>个需要展示的全屏页面，那么高度是<code>500%</code>，只是展示<code>100%</code>。也可以理解为超出隐藏部分，滚动时显示。</p><p>可能用到的<code>CSS</code>属： <code>overflow:hidden; transform:translate(100%, 100%); display:none;</code></p><p>❤️<strong>拓展</strong> ： 也可以利用全屏视觉滚动差，使用<code>background-attachment: fixed;</code> 来实现全屏效果。（这里是细心的小伙伴提出的另一个idea🤨）</p><h3 id="42-对浏览器内核的理解？"><a href="#42-对浏览器内核的理解？" class="headerlink" title="42.对浏览器内核的理解？"></a>42.对浏览器内核的理解？</h3><p>浏览器内核主要分为两个部分： 渲染引擎和js引擎；</p><ul><li>渲染引擎： 负责取得页面的内容（<code>html</code>，<code>xml</code>， 图像等）、整理讯息（加入<code>css</code>等）、以及计算网页的显示方式，然后对输出至显示器或者打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同。所有网页浏览器、电子邮件客户以及其他所需要编辑、显示网络的应用程序都需要内核。</li><li><code>JS</code>引擎： 解析和执行<code>Javascript</code>来实现网页的动态效果。</li></ul><p>最开始渲染引擎和<code>js</code>引擎没有明确的区分，后来<code>js</code>引擎越来越独立，内核就倾向于只渲染引擎。</p><h3 id="43-对WEB标准以及W3C的理解与认识"><a href="#43-对WEB标准以及W3C的理解与认识" class="headerlink" title="43.对WEB标准以及W3C的理解与认识"></a>43.对WEB标准以及W3C的理解与认识</h3><p>对于结构的要求：（规范的标签可以提高搜索引擎对页面的抓取效率，对<code>SEO</code>很有帮助）</p><ul><li>标签要闭合</li><li>标签字母小写</li><li>标签不允许随意嵌套</li></ul><p>对于<code>CSS</code>和<code>JS</code>来说：</p><ul><li>尽量使用外链<code>CSS</code>样式表和<code>JS</code>脚本。同时结构，表现和行为分为三块，符合规范。此外，还得提高页面渲染速度，提高用户体验。</li><li>尽量少用行内样式，保证结构和表现分离。标签的<code>id</code>和<code>class</code>等的属性命名要做到见文知意，标签越少，加载越快，用户体验就会越高。同时代码方面也会更易于维护，便于改版。</li><li>不需要变动内容，便可一同打印版本而不需要复制内容，提高网站易用性。</li></ul><h3 id="44-制作一个访问量很大的网站，如何管理所有的css文件，js和图片？"><a href="#44-制作一个访问量很大的网站，如何管理所有的css文件，js和图片？" class="headerlink" title="44.制作一个访问量很大的网站，如何管理所有的css文件，js和图片？"></a>44.制作一个访问量很大的网站，如何管理所有的css文件，js和图片？</h3><p>从人手，分工和同步方面回答：</p><ul><li>前期团队必须确认好全局样式，编码模式；</li><li>代码风格，编写习惯保持一致；</li><li>标注样式编写人，各模块都要及时标注（标注关键样式调用的地方）；</li><li>对自己负责的页面进行标注；</li><li><code>CSS</code>和<code>JS</code>分文件夹存并行存放，命名都要统一；</li><li><code>JS</code>分文件夹存放，明明以该<code>JS</code>功能为准的英文翻译；</li><li>图片采用整合的<code>.png</code>格式存放，尽量整合在一起，方便将来管理；</li></ul><h3 id="45-视差滚动效果以及如何实现？"><a href="#45-视差滚动效果以及如何实现？" class="headerlink" title="45.视差滚动效果以及如何实现？"></a>45.视差滚动效果以及如何实现？</h3><p>视差滚动<code>（Parallax Scrolling）</code>指网页滚动过程中，多层次的元素进行不同程度的移动，视觉上形成立体运动效果的网页展示技术（3D效果）。</p><p>实现方式：</p><ul><li><code>CSS3</code>实现： 优点是开发时间相对较短，性能和开发效率比较好。缺点是不能兼容到低版本的浏览器；</li><li><code>JQuery</code>实现：（通过控制不同层滚动速度，计算每一层的时间）优点是能兼容到各个版本，效果可控性好，缺点是开发起来对制作者的要求较高；</li><li>插件实现方式： 例如使用<code>parallax-scrolling</code>,兼容性十分好；</li></ul><h3 id="46-对BFC规范-块级格式化上下文：block-formatting-context-的理解"><a href="#46-对BFC规范-块级格式化上下文：block-formatting-context-的理解" class="headerlink" title="46.对BFC规范(块级格式化上下文：block formatting context)的理解"></a>46.对BFC规范(块级格式化上下文：block formatting context)的理解</h3><p><code>BFC</code>规定了内部的<code>Block Box</code>如何布局。一个页面是由很多个<code>Box</code>组成的，元素的类型和<code>display</code>属性，决定了这个<code>Box</code>的类型。不同类型的<code>box</code>，会参与不同的<code>Formatting Context</code>（决定如何渲染文档的容器），因此<code>Box</code>内的元素会以不用的方式渲染，也是就是说<code>BFC</code>内部的元素和外部的元素不会相互影响。</p><p>定位方案：</p><ul><li>内部的<code>box</code>会在垂直方向上一个接一个的放置；</li><li><code>box</code>垂直方向的距离由<code>margin</code>决定，属于同一个<code>BFC</code>的两个相邻<code>Box</code>的<code>margin</code>会发生重叠；</li><li>每个元素<code>margin box</code>的左边，与包含块<code>border box</code>的左边相接触；</li><li><code>BFC</code>的区域不会与float box重叠；</li><li><code>BFC</code>是页面上的一个隔离的独立容器，容器里面的元素不会影响到外面的元素；</li><li>计算<code>BFC</code>的高度时，浮动元素也会参与计算。</li></ul><p>满足下列条件之一就可以出发BFC：</p><ul><li>根元素变化，即<code>html</code>；</li><li><code>float</code>的值不为<code>none</code>（默认）；</li><li><code>overflow</code>的值不为<code>visible</code>（默认）；</li><li><code>display</code>的值为<code>inline-block</code>, <code>tabke-cell</code>，<code>table-caption</code>；</li><li><code>position</code>的值为<code>absolute</code>或<code>fixed</code>;</li></ul><h3 id="47-元素竖向的百分比设定是相对于容器的高度吗？"><a href="#47-元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="47.元素竖向的百分比设定是相对于容器的高度吗？"></a>47.元素竖向的百分比设定是相对于容器的高度吗？</h3><p>一般来说，子元素的百分比单位都是以父元素为依据。但是<code>margin</code>和<code>padding</code>例外。元素的<code>height</code>是相对于容器的高度，但是元素的<code>margin</code>和<code>padding</code>是相对于容器的宽度。</p><h3 id="48-一个满屏’品字’布局如何设计"><a href="#48-一个满屏’品字’布局如何设计" class="headerlink" title="48.一个满屏’品字’布局如何设计?"></a>48.一个满屏’品字’布局如何设计?</h3><p>方法有挺多种，但是比较简单的方式就是： 上面的<code>div</code>宽度设置为100%，底下两个<code>div</code>设置成<code>50%</code>，并使用<code>float</code>或者<code>inline</code>使其保持在同一行即可（具体的样式可以自己微调）。如下：</p><div class="code-wrapper"><pre><code class="hljs css">css: .content &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;&#125;<span class="hljs-selector-class">.top</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">40%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">background-color</span>: pink;    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">30%</span>;&#125;<span class="hljs-selector-class">.left</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">45%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">background-color</span>: pink;    <span class="hljs-attribute">float</span>: left;&#125;<span class="hljs-selector-class">.right</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">45%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">background-color</span>: pink;    <span class="hljs-attribute">float</span>: right;&#125;<span class="hljs-selector-tag">html</span>: &lt;div class=<span class="hljs-string">&quot;content&quot;</span>&gt;    &lt;div class=<span class="hljs-string">&quot;top&quot;</span>&gt;&lt;/div&gt;    &lt;div class=<span class="hljs-string">&quot;left&quot;</span>&gt;&lt;/div&gt;    &lt;div class=<span class="hljs-string">&quot;right&quot;</span>&gt;&lt;/div&gt;&lt;/div&gt;&gt;复制代码</code></pre></div><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/1/1726ed981ba3eb0a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><h3 id="49-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？"><a href="#49-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？" class="headerlink" title="49.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？"></a>49.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</h3><p>（1）、问题：<code>png24</code>位的图片在<code>ie</code>浏览器上出现背景。解决： 做成<code>png8</code>；</p><p>（2）、问题：浏览器默认的<code>margin</code>和<code>padding</code>不同。 解决： 添加一个全局的<code>*&#123; margin： 0; padding： 0;&#125;</code>；</p><p>（3）、问题：<code>IE</code>下,可以使用获取常规属性的方法来获取自定义属性,也可以使用<code>getAttribute()</code>获取自定义属性，而<code>Firefox</code>下,只能使用<code>getAttribute()</code>获取自定义属性。 解决： 统一通过<code>getAttribute()</code>获取自定义属性；</p><p>（4）、问题： <code>IE</code>下,<code>event</code>对象有<code>x</code>,<code>y</code>属性,但是没有<code>pageX</code>,<code>pageY</code>属性，而<code>Firefox</code>下,<code>event</code>对象有<code>pageX</code>,<code>pageY</code>属性,但是没有<code>x</code>,<code>y</code>属性。 解决： 使用<code>mX(mX = event.x ? event.x : event.pageX;)</code>来代替<code>IE</code>下的<code>event.x</code>或者<code>Firefox</code>下的<code>event.pageX</code>。</p><h3 id="50-box-sizing-常用的属性有哪些？分别有什么作用？"><a href="#50-box-sizing-常用的属性有哪些？分别有什么作用？" class="headerlink" title="50.box-sizing 常用的属性有哪些？分别有什么作用？"></a>50.box-sizing 常用的属性有哪些？分别有什么作用？</h3><ul><li><code>box-sizing: content-box;</code> &#x2F;&#x2F; 默认的标准<code>(W3C)</code>盒模型元素效果；</li><li><code>box-sizing: border-box;</code> &#x2F;&#x2F; 触发怪异<code>(IE)</code>盒模型元素的效果；</li><li><code>box-sizing: inherit;</code> &#x2F;&#x2F; 继承父元素 <code>box-sizing</code> 属性的值；</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/1728204f634255b2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="51-🤤在网页中的应该使用奇数还是偶数的字体？"><a href="#51-🤤在网页中的应该使用奇数还是偶数的字体？" class="headerlink" title="51. 🤤在网页中的应该使用奇数还是偶数的字体？"></a>51. 🤤在网页中的应该使用奇数还是偶数的字体？</h3><p>一般情况下，在网页中，应该使用 <strong>偶数</strong> 字体。原因：</p><ul><li>偶数字号相对更容易和<code>web</code>设计的其他部分构成比例关系；</li><li>使用基数字号时文本段落无法对齐；</li><li>宋体的中文网页排布中使用最多的是12号和14号。</li></ul><h3 id="52-margin和padding分别适合什么场景使用？"><a href="#52-margin和padding分别适合什么场景使用？" class="headerlink" title="52. margin和padding分别适合什么场景使用？"></a>52. margin和padding分别适合什么场景使用？</h3><p>（1）、需要在<code>border</code>外侧添加空白且空白处不需要背景（色），或上下相连的两个盒子之间的空白需要相互抵消时，可以使用<code>margin</code>；</p><p>（2）、需要在<code>border</code>内侧添加空白且空白处需要背景（色），或上下相连的两个盒子之间的空白，希望等于两者之和时，可以使用<code>padding</code>。</p><h3 id="53-伪元素和伪类的区别和作用？"><a href="#53-伪元素和伪类的区别和作用？" class="headerlink" title="53. 伪元素和伪类的区别和作用？"></a>53. 伪元素和伪类的区别和作用？</h3><p>首先，伪类的效果可以通过添加实际的类来实现，而伪元素的效果可以通过添加实际的元素来实现。所以它们的<strong>本质区别就是是否抽象创造了新元素</strong>。</p><p>伪元素&#x2F;伪对象： 不存在在DOM文档中，是虚拟的元素，是创建新元素。代表某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>::first-child &#123;<span class="hljs-attribute">color</span>: red&#125;复制代码</code></pre></div><p>伪类：存在<code>DOM</code>文档中，逻辑上存在但在文档树中却无须标识的“幽灵”分类。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-number">#FF00FF</span>&#125;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<span class="hljs-attribute">color</span>: red&#125;复制代码</code></pre></div><p>🍀<strong>注意</strong>：</p><ul><li>伪类只能使用“：”；</li><li>而伪元素既可以使用“:”，也可以使用“::”；</li><li>因为伪类是类似于添加类所以可以是多个，而伪元素在一个选择器中只能出现一次，并且只能出现在末尾。</li></ul><h3 id="54-before-和-after-中双冒号和单冒号有什么区别？"><a href="#54-before-和-after-中双冒号和单冒号有什么区别？" class="headerlink" title="54. ::before 和 :after 中双冒号和单冒号有什么区别？"></a>54. ::before 和 :after 中双冒号和单冒号有什么区别？</h3><ul><li>在 <code>CSS</code> 中伪类一直用 : 表示，如 <code>:hover</code>, <code>:active</code> 等；</li><li>伪元素在<code>CSS1</code>中已存在，当时语法是用 : 表示，如 <code>:before</code> 和<code>:after</code>；</li><li>后来在<code>CSS3</code>中修订，伪元素用 <code>::</code> 表示，如 <code>::before</code> 和 <code>::after</code>，以此区分伪元素和伪类；</li><li>由于低版本<code>IE</code>对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 <code>:after</code> 这种老语法表示伪元素；</li></ul><p>综上所述：<code>::before</code> 是<code>CSS3</code>中写伪元素的新语法； <code>:after</code>是 <code>CSS1</code> 中存在的、兼容<code>IE</code>的老语法。</p><h3 id="55-怎么让Chrome支持小于12px-的文字？"><a href="#55-怎么让Chrome支持小于12px-的文字？" class="headerlink" title="55. 怎么让Chrome支持小于12px 的文字？"></a>55. 怎么让Chrome支持小于12px 的文字？</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.shrink</span> &#123;    -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.8</span>);    -o-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);    <span class="hljs-attribute">display</span>: inilne-block;&#125;复制代码</code></pre></div><h3 id="56-将多个元素设置为同一行-清除浮动有几种方式"><a href="#56-将多个元素设置为同一行-清除浮动有几种方式" class="headerlink" title="56. 将多个元素设置为同一行?清除浮动有几种方式?"></a>56. 将多个元素设置为同一行?清除浮动有几种方式?</h3><p>将多个元素设置为同一行的方法： 使用<code>float</code>或<code>inline-block</code>；</p><p>清除浮动的方式：</p><ul><li>添加新的元素，应用<code>clear： both</code>；</li><li>父级<code>div</code>定义<code>overflow：hidden</code>;</li><li>利用<code>：after</code>和<code>：before</code>来在元素内部插入两个元素块，从而达到清除浮动的效果。</li></ul><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.clear</span> &#123; zoom:<span class="hljs-number">1</span>; &#125;<span class="hljs-selector-class">.clear</span><span class="hljs-selector-pseudo">:after</span> &#123;   <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot; &quot;</span>;   <span class="hljs-attribute">clear</span>:both;  <span class="hljs-attribute">display</span>:block;  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">overflow</span>:hidden;  <span class="hljs-attribute">visibility</span>:hidden;&#125;复制代码</code></pre></div><h3 id="57-css-hack概念以及简述几个css-hack"><a href="#57-css-hack概念以及简述几个css-hack" class="headerlink" title="57. css hack概念以及简述几个css hack?"></a>57. css hack概念以及简述几个css hack?</h3><blockquote><p><strong>概念</strong>： <code>CSS hack</code>是通过在<code>CSS</code>样式中加入一些特殊的符号，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号是有标准的，<code>CSS hack</code>就是让你记住这个标准），以达到应用不同的<code>CSS</code>样式的目的。</p></blockquote><p>（1）、图片间隙</p><p>在<code>div</code>中插入图片，图片会将<code>div</code>下方撑大<code>3px</code>：</p><ul><li><code>hack1</code>： 将<code>&lt;div&gt;</code>与<code>&lt;img&gt;</code>写在同一行；</li><li><code>hack2</code>： 给<code>&lt;img&gt;</code>添加<code>display：block</code>；</li></ul><p><code>dt</code> <code>li</code> 中的图片间隙：</p><ul><li><code>hack1:</code> 给<code>&lt;img&gt;</code>添加<code>display：block</code>；</li></ul><p>（2）、默认高度，<code>IE6</code>以下版本中，部分块元素，拥有默认高度（低于18px）：</p><ul><li><code>hack1</code>： 给元素添加： <code>font-size： 0</code>；</li><li><code>hack2</code>： 声明： <code>overflow： hidden</code>；</li></ul><p>表单行高不一致：</p><ul><li><code>hack1</code>： 给表单添加声明： <code>float： left; height: ; border: 0</code>;</li></ul><p>鼠标指针：</p><ul><li><code>hack</code>： 若统一某一元素鼠标指针为手型：<code>cursor： pointer;</code>,当li内的a转化为块元素时，给<code>a</code>设置<code>float</code>，<code>IE</code>里面会出现阶梯状；</li><li><code>hack1</code>： 给<code>a</code>添加<code>display： inline-block</code>;</li><li><code>hack2</code>： 给<code>li</code>添加<code>float: left</code>;</li></ul><h3 id="58-css2-0-和css3-0对比有什么不同？"><a href="#58-css2-0-和css3-0对比有什么不同？" class="headerlink" title="58. css2.0 和css3.0对比有什么不同？"></a>58. css2.0 和css3.0对比有什么不同？</h3><p><code>CSS3</code>加强了<code>CSS2</code>的功能，增加了新的属性和新的标签，并且删除了一些冗余的标签，在布局方面减少了代码量。以前比较复杂的布局，现在使用一个属性就能解决（例如<code>columns</code>等）。在展示型效果方面还加入了更多的效果（如动画，阴影，圆角等），在盒子模型和列表模块都有了改进。但是<code>CSS3</code>就兼容性而言，还是有些不足之处是，只能支持一些高版本的浏览器。</p><h3 id="59-块级元素、行内元素和空元素定义？"><a href="#59-块级元素、行内元素和空元素定义？" class="headerlink" title="59. 块级元素、行内元素和空元素定义？"></a>59. 块级元素、行内元素和空元素定义？</h3><ul><li><strong>行内元素</strong>：和有他元素都在一行上，高度、行高及外边距和内边距都不可改变，文字图片的宽度不可改变，只能容纳文本或者其他行内元素；</li><li><strong>块级元素</strong>：总是在新行上开始，高度、行高及外边距和内边距都可控制，可以容纳内敛元素和其他元素；</li><li><strong>空元素</strong>：在<code>HTML</code>元素中，没有内容的 <code>HTML</code> 元素被称为空元素。空元素是在开始标签中关闭的。<code>&lt;br&gt;</code> 就是没有关闭标签的空元素。</li></ul><h3 id="60-如何解决特定浏览器的样式问题？"><a href="#60-如何解决特定浏览器的样式问题？" class="headerlink" title="60. 如何解决特定浏览器的样式问题？"></a>60. 如何解决特定浏览器的样式问题？</h3><p>建议方案： 主张向前兼容，不考虑向后兼容。根据产品的用户群中各大浏览器，来考虑需要兼容的浏览器。</p><p>可以把浏览器分为两类： 一类是历史遗留浏览器，一类是现代浏览器。根据这个分类开发两个版本的网站，然后自己来定义哪些浏览器是历史遗留版本。</p><p>在用户使用历史遗留版本的时候，通过通告栏告知用户使用现代浏览器，获取更多的功能，拥有更好的用户体验等（升级）。当用户的浏览器不能兼容时，提示用户只是使用什么版本的浏览器才能使用网站（下载可以兼容的浏览器）。</p><p>🍀<strong>注意</strong>：项目开始前就需要确认兼容支持的最低版本是多少，以此设计一个对应的兼容方案。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/1728205163289fcb~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="61-🥴浏览器如何判断元素是否匹配某个CSS选择器？"><a href="#61-🥴浏览器如何判断元素是否匹配某个CSS选择器？" class="headerlink" title="61. 🥴浏览器如何判断元素是否匹配某个CSS选择器？"></a>61. 🥴浏览器如何判断元素是否匹配某个CSS选择器？</h3><p>浏览器先产生一个集合，这个集合往往由最后一个部分的索引产生（如果没有索引就是所有元素的集合）。然后向上匹配，如果不符合上一个部分，就把元素从集合中删除，直到这个选择器都匹配完，还在集合中的元素就匹配这个选择器了。</p><h3 id="62-描述css-reset的作用和用途？"><a href="#62-描述css-reset的作用和用途？" class="headerlink" title="62. 描述css reset的作用和用途？"></a>62. 描述css reset的作用和用途？</h3><p><code>Reset</code>重置浏览器的<code>CSS</code>默认属性，浏览器的品种不同，样式不同时，将他们重置，让他们统一。</p><h3 id="63-css-sprites是什么？如何使用？"><a href="#63-css-sprites是什么？如何使用？" class="headerlink" title="63. css sprites是什么？如何使用？"></a>63. css sprites是什么？如何使用？</h3><p><code>css</code>精灵图，把一堆小的图片整合到一张大的图片（png）上，利用<code>CSS</code>的<code>“background-image”</code>，<code>“background- repeat”``，“background-position”</code>的组合进行背景定位<code>background-position</code>可以用数字能精确的定位出背景图片的位置，减轻服务器对图片的请求数量。</p><h3 id="64-css-sprites的优缺点？"><a href="#64-css-sprites的优缺点？" class="headerlink" title="64. css sprites的优缺点？"></a>64. css sprites的优缺点？</h3><p><strong>优点：</strong></p><ul><li>利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而大大提高了页面的性能，这也是<code>CSS Sprites</code>最大的优点；</li><li><code>CSS Sprites</code>能减少图片的字节，曾经多次比较过，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li></ul><p><strong>缺点：</strong></p><ul><li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li><li><code>CSSSprites</code>在开发的时候相对来说有点麻烦，需要借助<code>photoshop</code>或其他工具来对每个背景单元测量其准确的位置。</li><li>维护方面：<code>CSS Sprites</code>在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的<code>CSS</code>，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动<code>CSS</code>。</li></ul><p><strong>拓展：</strong> 目前网站开发所用的精灵图（如字体库）一般都是直接用云端，而不是采用这种本地的了，如阿里图标库等。</p><h3 id="65-绝对定位和浮动的区别和应用？"><a href="#65-绝对定位和浮动的区别和应用？" class="headerlink" title="65. 绝对定位和浮动的区别和应用？"></a>65. 绝对定位和浮动的区别和应用？</h3><p><strong>绝对定位</strong>： 绝对定位脱离标准文档流，它的参考点是文档的左上角或者是右上角。如果有任何父元素有定位属性，此时就可以参考“<strong>子绝父相</strong>”定律来设置自己的定位参考元素。在网页制作过程中很灵活。制作覆盖效果的时候，会大量使用绝对定位。</p><p><strong>浮动</strong>： 浮动脱离标准文档流，通常用于制作并排显示的元素，通常用于大的布局，或者无序列表比如图片的并排。可以使用<code>clear:both</code>属性让标准流中的其他元素在此之后依次排列。</p><h3 id="66-当float和margin同时使用时，如何解决IE6的双倍边距？"><a href="#66-当float和margin同时使用时，如何解决IE6的双倍边距？" class="headerlink" title="66. 当float和margin同时使用时，如何解决IE6的双倍边距？"></a>66. 当float和margin同时使用时，如何解决IE6的双倍边距？</h3><p>当浮动的方向和<code>margin</code>是同方向的时候，此时IE6会在这个方向的第一个元素身上产生双倍<code>margin</code>。</p><p>解决办法：</p><p>（1）、改变<code>margin</code>的方向，<code>float:left; margin-right:20px;</code> 浮动向左，<code>margin</code>向右； （2）、给第一个元素单独写一个类叫做<code>.content</code>, 此时<code>.content&#123;_margin-left:一半的margin;&#125;</code>； （3）、用<code>display:inline;</code>不用浮动了（哈哈哈哈）。</p><h3 id="67-简述什么是内容与表现分离？"><a href="#67-简述什么是内容与表现分离？" class="headerlink" title="67. 简述什么是内容与表现分离？"></a>67. 简述什么是内容与表现分离？</h3><p>首先对于<code>html</code>，<code>css</code>以及<code>javascript</code>，可以这样理解：</p><p>把网站理解成一个人，<code>html</code>就是构成人体的‘骨架’，<code>css</code>就是人体的‘装饰’，比如衣服，饰品等；而<code>javascript</code>就相当于人做出的‘动作’，这样就通俗易懂了。</p><p>对于内容和表现分离，小编的理解是：尽量不要再<code>html</code>中插入行内样式，尽量将css抽成一个独立的模块，实现<code>html</code>‘骨架’和样式的分离，利于搜索引擎的同时，也便于后期维护。</p><h3 id="68-CSS怎样判断不同分辨率显示不同宽度布局，从而实现自适应宽度？"><a href="#68-CSS怎样判断不同分辨率显示不同宽度布局，从而实现自适应宽度？" class="headerlink" title="68. CSS怎样判断不同分辨率显示不同宽度布局，从而实现自适应宽度？"></a>68. CSS怎样判断不同分辨率显示不同宽度布局，从而实现自适应宽度？</h3><ul><li>使用百分比布局，用百分比来写宽度、<code>marign</code>、<code>padding</code>；</li><li>使用<code>rem</code>做单位，适当的写<code>js``让html</code>根元素的字号随着浏览器宽度的变化而等比例变化；</li><li>使用媒体查询让不同宽度的浏览器使用不同的样式表。</li></ul><h3 id="69-rem为什么可以缩放，以什么为基准？其优缺点有哪些？"><a href="#69-rem为什么可以缩放，以什么为基准？其优缺点有哪些？" class="headerlink" title="69.rem为什么可以缩放，以什么为基准？其优缺点有哪些？"></a>69.rem为什么可以缩放，以什么为基准？其优缺点有哪些？</h3><p><code>rem``以html</code>的字号为基准，比如<code>2rem</code>，而<code>html</code>的字号时<code>16px</code>，此时<code>rem</code>就是<code>32px</code>。可以写一段<code>js</code>让<code>html</code>根元素的字号随着浏览器宽度的变化而等比例变化，此时造成页面等比例缩放的现象。</p><p><strong>优点</strong>：</p><p>相对于<code>em</code>的好处来说，不会发生逐渐增大或者减小字体尺寸的情况，因为始终集成根元素的字体大小；<code>rem</code>单位不仅仅是可应用于字体大小，还可以用于设定高度等其它大小，使页面可以适配不同屏幕尺寸。</p><p>🍀<strong>注意</strong>： <code>rem</code> 一般只用于移动端。</p><h3 id="70-5条常见的Firefox和IE的脚本兼容的问题。"><a href="#70-5条常见的Firefox和IE的脚本兼容的问题。" class="headerlink" title="70. 5条常见的Firefox和IE的脚本兼容的问题。"></a>70. 5条常见的Firefox和IE的脚本兼容的问题。</h3><ul><li><strong>绑定监听</strong>： <code>IE</code>是<code>attatchEvent()</code> 、 <code>firefox</code>是<code>addEventListener()</code>;</li><li><strong>计算样式</strong>：<code>IE</code>是<code>currentStyle</code>、 <code>firefox</code>是<code>getComputedSyle</code>;</li><li><strong>滚动事件</strong>：<code>IE</code>是<code>MouseWheel</code>、 <code>firefox</code>是<code>onmousewheel</code>；</li><li><strong>表单元素</strong>：<code>IE</code>是 <code>document.forms(”formname”)</code> ， <code>firefox</code>是<code>document.forms[&quot;formname&quot;]</code>；</li><li><strong>事件对象</strong>： <code>IE</code>是<code>window.event</code>属性， <code>firefox</code>必须给事件处理函数注入实参<code>event</code>；</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/17282053da3df444~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="71-🥳css的优先级如何计算？"><a href="#71-🥳css的优先级如何计算？" class="headerlink" title="71. 🥳css的优先级如何计算？"></a>71. 🥳css的优先级如何计算？</h3><p>巩固一下：</p><table><thead><tr><th>分类</th><th>优先级</th></tr></thead><tbody><tr><td>元素选择符</td><td>1</td></tr><tr><td>class选择器</td><td>10</td></tr><tr><td>id选择器</td><td>100</td></tr><tr><td>元素标签</td><td>1000</td></tr></tbody></table><p>（1）、<code>!important</code>声明的样式优先级最高，若有冲突会再进行计算；</p><p>（2）、优先级相同时，以最后出现的样式为准；</p><p>（3）、继承得到的样式的优先级是最低的。</p><h3 id="72-回顾position的值及其作用？"><a href="#72-回顾position的值及其作用？" class="headerlink" title="72. 回顾position的值及其作用？"></a>72. 回顾position的值及其作用？</h3><ul><li><code>static</code>（默认）：按照正常文档流进行排列；</li><li><code>relative</code>（相对定位）： 不脱离文档流，参考自身静态位置通过<code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>定位；</li><li><code>absolute</code>（绝对定位）： 参考距离最近一个不为<code>static</code>的父级元素通过<code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>定位；</li><li><code>fixed</code>（固定定位）： 所固定的参照对象是可视窗口。</li></ul><h3 id="73-有哪几种高等布局？"><a href="#73-有哪几种高等布局？" class="headerlink" title="73.有哪几种高等布局？"></a>73.有哪几种高等布局？</h3><ul><li>假等高列：使用背景图片，在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假象；</li><li>给容器的<code>div</code>使用单独的背景色（固定布局）（流体布局）：用元素中的最大高度撑起其他容器的高度；</li><li>创建带边框的两列等高布局： 用<code>border-left</code>来做，之鞥呢使用两列；</li><li>使用正<code>padding</code>和负<code>margin</code>对冲实现多列布局方法： 在所有列中使用的上，下<code>padding</code>和负的上，下<code>margin</code>，并在所有列外面加上一个容器，设置<code>overflow： hidden</code>，把溢出的背景切掉。</li><li>使用边框和定位模拟列等高： 但不能使用在多列；</li><li>模仿表格布局等高列效果： 兼容性不好，在<code>ie6-7</code>中无法正常运行；</li></ul><h3 id="74-link、-visited、-hover、-active的执行顺序是怎么样的？"><a href="#74-link、-visited、-hover、-active的执行顺序是怎么样的？" class="headerlink" title="74. :link、:visited、:hover、:active的执行顺序是怎么样的？"></a>74. :link、:visited、:hover、:active的执行顺序是怎么样的？</h3><p><code>L-V-H-A</code>，<code>l(link)ov(visited)e h(hover)a(active)te</code>，即用喜欢和讨厌两个词来概括。</p><h3 id="75-经常遇到的浏览器兼容性有哪些？如何解决？"><a href="#75-经常遇到的浏览器兼容性有哪些？如何解决？" class="headerlink" title="75. 经常遇到的浏览器兼容性有哪些？如何解决？"></a>75. 经常遇到的浏览器兼容性有哪些？如何解决？</h3><ul><li>浏览器默认的<code>margin</code>和<code>padding</code>不同；</li><li><code>IE6</code>双边距<code>bug</code>；</li><li>在<code>IE6-7</code>中元素高度超出自己设置的高度。原因是IE8以前的浏览器中会给元素设置偶人的行高的高度所导致的；</li><li><code>min-height</code>在<code>IE6</code>下不起作用；</li><li>透明性<code>IE</code>用<code>filter：Alpha（Opacity=60）</code>,而其它主流浏览器用<code>opacity： 0.6</code>；</li><li><code>input</code>边框问题，去掉<code>input</code>边框一般用<code>border：none；</code>就可以但是由于<code>IE6</code>在解析<code>input</code>样式时<code>bug</code>（优先级问题），在<code>IE6</code>下无效；</li></ul><h3 id="76-为什么要语义化以及对于标签语义化的理解？"><a href="#76-为什么要语义化以及对于标签语义化的理解？" class="headerlink" title="76. 为什么要语义化以及对于标签语义化的理解？"></a>76. 为什么要语义化以及对于标签语义化的理解？</h3><p>原因： <strong>为了在没有css的情况下，页面也能呈现出很好的内筒结构和代码架构（可以理解为为了裸奔时好看哈哈哈）</strong>。</p><p>理解：</p><ul><li>去掉或者丢失样式的时候能够让页面呈现清晰的结构；</li><li>有利于<code>SEO</code>，可以和搜索引擎建立良好的沟通，有助于爬虫抓取更多的有效信息（爬虫依赖于标签来确定上下文和各个关键字的权重）；</li><li>方便其他设备解析（如屏幕阅读器，盲人阅读器，移动设备等），以意义的方式来渲染网页；</li><li>便于团队的开发和维护，语义化更具有可读性，遵循<code>W3C</code>标准的团队都遵循这个标准，可以减少代码差异化；</li></ul><h3 id="77-常见的CSS布局有几种？"><a href="#77-常见的CSS布局有几种？" class="headerlink" title="77. 常见的CSS布局有几种？"></a>77. 常见的CSS布局有几种？</h3><p>常见的<code>CSS</code>布局有： <strong>固定布局</strong>、<strong>流式布局</strong>、<strong>弹性布局</strong>、<strong>浮动布局</strong>、<strong>定位布局</strong>、<strong>margin和padding</strong>。</p><h3 id="78-position的absolute与fixed共同点与不同点？"><a href="#78-position的absolute与fixed共同点与不同点？" class="headerlink" title="78. position的absolute与fixed共同点与不同点？"></a>78. position的absolute与fixed共同点与不同点？</h3><p>相同点：</p><ul><li>改变行内元素的呈现方式，<code>display</code>被设置为<code>block</code>；</li><li>让元素脱离普通流，不占据空间；</li><li>默认会覆盖到非定位元素上；</li></ul><p>不同点：</p><ul><li><code>absolute</code>的“根元素”是可以设置的，而<code>fixed</code>的“根元素”固定为浏览器窗口；</li><li>当滚动网页时，<code>fixed</code>元素与浏览器窗口之间的距离是不变的。</li></ul><h3 id="79-CSS哪些属性可以继承？哪些属性不可以继承？"><a href="#79-CSS哪些属性可以继承？哪些属性不可以继承？" class="headerlink" title="79. CSS哪些属性可以继承？哪些属性不可以继承？"></a>79. CSS哪些属性可以继承？哪些属性不可以继承？</h3><ul><li>可以继承的样式属性： <code>font-size</code>、<code>font-family</code>、<code>color</code>、<code>list-style</code>、<code>cursor</code>、<code>ul</code>, <code>li</code>, <code>dl</code>, <code>dd</code>, <code>dt</code>;</li><li>不可继承的样式属性： <code>width</code>、<code>height</code>、 <code>border</code>、 <code>padding</code>、 <code>margin</code>、 <code>background</code>；</li></ul><p>🍀<strong>注意</strong>： 为了便于理解，小编觉得可以大致理解为<strong>字体相关的样式可以继承，与尺寸相关的样式不可继承</strong>。</p><h3 id="80-使用过的-CSS-预处理器？"><a href="#80-使用过的-CSS-预处理器？" class="headerlink" title="80.使用过的 CSS 预处理器？"></a>80.使用过的 CSS 预处理器？</h3><p><code>CSS</code>预处理器的基本思想： 为<code>CSS</code>增加了一些变量的特性（变量，判断逻辑和函数等）。</p><p>开发者使用这种语言进行web页面上样式设计，再编译成正常的<code>css</code>文件使用。使用CSS预处理器，可以使<code>CSS</code>更加简洁，适应性更强，可读性更佳，无需考虑兼容性。最常用的<code>CSS</code>预处理器语言包括： <code>Sass(Scss)</code>和<code>Less</code>。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/17282056ed97998b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="81-🤧设置元素浮动后，该元素的-display-值会如何变化？"><a href="#81-🤧设置元素浮动后，该元素的-display-值会如何变化？" class="headerlink" title="81. 🤧设置元素浮动后，该元素的 display 值会如何变化？"></a>81. 🤧设置元素浮动后，该元素的 display 值会如何变化？</h3><p>设置元素浮动后，该元素的<code>display</code>值自动变成<code>block</code>。</p><h3 id="82-行内元素有哪些-块级元素有哪些-空-void-元素有那些"><a href="#82-行内元素有哪些-块级元素有哪些-空-void-元素有那些" class="headerlink" title="82. 行内元素有哪些?块级元素有哪些? 空(void)元素有那些?"></a>82. 行内元素有哪些?块级元素有哪些? 空(void)元素有那些?</h3><ul><li>行内元素： <code>a</code>、<code>b</code>、 <code>span</code>、<code>img</code>、 <code>input</code>、 <code>strong</code>、 <code>select</code>、 <code>label</code>、 <code>em</code>、 <code>button</code>、 <code>textarea</code>；</li><li>块级元素： <code>div</code>、 <code>ul</code>、 <code>li</code>、 <code>dl</code>、 <code>dt</code>、 <code>dd</code>、 <code>p</code>、 <code>h1-h6</code>、 <code>blockquote</code>；</li><li>空元素： 即没有实际内容内容的<code>html</code>元素，如：<code>br</code>、 <code>meta</code>、 <code>hr</code>、 <code>link</code>、 <code>input</code>、 <code>img</code>；</li></ul><h3 id="83-box-sizing属性？"><a href="#83-box-sizing属性？" class="headerlink" title="83. box-sizing属性？"></a>83. box-sizing属性？</h3><p>用来控制元素的盒子模型的解析模式，默认为<code>content-box</code>。</p><ul><li><code>content-box: W3C</code>的标准盒子模型，设置元素的<code>height/width</code>属性指的是<code>content</code>部分的宽&#x2F;高；</li><li><code>border-box</code>：IE传统盒子模型。设置元素的<code>height/width</code>属性指的是<code>border + padding + content</code>部分的高&#x2F;宽；</li></ul><h3 id="84-CSS3动画比基于脚本的动画有哪些优势？"><a href="#84-CSS3动画比基于脚本的动画有哪些优势？" class="headerlink" title="84. CSS3动画比基于脚本的动画有哪些优势？"></a>84. CSS3动画比基于脚本的动画有哪些优势？</h3><p>跟脚本动画相比，使用<code>CSS3</code>动画具有以下优势：</p><ul><li>易于使用，任何人都可以在不了解<code>javascript</code>的情况下创建它们；</li><li>即使在合理的系统负载下也能很好的执行。</li><li>由于简单的动画在<code>javascript</code>中的效果比较差，因此渲染引擎使用跳帧技术来使动画流畅进行；</li><li>允许浏览器控制动画序列，通过建撒谎哦在当前不可见的选项卡中执行的动画的更新频率来优化性能和效率；</li></ul><h3 id="85-如何优化网页的打印样式？"><a href="#85-如何优化网页的打印样式？" class="headerlink" title="85. 如何优化网页的打印样式？"></a>85. 如何优化网页的打印样式？</h3><p><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen(或者print、tv等) href=&quot;aaa.css&quot;&gt;</code></p><p>🍀<strong>注意</strong>，在打印样式表也应该注意以下几点：</p><ul><li>打印样式表中最好不要用背景图片，因为打印机不能打印CSS中的背景图。如果坚持要显示图片，可以使用<code>html</code>插入到页面中；</li><li>最好不要使用像素作为单位，因为打印样式表要打印出来的是实物，建议使用<code>pt/cm</code>;</li><li>隐藏掉不必要的内容。（如<code>@print content&#123;display: none&#125;</code>）;</li><li>打印样式表中不建议使用浮动属性（建议少用），因为它们会消失。</li></ul><h3 id="86-React-Native中的样式与css的区别？"><a href="#86-React-Native中的样式与css的区别？" class="headerlink" title="86. React Native中的样式与css的区别？"></a>86. React Native中的样式与css的区别？</h3><ul><li><code>React Native</code> 的样式基本上是实现了 <code>CSS</code> 的一个子集，并且属性名不完全一致，所以当你开始在考虑兼容 <code>React Native</code> 端之前，可以先简要了解一下 <code>React Native</code> 的样式。</li><li>这些样式名基本上是遵循了 <code>web</code> 上的 <code>CSS</code> 的命名，只是按照 <code>JS</code> 的语法要求使用了驼峰命名法。</li><li><code>RN</code>使用 <code>JavaScript</code> 来写样式，所有核心组件都接受名为<code>style</code>的属性，相当于<code>css</code>的行内样式。</li><li>在 <code>React Native</code> 中使用 Flexbox 规则来指定某个组件的子元素的布局。<code>Flexbox</code> 可以在不同屏幕尺寸上提供一致的布局结构。因此，如果你要考虑 <code>React Native</code> 端，那你的样式布局就得采用 <code>Flex</code> 布局。</li></ul><h3 id="87-style标签写在body后与body前有什么区别？"><a href="#87-style标签写在body后与body前有什么区别？" class="headerlink" title="87. style标签写在body后与body前有什么区别？"></a>87. style标签写在body后与body前有什么区别？</h3><p>一般情况下，页面加载时自上而下的。将<code>style</code>标签至于<code>body</code>之前，为的是先加载样式。</p><p>若是写在<code>body</code>标签之后，由于浏览器以逐行方式对html文档进行解析，当解析到写在写在文档尾部的样式表时，会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后会重新渲染，在<code>windows</code>的<code>IE</code>下可能会出现<code>FOUC</code>现象（页面闪烁）。</p><h3 id="88-CSS属性overflow属性定义溢出元素内容区的内容会如何处理"><a href="#88-CSS属性overflow属性定义溢出元素内容区的内容会如何处理" class="headerlink" title="88. CSS属性overflow属性定义溢出元素内容区的内容会如何处理?"></a>88. CSS属性overflow属性定义溢出元素内容区的内容会如何处理?</h3><ul><li>参数是<code>scroll</code>的时候，一定会出滚动条；</li><li>参数是<code>auto</code>的时候，子元素内容大于父元素时出现滚动条；</li><li>参数是<code>visible</code>的时候，溢出的内容出现在父元素之外；</li><li>参数是<code>hidden</code>的时候，溢出隐藏；</li></ul><h3 id="89-BFC、IFC、GFC、FFC是什么？"><a href="#89-BFC、IFC、GFC、FFC是什么？" class="headerlink" title="89. BFC、IFC、GFC、FFC是什么？"></a>89. BFC、IFC、GFC、FFC是什么？</h3><ul><li><code>Block formatting context(BFC)</code>--块级格式化上下文；</li><li><code>Inline formatting context(IFC)</code>--内联格式化上下文；</li><li><code>Grid formatting context(GFC)</code>--网格布局格式化上下文；</li><li><code>Flex formatting context(FFC)</code>--自适应格式化上下文；</li></ul><h3 id="90-对于使用图片，需要注意什么？"><a href="#90-对于使用图片，需要注意什么？" class="headerlink" title="90. 对于使用图片，需要注意什么？"></a>90. 对于使用图片，需要注意什么？</h3><ul><li>优化图片；</li><li>尽量避免在<code>html</code>中使用压缩图片；</li><li>使用恰当的图片格式；</li><li>使用<code>css sprites</code>技巧对图片优化；</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/172820593043a22d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="91-😯如何优化图像以及图像格式有什么区别？"><a href="#91-😯如何优化图像以及图像格式有什么区别？" class="headerlink" title="91.😯如何优化图像以及图像格式有什么区别？"></a>91.😯如何优化图像以及图像格式有什么区别？</h3><p><strong>优化图像</strong>：</p><ul><li>不用图片，尽量使用<code>CSS3</code>代替。对于一些要实现的修饰效果，例如阴影，圆角，半透明等，可以用<code>CSS3</code>完成；</li><li>尽可能使用矢量图<code>SVG</code>代替位图。对于绝大多数图案和图标等，矢量图更小，而且可以缩放而无需生成多套图。现代的主流浏览器大多数都能稳定的支持<code>SVG</code>。</li></ul><p><strong>图像格式区别</strong>：</p><ul><li>矢量图： 图标字体，如<code>font-awesome</code>、<code>svg</code>；</li><li>位图： <code>GIF</code>、<code>jpg（JPEG）</code>、<code>png</code>；</li></ul><p>矢量图和位图的区别：</p><ul><li><code>PNG</code>：它可以细分为三种格式： <code>PNG8</code>，<code>PNG24</code>，<code>PNG32</code>。后面的数字代表这种<code>PNG</code>格式最多可以索引和存储的颜色值；</li><li><code>JPG</code>: 一种大小与质量相对平衡的压缩图片格式。适用于允许轻微失真的色彩丰富的照片，不适用于色彩简单（色调少）的图片，比如图标啊，<code>logo</code>等；</li><li><code>GIF</code>： 一种无损的，8位图片格式。具有支持动画，索引透明，压缩等特性。使用色彩简单的图片。</li></ul><p><strong>优点</strong>： 能保证在最不失真的情况下尽可能压缩图像文件的大小；</p><p><strong>缺点</strong>： 对于需要高保真的较为复杂的图像，<code>PNG</code>虽然能无损压缩，但是图片较大，不适合应用在web页面上；</p><h3 id="92-position-fixed-在手机端下无效怎么处理？"><a href="#92-position-fixed-在手机端下无效怎么处理？" class="headerlink" title="92. position:fixed;在手机端下无效怎么处理？"></a>92. position:fixed;在手机端下无效怎么处理？</h3><p><code>fixed</code>的元素实现相对于整个页面是固定位置的，当在屏幕上滑动时是在滑动整个<code>viewport</code>。原来的网页还在，fixed也没有变过位置，所以说并不是手机端不支持<code>fixed</code>，只是<code>fixed</code>元素不是相对于手机屏幕固定的，因此我们按照以下方式来设计：</p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span>/&gt;复制代码</code></pre></div><h3 id="93-css样式引入方式的优缺点对比"><a href="#93-css样式引入方式的优缺点对比" class="headerlink" title="93. css样式引入方式的优缺点对比"></a>93. css样式引入方式的优缺点对比</h3><ul><li>内嵌样式： 优点： 方便书写，权重高；缺点： 没有做到结构和样式分离；</li><li>内联样式： 优点：结构样式相分离； 缺点：没有彻底分离；</li><li>外联样式： 优点： 完全实现了结构和样式相分离； 缺点： 需要引入才能使用；</li></ul><h3 id="94-border-none-与border-0-有什么区别？"><a href="#94-border-none-与border-0-有什么区别？" class="headerlink" title="94. border:none;与border:0;有什么区别？"></a>94. border:none;与border:0;有什么区别？</h3><p><strong>首先是性能差异</strong>：</p><ul><li><code>&#123;border：0;&#125;</code>: 把<code>border</code>设置为0像素，虽然在页面上看不到，但是按<code>border</code>默认值理解，浏览器依然对<code>border-width/border-color</code>进行了渲染，即已经占用内存值；</li><li><code>&#123;border：none；&#125;</code>被理解为<code>border-style:none</code>。<code>boder:0</code>;比<code>border:none</code>多渲染了一个<code>border-width:0</code>,也就是为什么<code>border:none</code>的性能要比<code>border:0</code>高；</li></ul><p><strong>兼容性差异</strong>：</p><ul><li><code>&#123;border:none;&#125;</code>当<code>border</code>为<code>“none”</code>时似乎对<code>IE6/7</code>无效边框依然存在当<code>border</code>为“0”时，感觉比<code>“none”</code>更有效，所有浏览器都一致把边框隐藏。</li></ul><h3 id="95-position-跟-display、overflow、float-这些特性相互叠加后会怎么样？"><a href="#95-position-跟-display、overflow、float-这些特性相互叠加后会怎么样？" class="headerlink" title="95. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？"></a>95. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？</h3><ul><li><code>display</code>属性规定元素应该生成的框的类型；</li><li><code>position</code>属性规定元素的定位类型；</li><li><code>float</code>属性是一种布局方式，定义元素往哪个方向浮动；</li></ul><p><strong>叠加结果</strong>：有点类似于优先机制。<code>position</code>的值– <code>absolute/fixed</code>优先级最高，有他们在时，<code>float</code>不起作用，<code>display</code>值需要调整。<code>float</code>或者<code>absolute</code>定位的元素，只鞥是块元素或者表格。</p><h3 id="96-什么是critical-CSS？"><a href="#96-什么是critical-CSS？" class="headerlink" title="96. 什么是critical CSS？"></a>96. 什么是critical CSS？</h3><p><code>Critical CSS</code>是一种提取首屏中 <code>CSS</code> 的技术，以便尽快将内容呈现给用户。这是快速加载网页首屏的好方法。</p><p>核心思路：</p><p>（1）、抽取出首页的<code>CSS</code>；</p><p>（2）、用行内css样式，加载这部分的<code>css(critical CSS)</code>;</p><p>（3）、等到页面加载完之后，再加载整个<code>css</code>，会有一部分<code>css</code>与<code>critical css</code>重叠；</p><h3 id="97-什么是回流（重排）和重绘以及其区别？"><a href="#97-什么是回流（重排）和重绘以及其区别？" class="headerlink" title="97. 什么是回流（重排）和重绘以及其区别？"></a>97. 什么是回流（重排）和重绘以及其区别？</h3><ul><li>回流（重排），<code>reflow</code>:当<code>render tree</code>中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变时而需要重新构建；</li><li>重绘<code>（repaint</code>）:当<code>render tree</code>中的一些元素需要更新属性，而这些属性只影响元素的外观，风格，而不会影响布局时，称其为<strong>重绘</strong>，例如颜色改变等。</li></ul><p>🍀<strong>注意</strong>：<strong>每个页面至少需要引发一次重排+重绘，而且重排（回流）一定会引发重绘</strong>。</p><p>触发重排（回流）的条件：</p><ul><li>增加或者删除可见的<code>dom</code>元素；</li><li>元素的位置发生了改变；</li><li>元素的尺寸发生了改变，例如边距，宽高等几何属性改变；</li><li>内容改变，例如图片大小，字体大小改变等；</li><li>页面渲染初始化；</li><li>浏览器窗口尺寸改变，例如<code>resize</code>事件发生时等；</li></ul><h3 id="98-css-中可以让文字在垂直和水平方向上重叠的两个属性是什么？"><a href="#98-css-中可以让文字在垂直和水平方向上重叠的两个属性是什么？" class="headerlink" title="98. css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？"></a>98. css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？</h3><ul><li>垂直方向： <code>line-height</code>；</li><li>水平方向： <code>letter-spacing</code>；</li></ul><p>🍀<strong>注意</strong>： <code>letter-spacing</code>还可以用来消除<code>inline-block</code>元素间的换行符空格间隙等问题。</p><h3 id="99-对-WEB-标准以及-W3C-有什么理解与认识？"><a href="#99-对-WEB-标准以及-W3C-有什么理解与认识？" class="headerlink" title="99. 对 WEB 标准以及 W3C 有什么理解与认识？"></a>99. 对 WEB 标准以及 W3C 有什么理解与认识？</h3><ul><li>标签闭合，标签小写，不乱嵌套；</li><li>提高搜索机器人的搜索几率；</li><li>使用外链<code>CSS</code>和<code>JS</code>脚本；</li><li>结构行为标签分离；</li><li>文件下载和页面速度更快；</li><li>内容能被更多的用户以及更广泛的设备访问；</li><li>更少的代码和组件，易于维护，改版方便；</li><li>不需要动页面内容，同时提供打印版本也不需要复制内容，提高网站的易用性；</li></ul><h3 id="100-Happy-Ending💃🍃"><a href="#100-Happy-Ending💃🍃" class="headerlink" title="100. Happy Ending💃🍃"></a>100. Happy Ending💃🍃</h3><p>到了这儿，小编希望本文能帮助到有需要的童鞋，扎实基础知识（亦或是温习遗忘的知识点），温故而知新，逐渐提升。</p><h3 id="写在最后-🌼🌼"><a href="#写在最后-🌼🌼" class="headerlink" title="写在最后 🌼🌼"></a>写在最后 🌼🌼</h3><p>本篇文章会持续保持更新。文中若有不足，亦或是有小伙伴知道还有小编没有写入的知识点的，欢迎留言💌💌，小编看到后会第一时间加上。</p><p>最后，如果觉得文章对自身有所帮助，麻烦支持一下，因为小编最近有点点想升级（一直卡在最后，真是一言难尽），谢谢大家。后继小编会更加努力推出优质的文章回馈给需要的小伙伴。（发完文，感觉生活又开始美好了🌻🌻）</p><p><strong>更新</strong>：有关<a href="https://juejin.cn/post/6844904194474770445" title="https://juejin.cn/post/6844904194474770445">javascript</a>的知识点已更新🌈🌈</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172917eba7a2309f~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试的区别</title>
    <link href="/2023/01/29/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/01/29/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="1-箭头函数和普通函数的区别"><a href="#1-箭头函数和普通函数的区别" class="headerlink" title="1. 箭头函数和普通函数的区别"></a>1. 箭头函数和普通函数的区别</h2><p>a. 箭头函数和普通函数的样式不同，箭头函数语法更加简洁、清晰，箭头函数是<code>=&gt;</code>定义函数,普通函数是<code>function</code>定义函数。  </p><p>b. 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，定义的时候就确定并固定了。  </p><p>c. 箭头函数不能作为构造函数使用，也不能使用new关键字(<code>因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的this，且this指向永远不会改变,作为构造函数其的this要是指向创建的新对象</code>)。  </p><p>d. 箭头函数没有自己的arguments。在箭头函数中访问arguments实际上获得的是外层局部（函数）执行环境中的值。  </p><p>e. call、apply、bind 并不会影响其 this 的指向。  </p><p>f. 箭头函数没有原型prototype。  </p><p>g. 箭头函数不能当作 Generator 函数，不能使用 yield 关键字。  </p><h2 id="2-var，let和const之间的区别"><a href="#2-var，let和const之间的区别" class="headerlink" title="2. var，let和const之间的区别"></a>2. var，let和const之间的区别</h2><p>从以下<code>三个方面</code>说。  </p><p><strong>变量提升方面</strong>：var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined。<br>let和const不存在变量提升问题(<code>注意这个‘问题’后缀，其实是有提升的，只不过是let和const具有一个暂时性死区的概念，即没有到其赋值时，之前就不能用</code>)，即它们所声明的变量一定要在声明后使用，否则报错。  </p><p><strong>块级作用域方面</strong>：var不存在块级作用域,let和const存在块级作用域  </p><p><strong>声明方面</strong>：var允许重复声明变量,let和const在同一作用域不允许重复声明变量。其中const声明一个只读的常量(因为如此，其声明时就一定要赋值，不然报错)。一旦声明，常量的值就不能改变。  </p><p><strong>如何使const声明的对象内属性不可变，只可读呢？</strong><br>如果const声明了一个对象，对象里的属性是可以改变的。</p><div class="code-wrapper"><pre><code class="hljs sqf">const obj=&#123;<span class="hljs-built_in">name</span>:<span class="hljs-string">&#x27;蟹黄&#x27;</span>&#125;;obj.<span class="hljs-built_in">name</span>=<span class="hljs-string">&#x27;同学&#x27;</span>;console.<span class="hljs-built_in">log</span>(obj.<span class="hljs-built_in">name</span>);<span class="hljs-comment">//同学</span>复制代码</code></pre></div><p>因为const声明的obj只是保存着其对象的<strong>引用地址</strong>，只要地址不变，就不会出错。  </p><p>使用<code>Object.freeze(obj)</code> 冻结obj,就能使其内的属性不可变,但它有局限，就是obj对象中要是有属性是对象，该对象内属性还能改变，要全不可变，就需要使用递归等方式一层一层全部冻结。</p><h2 id="3-Bigint和Number的区别"><a href="#3-Bigint和Number的区别" class="headerlink" title="3. Bigint和Number的区别"></a>3. Bigint和Number的区别</h2><p>Number类型的数字<strong>有精度限制</strong>，数值的精度只能到 53 个二进制位（相当于 16 个十进制位, <code>正负9007199254740992</code>），大于这个范围的整数，就无法精确表示了。  </p><p>Bigint<strong>没有位数的限制，任何位数的整数都可以精确表示</strong>。但是其只能用于表示整数，且为了与Number进行区分，BigInt 类型的数据必须添加后缀n。BigInt 可以使用负号（-），但是不能使用正号（+）。  </p><p>另外number类型的数字和Bigint类型的数字<strong>不能</strong>混合计算。</p><p><code>12n+12;//报错</code></p><h2 id="4-基本数据类型和引用数据类型的区别"><a href="#4-基本数据类型和引用数据类型的区别" class="headerlink" title="4. 基本数据类型和引用数据类型的区别"></a>4. 基本数据类型和引用数据类型的区别</h2><p><strong>基本数据类型：</strong><br>a. 基本数据类型的值是不可变的(重新赋值属于改变属性名的指向了，而不是对值进行操作),这里你就可以联想到，<code>是不是所有关于字符串和数字的方法</code>都是带有<code>返回值</code>的，而不是改变原字符串或数字。<br>例如</p><div class="code-wrapper"><pre><code class="hljs arcade">let a=<span class="hljs-string">&#x27;abc&#x27;</span>;a.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);<span class="hljs-comment">//abc</span>复制代码</code></pre></div><p>b. 基本数据类型不可以添加属性和方法，虽然不会报错，但也只是一瞬间转为了相应包装对象，操作完又转化回原基本数据类型，不会保存结果。  </p><p>c. 基本数据类型的赋值是简单赋值,基本数据类型的比较是值的比较。  </p><p>d. 基本数据类型是存放在栈区的  </p><p><strong>引用数据类型：</strong><br>a. 引用类型的值是可以改变的,例如对象就可以通过修改对象属性值更改对象。  </p><p>b. 引用类型可以添加属性和方法。  </p><p>c. 引用类型的赋值是对象引用,即声明的变量标识符，存储的只是对象的指针地址。  </p><p>d. 引用类型的比较是引用(<code>指针地址</code>)的比较。  </p><p>e. 引用类型是同时保存在栈区和堆区中的,栈区保存变量标识符和指向堆内存的地址。  </p><h2 id="5-defer和async的区别"><a href="#5-defer和async的区别" class="headerlink" title="5. defer和async的区别"></a>5. defer和async的区别</h2><p><code>大家应该都知道在script标签内有这两个属性async和defer，例如&lt;script src=&quot;./home.js&quot; async defer&gt;&lt;/script&gt;</code>  </p><p><strong>defer</strong>：中文意思是延迟。用途是表示脚本会被延迟到整个页面都解析完毕后再运行。因此，在<code>&lt;script&gt;</code>元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。<br>HTML5规范要求脚本按照它们出现的<code>先后顺序执行</code>，因此第一个延迟脚本会先于第二个延迟脚本执行,但执行脚本之间<code>存在依赖，需要有执行的先后顺序时</code>，就可以使用<code>defer</code>,延迟执行。我觉得把script脚本放在body底部和defer差不多。</p><p><strong>async</strong>：中文意思是异步，这个属性与defer类似，都用于改变处理脚本的行为。同样与defer类似，async只适用于外部脚本文件，并告诉浏览器立即下载文件。当页面继续进行解析时，脚本将被执行。与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。<br>指定async属性的目的是不让页面等待两个脚本下载和执行，从而<code>异步加载页面</code>其他内容,这使用于之间<code>互不依赖</code>的各脚本。</p><h2 id="看到这里，就能知道其的一些作用了"><a href="#看到这里，就能知道其的一些作用了" class="headerlink" title="看到这里，就能知道其的一些作用了"></a>看到这里，就能知道其的一些作用了</h2><p>当网页交给浏览器的HTML解析器转变成一系列的词语（Token）。解释器根据词语构建节点（Node），形成DOM树。因为JavaScript代码可能会修改DOM树的结构，所以节点是JavaScript代码的话，就需要停止当前DOM树的创建，直到JavaScript的资源加载并被JavaScript引擎执行后才继续DOM树的创建。<br>这里就会产生<strong>阻塞</strong>，出现<strong>白屏问题</strong>(白屏问题优化有很多方面，这里就脚本阻塞这一小点)，我们就可以使用<code>async和defer</code>属性来解决JavaScript脚本阻塞问题。  </p><p>当然最稳妥的办法还是把script标签放置在body的底部，没有兼容性问题，不会因此产生白屏问题，没有执行顺序问题。</p><p>最后总结：</p><ul><li>如果 async&#x3D;”async”：脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）</li><li>如果不使用 async 且 defer&#x3D;”defer”：脚本将在页面完成解析时执行</li><li>如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本</li></ul><h2 id="6-async-await对比promise的优缺点"><a href="#6-async-await对比promise的优缺点" class="headerlink" title="6. async await对比promise的优缺点"></a>6. async await对比promise的优缺点</h2><p><strong>async&#x2F;await优点</strong>：<br>a. 它做到了真正的串行的同步写法，代码阅读相对容易  </p><p>b. 对于条件语句和其他流程语句比较友好，可以直接写到判断条件里面  </p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">222</span>)      &#125;, <span class="hljs-number">2222</span>)    &#125;)  &#125;;<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">await</span> <span class="hljs-title function_">a</span>() === <span class="hljs-number">222</span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;yes, it is!&#x27;</span>) <span class="hljs-comment">// 会打印</span>      &#125;    &#125; <span class="hljs-keyword">catch</span> (err) &#123;      <span class="hljs-comment">// ...</span>    &#125;  &#125;复制代码</code></pre></div><p>c. 处理复杂流程时，在代码清晰度方面有优势  </p><p><strong>async&#x2F;await缺点</strong>：<br>a. 无法处理promise返回的reject对象，要借助try…catch…  </p><p>b. 用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">//promise</span>Promise<span class="hljs-selector-class">.all</span>([ajax1(), <span class="hljs-built_in">ajax2</span>()])复制代码</code></pre></div><p>c. try…catch…内部的变量无法传递给下一个try…catch…,Promise和then&#x2F;catch内部定义的变量，能通过then链条的参数传递到下一个then&#x2F;catch，但是async&#x2F;await的try内部的变量，如果用let和const定义则无法传递到下一个try…catch…，只能在外层作用域先定义好。</p><p><strong>但async&#x2F;await确确实实是解决了promise一些问题的。更加灵活的处理异步</strong>  </p><p><strong>promise的一些问题：</strong><br>a. 一旦执行，无法中途取消，链式调用多个then中间不能随便跳出来  </p><p>b. 错误无法在外部被捕捉到，只能在内部进行预判处理，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部  </p><p>c. Promise内部如何执行，监测起来很难，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）  </p><h2 id="7-get和post的区别"><a href="#7-get和post的区别" class="headerlink" title="7. get和post的区别"></a>7. get和post的区别</h2><p>a. GET 是将参数写在 <code>URL 中 ?</code> 的后面，并用 <code>&amp;</code> 分隔不同参数；而 POST 是将信息存放在 <code>Message Body</code> 中传送，参数‘不会’显示在 URL 中(Restful规范中是这样，但post在有需要时可以把参数放URL里)。GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。  </p><p>b. GET请求提交的数据有长度限制（<strong>HTTP 协议本身没有限制 URL 及正文长度</strong>,对 URL 的限制大多是浏览器和服务器的原因），POST请求没有内容长度限制。  </p><p>c. GET请求返回的内容会被浏览器缓存起来。而每次提交POST请求，浏览器不会缓存POST请求返回的内容。  </p><p>d. GET对数据进行查询，POST主要对数据进行增删改！简单说，GET是只读，POST是写。  </p><p>e. 关于安全性，GET 请求方式从浏览器的 URL 地址就可以看到参数；所以post更安全，其实无论是 GET 还是 POST 其实<strong>都是不安全的</strong>，因为 HTTP 协议是明文传输，只要拦截封包便能轻易获取重要资讯。想要安全传输资料，必须使用 SSL&#x2F;TLS来加密封包，也就是 HTTPS。  </p><p><strong>那为什么推崇使用post来处理敏感数据呢？</strong><br>因为get的记录会保存在浏览器，上网日志中，而使用Post，因为数据不会记录存储在浏览器的记录和网址访问记录中，这样会有更大的<strong>安全性</strong>。  </p><p>f.<strong>一个误区</strong> 说GET产生一个TCP数据包；POST产生两个TCP数据包<br><strong>其说法</strong>：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。  </p><p>对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。  </p><p><strong>为其正名</strong>:上面所说的post会比get多一个tcp包其实不太严谨。多发的那个expect 100 continue header报文，是<code>由客户端对http的post和get的请求策略决定</code>的，目的是为了避免浪费资源，如带宽，数据传输消耗的时间等等。所以客户端会在发送header的时候添加expect 100去探探路，如果失败了就不用继续发送data，从而减少了资源的浪费。所以是否再发送一个包取决了客户端的实现策略，和get&#x2F;post并没什么关系。有的客户端比如fireFox就只发送一个包。  </p><h2 id="8-用框架和不用框架的区别，vue和react的区别"><a href="#8-用框架和不用框架的区别，vue和react的区别" class="headerlink" title="8. 用框架和不用框架的区别，vue和react的区别"></a>8. 用框架和不用框架的区别，vue和react的区别</h2><p><strong>首先说说用框架和不用框架的区别：（以使用框架的角度看）</strong><br>框架好处：<br>a. 使用框架工具写项目，在浏览器中代码依然是原生的HTML CSS JS。而框架帮开发者做了很多事情，开发者只关注业务逻辑就可以,极大的加快了开发速度。<br>例如前端框架根本上是解决了<code>UI 与状态同步问题</code>,<code>频繁操作 DOM 性能低下</code>.<code>中间步骤过多,易产生 bug且不易维护</code>,而且<code>心智要求较高不利于开发效率</code>的一系列阻碍  </p><p>b. <code>组件化</code>: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。  </p><p>c. <code>天然分层</code>: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。  </p><p>d. <code>生态</code>: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案  </p><p>e. 待补充。。。(<strong>希望评论区能提出宝贵见解</strong>)</p><p>框架缺点：<br>a. 代码臃肿，使用者使用框架的时候会将整个框架引入，而框架封装了很多功能和组件，使用者必须按照它的规则使用，而实际开发中很多功能和组件是用不到的。  </p><p>b. 框架迭代更新速度非常快，需要时间熟悉它。  </p><p>c. 待补充。。。(<strong>希望评论区能提出宝贵见解</strong>)</p><p><strong>说说Vue和React的区别：</strong><br>这里就说说其思想差异(毕竟面试时不一定就要把两个框架差异说清楚，理解核心就好)：  </p><p><code>react整体是函数式的思想</code>，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；  </p><p><code>vue的思想是响应式的</code>，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。  </p><p>其他的细节差异可以看看这篇文章：<a href="https://juejin.cn/post/6844904040564785159" title="https://juejin.cn/post/6844904040564785159">关于Vue和React的一些对比</a></p><h2 id="9-cookies和session的区别"><a href="#9-cookies和session的区别" class="headerlink" title="9. cookies和session的区别"></a>9. cookies和session的区别</h2><p>a. <code>存储位置不同:</code>cookie的数据信息存放在客户端浏览器上，session的数据信息存放在服务器上。  </p><p>b. <code>存储容量不同:</code>单个cookie保存的数据&lt;&#x3D;4KB，一个站点最多保存20个Cookie，而对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。  </p><p>c. <code>存储方式不同:</code>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。  </p><p>d. <code>隐私策略不同:</code>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的，而session存储在服务器上，对客户端是透明的，不存在敏感信息泄漏的风险。  </p><p>e. <code>有效期上不同:</code>开发可以通过设置cookie的属性，达到使cookie长期有效的效果。session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。  </p><p>f. <code>服务器压力不同:</code>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。  </p><p>g. <code>跨域支持上不同:</code>cookie支持跨域名访问(二级域名是可以共享cookie的)。session不支持跨域名访问。  </p><h2 id="10-宏任务和微任务有什么区别"><a href="#10-宏任务和微任务有什么区别" class="headerlink" title="10. 宏任务和微任务有什么区别"></a>10. 宏任务和微任务有什么区别</h2><p>微任务和宏任务皆为异步任务，它们都属于一个队列，主要<strong>区别在于他们的执行顺序，Event Loop的走向和取值</strong>。  </p><p><strong>宏任务和微任务的一些分配</strong></p><div class="code-wrapper"><pre><code class="hljs coffeescript">         宏任务          浏览器         NodeI/O      ✅✅<span class="hljs-built_in">setTimeout</span>✅✅<span class="hljs-built_in">setInterval</span>✅✅setImmediate    ❌✅requestAnimationFrame           ✅✅         微任务process.nextTick        ❌✅MutationObserver        ✅❌<span class="hljs-built_in">Promise</span>.<span class="hljs-keyword">then</span> <span class="hljs-keyword">catch</span> <span class="hljs-keyword">finally</span>              ✅✅复制代码</code></pre></div><p><strong>宏任务与微任务之间的执行顺序</strong>(同步任务-&gt;微任务-&gt;宏任务)<br>下面说说执行到宏任务后是怎么继续运行的<br>(这里声明下，整段js代码就是第一个大的宏任务，事件循环是由这第一个宏任务开始的，然后分出微任务，这里是为了理解微任务宏任务的执行区别就先跳过这第一层)  </p><p><code>说一个很有名的银行例子</code>：银行柜台前排着一条队伍，都是存钱的人，存钱属于宏任务，这条队伍就是宏任务队列，当一个‘宏大爷’被叫到了自己的号码，就上前去–被处理，处理存钱业务时，‘宏大爷’<strong>突然</strong>想给自己的存款办个微理财(<code>微任务</code>)，那么银行职员就将他的需求添加到自己的微任务队列，大爷就不用再排队了，直接在存钱宏任务进行完后就处理衍生出来的微任务理财，办理财时大爷又说办个信用卡，那就又排到微任务队列里。<strong>但要是</strong>在此次存钱时‘宏大爷’说他还要存钱，且是他老伴要存钱，也是<code>宏任务</code>，但不好意思，需要取号到宏任务队列的后面排队（这里就是在宏任务进行时产生微任务和宏任务的处理方式）。  </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b68f33891a3e418696c2258e96441d7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image"></p><p>结合下面的题目理解理解（这里先不介绍node环境的事件循环的特殊地方，主要以浏览器环境，最好看看底下推荐的文章）：  </p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//宏任务1</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);<span class="hljs-comment">//同步任务1</span></span><span class="language-javascript">      <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//微任务1</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>);<span class="hljs-comment">//同步任务2</span></span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//宏任务2</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;5&#x27;</span>);<span class="hljs-comment">//宏任务2中的同步任务</span></span><span class="language-javascript">      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;6&#x27;</span>);<span class="hljs-comment">//宏任务2中的同步任务</span></span><span class="language-javascript">        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<span class="hljs-comment">//宏任务2中的微任务</span></span><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x1&#x27;</span>);</span><span class="language-javascript">            <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">          &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;X2&#x27;</span>);</span><span class="language-javascript">          &#125;);</span><span class="language-javascript">        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//宏任务2中的宏任务</span></span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;X3&#x27;</span>);</span><span class="language-javascript">          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<span class="hljs-comment">//宏任务2中的宏任务中的同步任务</span></span><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;X4&#x27;</span>);</span><span class="language-javascript">            <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">          &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//宏任务2中的宏任务中的微任务</span></span><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;X5&#x27;</span>);</span><span class="language-javascript">          &#125;);</span><span class="language-javascript">        &#125;)</span><span class="language-javascript">        <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">      &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//宏任务2中的微任务</span></span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;7&#x27;</span>);</span><span class="language-javascript">      &#125;);</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//宏任务3</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;8&#x27;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    <span class="hljs-comment">//（对于这段代码node环境和浏览器环境输出一致）</span></span><span class="language-javascript">    <span class="hljs-comment">//输出答案：2,4,3,1,5,6,x1,x2,7,8,x3,x4,x5</span></span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码</code></pre></div><p>上面这个例子我为了测试，可能搞得有点长。。。</p><p><a href="https://juejin.cn/post/6844903657264136200#heading-3" title="https://juejin.cn/post/6844903657264136200#heading-3">更多eventloop详细可看这篇文章</a></p><h2 id="11-fetch-Ajax-axios区别"><a href="#11-fetch-Ajax-axios区别" class="headerlink" title="11. fetch,Ajax,axios区别"></a>11. fetch,Ajax,axios区别</h2><p>Ajax是什么：Ajax是（Asynchronous JavaScript and XML）的缩写。现在，允许浏览器与服务器通信而无须刷新当前页面的技术都被叫做Ajax。核心使用<code>XMLHttpRequest</code>对象。  </p><p>axios是什么：axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上<code>也是对原生XHR</code>的封装，只不过它是Promise的实现版本，符合最新的ES规范。  </p><p>fetch是什么：Fetch被称为下一代Ajax技术,采用Promise方式来处理数据。是一种简洁明了的API，比XMLHttpRequest更加简单易用。  </p><p>所以其主要区别是 axios、fetch请求后都支持Promise对象API，ajax只能用回调函数。  </p><p>具体了解可看此文章<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/89089088" title="https://zhuanlan.zhihu.com/p/89089088">一文秒懂 ajax, fetch, axios</a></p><h2 id="12-TCP和UDP的区别"><a href="#12-TCP和UDP的区别" class="headerlink" title="12. TCP和UDP的区别"></a>12. TCP和UDP的区别</h2><p>a. TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。  </p><p>b. TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠， 面向连接，不会丢失数据因此适合大数据量的交换。  </p><p>c. TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因 此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。  </p><p>d. TCP 只能是 1 对 1 的，而UDP 支持 1 对 1,1 对多。  </p><p>e. TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。  </p><p>f. TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。  </p><h2 id="13-js中的堆和栈-栈和队列有什么区别"><a href="#13-js中的堆和栈-栈和队列有什么区别" class="headerlink" title="13. js中的堆和栈,栈和队列有什么区别"></a>13. js中的堆和栈,栈和队列有什么区别</h2><p><strong>堆(heap)和栈(stack)的区别:</strong>  </p><p>堆：队列优先,<strong>先进先出</strong>；由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。  </p><p>栈：<strong>先进后出</strong>；动态分配的空间 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。  </p><p><strong>栈和队列的区别：</strong>  </p><p>a. 栈只允许在表尾一端进行插入和删除，队列只允许在表尾一端进行插入，在表头一端进行删除。  </p><p>b. 栈是先进后出，队列是先进先出。  </p><h2 id="14-WebSocket和HTTP有什么区别"><a href="#14-WebSocket和HTTP有什么区别" class="headerlink" title="14. WebSocket和HTTP有什么区别"></a>14. WebSocket和HTTP有什么区别</h2><p><strong>相同点</strong><br>a. 都是一样基于TCP的，都是可靠性传输协议。  </p><p>b. 都是应用层协议。  </p><p><strong>不同点</strong><br>a. WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。  </p><p>b. WebSocket是需要握手进行建立连接的(相对HTTP来说，WebSocket是一种持久化的协议。它会基于HTTP协议，来完成一部分握手，HTTP握手部分完成，协议升级为WebSocket)。  </p><p>可以学习这篇文章<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/74326818" title="https://zhuanlan.zhihu.com/p/74326818">WebSocket其实没那么难</a></p><h2 id="15-http和https的区别"><a href="#15-http和https的区别" class="headerlink" title="15. http和https的区别"></a>15. http和https的区别</h2><p>a. HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。  </p><p>b. 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而<strong>需要一定费用</strong>。  </p><p>c. HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。  </p><p>d. http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。  </p><p>e. HTTPS 其实就是建构在 SSL&#x2F;TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。  </p><h2 id="16-px-em-rem-vw-vh区别"><a href="#16-px-em-rem-vw-vh区别" class="headerlink" title="16. px,em,rem,vw,vh区别"></a>16. px,em,rem,vw,vh区别</h2><p>px: px就是pixel的缩写，意为像素。px就是一张图片最小的一个点，一张位图就是千千万万的这样的点构成的。  </p><p>em: <strong>参考物是父元素</strong>的font-size，具有继承的特点。如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。  </p><p>rem: css3新单位，<strong>相对于根元素html</strong>（网页）的font-size，不会像em那样，依赖于父元素的字体大小，而造成混乱。  </p><p>vw: css3新单位，viewpoint width的缩写，<strong>视窗宽度</strong>，1vw等于视窗宽度的1%。<br>举个例子：浏览器宽度1200px, 1 vw &#x3D; 1200px&#x2F;100 &#x3D; 12 px。  </p><p>vh: css3新单位，viewpoint height的缩写，<strong>视窗高度</strong>，1vh等于视窗高度的1%。<br>举个例子：浏览器高度900px, 1 vh &#x3D; 900px&#x2F;100 &#x3D; 9 px。  </p><h2 id="17-wepack中loader和plugin的区别"><a href="#17-wepack中loader和plugin的区别" class="headerlink" title="17. wepack中loader和plugin的区别"></a>17. wepack中loader和plugin的区别</h2><p><strong>什么是loader?</strong><br>loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中  </p><p><strong>什么是plugin？</strong><br>在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果。  </p><p><strong>区别：</strong>  </p><ul><li>对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程</li><li>plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务</li></ul><h2 id="18-bind-call-apply区别"><a href="#18-bind-call-apply区别" class="headerlink" title="18. bind call apply区别"></a>18. bind call apply区别</h2><p>a. 三者都可以改变函数的this对象指向。  </p><p>b. 三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。  </p><p>c. 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。  </p><p>d. bind 改变this指向后不会立即执行，而是返回一个永久改变this指向的函数便于稍后调用； apply, call则是立即调用  </p><h2 id="19-301-和-302-有什么区别"><a href="#19-301-和-302-有什么区别" class="headerlink" title="19. 301 和 302 有什么区别"></a>19. 301 和 302 有什么区别</h2><p><code>301 Moved Permanently:</code> 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应 当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也 是可缓存的。  </p><p><code>302 Found:</code> 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。  </p><p>字面上的区别就是 301 是永久重定向，而 302 是临时重定向。  </p><p>301 比较常用的场景是使用域名跳转。302 用来做临时跳转, 比如未登陆的用户访问用户中心被重定向到登录页面  </p><h2 id="20-进程线程的区别"><a href="#20-进程线程的区别" class="headerlink" title="20. 进程线程的区别"></a>20. 进程线程的区别</h2><p>a. <strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><p>b. <strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><p>c. <strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><p>d. <strong>内存分配</strong>：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p><p>e. <strong>影响关系</strong>：因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程要比多线程健壮。  </p><p>还可看看：<br><a href="https://link.juejin.cn/?target=http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" title="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">阮一峰对进程线程的简单解释</a><br><a href="https://juejin.cn/post/6844903908385488903" title="https://juejin.cn/post/6844903908385488903">深入理解Node.js 中的进程与线程</a></p><h2 id="21-JavaScript和typescript的区别"><a href="#21-JavaScript和typescript的区别" class="headerlink" title="21. JavaScript和typescript的区别"></a>21. JavaScript和typescript的区别</h2><p>a. TypeScript 从核心语言方面和类概念的模塑方面对 JavaScript 对象模型进行扩展。</p><p>b. JavaScript 代码可以在无需任何修改的情况下与 TypeScript 一同工作，同时可以使用编译器将 TypeScript 代码转换为 JavaScript。</p><p>c. TypeScript 通过类型注解提供编译时的静态类型检查。</p><p>d. TypeScript 中的数据要求带有明确的类型，JavaScript不要求。</p><p>e. TypeScript 为函数提供了缺省参数值。</p><p>f. TypeScript 引入了 JavaScript 中没有的“类”概念。</p><p>h. TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。</p><h2 id="22-localstorage、sessionstorage、cookie的区别"><a href="#22-localstorage、sessionstorage、cookie的区别" class="headerlink" title="22. localstorage、sessionstorage、cookie的区别"></a>22. localstorage、sessionstorage、cookie的区别</h2><p>a. 相同点是都是保存在浏览器端、且同源的</p><p>b. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p><p>c. 存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p><p>d. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</p><p>e. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</p><p>f. webStorage(<code>webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage</code>)支持事件通知机制，可以将数据更新的通知发送给监听者</p><p>h. webStorage的api接口使用更方便</p><h2 id="23-http-1-0-x2F-1-1-x2F-2-0的不同"><a href="#23-http-1-0-x2F-1-1-x2F-2-0的不同" class="headerlink" title="23. http 1.0&#x2F; 1.1&#x2F; 2.0的不同"></a>23. http 1.0&#x2F; 1.1&#x2F; 2.0的不同</h2><p><strong>http 1.0(构建可扩展性)</strong><br>HTTP原有的应用非常局限，浏览器和服务器迅速扩展使其用途更广：</p><p>a. 版本信息现在会随着每个请求发送（HTTP1.0 被追加到GET行）</p><p>b. 状态代码行也会在响应开始时发送，允许浏览器本身了解请求的成功或失败，并相应地调整其行为（如以特定方式更新或使用本地缓存）</p><p>c. 引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，并使协议非常灵活和可扩展。</p><p>d. Content-Type标头告诉客户端实际返回的内容的内容类型。在Content-Type标头帮助下，增加了传输除纯文本HTML文件外的其他类型文档的能力。</p><p><strong>http 1.1(标准化的协议)</strong><br>HTTP&#x2F;1.0的多种不同的实现运用起来有些混乱，HTTP1.1是第一个标准化版本，重点关注的是校正HTTP设计中的结构性缺陷：</p><p>a. 连接可以重复使用，节省了多次打开它的时间，以显示嵌入到单个原始文档中的资源。</p><p>b. 增加流水线操作，允许在第一个应答被完全发送之前发送第二个请求，以降低通信的延迟。</p><p>c. 支持响应分块。</p><p>d. 引入额外的缓存控制机制。</p><p>e. 引入内容协商，包括语言，编码，或类型，并允许客户端和服务器约定以最适当的内容进行交换。</p><p>f. 通过 Host 头，能够使不同的域名配置在同一个IP地址的服务器。</p><p>g. 安全性得到了提高</p><p><strong>http 2.0(为了更优异的表现)</strong><br>HTTP&#x2F;2在HTTP&#x2F;1.1有几处基本的不同:</p><p>HTTP2是二进制协议而不是文本协议。不再可读和无障碍的手动创建，改善的优化技术现在可被实施。</p><p>这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP&#x2F;1.x中顺序和阻塞的约束。</p><p>压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</p><p>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</p><p><a href="https://link.juejin.cn/?target=https://www.cnblogs.com/zytrue/p/8568181.html" title="https://www.cnblogs.com/zytrue/p/8568181.html">参考自这篇文章</a></p><h2 id="24-MongoDB和MySQL的区别"><a href="#24-MongoDB和MySQL的区别" class="headerlink" title="24. MongoDB和MySQL的区别"></a>24. MongoDB和MySQL的区别</h2><p>直接放上对比表格：  </p><table><thead><tr><th>数据库</th><th>MongoDB</th><th>MySQL</th></tr></thead><tbody><tr><td>数据库模型</td><td>非关系型</td><td>关系型</td></tr><tr><td>存储方式</td><td>以类JSON的文档的格式存储</td><td>不同引擎有不同的存储方式</td></tr><tr><td>查询语句</td><td>MongoDB查询方式（类似JavaScript的函数）</td><td>SQL语句</td></tr><tr><td>数据处理方式</td><td>基于内存，将热数据存放在物理内存中，从而达到高速读写</td><td>不同引擎有自己的特点</td></tr><tr><td>成熟度</td><td>新兴数据库，成熟度较低</td><td>成熟度高</td></tr><tr><td>广泛度</td><td>NoSQL数据库中，比较完善且开源，使用人数在不断增长</td><td>开源数据库，市场份额不断增长</td></tr><tr><td>事务性</td><td>仅支持单文档事务操作，弱一致性</td><td>支持事务操作</td></tr><tr><td>占用空间</td><td>占用空间大</td><td>占用空间小</td></tr><tr><td>join操作</td><td>MongoDB没有join</td><td>MySQL支持join</td></tr></tbody></table><p>希望各位看官指出其中的错误，我必改正！也请对其中的一些问题提出自己的一些看法。这里只是一些大概的总结，想要有最好的学习效果，还是对其中每有一个点进行系统的学习。</p><p>笔者最近也在准备面试和寻找前端实习岗位中！wx：xieHB-frontend-178,加个微信一起学习😜，也希望有大佬介绍个内推和提出学习意见，感谢。哈哈！</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack攻略</title>
    <link href="/2023/01/29/webpack%E6%94%BB%E7%95%A5/"/>
    <url>/2023/01/29/webpack%E6%94%BB%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack简介"><a href="#webpack简介" class="headerlink" title="webpack简介"></a>webpack简介</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本质上，webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。</p><p>webpack的核心概念为以下模块，后续会对以下概念针对性输出文章。</p><ul><li><p>入口（entry）</p></li><li><p>输出（output）</p></li><li><p>loader</p></li><li><p>插件（plugin）</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>webpack 对操作系统没有要求，使用 Windows、Mac、Linux 操作系统均可，它唯一的依赖是 Node.js，所以使用 webpack 前需要先安装 Node.js，安装地址为 [Nodejs]](<a href="https://leetcode.cn/link/?target=http://nodejs.cn/download/">http://nodejs.cn/download/</a>) 推荐安装TLS（长期维护）版本。node 安装完成后，在命令行输入 node -v，可显示版本号即安装成功。<br>接下来，我们需要使用 Node.js 的包管理器 npm 来安装 webpack ，安装模块的方式有两种：一种是全局安装，一种是本地安装，此处我们选择本地安装，主要有以下两点原因：</p><ol><li>如果采用全局安装，那在与他人协作时，由于每个人的 webpack 版本不同，可能导致打包出的内容不一致</li><li>通常会通过运行一个或多个 npm scripts 以在本地 node_modules 目录中查找安装的 webpack，来运行 webpack，所以在这种情况下可能导致本地全局都有，容易造成混淆</li></ol><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>基于以上两点，我们选择在项目内安装，首先新建一个工程目录，并执行 npm 的初始化命令</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> webpack_init &amp;&amp; <span class="hljs-built_in">cd</span> webpack_initnpm init</code></pre></div><p>命令行输入项目的基本信息，如：名称、版本、描述、仓库地址等信息。成功后工程目录中会出现一个 package.json 文件。<br>接下来输入安装webpack的命令：</p><div class="code-wrapper"><pre><code class="hljs q">npm install webpack webpack-cli --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div><p>webpack v4+ 版本都需要手动安装 webpack-cli，webpack-cli 提供了许多命令用于在命令行中运行 webpack。具体包含命令可查看文档[webpack-cli]](<a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/api/cli/">https://webpack.docschina.org/api/cli/</a>) 检查安装是否成功执行 webpack -v ， webpack-cli -v ，显示对应版本则安装成功</p><h2 id="打包第一个应用"><a href="#打包第一个应用" class="headerlink" title="打包第一个应用"></a>打包第一个应用</h2><p>在 webpack_init 文件夹下添加 index.html、src 文件夹下添加 index.js、hello.js 文件</p><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>src&#x2F;index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> helloWorld <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hello.js&#x27;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">component</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);   element.<span class="hljs-property">innerHTML</span> = <span class="hljs-title function_">helloWorld</span>();  <span class="hljs-keyword">return</span> element;&#125;<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">component</span>());</code></pre></div><p>src&#x2F;hello.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world!!!&#x27;</span>&#125;</code></pre></div><p>在控制台输入打包命令 npx webpack，</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">npx webpack</span></code></pre></div><p>因为 npm 会从全局模块中找 webpack ，但是我并非全局安装，而是项目本地安装，所以报错。所以需要 npx 命令运行命令。npx 会先找当前目录下的 node_modules&#x2F;.bin 目录下的二进制可执行文件，如果当前目录下没有 npx 会在 PATH 目录下继续寻找，如果没有会自动下载安装 webpack。此时，第一步手动安装 npm install webpack –save-dev 可省略。执行命令成功后会在项目中增加一个 dist 文件，文件中有一个打包后的 main.js 文件。<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453743-XEjonp-2.png" alt="2.png"></p><p>此时我们在浏览器中打开 index.html 文件，在页面中看到 hello world!!!<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453821-swEKUQ-1.png" alt="1.png"></p><p>在上面的命令中，我们采用了 webpack 的默认设置，我们也可以在命令行中指定入口文件、输出文件、打包模式等信息</p><div class="code-wrapper"><pre><code class="hljs routeros">npx webpack <span class="hljs-attribute">--entry</span>=./src/index.js <span class="hljs-attribute">--output-filename</span>=bundle.js <span class="hljs-attribute">--mode</span>=development</code></pre></div><p>删除 webpack 默认配置打包的内容，重新执行带配置的命令，打包后在 dist 目录下生成了 bundle.js 文件，将 index.html 中引入 js 文件地址 main.js 改为 bundle.js，在浏览器打开 index.html 发现控制台再一次输出了 hello world!!!。</p><h2 id="使用-npm-scripts"><a href="#使用-npm-scripts" class="headerlink" title="使用 npm scripts"></a>使用 npm scripts</h2><p>从上面的命令行配置打包例子来看，每次打包都需要在命令行输入冗长的命令，这样做会很耗时和容易出错，为了使命令更加简洁，可以在 package.json 文件中的”scripts”对象下添加一个打包命令脚本 build。<br>scripts 是 npm 提供的脚本命令功能，所以在这里我们可以直接使用 webpack 命令取代之前的 npx webpack。</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>在控制台输入npm命令，打包成功<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453846-cPODUe-3.png" alt="3.png"></p><div class="code-wrapper"><pre><code class="hljs routeros">npm <span class="hljs-built_in">run</span> build</code></pre></div><h2 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h2><p>在 webpack4 中，可以无需配置采用默认方式打包，直接在控制台输入 npx webpack 即可打包，然后大多数项目需要很复杂的设置，如项目分包、压缩、懒加载等，所以大多数情况下还是需要一个配置文件，webpack 默认加载的配置文件为 webpack.config.js，也可以指定 webpack 配置文件，需要命令行指定。</p><h3 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><p>在项目 webpack_init 中新建一个 webpack.config.js 文件</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-built_in">module</span>.exports = &#123;  entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,  <span class="hljs-built_in">output</span>: &#123;    filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)  &#125;&#125;;</code></pre></div><p>上面通过 module.exports 导出了一个对象，将之前命令行中输入的 key-value 形式的参数放在这个对象中。<br>这个对象包含连个属性，entry 为项目入口文件，output 为打包出口文件，其中 filename 为打包文件名称，path 为文件打包路径。通过调用 node.js 的path模块，将 __dirname(node.js内置全局变量，__dirname 为当前文件所在目录的绝对路径)与输出路径连接起来，得到了最终资源输出路径。</p><p>现在我们去掉 package.json 中 build 后面的参数去掉，只保留 “build”: “webpack”，然后在控制台输入 npm run build，打包成功了<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453847-kbCvea-4.png" alt="4.png"></p><h3 id="使用不同的配置文件"><a href="#使用不同的配置文件" class="headerlink" title="使用不同的配置文件"></a>使用不同的配置文件</h3><p>出于某种原因，需要根据特定情况使用不同的配置文件，则可以通过在命令行中使用 –config 标志修改<br>删除项目中的 webpack-config.js，新建一个 webpack-config-dev.js，内容和 webpack-config.js 一致。在命令行输入npm run build –config webpack.config.dev.js 或者在 package.json 的 scripts 中增加配置</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.config.dev.js&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span></code></pre></div><p>执行打包命令后。打包结果如下<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453849-gYWreG-5.png" alt="5.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在上面我们介绍了</p><ul><li>webpack 的作用及包含核心模块</li><li>如何从零安装一个 webpack 运行环境</li><li>打包第一个 webpack 项目</li><li>告别命令行，通过配置文件打包 webpack</li></ul><p>下一节我们将介绍下 webpack 的配置文件，包含的参数及作用。</p><h1 id="资源处理流程"><a href="#资源处理流程" class="headerlink" title="资源处理流程"></a>资源处理流程</h1><p>借用 webpack 官网对 webpack 的描述： webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle</p><h2 id="什么是bundle"><a href="#什么是bundle" class="headerlink" title="什么是bundle"></a>什么是bundle</h2><p>代码分离是 webpack 的特性之一，使用 entry 配置入口起点，会将代码分成源代码和分发代码<br>其中源代码是开发编辑的代码，分发代码是经过 webpack 构建，可能经过转义、压缩或优化后的代码，这些代码存放于 bundle 中，可以被浏览器等环境直接运行</p><h2 id="什么是dependency-graph"><a href="#什么是dependency-graph" class="headerlink" title="什么是dependency graph"></a>什么是dependency graph</h2><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453942-GhafnS-6.png" alt="6.png"></p><p>看了上面的内容，其实我们还是不清楚 webpack 到底做了哪些事情使浏览器不支持的语法变得可以执行，而去查看源码，会发现源码中代码对我们不是特别友好，经常左跳右跳无法持续跟踪，所以针对 webpack 打包流程，总结了下面的一个简版打包代码，让我们能大体看清 webpack 做了哪些操作，以下只是简版 demo，没有强行靠近 webpack 打包结果，让我们更能清晰的梳理流程。</p><h2 id="打包步骤总结"><a href="#打包步骤总结" class="headerlink" title="打包步骤总结"></a>打包步骤总结</h2><ol><li>我们工程的依赖路径 index.js -&gt; hello.js -&gt; message.js</li><li>根据 webpack.config.js 中定义的 entry 解析入口（index.js）文件，找到他的依赖</li><li>递归的构建依赖关系图</li><li>将所有内容打包到 webpack.config.js 定义的 output 文件</li></ol><p>在整理打包内容之前，我们先来看下我们现在项目的结构，项目名称为 webpack_demo，其中包含 webpack.config.js，package.json，dist&#x2F;main.js，src&#x2F;index.js，src&#x2F;hello.js，src&#x2F;message.js，src&#x2F;bundler.js，src&#x2F;complier.js。</p><p>webpack.config.js 定义对象，导出项目入口出口文件</p><div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-built_in">module</span>.exports = &#123;    entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,    <span class="hljs-built_in">output</span>: &#123;        <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;./dist&#x27;</span>),        filename: <span class="hljs-string">&#x27;main.js&#x27;</span>    &#125;&#125;</code></pre></div><p>src&#x2F;index.js 代码中导入 hello.js方法并执行</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> hello <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hello.js&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hello</span>())</code></pre></div><p>src&#x2F;hello.js 代码中导入 message.js中的message参数</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; message &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./message.js&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello &#x27;</span> + message;&#125;</code></pre></div><p>src&#x2F;message.js 中定义了一个message变量</p><div class="code-wrapper"><pre><code class="hljs delphi"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">message</span> = <span class="hljs-string">&#x27;world!!!&#x27;</span></code></pre></div><p>上面的代码层层引用下来，可以在控制台输出 ‘hello world!!!’，就代表打包成功了。</p><p>上面的环境已经定义完成，接下来让我们按照步骤完成打包操作：</p><ol><li>在src&#x2F;complier.js文件中创建complier构造函数，在构造函数中获取webpack.config.js中定义的入口出口参数</li></ol><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">Complier</span> &#123;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;      <span class="hljs-keyword">const</span> &#123; entry, output &#125; = options      <span class="hljs-variable language_">this</span>.<span class="hljs-property">entry</span> = entry      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(options)      <span class="hljs-variable language_">this</span>.<span class="hljs-property">output</span> = output    &#125;&#125;</code></pre></div><ol><li>在 src&#x2F;bundler.js 文件中引入 webpack.config.js 文件，创建 Complier 的实例化对象并传入 options</li></ol><div class="code-wrapper"><pre><code class="hljs isbl"><span class="hljs-variable">const</span> <span class="hljs-variable">complier</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;./complier&#x27;</span>)</span><span class="hljs-variable">const</span> <span class="hljs-variable">options</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;../webpack.config&#x27;</span>)</span><span class="hljs-variable">new</span> <span class="hljs-function"><span class="hljs-title">complier</span>(<span class="hljs-variable">options</span>)</span></code></pre></div><p>在命令行执行 node src&#x2F;bundler.js 后，在控制台会打印出 options 内容<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453942-qDwVoX-12.png" alt="12.png"></p><ol><li>拿到配置参数后，开始根据入口文件解析文件内容，解析单流程整体为：<ol><li>根据入口文件名称通过 nodejs 提供的方法 fs.readFileSync 读取到文件内容</li><li>使用 @babel&#x2F;parser 将文件内容转换成ast语法树</li><li>ast 语法树中 node 节点中包含了文件依赖的文件名称，使用 @babel&#x2F;traverse 方法提取出依赖的文件名称并存储到一个数组中</li><li>通过 @babel&#x2F;core 中的 babel.transformFromAst 方法将 ast 转换成目标浏览器可执行的代码</li><li>将上述获取的参数返回个对象，对象包含文件名，依赖数组，文件可执行代码，这个对象即为一个依赖图谱中的一个节点</li><li>遍历入口文件的依赖数组，由于数组中是文件名，则递归执行上述方法，直到找到所有依赖</li><li>返回所有依赖对象</li></ol></li></ol><p>根据上面总结内容我们在 src&#x2F;complier.js 中创建一个 createAsset 方法</p><div class="code-wrapper"><pre><code class="hljs awk">const fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>)const path = require(<span class="hljs-string">&#x27;path&#x27;</span>)const parser = require(<span class="hljs-string">&#x27;@babel/parser&#x27;</span>)const traverse = require(<span class="hljs-string">&#x27;@babel/traverse&#x27;</span>).defaultconst babel = require(<span class="hljs-string">&#x27;@babel/core&#x27;</span>)...<span class="hljs-regexp">//</span> 开始编译，构建ast语法树 filename: .<span class="hljs-regexp">/src/i</span>ndex.js    createAsset(filename) &#123;       <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>       <span class="hljs-regexp">//</span> content 内容即为index.js中书写的内容      const content = fs.readFileSync(filename, <span class="hljs-string">&#x27;utf-8&#x27;</span>)      <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>      <span class="hljs-regexp">//</span> ast 内容为对象，具体内容可以console.log(ast)查看      <span class="hljs-regexp">//</span> https:<span class="hljs-regexp">//</span>astexplorer.net/ 在官网输入index.js内容即可看到对应的树      const ast = parser.parse(content, &#123;          sourceType: <span class="hljs-string">&#x27;module&#x27;</span>      &#125;)      <span class="hljs-regexp">//</span> 创建依赖对象      const dependencies = &#123;&#125;      <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>      <span class="hljs-regexp">//</span> 获取抽象语法树中的依赖文件名      traverse(ast, &#123;            ImportDeclaration: (&#123;node&#125;) =&gt; &#123;             <span class="hljs-regexp">//</span> 获取文件的路径名如 <span class="hljs-string">&#x27;./src/index.js&#x27;</span> dirname=<span class="hljs-string">&#x27;./src&#x27;</span>             const dirname = path.dirname(filename)             const absPath = path.join(dirname, node.source.value)             <span class="hljs-regexp">//</span> node.source.value: .hello.js             <span class="hljs-regexp">//</span> absPath: .<span class="hljs-regexp">/src/i</span>ndex.js             dependencies[node.source.value] = absPath            &#125;      &#125;)      <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>      <span class="hljs-regexp">//</span> 将ast转换成可执行代码       <span class="hljs-regexp">//</span> https:<span class="hljs-regexp">//</span>www.babeljs.cn<span class="hljs-regexp">/docs/</span>babel-core 将index.js内容直接放在官网即可看到转译后代码      const &#123; code &#125; = babel.transformFromAst(ast, null, &#123;        presets: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]      &#125;)      <span class="hljs-regexp">//</span> <span class="hljs-number">5</span>      return &#123;          filename,          dependencies,          code      &#125;    &#125;</code></pre></div><p>入口文件的依赖关系已经定义好，接下来根据入口文件的 dependencies ，递归遍历出所有子依赖，在 src&#x2F;complier.js 文件中定义 run 方法</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 拿到参数、执行、分析入口文件</span> <span class="hljs-built_in">run</span>() &#123;    <span class="hljs-comment">// 拿到入口文件的依赖</span>    <span class="hljs-type">const</span> mainAsset = <span class="hljs-keyword">this</span>.<span class="hljs-built_in">createAsset</span>(<span class="hljs-keyword">this</span>.entry)    <span class="hljs-type">const</span> queue = [mainAsset]    <span class="hljs-comment">// 6</span>    <span class="hljs-comment">// 遍历对象</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> asset of queue) &#123;       <span class="hljs-comment">// 遍历文件的依赖文件，递归创建依赖图</span>      Object.<span class="hljs-built_in">values</span>(asset.dependencies).forEach(filename =&gt; &#123;          <span class="hljs-type">const</span> child = <span class="hljs-keyword">this</span>.<span class="hljs-built_in">createAsset</span>(filename)          queue.<span class="hljs-built_in">push</span>(child)      &#125;)    &#125;    <span class="hljs-comment">// 7</span>    <span class="hljs-keyword">return</span> queue &#125;</code></pre></div><p>命令行执行 node src&#x2F;bundler.js 看下 queue 的内容如下<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453942-BjjsRD-8.png" alt="8.png"></p><ol><li>依赖树已经拿到，接下来在 src&#x2F;bundler.js 中获取 complier 中返回的 queue</li></ol><div class="code-wrapper"><pre><code class="hljs stata"><span class="hljs-comment">// 获取dependence graph</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">graph</span> = new complier(options).<span class="hljs-keyword">run</span>()</code></pre></div><ol><li>在 src&#x2F;bundler.js 中创建函数 bundle，解析 graph 树，定义 require 函数，定义 modules，通过 eval 函数执行依赖树中的 code，在此我们可以知道 webpack 重写了 require 函数，所以 babel 中转换的函数可以正常执行</li></ol><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bundle</span>(<span class="hljs-params">graph</span>)</span>&#123;  <span class="hljs-comment">// 得到依赖文件名的对象 </span>  let modules = &#123;&#125;;  graph.<span class="hljs-title function_ invoke__">forEach</span>(item =&gt; &#123;     // 将文件名作为key, value为依赖文件，code为文件名对应的函数    modules[item.filename] = &#123;        <span class="hljs-attr">dependencies</span>: item.dependencies,        <span class="hljs-attr">code</span>: item.code    &#125;  &#125;)  modules = JSON.<span class="hljs-title function_ invoke__">stringify</span>(modules)  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">result</span> = `(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">graph</span>)</span>&#123;      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">require</span>(<span class="hljs-params">filepath</span>) </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">localRequire</span>(<span class="hljs-params">relativePath</span>) </span>&#123;            <span class="hljs-comment">// 将代码中的require中的路径转换成dependencies存储的带文件夹名的路径</span>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">require</span>(graph[filepath].dependencies[relativePath])        &#125;        <span class="hljs-keyword">var</span> exports = &#123;&#125;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"><span class="hljs-keyword">require</span>, exports, code</span>) </span>&#123;            <span class="hljs-keyword">eval</span>(code)        &#125;        <span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params">localRequire, exports, graph[filepath].code</span>)</span><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">exports</span></span><span class="hljs-function">      &#125;</span><span class="hljs-function">      <span class="hljs-title">require</span>(<span class="hljs-params"><span class="hljs-string">&#x27;$&#123;entry&#125;&#x27;</span></span>)</span><span class="hljs-function">    &#125;)(<span class="hljs-params">$&#123;modules&#125;</span>)`</span><span class="hljs-function">  <span class="hljs-title">return</span> <span class="hljs-title">result</span></span><span class="hljs-function">&#125;</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">const</span> <span class="hljs-title">graph</span> = <span class="hljs-title">new</span> <span class="hljs-title">complier</span>(<span class="hljs-params">options</span>).<span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span><span class="hljs-function">// 执行<span class="hljs-title">bundle</span>函数</span><span class="hljs-function"><span class="hljs-title">const</span> <span class="hljs-title">result</span> = <span class="hljs-title">bundle</span>(<span class="hljs-params">graph</span>)</span></code></pre></div><p>命令行输出 result 内容，粘贴内容到浏览器控制台并回车执行，发现我们预期的 ‘hello world!!!’ 已经可以正常打印<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655454170-vhNhQb-11.png" alt="11.png"></p><ol><li>以上我们已经拿到了编译后的代码，最后将它输出到 dist&#x2F;main.js 中，在 src&#x2F;bundler.js 中创建方法 createFile()，使用 fs 对象的 writeFileSync 将内容输出，在命令行执行命令后可以看到 src&#x2F;main.js 中输出了对应内容</li></ol><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> create<span class="hljs-constructor">File(<span class="hljs-params">code</span>)</span> &#123;    fs.write<span class="hljs-constructor">FileSync(<span class="hljs-params">path</span>.<span class="hljs-params">join</span>(<span class="hljs-params">output</span>.<span class="hljs-params">path</span>, <span class="hljs-params">output</span>.<span class="hljs-params">filename</span>)</span>, code)&#125;</code></pre></div><ol><li>下面是 src&#x2F;complier.js和 src&#x2F;bundler.js文件全部内容</li></ol><p>complier.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 文件操作模块，读取文件内容</span><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/parser&#x27;</span>)<span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/traverse&#x27;</span>).<span class="hljs-property">default</span><span class="hljs-keyword">const</span> babel = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@babel/core&#x27;</span>)<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">Complier</span> &#123;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;      <span class="hljs-keyword">const</span> &#123; entry, output &#125; = options      <span class="hljs-variable language_">this</span>.<span class="hljs-property">entry</span> = entry      <span class="hljs-variable language_">this</span>.<span class="hljs-property">output</span> = output    &#125;    <span class="hljs-comment">// 拿到参数、执行、分析入口文件</span>    <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;       <span class="hljs-keyword">const</span> mainAsset = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createAsset</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">entry</span>)       <span class="hljs-keyword">const</span> queue = [mainAsset]       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> asset <span class="hljs-keyword">of</span> queue) &#123;         <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(asset.<span class="hljs-property">dependencies</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span> &#123;             <span class="hljs-keyword">const</span> child = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createAsset</span>(filename)             queue.<span class="hljs-title function_">push</span>(child)         &#125;)       &#125;       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue)       <span class="hljs-keyword">return</span> queue    &#125;    <span class="hljs-comment">// 开始编译，构建ast语法树 filename: ./src/index.js</span>    <span class="hljs-title function_">createAsset</span>(<span class="hljs-params">filename</span>) &#123;      <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(filename, <span class="hljs-string">&#x27;utf-8&#x27;</span>)      <span class="hljs-keyword">const</span> ast = parser.<span class="hljs-title function_">parse</span>(content, &#123;          <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&#x27;module&#x27;</span>      &#125;)      <span class="hljs-comment">// 创建依赖</span>      <span class="hljs-keyword">const</span> dependencies = &#123;&#125;      <span class="hljs-title function_">traverse</span>(ast, &#123;            <span class="hljs-title class_">ImportDeclaration</span>: <span class="hljs-function">(<span class="hljs-params">&#123;node&#125;</span>) =&gt;</span> &#123;             <span class="hljs-comment">// 获取文件的路径名如 &#x27;./src/index.js&#x27; dirname=&#x27;./src&#x27;</span>             <span class="hljs-keyword">const</span> dirname = path.<span class="hljs-title function_">dirname</span>(filename)             <span class="hljs-keyword">const</span> absPath = path.<span class="hljs-title function_">join</span>(dirname, node.<span class="hljs-property">source</span>.<span class="hljs-property">value</span>)             dependencies[node.<span class="hljs-property">source</span>.<span class="hljs-property">value</span>] = absPath            &#125;        &#125;)      <span class="hljs-comment">// 将ast转换成代码 </span>      <span class="hljs-comment">// https://www.babeljs.cn/docs/babel-core</span>      <span class="hljs-keyword">const</span> &#123; code &#125; = babel.<span class="hljs-title function_">transformFromAst</span>(ast, <span class="hljs-literal">null</span>, &#123;        <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>]      &#125;)      <span class="hljs-keyword">return</span> &#123;          filename,          dependencies,          code      &#125;    &#125;&#125;</code></pre></div><p>bundler.js</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// 引入配置</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">fs</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">path</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">options</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;../webpack.config&#x27;</span>)<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">complier</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;./complier&#x27;</span>)<span class="hljs-keyword">const</span> &#123; entry, output &#125; = options<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bundle</span>(<span class="hljs-params">graph</span>)</span>&#123;  <span class="hljs-comment">// 得到以依赖文件名的对象 </span>  let modules = &#123;&#125;;  graph.<span class="hljs-title function_ invoke__">forEach</span>(item =&gt; &#123;    modules[item.filename] = &#123;        <span class="hljs-attr">dependencies</span>: item.dependencies,        <span class="hljs-attr">code</span>: item.code    &#125;  &#125;)  modules = JSON.<span class="hljs-title function_ invoke__">stringify</span>(modules)  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">result</span> = `(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">graph</span>)</span>&#123;      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">require</span>(<span class="hljs-params">filepath</span>) </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">localRequire</span>(<span class="hljs-params">relativePath</span>) </span>&#123;            <span class="hljs-comment">// 将代码中的require中的路径转换成dependencies存储的带文件夹名的路径</span>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">require</span>(graph[filepath].dependencies[relativePath])        &#125;        <span class="hljs-keyword">var</span> exports = &#123;&#125;                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"><span class="hljs-keyword">require</span>, exports, code</span>) </span>&#123;            <span class="hljs-keyword">eval</span>(code)        &#125;                <span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params">localRequire, exports, graph[filepath].code</span>)</span><span class="hljs-function"></span><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">exports</span></span><span class="hljs-function">      &#125;</span><span class="hljs-function">      <span class="hljs-title">require</span>(<span class="hljs-params"><span class="hljs-string">&#x27;$&#123;entry&#125;&#x27;</span></span>)</span><span class="hljs-function">    &#125;)(<span class="hljs-params">$&#123;modules&#125;</span>)`</span><span class="hljs-function">  <span class="hljs-title">return</span> <span class="hljs-title">result</span></span><span class="hljs-function">&#125;</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">function</span> <span class="hljs-title">createFile</span>(<span class="hljs-params">code</span>) </span>&#123;    fs.<span class="hljs-title function_ invoke__">writeFileSync</span>(path.<span class="hljs-title function_ invoke__">join</span>(output.path, output.filename), code)&#125;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">graph</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">complier</span>(options).<span class="hljs-title function_ invoke__">run</span>()<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">result</span> = <span class="hljs-title function_ invoke__">bundle</span>(graph)<span class="hljs-title function_ invoke__">createFile</span>(result)</code></pre></div><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>通过上面的 demo，我们已经可以大概了解 webpack 的编译流程，当然 webpack 的源码功能强大且复杂，感兴趣的小伙伴儿可以自行研究。</p><h3 id="Entry-和-Context"><a href="#Entry-和-Context" class="headerlink" title="Entry 和 Context"></a>Entry 和 Context</h3><h1 id="配置入口context和entry"><a href="#配置入口context和entry" class="headerlink" title="配置入口context和entry"></a>配置入口context和entry</h1><p>webpack 在构建打包时，通过 context 和 entry 这两个配置来找到打包入口路径。在配置入口时其实做了两件事：</p><ul><li><p>确认入口文件位置，告诉 webpack 从哪个文件开始打包</p></li><li><p>描述 chunk name。如果传入一个字符串或字符串数组，那么默认的 chunk name 为 “main”，如果传入的是一个对象，则每个属性的 key 会是 chunk 的名称，该属性的值描述了 chunk 的入口点</p></li></ul><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>context 可以理解为配置资源入口的基础目录，在配置时要求必须使用绝对路径。如：现有的目录结构入口为 &#x2F;src&#x2F;script&#x2F;index.js，则我们可以通过下面的配置来指定入口目录</p><div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-built_in">module</span>.exports = &#123;  context: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;./src/script&#x27;</span>),  entry: <span class="hljs-string">&#x27;./index.js&#x27;</span>&#125;;<span class="hljs-built_in">module</span>.exports = &#123;  context: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;./src&#x27;</span>),  entry: <span class="hljs-string">&#x27;./script/index.js&#x27;</span>&#125;;</code></pre></div><p>这样配置后，命令行执行打包，发现依然成功的找到了入口并顺利打包（我们使用 hello world 的那个 demo 来执行现有配置）<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655454753-KcOwRo-1.png" alt="1.png"></p><p>配置 context 的目的可以使 entry 的写法更加简洁，尤其是在多入口文件的情况下。不过 context 是可以省略的，默认值为当前工程的根目录。</p><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>在 webpack 配置中有多种方式定义 entry 属性，如：字符串、数组、对象、函数，接下来我们展示下每种类型如何配置</p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>直接定义入口名称</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  entry: <span class="hljs-string">&#x27;./src/script/index.js&#x27;</span>,&#125;;<span class="hljs-comment">// entry 单入口语法，是下面的简写</span><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  entry: &#123;    main: <span class="hljs-string">&#x27;./src/script/index.js&#x27;</span>,  &#125;,&#125;;</code></pre></div><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>传入一个数组的作用是将多个文件预先合并，最终将多个依赖的内容绘制在一个 chunk 中，在打包时 webpack 会将数组中的最后一个元素作为实际的入口路径，其余文件会预先构建到入口文件。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  entry: [<span class="hljs-string">&#x27;lodash&#x27;</span>, <span class="hljs-string">&#x27;./src/script/index.js&#x27;</span>],&#125;;</code></pre></div><p>这种配置和下面是等效的</p><div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-comment">// index.js</span><span class="hljs-keyword">import</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span><span class="hljs-comment">// webpack.config.js</span><span class="hljs-keyword">module</span>.exports = &#123;  entry: <span class="hljs-string">&#x27;./src/script/index.js&#x27;</span>,&#125;</code></pre></div><p>这种写法会将 lodash 打包到我们的 bundle.js 中。这种写法类似于在 index.js 中引入 lodash，在控制台执行打包命令我们来看下生成的文件，从下面两张图可以看到在 index 中我们没有引入 lodash，但打包的文件中已经引入了 lodash<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655454755-pHqfJy-2.png" alt="2.png"></p><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>如果要定义多入口文件则需要使用对象的形式，通过这种方式可以自定义 chunk name，其中对象的key即为 chunk name，对象的 value 为入口路径。在使用对象描述入口时，我们可以使用以下属性</p><ul><li>dependOn: 当前入口所依赖的入口。它们必须在该入口被加载前被加载</li><li>filename: 指定要输出的文件名称</li><li>import: 启动时需加载的模块</li><li>library: 指定 library 选项，为当前 entry 构建一个 library</li><li>runtime: 运行时 chunk 的名字。如果设置了，就会创建一个新的运行时 chunk。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时 chunk</li><li>publicPath: 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共 URL 地址</li></ul><p>多入口配置本质上打包后生成多个js文件</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  entry: &#123;    index: [<span class="hljs-string">&#x27;lodash&#x27;</span>, <span class="hljs-string">&#x27;./src/script/index.js&#x27;</span>],    vendor: <span class="hljs-string">&#x27;./vendor&#x27;</span>  &#125;&#125;</code></pre></div><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>使用函数类型定义入口时，只要返回上面介绍的几种形式即可，如</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 返回字符串module.<span class="hljs-built_in">exports</span> = &#123;  entry: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">&#x27;./src/script/index.js&#x27;</span>&#125;<span class="hljs-regexp">//</span> 返回对象module.<span class="hljs-built_in">exports</span> = &#123;  entry: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&#123;    index: [<span class="hljs-string">&#x27;lodash&#x27;</span>, <span class="hljs-string">&#x27;./src/script/index.js&#x27;</span>],    vendor: <span class="hljs-string">&#x27;./vendor&#x27;</span>  &#125;)&#125;</code></pre></div><p>传入函数的优点是我们可以通过函数中增加一些逻辑来动态改变打包入口</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本章我们梳理了 webpack 入口配置的几种方式，包括字符串、对象、数组、函数几种</p><ul><li><a href="https://leetcode.cn/"><img src="https://static.leetcode.cn/cn-mono-assets/production/assets/logo-dark-cn.c42314a8.svg" alt="logo"></a></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/avatar_1645205761.webp" alt="img"><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/plus-light.594ca211.svg+xml" alt="img"></p><p><a href="https://leetcode.cn/leetbook/detail/qian-duan-webpack-gong-lue/">返回 前端 Webpack 攻略</a></p><p><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0tokh/">新手上路</a></p><p><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n03ct1/">前言</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n085q3/">Hello World</a></p><p><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0q4u7/">核心概念-入口</a></p><p><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0zlwc/">资源处理流程</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0sdvi/">Entry 和 Context</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n04nne/">Entry 配置实例</a></p><p><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n06gi5/">核心概念-出口</a></p><p><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n01mag/">配置参数详解</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0yomv/">输出配置实例</a></p><p><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0kq76/">核心概念-Loader</a></p><p><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0c5rj/">概述</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0cfot/">HTML-Loader</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0bcer/">URL-Loader</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0j45s/">File-Loader</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0fgxd/">CSS-Loader</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n7hqhh/">Style-Loader</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n7xuj3/">Postcss-Loader</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n757bm/">Sass-Loader</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n79wy1/">Svg-URL-Loader</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n7e217/">Svg-Sprite-Loader</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n7op45/">VUE-Loader</a><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n7rez6/">VUE-Style-Loader</a></p><p><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/n0gt02/">核心概念-Plugin</a></p><p><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/nsnsns/">配置</a></p><p><a href="https://leetcode.cn/leetbook/read/qian-duan-webpack-gong-lue/nsvk2d/">优化</a></p><h3 id="Entry-配置实例"><a href="#Entry-配置实例" class="headerlink" title="Entry 配置实例"></a>Entry 配置实例</h3><h1 id="entry-配置实例"><a href="#entry-配置实例" class="headerlink" title="entry 配置实例"></a>entry 配置实例</h1><p>webpack 的 entry 配置在实际的应用中可以分几个场景。</p><ul><li>单页应用</li><li>多页应用</li><li>分离应用程序和第三方库</li></ul><p>下面我们来介绍下这几种应用</p><h2 id="单页应用"><a href="#单页应用" class="headerlink" title="单页应用"></a>单页应用</h2><p>对于单页应用，我们一般来定义单一入口即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,&#125;;</code></pre></div><p>通过单一入口打包文件，可以将所有入口文件依赖的 框架、引入的工具库、各个页面内容打包到一起。这样的好处是将所有内容都打包成一个 js 文件，依赖关系清晰。但是这种方式也有个弊端，即所有模块都打到一个包中，当应用规模上升到一定程度后导致打包资源体积过大，导致页面首次加载速度变慢</p><h2 id="多页应用"><a href="#多页应用" class="headerlink" title="多页应用"></a>多页应用</h2><p>对于多页应用的场景，为了尽可能减少打包资源的体积，我们希望每个页面都只加载各自必要的逻辑，而不是将所有内容都打包到一个 bundle 中，我们来看下多应用的配置</p><div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-built_in">module</span>.exports = &#123;  entry: &#123;    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,    hello: <span class="hljs-string">&#x27;./src/hello.js&#x27;</span>  &#125;,  <span class="hljs-built_in">output</span>: &#123;    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)  &#125;&#125;;</code></pre></div><p>打包后的文件如下，可以看到打包的内容中包含了 index.js 和 hello.js 两个文件。<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655454806-jTABfY-1.png" alt="1.png"></p><h2 id="分离应用程序和第三方库"><a href="#分离应用程序和第三方库" class="headerlink" title="分离应用程序和第三方库"></a>分离应用程序和第三方库</h2><p>在一个应用中，我们使用的框架、库、第三方依赖等往往很少会有改动，如果我们将所有内容都打包到一个 bundle 文件，一旦业务代码有一点点变更，那用户就要重新下载整个资源，这对于页面的性能是很不友好的。为了解决这个问题，我们可以使用应用程序和第三方库分离的方式来打包文件。也就是将业务代码和不频繁变更的第三方依赖分 bundle 打包，示例如下<br>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  mode: <span class="hljs-string">&#x27;development&#x27;</span>,  entry: &#123;    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,    vendor: [<span class="hljs-string">&#x27;lodash&#x27;</span>]  &#125;&#125;;</code></pre></div><p>index.js</p><div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span></code></pre></div><p>在上面的配置中，index.js 仍然和之前一样不做任何处理，只是我们新添加了一个 chunk name 为 vendor 的入口，并通过数组的形式将第三方依赖添加进去，执行打包命令我们看到输出了两个打包文件。<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655454806-dpjQmi-2.png" alt="2.png"></p><p>其实上面的代码虽然打包成功了，也成功提取了 vender 文件，但是打开打包后的 dist&#x2F;index.js 我们发现 lodash 还是被打到文件中了，对于这种情况我们可以配合使用 optimization.splitChunks，将 vender 和 index 中的公共代码提取出来，这个方法我们后面的文章在详细介绍。</p><p>通过上面的配置，我们可以业务依赖的第三方模块抽取成一个独立的 bundle，由于这个 bundle 不经常变动，因此可以有效的利用客户端缓存，在用户后续请求页面时加快整体渲染速度。</p><h2 id="配置参数详解"><a href="#配置参数详解" class="headerlink" title="配置参数详解"></a>配置参数详解</h2><h1 id="output-输出配置详解"><a href="#output-输出配置详解" class="headerlink" title="output 输出配置详解"></a>output 输出配置详解</h1><p>output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 .&#x2F;dist&#x2F;main.js，其他生成文件默认放置在 .&#x2F;dist 文件夹中。</p><p>我们可以通过在配置中指定一个 output 对象，来配置这些处理过程：</p><div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-built_in">module</span>.exports = &#123;  mode: <span class="hljs-string">&#x27;development&#x27;</span>,  entry: &#123;    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>  &#125;,  <span class="hljs-built_in">output</span>: &#123;    filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),    publicPath: <span class="hljs-string">&#x27;/assets/&#x27;</span>,    library: <span class="hljs-string">&#x27;DemoLibrary&#x27;</span>, // 导出名称    libraryTarget: <span class="hljs-string">&#x27;window&#x27;</span> // 挂载目标  &#125;&#125;;</code></pre></div><p>output 对象中可以包含数十个配置项，其中大部分开发中使用频率不高，我们在本章内容中只介绍几个常用配置，对其他配置感兴趣的同学可以查看官网 <a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/configuration/output/#outputlibrary">output配置</a></p><h2 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h2><p>filename 决定了每个输出 bundle 的名称。这些 bundle 将写入到 output.path 选项指定的目录下。<br>对于单个入口起点，filename 会是一个静态名称。 filename 支持以字符串和函数的形式定义参数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 字符串形式</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  ...  <span class="hljs-attr">output</span>: &#123;    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,  &#125;&#125;;<span class="hljs-comment">// 函数形式</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  ...  <span class="hljs-attr">output</span>: &#123;    <span class="hljs-attr">filename</span>: <span class="hljs-function">(<span class="hljs-params">pathData</span>) =&gt;</span> &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pathData)      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[name].js&#x27;</span>;    &#125;  &#125;&#125;;</code></pre></div><p>字符串形式的 filename，会在输出文件中生成 bundle.js，函数形式的 filename 会在输出文件中生成 index.js (以 chunk name 命名)，在控制台输出下 pathData，我们可以看到返回了一个包含 chunk 内容等信息的对象。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455164-gvBnpN-2.png" alt="2.png"></p><p>filename 可以不仅仅是 bundle 的名字，还可以使用像 ‘js&#x2F;[name]&#x2F;bundle.js’ 这样的文件路径，即便路径中的目录不存在也没关系，webpack 会在输出资源时创建该目录。例子如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  output: &#123;    filename: <span class="hljs-string">&#x27;js/[name]/bundle.js&#x27;</span>  &#125;&#125;;</code></pre></div><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455238-APpelQ-3.png" alt="3.png"></p><p>当通过多个入口起点(entry point)、代码拆分(code splitting)或各种插件(plugin)创建多个 bundle，应该使用以下一种替换方式，来赋予每个 bundle 一个唯一的名称</p><table><thead><tr><th>替换方式</th><th>变量名称</th><th>功能描述</th><th>使用方式</th><th>打包结果</th></tr></thead><tbody><tr><td>入口名称</td><td>[name]</td><td>如果设置，则为此 chunk 的名称，否则使用 chunk 的 ID</td><td>filename: ‘[name].bundle.js’</td><td><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455277-rmXrzq-4.png" alt="4.png"></td></tr><tr><td>chunk id</td><td>[id]</td><td>指代 此 chunk 的 id</td><td>filename: ‘[id].bundle.js’</td><td><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455277-XjORkS-5.png" alt="5.png"></td></tr><tr><td>chunk hash</td><td>[chunkhash]</td><td>此 chunk 的 hash 值，包含该 chunk 的所有元素</td><td>filename: ‘[chunkhash].bundle.js’</td><td><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455277-XrOcco-6.png" alt="6.png"></td></tr><tr><td>content hash</td><td>[contenthash]</td><td>指代由生成的内容产生的 hash</td><td>filename: ‘[contenthash].bundle.js’</td><td><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455277-HqewjZ-7.png" alt="7.png"></td></tr></tbody></table><p>上面的配置除了可以对不同的 bundle 进行名称区分，还能起到一个控制客户端缓存的作用，表中的[chunkhash] 和 [contenthash] 都与文件内容直接相关，在 filename 中使用了这些变量后，当对文件内容做了修改，可以引起 bundle 文件名的修改，从而用户在下一次请求文件资源时会重新加载文件，而不会直接命中缓存资源。</p><p>在实际的工程中，我们一般使用较多的是[name]，一般与定义的 chunk 一一对应，可读性较高，为了控制客户端缓存，我们一般还加上 [contenthash]，如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  output: &#123;    filename: <span class="hljs-string">&#x27;[name]-[contenthash].js&#x27;</span>  &#125;&#125;;</code></pre></div><p>打包结果如下<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455351-gcqeym-8.png" alt="8.png"></p><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>path 可以指定资源输出位置，要求必须使用绝对路径，如</p><div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-built_in">module</span>.exports = &#123;  mode: <span class="hljs-string">&#x27;development&#x27;</span>,  entry: &#123;    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,  &#125;,  <span class="hljs-built_in">output</span>: &#123;    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)  &#125;&#125;;</code></pre></div><p>上述配置将工程的dist目录设置为资源的输出目录，在 webpack 4 之后，output.path 已经默认为 dist 目录，除非我们需要修改他，否则可以不用单独配置。</p><h2 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h2><p>publicPath 从功能上来说，用于指定资源的请求位置。页面中的资源分为两种，一种是由 HTML 页面直接请求的，比如通过 script 标签加载 js，通过 link 标签加载 css。另一种是由 js 或 css 请求的，如加载图片字体文件等。 publicPath 就用来指定第二种间接资源的请求位置。如果指定了一个错误的值，则在加载这些资源时会收到 404 错误。</p><p>publicPath 有以下三种形式</p><ol><li><p>相对于 HTML</p></li><li><p>相对于 HOST</p></li><li><p>相对于 CDN</p></li></ol><h3 id="相对于-HTML"><a href="#相对于-HTML" class="headerlink" title="相对于 HTML"></a>相对于 HTML</h3><p>在请求资源时，会以当前 html 页面所在路径加上 publicPath 的相对路径来构成实际请求的 URL，如</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 假设当前 html 页面地址为 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/webpack/i</span>ndex.html<span class="hljs-regexp">//</span> 需要请求文件名为 demo.pngmodule.exports = &#123;  ...  output: &#123;    publicPath: <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/webpack/</span>demo.png    publicPath: <span class="hljs-string">&#x27;./css&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/webpack/</span>css/demo.png    publicPath: <span class="hljs-string">&#x27;../assets/&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/assets/</span>demo.png  &#125;&#125;;</code></pre></div><h3 id="相对于-HOST"><a href="#相对于-HOST" class="headerlink" title="相对于 HOST"></a>相对于 HOST</h3><p>若 publicPath 的值以 “&#x2F;” 开始，则代表此时 publicPath 是以当前页面的域名加上 publicPath 的相对路径来构成实际请求的 URL，如</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 假设当前 html 页面地址为 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/webpack/i</span>ndex.html<span class="hljs-regexp">//</span> 需要请求文件名为 demo.pngmodule.exports = &#123;  ...  output: &#123;    publicPath: <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 http:<span class="hljs-regexp">//</span>demo.com/demo.png    publicPath: <span class="hljs-string">&#x27;/css&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/css/</span>demo.png    publicPath: <span class="hljs-string">&#x27;../assets/&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/assets/</span>demo.png  &#125;&#125;;</code></pre></div><h3 id="相对于-CDN"><a href="#相对于-CDN" class="headerlink" title="相对于 CDN"></a>相对于 CDN</h3><p>上面两种配置都是相对路径，我们也可以使用绝对路径的形式配置 publicPath，这种情况一般发生在将静态资源放在 CDN 上面，如</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 假设当前 html 页面地址为 http:<span class="hljs-regexp">//</span>demo.com<span class="hljs-regexp">/webpack/i</span>ndex.html<span class="hljs-regexp">//</span> 需要请求文件名为 demo.pngmodule.exports = &#123;  ...  output: &#123;    publicPath: <span class="hljs-string">&#x27;http://cdn.example.com/assets/&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 http:<span class="hljs-regexp">//</span>cdn.example.com<span class="hljs-regexp">/assets/</span>demo.png    publicPath: <span class="hljs-string">&#x27;https://cdn.example.com/assets/&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 https:<span class="hljs-regexp">//</span>cdn.example.com<span class="hljs-regexp">/assets/</span>demo.png    publicPath: <span class="hljs-string">&#x27;//cdn.example.com/assets/&#x27;</span> <span class="hljs-regexp">//</span> 实际请求路径 <span class="hljs-regexp">//</span>cdn.example.com<span class="hljs-regexp">/assets/</span>demo.png  &#125;&#125;;</code></pre></div><p>webpack-dev-server 也会默认从 publicPath 为基准，使用它来决定在哪个目录下启用服务，来访问 webpack 输出的文件。</p><h2 id="library"><a href="#library" class="headerlink" title="library"></a>library</h2><p>library 的作用是将打包的内容生成一个库，可以供其他工程加载使用。这一点在目前流行的微前端架构实战上面很有用，如子应用通过输出类库的形式将内容输出到一个对象上，这样主应用就可以通过加载 js 的方式去引入子应用，并且可以通过子应用输出的对象名称来加载子应用的内容。library 具体的使用方法，我们来看下面的例子：</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,  output: &#123;    library: <span class="hljs-string">&#x27;DemoLibrary&#x27;</span>  &#125;&#125;;</code></pre></div><p>src&#x2F;index.js 的入口中导出了如下函数</p><div class="code-wrapper"><pre><code class="hljs arcade">export <span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">webpack</span>) &#123;  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`hello <span class="hljs-subst">$&#123;webpack&#125;</span>`</span>);&#125;</code></pre></div><p>此时，变量 DemoLibrary 将与入口文件所导出的文件进行绑定，下面是如何使用打包生成的index.js文件：<br>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>测试DemoLibrary库<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./dist/index.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-title class_">DemoLibrary</span>.<span class="hljs-title function_">hello</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>在浏览器中可以看到成功输出 hello webpack。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455351-EBIJbq-9.png" alt="9.png"></p><p>library 的类型可以为字符串、数组、和对象，字符串的参数类型则直接指代库的名称，与对象中设置 name 属性作用相同。如果 entry 入口设置为 object，所有入口都可以通过 library 的 array 语法暴露：</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;  <span class="hljs-regexp">//</span> …  entry: &#123;    a: <span class="hljs-string">&#x27;./src/a.js&#x27;</span>,    b: <span class="hljs-string">&#x27;./src/b.js&#x27;</span>,  &#125;,  output: &#123;    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,    library: [<span class="hljs-string">&#x27;DemoLibrary&#x27;</span>, <span class="hljs-string">&#x27;[name]&#x27;</span>], <span class="hljs-regexp">//</span> [name] 为 chunk name  &#125;,&#125;;</code></pre></div><p>假设 a.js 与 b.js 导出名为 hello 的函数，下面就是如何使用这些库的方法：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>测试DemoLibrary库<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./dist/a.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./dist/b.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-title class_">DemoLibrary</span>.<span class="hljs-property">a</span>.<span class="hljs-title function_">hello</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);</span><span class="language-javascript">    <span class="hljs-title class_">DemoLibrary</span>.<span class="hljs-property">b</span>.<span class="hljs-title function_">hello</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>请注意，如果你打算在每个入口点配置 library 配置项的话，以上配置将不能按照预期执行。这里是如何 在每个入口点下 做的方法：</p><div class="code-wrapper"><pre><code class="hljs dart">module.exports = &#123;  <span class="hljs-comment">// …</span>  entry: &#123;    main: &#123;      <span class="hljs-keyword">import</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,      <span class="hljs-keyword">library</span>: &#123;        <span class="hljs-comment">// `output.library` 下的所有配置项可以在这里使用</span>        name: <span class="hljs-string">&#x27;MyLibrary&#x27;</span>,        type: <span class="hljs-string">&#x27;umd&#x27;</span>,        umdNamedDefine: <span class="hljs-keyword">true</span>,      &#125;,    &#125;,    another: &#123;      <span class="hljs-keyword">import</span>: <span class="hljs-string">&#x27;./src/another.js&#x27;</span>,      <span class="hljs-keyword">library</span>: &#123;        name: <span class="hljs-string">&#x27;AnotherLibrary&#x27;</span>,        type: <span class="hljs-string">&#x27;commonjs2&#x27;</span>,      &#125;,    &#125;,  &#125;,&#125;;</code></pre></div><p>library 包含以下可配置参数</p><table><thead><tr><th>参数名称</th><th>功能描述</th><th>支持类型</th></tr></thead><tbody><tr><td>name</td><td>指定库的名称</td><td>字符串、数组、对象</td></tr><tr><td>type</td><td>配置将库暴露的方式</td><td>字符串</td></tr><tr><td>export</td><td>指定哪一个导出应该被暴露为一个库</td><td>字符串、数组</td></tr><tr><td>auxiliaryComment</td><td>在 UMD 包装器中添加注释</td><td>字符串、对象</td></tr><tr><td>umdNamedDefine</td><td>将 AMD 模块命名为 UMD 构建</td><td>布尔</td></tr></tbody></table><p>这里我们说下 type 类型，在实际的使用中，我们可能根据工程运行环境的需要，而需要将类库暴露为不同的类型，如 支持 esModule、amd、cmd、umd 等，type 配置就可以帮我们完成不同输出方式。</p><p>type 类型默认包括 ‘var’、’module’、’assign’、’assign-properties’、’this’、’window’、’self’、’global’、’commonjs’、’commonjs2’、’commonjs-module’、’commonjs-static’、’amd’、’amd-require’、’umd’、’umd2’、’jsonp’ 以及 ‘system’，除此之外也可以通过插件添加。官方文档对每种类型给了详细说明和事例，具体我们可查看官方文档，<a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/configuration/output/#outputlibrarytype">output.target.type 配置</a></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>以上为我们在实际开发中使用的 output 配置，包含 path、filename、publicPath、library，日常使用中可能还会用到 libraryTarget ，不过 webpack 未来会放弃对 output.libraryTarget 的支持，所以可以使用 output.library.type 替代 output.libraryTarget。</p><h2 id="输出配置实例"><a href="#输出配置实例" class="headerlink" title="输出配置实例"></a>输出配置实例</h2><h1 id="output-输出配置实例"><a href="#output-输出配置实例" class="headerlink" title="output 输出配置实例"></a>output 输出配置实例</h1><p>到目前为止，我们都是在 index.html 文件中手动引入打包生成的资源，然而随着应用程序增长，并且一旦开始在文件名中使用 hash 并输出 多个 bundle，如果继续手动管理 index.html 文件，就会变得困难起来。然而，通过一些插件可以使这个过程更容易管控。HtmlWebpackPlugin 可以帮我们解决这个问题。</p><h2 id="设置-HtmlWebpackPlugin"><a href="#设置-HtmlWebpackPlugin" class="headerlink" title="设置 HtmlWebpackPlugin"></a>设置 HtmlWebpackPlugin</h2><p>继续使用之前的工程文件，目录结构为：</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455531-GLJkvW-1.png" alt="1.png"></p><p>首先安装插件，并且调整 webpack.config.js 文件：<br>安装 html-webpack-plugin 插件</p><div class="code-wrapper"><pre><code class="hljs css">npm install <span class="hljs-attr">--save-dev</span> <span class="hljs-selector-tag">html</span>-webpack-plugin</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,  <span class="hljs-attr">entry</span>: &#123;    <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,    <span class="hljs-attr">hello</span>: <span class="hljs-string">&#x27;./src/hello.js&#x27;</span>  &#125;,  <span class="hljs-attr">output</span>: &#123;    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>  &#125;,  <span class="hljs-attr">plugins</span>: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;管理输出&#x27;</span>,    &#125;),  ],&#125;;</code></pre></div><p>执行构建命令 npm run build，我们看下打包后的结果，我们可以看到，打包文件包含两个入口文件对应的 js 文件，还包含一个 index.html 文件</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455531-mkBBWv-2.png" alt="2.png"></p><p>在 dist 目录下我们看下打包的 index.html 文件，我们可以看到 HtmlWebpackPlugin 创建了一个全新的 index.html 文件，所有的 bundle 会自动添加到 html 中。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655455531-YxKehy-3.png" alt="3.png"></p><h2 id="清理-x2F-dist-文件夹"><a href="#清理-x2F-dist-文件夹" class="headerlink" title="清理 &#x2F;dist 文件夹"></a>清理 &#x2F;dist 文件夹</h2><p>你可能已经注意到，由于遗留了之前指南中的代码示例，我们的 &#x2F;dist 文件夹显得相当杂乱。webpack 将生成文件并放置在 &#x2F;dist 文件夹中，但是它不会追踪哪些文件是实际在项目中用到的。</p><p>通常比较推荐的做法是，在每次构建前清理 &#x2F;dist 文件夹，这样 &#x2F;dist 文件夹中只有最近一次生成的文件。让我们使用 output.clean（ webpack 5.20.0 及以上版本支持）配置项实现这个需求。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  output: &#123;    clean: <span class="hljs-literal">true</span>  &#125;&#125;;</code></pre></div><p>现在，执行 npm run build，检查 &#x2F;dist 文件夹。如果一切顺利，现在只会看到构建后生成的文件，而没有旧文件！</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>本章我们介绍了一个优化开发效率的插件和一个配置项，使用 HtmlWebpackPlugin 插件可以动态的生成 index.html 文件，以及动态的向 index.html 文件插入 bundle。了解了如何在编译时清空 dist 文件内容。</p><h1 id="核心概念-Loader"><a href="#核心概念-Loader" class="headerlink" title="核心概念-Loader"></a>核心概念-Loader</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h1 id="loader-概述"><a href="#loader-概述" class="headerlink" title="loader 概述"></a>loader 概述</h1><p>到目前为止，我们的案例都是都是介绍的如何打包 js 文件，对于工程中的其他类型资源，如 CSS、图片、字体等， webpack 会如何处理呢？在实际的项目开发中，我们经常会用到 Sass 或者 Less 来编写样式，我们使用 Typescript 增加静态类型检查，我们使用浏览器不支持的 ECMAScript 新特性，如何让 webpack 来对所有的编译进行统一管理呢？</p><p>本章我们会介绍 loader（预处理器），它赋予了 webpack 可以处理不同资源的能力，极大丰富了其可扩展性。</p><h2 id="loader-作用"><a href="#loader-作用" class="headerlink" title="loader 作用"></a>loader 作用</h2><p>在 webpack 中，一切皆模块，我们可以使用 import、require 等方式 在JavaScript 模块中导入 JS、CSS、图片、字体等多种类型的静态资源，loader 用于对模块的源代码进行转换。loader 可以使我们在导入模块时预处理文件。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript。loader 甚至允许我们直接在 JavaScript 模块中 import CSS 文件！</p><p>loader 本质上是 node module 导出的一个函数，当资源需要被转换时，调用这个函数。下面我们通过自定义 loader，来看 loader 的使用方法。</p><p>src&#x2F;index.js</p><div class="code-wrapper"><pre><code class="hljs arcade">const demoName = <span class="hljs-string">&#x27;webpack loader&#x27;</span><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(demoName)</code></pre></div><p>webpack 默认支持解析 js 文件，我们增加解析 js 的 loader 只为展示 loader 是如何工作的</p><p>src&#x2F;js-loader.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(source)  <span class="hljs-keyword">return</span> <span class="hljs-string">`module.exports=<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(source)&#125;</span>`</span>&#125;</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,  <span class="hljs-attr">entry</span>: &#123;    <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>  &#125;,  <span class="hljs-attr">output</span>: &#123;    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>,    <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>  &#125;,  <span class="hljs-attr">plugins</span>: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;loader&#x27;</span>,    &#125;),  ],  <span class="hljs-attr">module</span>: &#123;    <span class="hljs-attr">rules</span>: [      &#123;        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,        <span class="hljs-attr">use</span>: <span class="hljs-string">&quot;./src/js-loader.js&quot;</span>      &#125;    ]  &#125;&#125;;</code></pre></div><p>执行构建命令，在控制台可以看到 js-loader 文件的 console.log 输出了 index.js 文件内容，从上面的 简易版 js-loader.js 文件中可以看出，loader 本身就是一个函数，在该函数中对接收的内容进行转换，然后返回转换后的结果。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456019-nGbqaR-1.png" alt="1.png"></p><h2 id="loader-使用方式配置"><a href="#loader-使用方式配置" class="headerlink" title="loader 使用方式配置"></a>loader 使用方式配置</h2><p>在我们的应用中，有两种使用 loader 的方式，分别是 配置方式（推荐），内联方式。</p><h3 id="配置方式（推荐）"><a href="#配置方式（推荐）" class="headerlink" title="配置方式（推荐）"></a>配置方式（推荐）</h3><p>module.rules 允许我们在 webpack 配置中指定多个 loader。 这种方式是展示 loader 的一种简明方式，并且有助于使代码变得简洁和易于维护。同时让我们对各个 loader 有个全局概览：</p><p>loader 从右到左（或从下到上）地取值(evaluate)&#x2F;执行(execute)。在下面的示例中，从 css-loader 开始执行，最后以 style-loader 为结束。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  <span class="hljs-keyword">module</span>: &#123;    rules: [      &#123;        test: /\.css$/,        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>,<span class="hljs-string">&#x27;css-loader&#x27;</span>]      &#125;    ]  &#125;&#125;;</code></pre></div><p>src&#x2F;index.js</p><div class="code-wrapper"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;</code></pre></div><p>src&#x2F;index.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;    <span class="hljs-attribute">color</span>: red;    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">text-align</span>: center;&#125;</code></pre></div><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml">...<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>import css<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./dist/index.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>webpack 无法处理 CSS 语法，此时我们执行打包命令 控制台会报 “请使用合适的loader来处理这个文件类型”</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456019-nygaex-2.png" alt="2.png"></p><p>下面我们将 css-loader，style-loader 加到工程中，loader 都是一些第三方 npm 模块，webpack 本身不包含任何 loader, 所以使用前我们需要先安装这些 loader，在工程中执行以下命令安装。</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> css-loader style-loader</code></pre></div><p>安装成功后，在控制台执行打包命令，我们可以看到错误已经消失了，在浏览器打开index.html 文件我们可以看到，样式正常展示。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456019-xKzhzK-3.png" alt="3.png"></p><h3 id="内联方式"><a href="#内联方式" class="headerlink" title="内联方式"></a>内联方式</h3><p>loader 除了使用配置的方式，还有一种内联的用法，可以在 import 语句或任何 与 “import” 方法同等的引用方式 中指定 loader。使用 ! 将资源中的 loader 分开。每个部分都会相对于当前目录解析。</p><p>在上面的例子中，我们注释掉 webpack.config.js 中 module.rules 的配置，将引入方式改为内联方式。</p><p>src&#x2F;index.js</p><div class="code-wrapper"><pre><code class="hljs llvm">import &#x27;<span class="hljs-title">!style-loader</span><span class="hljs-title">!css-loader</span><span class="hljs-title">!.</span>/index.css&#x27;<span class="hljs-comment">;</span></code></pre></div><p>执行打包命令后，我们在浏览器中打开 index.html 文件，可以看到样式正常显示。我们在工程中尽可能使用 module.rules，因为这样可以减少源码中的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。</p><h2 id="loader-特性"><a href="#loader-特性" class="headerlink" title="loader 特性"></a>loader 特性</h2><ul><li>loader 支持链式调用。链中的每个 loader 会将转换应用在已处理过的资源上。一组链式的 loader 将按照相反的顺序执行。链中的第一个 loader 将其结果（也就是应用过转换后的资源）传递给下一个 loader，依此类推。最后，链中的最后一个 loader，返回 webpack 所期望的 JavaScript。</li><li>loader 可以是同步的，也可以是异步的。</li><li>loader 运行在 Node.js 中，并且能够执行任何操作。</li><li>loader 可以通过 options 对象配置（仍然支持使用 query 参数来设置选项，但是这种方式已被废弃）。</li><li>除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块。</li><li>插件(plugin)可以为 loader 带来更多特性。</li><li>loader 能够产生额外的任意文件。</li></ul><h3 id="HTML-Loader"><a href="#HTML-Loader" class="headerlink" title="HTML-Loader"></a>HTML-Loader</h3><h1 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a>html-loader</h1><p>html-loader 用于将 html 文件转换为字符串，支持压缩、导出、对内容预处理。下面让我们来看一个例子。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>html-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./src/assets/card-mark.png&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">const</span> <span class="hljs-variable">HtmlWebpackPlugin</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;      <span class="hljs-comment">// 使用 index.html 内容作为输出模版 </span>      template: <span class="hljs-string">&quot;./index.html&quot;</span>,     &#125;),  ],</code></pre></div><p>在index.html 中我们使用 img 标签展示一张图片，图片为相对路径，在 src&#x2F;assets 文件夹下增加名为 card-mark.png 的图片，在浏览器直接打开 index.html 我们可以看到，图片可以正常展示。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456744-FeKOzS-1.png" alt="1.png"></p><p>此时我们在控制台执行打包命令 npm run build，在 dist 文件夹中 输出了 index.html 文件，我们直接在浏览器打开 index.html 文件，此时图片无法打开。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456744-qKyiJP-2.png" alt="2.png"></p><p>图片打不开的原因为 src 地址使用了相对路径，dist 文件夹与 src 文件夹同目录，所以 src&#x3D;”.&#x2F;src&#x2F;assets&#x2F;card-mark.png” 这个地址无法找到图片，导致图片无法展示。此时我们就可以借助 html-loader 来帮我们解决这个问题。</p><p>安装 html-loader</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> html-loader -D</code></pre></div><p>安装成功后，将 html-loader 配置到 webpack.config.js 中</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  ...  <span class="hljs-attr">plugins</span>: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;      <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;./index.html&quot;</span>,    &#125;),  ],  <span class="hljs-attr">module</span>: &#123;    <span class="hljs-attr">rules</span>: [      &#123;        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.html$/</span>,        <span class="hljs-attr">use</span>: &#123;          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;html-loader&#x27;</span>,        &#125;      &#125;    ]  &#125;&#125;;</code></pre></div><p>此时在执行打包命令，可以看到在 dist 文件夹下除了index.html 文件和 index.js 文件，又多了一个 扩展名为 .png 的文件，我们打开 dist 文件夹下的 index.html 发现 src 的引用地址已修改，此时在浏览器中直接打开 dist 文件夹下的 index.html 发现图片可以正常显示。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456744-siwEwv-3.png" alt="3.png"></p><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><p>html-loader 包含下面四个配置项</p><table><thead><tr><th>参数名称</th><th>支持类型</th><th>默认值</th><th>功能描述</th></tr></thead><tbody><tr><td>sources</td><td>{Boolean、Object}</td><td>true</td><td>启用&#x2F;禁用 sources 处理</td></tr><tr><td>preprocessor</td><td>{Function}</td><td>undefined</td><td>允许在处理前对内容进行预处理</td></tr><tr><td>minimize</td><td>{Boolean、Object}</td><td>在生产模式下为 true，其他情况为 false</td><td>通知 html-loader 压缩 HTML</td></tr><tr><td>esModule</td><td>{Boolean}</td><td>true</td><td>启用&#x2F;禁用 ES modules 语法</td></tr></tbody></table><h3 id="sources"><a href="#sources" class="headerlink" title="sources"></a>sources</h3><h4 id="sources-默认值为-true"><a href="#sources-默认值为-true" class="headerlink" title="sources 默认值为 true"></a>sources 默认值为 true</h4><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">    rules:</span> [      <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        test:</span> /\.html$/,<span class="hljs-symbol">        loader:</span> <span class="hljs-string">&quot;html-loader&quot;</span>,<span class="hljs-symbol">        options:</span> <span class="hljs-punctuation">&#123;</span>          <span class="hljs-comment">// 设置为 false 则不会对可加载属性做任何处理</span><span class="hljs-symbol">          sources:</span> false,        <span class="hljs-punctuation">&#125;</span>,      <span class="hljs-punctuation">&#125;</span>,    ],  <span class="hljs-punctuation">&#125;</span>,<span class="hljs-punctuation">&#125;;</span></code></pre></div><p>默认情况下，每个可加载属性（例如 img 图片导入）都将被导入（ const img &#x3D; require (‘.&#x2F;image.png’) 或 import img from “.&#x2F;image.png” ）。 你可能需要为配置中的图片指定 loader（我们前面的例子，如果配置 html-loader 的参数 esModule: false，则需要使用 loader 对图片进行处理，否则打包报错）。</p><p>html-loader 支持处理的 可加载属性 包括：</p><ul><li><p>audio 标签的 src 属性</p></li><li><p>img 标签的 src 属性</p></li><li><p>img 标签的 srcset 属性</p></li><li><p><a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/loaders/html-loader/#sources">剩余标签和属性可查看文档</a></p></li></ul><h4 id="source-设置为-Object"><a href="#source-设置为-Object" class="headerlink" title="source 设置为 Object"></a>source 设置为 Object</h4><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">    rules:</span> [      <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        test:</span> /\.html$/,<span class="hljs-symbol">        loader:</span> <span class="hljs-string">&quot;html-loader&quot;</span>,<span class="hljs-symbol">       options:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">            sources:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">              list:</span> [                <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">                  tag:</span> <span class="hljs-string">&quot;img&quot;</span>,<span class="hljs-symbol">                  attribute:</span> <span class="hljs-string">&quot;data-src&quot;</span>,<span class="hljs-symbol">                  type:</span> <span class="hljs-string">&quot;src&quot;</span>,                <span class="hljs-punctuation">&#125;</span>              ]            <span class="hljs-punctuation">&#125;</span>,          <span class="hljs-punctuation">&#125;</span>,      <span class="hljs-punctuation">&#125;</span>,    ],  <span class="hljs-punctuation">&#125;</span>,<span class="hljs-punctuation">&#125;;</span></code></pre></div><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;./src/assets/card-mark.png&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./src/assets/card-mark.png&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>执行打包命令，看下 dist 文件夹下的 index.html 文件，发现 html-loader 只对 img 标签的 data-src 属性做了转换。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456744-dAdrmF-4.png" alt="4.png"></p><p>sources 对象中 支持 list 和 urlFilter 属性，<a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/loaders/html-loader/#sources">详情可查看文档</a></p><h3 id="preprocessor"><a href="#preprocessor" class="headerlink" title="preprocessor"></a>preprocessor</h3><p>允许在处理之前对内容进行预处理。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Handlebars</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;handlebars&quot;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">module</span>: &#123;    <span class="hljs-attr">rules</span>: [      &#123;        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.html$/</span>,        <span class="hljs-attr">use</span>: &#123;          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;html-loader&#x27;</span>,          <span class="hljs-attr">options</span>: &#123;            <span class="hljs-attr">preprocessor</span>: <span class="hljs-function">(<span class="hljs-params">content, loaderContext</span>) =&gt;</span> &#123;              <span class="hljs-keyword">let</span> result;                <span class="hljs-keyword">try</span> &#123;                result = <span class="hljs-title class_">Handlebars</span>.<span class="hljs-title function_">compile</span>(content)(&#123;                  <span class="hljs-attr">firstname</span>: <span class="hljs-string">&quot;Value&quot;</span>,                  <span class="hljs-attr">lastname</span>: <span class="hljs-string">&quot;OtherValue&quot;</span>,                &#125;);              &#125; <span class="hljs-keyword">catch</span> (error) &#123;                loaderContext.<span class="hljs-title function_">emitError</span>(error);                  <span class="hljs-keyword">return</span> content;              &#125;              <span class="hljs-keyword">return</span> result;            &#125;          &#125;        &#125;       &#125;,      &#125;,    ],  &#125;,&#125;;</code></pre></div><p>index.html</p><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>html-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">firstname</span>&#125;&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">lastname</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  </span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./src/assets/card-mark.png&quot;</span> /&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><p>在 webpack.config.js 中我们使用了 handlebars ，需要先安装 handlebars。</p><p><a href="https://leetcode.cn/link/?target=https://handlebarsjs.com/">Handlebars</a> 是一种简单的模板语言。<br>它使用模板和输入对象来生成 HTML 或其他文本格式。Handlebars 模板看起来像带有嵌入式 Handlebars 表达式的常规文本。</p><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">firstname</span>&#125;&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">lastname</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> </span></code></pre></div><p>执行打包命令后，查看 dist 文件夹下的 index.html 文件，可以看到 p 标签内容已被替换。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655456744-wtxzhT-5.png" alt="5.png"></p><h3 id="minimize"><a href="#minimize" class="headerlink" title="minimize"></a>minimize</h3><p>告诉 html-loader 编译时需要压缩 HTML 字符串。<br>默认情况下，启用压缩的规则如下：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">(&#123;</span>  <span class="hljs-attr">caseSensitive:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>  <span class="hljs-attr">collapseWhitespace:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>  <span class="hljs-attr">conservativeCollapse:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>  <span class="hljs-attr">keepClosingSlash:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>  <span class="hljs-attr">minifyCSS:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>  <span class="hljs-attr">minifyJS:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>  <span class="hljs-attr">removeComments:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>  <span class="hljs-attr">removeRedundantAttributes:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>  <span class="hljs-attr">removeScriptTypeAttributes:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span>  <span class="hljs-attr">removeStyleLinkTypeAttributes:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span><span class="hljs-string">&#125;);</span></code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">    rules:</span> [      <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        test:</span> /\.html$/i,<span class="hljs-symbol">        loader:</span> <span class="hljs-string">&quot;html-loader&quot;</span>,<span class="hljs-symbol">        options:</span> <span class="hljs-punctuation">&#123;</span>          <span class="hljs-comment">// boolean</span><span class="hljs-symbol">          minimize:</span> true,          <span class="hljs-comment">// 对象</span><span class="hljs-symbol">          minimize:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">            removeComments:</span> false,<span class="hljs-symbol">            collapseWhitespace:</span> false,          <span class="hljs-punctuation">&#125;</span>,        <span class="hljs-punctuation">&#125;</span>,      <span class="hljs-punctuation">&#125;</span>,    ],  <span class="hljs-punctuation">&#125;</span>,<span class="hljs-punctuation">&#125;;</span></code></pre></div><h3 id="esModule"><a href="#esModule" class="headerlink" title="esModule"></a>esModule</h3><p>默认情况下， html-loader 生成使用 ES modules 语法的 JS 模块。 在某些情况下，使用 ES modules 会更好，例如在进行模块合并和 tree shaking 时。</p><p>你可以使用以下方法启用 CommonJS 模块语法：<br>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">    rules:</span> [      <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        test:</span> /\.html$/i,<span class="hljs-symbol">        loader:</span> <span class="hljs-string">&quot;html-loader&quot;</span>,<span class="hljs-symbol">        options:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">          esModule:</span> false,        <span class="hljs-punctuation">&#125;</span>,      <span class="hljs-punctuation">&#125;</span>,    ],  <span class="hljs-punctuation">&#125;</span>,<span class="hljs-punctuation">&#125;;</span></code></pre></div><h1 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 html-loader 的使用方法和 html-loader 包含的 4 个参数 sources、preprocessor、minimize、esModule, 它们分别对应 html-loader 在项目实践中的 4 个重要功能：</p><ol><li>将 HTML 中标签的可加载属性引入的文件作为模块导入</li><li>预处理 HTML，常用来支持模板引擎</li><li>压缩 HTML</li><li>默认导出 ES modules 便于模块合并和 tree shaking</li></ol><h3 id="URL-Loader"><a href="#URL-Loader" class="headerlink" title="URL-Loader"></a>URL-Loader</h3><h1 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h1><p>当我们在文件中加载图片、字体等资源时，webpack 无法直接处理以上资源，在 webpack 5 之前需要使用相应 loader 来处理资源文件，url-loader 可以将一个文件转换为 base64 编码来代替访问地址，这样做的好处是可以减少一次网络请求，下面我们来看看如何使用 url-loader 及 url-loader 有哪些常用配置。</p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>url-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>index.js</p><p>index.js 文件中引入一张图片，创建image标签后，将导入的图片赋值给 image 标签的 src 属性，将 image 标签添加到页面中</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Back</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./img/back.png&#x27;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">component</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>);   element.<span class="hljs-property">src</span>=<span class="hljs-title class_">Back</span>  <span class="hljs-keyword">return</span> element;&#125;<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">component</span>());</code></pre></div><p>安装 url-loader</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> url-loader -D</code></pre></div><p>安装成功后，将 url-loader 配置到 webpack.config.js 中</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">module.exports = &#123;</span><span class="hljs-attribute">  ...</span><span class="hljs-attribute">   module</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span>    <span class="hljs-attribute">rules</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>      <span class="hljs-attribute">&#123;</span><span class="hljs-attribute">        test</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/\.(png|jpg)$/,</span>        <span class="hljs-attribute">use</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>          <span class="hljs-attribute">&#123;</span><span class="hljs-attribute">            loader</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;url-loader&#x27;</span>          &#125;        ]      &#125;    ]  &#125;&#125;;</code></pre></div><p>此时在执行打包命令，此时在浏览器中直接打开 dist 文件夹下的 index.html 发现页面中展示一张图片。</p><h2 id="配置项-1"><a href="#配置项-1" class="headerlink" title="配置项"></a>配置项</h2><p>url-loader 包含下面 3 个配置项</p><table><thead><tr><th>参数名称</th><th>支持类型</th><th>默认值</th><th>功能描述</th></tr></thead><tbody><tr><td>limit</td><td>Boolean、Number、String</td><td>true</td><td>需要转换为 base64 的资源大小限制</td></tr><tr><td>mimetype</td><td>Boolean、String</td><td>基于mime-types 查找</td><td>为文件指定MIME类型</td></tr><tr><td>fallback</td><td>String</td><td>file-loader</td><td>文件大小等于或者超过 limit 限制后使用的资源处理 loader</td></tr></tbody></table><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">module.exports</span> <span class="hljs-string">=</span> &#123;  <span class="hljs-attr">module:</span> &#123;    <span class="hljs-attr">rules:</span> [      &#123;        <span class="hljs-attr">test:</span> <span class="hljs-string">/\.(png|jpg)$/</span>,        <span class="hljs-attr">use:</span> [          &#123;            <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;url-loader&#x27;</span>,            <span class="hljs-attr">options:</span> &#123;              <span class="hljs-attr">limit:</span> <span class="hljs-number">2048</span> <span class="hljs-string">//</span> <span class="hljs-string">2Kb</span>            &#125;          &#125;        ]      &#125;    ]  &#125;&#125;<span class="hljs-string">;</span></code></pre></div><p>一般情况下，当资源文件大小小于 2Kb 时，我们需要将资源路径转换为 base64 的格式将资源打包到 bundle 中，这样可以减少一次网络请求，当一个页面中引入多个资源文件时可以明显减少请求次数，但这种方式带来了另外一个问题，如果资源文件体积较大，就会导致 bundle 的体积增大，体积大的情况下网络请求时间变长，会导致页面白屏时间变长，非常影响用户体验。所以在处理资源文件时，一般会加上 limit 配置，文件资源体积超过配置的大小后，更改资源文件的处理方式，默认使用 file-loader 来处理。</p><p>上面的配置在执行打包命令时会报 “Cannot find module ‘file-loader’” 的错误，所以在使用 limit 配置时，我们先下载安装 file-loader。</p><p>安装 file-loader</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> <span class="hljs-keyword">file</span>-loader -D</code></pre></div><p>再次执行打包命令，在 dist 文件夹下输出了一个扩展名为 .png 的图片，让我们来对比下增加 limit 配置前和增加 limit 配置后 dist 文件夹和 index.js 文件的变化。</p><p>增加 limit 配置前</p><p>dist 文件夹</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655702983-rBTYab-3.png" alt="3.png"></p><p>index.js</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655702983-VEfXJw-4.png" alt="4.png"></p><p>增加 limit 配置后</p><p>dist 文件夹</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655702983-btTkSZ-5.png" alt="5.png"><br>index.js</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655702983-ypgcON-6.png" alt="6.png"></p><h3 id="mimetype"><a href="#mimetype" class="headerlink" title="mimetype"></a>mimetype</h3><p>设置文件的转换类型。如果未指定，将使用文件扩展名来查找MIME 类型。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs css">rules: [     &#123;       test: /\.(png|jpg)$/,       use: [         &#123;           loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,           options: &#123;             mimetype: <span class="hljs-string">&#x27;image/jpg&#x27;</span>           &#125;         &#125;       ]     &#125;   ]</code></pre></div><h3 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h3><p>指定当目标文件的大小等于或超过限制选项中设置的限制时，使用的替代加载 loader，默认为 file-loader。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">module:</span> &#123;    <span class="hljs-attr">rules:</span> [      &#123;        <span class="hljs-attr">test:</span> <span class="hljs-string">/\.(png|jpg)$/</span>,        <span class="hljs-attr">use:</span> [          &#123;            <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;url-loader&#x27;</span>,            <span class="hljs-attr">options:</span> &#123;              <span class="hljs-attr">limit:</span> <span class="hljs-number">2048</span>,              <span class="hljs-attr">fallback:</span> <span class="hljs-string">&#x27;responsive-loader&#x27;</span>            &#125;          &#125;        ]      &#125;    ]  &#125;</code></pre></div><h1 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 url-loader 的使用方法和 url-loader 包含的 3 个参数 limit、minitype、fallback, url-loader 设置了 limit 参数后，超过设置的限制大小后，默认使用 file-loader 加载资源文件，所以 file-loader 的可配置参数在 url-loader 中也可配置生效，剩余可配置参数在 file-loader 中继续总结。</p><h3 id="File-Loader"><a href="#File-Loader" class="headerlink" title="File-Loader"></a>File-Loader</h3><h1 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h1><p>在 webpack 5 之前处理图片、字体等资源，除了使用 url-loader 之外还经常使用 file-loader，file-loader 的处理方式和 url-loader 有些不同，url-loader 通过 limit 参数判断如果没有超过配置大小，则将文件转做 base64 编码，直接嵌入到 CSS&#x2F;JS&#x2F;HTML 代码中。而 file-loader 并不会对文件内容进行任何转换，只是复制一份文件内容，并根据配置为他生成一个唯一的文件名, 下面让我们梳理下 file-loader 如何使用及有哪些可配置参数。我们继续使用 url-loader 的例子, 只是对个别配置做些修改。</p><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>file-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>index.js</p><p>index.js 文件中引入一张图片，创建 image 标签后，将导入的图片赋值给 image 标签的 src 属性，将 image 标签添加到页面中。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Back</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./img/back.png&#x27;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">component</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>);   element.<span class="hljs-property">src</span>=<span class="hljs-title class_">Back</span>  <span class="hljs-keyword">return</span> element;&#125;<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">component</span>());</code></pre></div><p>安装 file-loader</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> <span class="hljs-keyword">file</span>-loader -D</code></pre></div><p>安装成功后，将 file-loader 配置到 webpack.config.js 中</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">module.exports = &#123;</span><span class="hljs-attribute">  ...</span><span class="hljs-attribute">   module</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span>    <span class="hljs-attribute">rules</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>      <span class="hljs-attribute">&#123;</span><span class="hljs-attribute">        test</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/\.(png|jpg)$/,</span>        <span class="hljs-attribute">use</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>          <span class="hljs-attribute">&#123;</span><span class="hljs-attribute">            loader</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;file-loader&#x27;</span>          &#125;        ]      &#125;    ]  &#125;&#125;;</code></pre></div><p>执行打包命令，此时在浏览器中直接打开 dist 文件夹下的 index.html 发现页面中展示一张图片，此时我们在 dist 目录下可以看到一张扩展名为 .png 的图片，直接点击图片打开，可以看到与我们引入的图片一致。</p><h2 id="配置项-2"><a href="#配置项-2" class="headerlink" title="配置项"></a>配置项</h2><p>file-loader 包含下面几个配置项</p><table><thead><tr><th>参数名称</th><th>支持类型</th><th>默认值</th><th>功能描述</th></tr></thead><tbody><tr><td>name</td><td>String、Function</td><td>[contenthash].[ext]</td><td>为文件配置自定义文件名模板</td></tr><tr><td>context</td><td>String</td><td>this.options.context</td><td>配置自定义文件 context，默认为 webpack.config.js 的 context</td></tr><tr><td>publicPath</td><td>String、Function</td><td>output.publicPath + outputPath</td><td>为文件配置自定义 public 发布目录</td></tr><tr><td>outputPath</td><td>String、Function</td><td>undefined</td><td>为文件配置自定义 output 输出目录</td></tr><tr><td>useRelativePath</td><td>Boolean</td><td>false</td><td>当设置为 true, 为每个文件生成一个相对 url 的 context</td></tr><tr><td>emitFile</td><td>Boolean</td><td>true</td><td>设置为 false, 禁止复制文件</td></tr></tbody></table><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>可以使用查询参数名称为您的文件配置一个自定义的文件名模板。默认情况下，不配置 name 属性生成的文件的文件名就是文件内容的 MD5 哈希值与原始扩展名。name 属性支持传入字符串或函数配置。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">module.exports = &#123;</span><span class="hljs-attribute">  module</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span>    <span class="hljs-attribute">rules</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>      <span class="hljs-attribute">&#123;</span><span class="hljs-attribute">        test</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/\.(png|jpg)$/,</span>        <span class="hljs-attribute">use</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>          <span class="hljs-attribute">&#123;</span><span class="hljs-attribute">            loader</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;file-loader&#x27;,</span>            <span class="hljs-attribute">options</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span>              <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[name].[ext]</span>            &#125;          &#125;        ]      &#125;    ]  &#125;&#125;;</code></pre></div><p>name 参数可以传入以下常用占位符</p><table><thead><tr><th>名称</th><th>类型</th><th>默认值</th><th>功能描述</th></tr></thead><tbody><tr><td>[ext]</td><td>String</td><td>file.extname</td><td>资源扩展名</td></tr><tr><td>[name]</td><td>String</td><td>file.basename</td><td>资源的名称</td></tr><tr><td>[path]</td><td>String</td><td>file.dirname</td><td>资源相对于 context 的路径</td></tr><tr><td>[hash]</td><td>String</td><td>md5</td><td>内容的哈希值, [hashes]]<a href="https://leetcode.cn/link/?target=https://www.webpackjs.com/loaders/file-loader/#hashes">https://www.webpackjs.com/loaders/file-loader/#hashes</a> 配置中有更多信息</td></tr></tbody></table><p>常见的打包命名方式是：assets&#x2F;[name]-[hash].[ext]，即将所有 file-loader 处理的图片按照 name 传入的文件名称 + hash 值.扩展名的方式打包到 assets 目录下。其中</p><ol><li><p>[ext] 表示是原文件的扩展名，如 back.png 就是指 png</p></li><li><p>[name] 表示原文件的文件名。如 back.png 就是指 back，但一般生产环境不推荐直接使用 [name]，一般和 [hash] 一起使用，这样可以防止命名冲突。</p></li><li><p>[path] 相对于 context 的路径，context 默认是 webpack.config.js 的路径</p></li><li><p>[hash:6]可以控制 hash 值的长度，6 表示长度为 6，默认是 32</p></li></ol><h3 id="context-1"><a href="#context-1" class="headerlink" title="context"></a>context</h3><p>修改打包文件生成路径，其实影响的 是 path 占位符，context 需要和 path 占位符同时配置才会影响文件生成路径。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs css">&#123;  loader: <span class="hljs-string">&#x27;file-loader&#x27;</span>,  options: &#123;    name: <span class="hljs-string">&#x27;[path][name].[ext]&#x27;</span>,    context: __dirname + <span class="hljs-string">&#x27;/../&#x27;</span>  &#125;&#125;</code></pre></div><p>打包后，当前项目根文件夹和图片所在路径形成了打包文件的新路径，如果不设置 context 则打包路径相对于 webpack.config.js 的 context 的路径。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655703446-hNPQck-1.png" alt="1.png"></p><h3 id="publicPath-1"><a href="#publicPath-1" class="headerlink" title="publicPath"></a>publicPath</h3><p>publicPath 一般会用 webpack 本身配置的，和那个效果也一样，但假如你想单独配置，就用这个。设置 publicPath 后，文件的请求地址会被打包进 js 文件。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs css">&#123;  loader: <span class="hljs-string">&#x27;file-loader&#x27;</span>,  options: &#123;    name: <span class="hljs-string">&#x27;[name].[ext]&#x27;</span>,    outputPath: <span class="hljs-string">&#x27;https://www.abc.cn/img/&#x27;</span>  &#125;&#125;</code></pre></div><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655703446-bgMKWl-2.png" alt="2.png"></p><h3 id="outputPath"><a href="#outputPath" class="headerlink" title="outputPath"></a>outputPath</h3><p>outputPath 在文件前增加路径，也就是增加文件夹。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs css">&#123;  loader: <span class="hljs-string">&#x27;file-loader&#x27;</span>,  options: &#123;    name: <span class="hljs-string">&#x27;[name].[ext]&#x27;</span>,    outputPath: <span class="hljs-string">&#x27;images/&#x27;</span>  &#125;&#125;</code></pre></div><h1 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 file-loader 的使用方法和 file-loader 包含的几个常用参数配置。file-loader 的可配置选项在 url-loader 中配置也可生效（limit 生效的情况下），在 webpack5 以前对于资源文件的处理一般使用这两种插件，webpack5 提供了一种模块<a href="https://leetcode.cn/link/?target=https://webpack.js.org/guides/asset-modules/">Asset Modules</a>，它允许人们在不配置额外加载器的情况下使用资源文件（字体、图标等）</p><h3 id="CSS-Loader"><a href="#CSS-Loader" class="headerlink" title="CSS-Loader"></a>CSS-Loader</h3><h1 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h1><p>css-loader 会对 import 和 url() 进行处理，就像 js 解析 import&#x2F;require() 一样。</p><h2 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h2><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>css-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>index.js</p><p>src&#x2F;index.js 文件中使用 import 导入 index.css 并输出导入的样式内容。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> indexCss <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(indexCss.<span class="hljs-title function_">toString</span>())</code></pre></div><p>index.css</p><p>src&#x2F;index.css 文件中使用 import 导入 index.css。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">background-color</span>: aqua;  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;&#125;</code></pre></div><p>安装 css-loader</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> css-loader -D</code></pre></div><p>安装成功后，将 css-loader 配置到 webpack.config.js 中</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">module.exports = &#123;</span><span class="hljs-attribute">  ...</span><span class="hljs-attribute">   module</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span>    <span class="hljs-attribute">rules</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>      <span class="hljs-attribute">&#123;</span><span class="hljs-attribute">        test</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/\.(css)$/,</span>        <span class="hljs-attribute">use</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[</span>          <span class="hljs-attribute">&#123;</span><span class="hljs-attribute">            loader</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;css-loader&#x27;</span>          &#125;        ]      &#125;    ]  &#125;&#125;;</code></pre></div><p>执行打包命令，此时在浏览器中打开 dist&#x2F;index.html 发现页面没有正确展示我们定义的样式，但是控制台中输出了我们定义的样式，到了这一步，css-loader 我们就正确引入并使用了，没有正确展示效果的原因是 css-loader 对 index.js 中的 import 进行处理，默认生成一个数组存放处理后的样式字符串，并将其导出。而 style-loader 负责将 css 插入到 html 中，style-loader 的使用我们在下一节展示。</p><h2 id="配置项-3"><a href="#配置项-3" class="headerlink" title="配置项"></a>配置项</h2><p>css-loader 包含下面几个配置项</p><table><thead><tr><th>参数名称</th><th>支持类型</th><th>默认值</th><th>功能描述</th></tr></thead><tbody><tr><td>url</td><td>Boolean</td><td>true</td><td>启用&#x2F;禁用 url() 处理</td></tr><tr><td>import</td><td>Boolean</td><td>true</td><td>启用&#x2F;禁用 @import 处理</td></tr><tr><td>modules</td><td>Boolean</td><td>false</td><td>启用&#x2F;禁用 CSS 模块</td></tr><tr><td>sourceMap</td><td>Boolean</td><td>取决于 compiler.devtool 值</td><td>启用&#x2F;禁用 Sourcemap</td></tr><tr><td>esModule</td><td>Boolean&#x2F;String</td><td>true</td><td>是否使用 ES 模块语法</td></tr><tr><td>importLoaders</td><td>Number</td><td>0</td><td>在 css-loader 前应用的 loader 的数量</td></tr><tr><td>exportType</td><td>“array”&#x2F;“string”&#x2F;“css-style-sheet”</td><td>[]</td><td>允许导出样式为模块数组、字符串或者可构造样式（即 CSSStyleSheet）</td></tr></tbody></table><h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><p>允许启用&#x2F;禁用处理 CSS 函数 url 和 image-set。如果设置为false, css-loader 将不会解析 url 或 image-set 中指定的任何路径。还可以通过传递函数来根据资源路径动态地控制这种行为。从版本4.0.0开始，绝对路径是基于服务器根目录进行解析的。</p><p>src&#x2F;index.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">./img/1.png</span>);&#125;</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">module.exports</span> <span class="hljs-string">=</span> &#123;  <span class="hljs-string">...</span>   &#123;      <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;css-loader&#x27;</span>,      <span class="hljs-attr">options:</span> &#123;          <span class="hljs-attr">url:</span> <span class="hljs-literal">false</span>,          <span class="hljs-string">//</span> <span class="hljs-attr">url:</span> <span class="hljs-literal">true</span>      &#125;    &#125;&#125;<span class="hljs-string">;</span></code></pre></div><p>在控制台我们在 index.js 中输出了 index.css 导出的字符串，我们来看下 url 设置为 false 和 true 的 background 区别。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655709629-GTgEyK-1.png" alt="1.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655709629-RPGYMd-2.png" alt="2.png"></p><p>当 url 设置为 false 时， url 中的图片地址没做任何处理，当 url 值为 true 时，编译后地址为图片的路径，并且 dist 文件夹下会生成一张图片。</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>允许启用&#x2F;禁用 @import 处理。</p><p>src&#x2F;index.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&#x27;./main.css&#x27;</span>);<span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;&#125;</code></pre></div><p>src&#x2F;main.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;&#125;</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;...  &#123;    loader: <span class="hljs-string">&#x27;css-loader&#x27;</span>,    options: &#123;        <span class="hljs-keyword">import</span>: <span class="hljs-literal">false</span>        <span class="hljs-comment">// import: true</span>    &#125;  &#125;&#125;;</code></pre></div><p>为了方便看到样式，我这安装了 style-loader 并添加到了 loader 中，我们来看下 import 设置为 false 和 true 的区别。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655709644-gvVFJh-3.png" alt="3.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655709644-EOifyM-4.png" alt="4.png"></p><p>当设置为 false 时 index.css 中的 @import 没有解析导致运行代码时找不到 main.css。</p><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>查询参数 modules 会启用 CSS 模块规范。</p><p>默认情况下，这将启用局部作用域 CSS。（你可以使用 :global(…) 或 :global 关闭选择器 and&#x2F;or 规则。详情可查看 <a href="https://leetcode.cn/link/?target=https://www.webpackjs.com/loaders/css-loader/#modules">modules</a></p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs yaml">&#123;  <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;css-loader&#x27;</span>,  <span class="hljs-attr">options:</span> &#123;      <span class="hljs-attr">modules:</span> <span class="hljs-literal">true</span>  &#125;&#125;</code></pre></div><h3 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h3><p>设置 sourceMap 选项查询参数来引入 source map。</p><p>例如 extract-text-webpack-plugin 能够处理它们。</p><p>默认情况下取决于compiler.devtool 值，值为 false 和 eval 时，不会生成 source map，一般情况下不启用它，因为它们会导致运行时的额外开销，并增加了 bundle 大小 (JS source map 不会)。此外，相对路径是错误的，你需要使用包含服务器 URL 的绝对公用路径。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs yaml">&#123;  <span class="hljs-string">...</span>  <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;css-loader&#x27;</span>,  <span class="hljs-attr">options:</span> &#123;      <span class="hljs-attr">sourceMap:</span> <span class="hljs-literal">true</span>  &#125;&#125;</code></pre></div><h3 id="esModule-1"><a href="#esModule-1" class="headerlink" title="esModule"></a>esModule</h3><p>css-loader 中有时生成 esModule 模块化的形式是有益的，比如 module-concatenation 和 tree-shaking 时必须使用 esModule 模式才会生效。如果想启用 CommonJS 模块语法，则 esModule 设置为 false。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs yaml">&#123;  <span class="hljs-string">...</span>  <span class="hljs-attr">options:</span> &#123;    <span class="hljs-attr">esModule:</span> <span class="hljs-literal">true</span>  &#125;&#125;</code></pre></div><h3 id="importLoaders"><a href="#importLoaders" class="headerlink" title="importLoaders"></a>importLoaders</h3><p>在 src&#x2F;index.css 中使用的 @import ‘.&#x2F;main.css’，importLoaders 选项可以定义在 @import 时使用哪些插件编译。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts"><span class="hljs-punctuation">&#123;</span>  ...<span class="hljs-symbol">  use:</span> [    <span class="hljs-string">&quot;style-loader&quot;</span>,    <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;css-loader&quot;</span>,<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-comment">// 0 =&gt; no loaders (default);</span>        <span class="hljs-comment">// 1 =&gt; postcss-loader;</span>        <span class="hljs-comment">// 2 =&gt; postcss-loader, sass-loader</span><span class="hljs-symbol">        importLoaders:</span> <span class="hljs-number">2</span>,      <span class="hljs-punctuation">&#125;</span>,    <span class="hljs-punctuation">&#125;</span>,    <span class="hljs-string">&quot;postcss-loader&quot;</span>,    <span class="hljs-string">&quot;sass-loader&quot;</span>,  ],<span class="hljs-punctuation">&#125;</span></code></pre></div><h3 id="exportType"><a href="#exportType" class="headerlink" title="exportType"></a>exportType</h3><p>允许将样式导出为带有模块的数组、字符串或可构造样式表(如CSSStyleSheet)。默认值是 ‘array’。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs css">&#123;  ...  use: [    &#123;      loader: <span class="hljs-string">&#x27;css-loader&#x27;</span>,      options: &#123;          exportType: <span class="hljs-string">&#x27;string&#x27;</span>      &#125;    &#125;    ]  &#125;&#125;</code></pre></div><p>src&#x2F;index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> indexCss <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(indexCss)</code></pre></div><p>打包后，执行 dist&#x2F;index.html 可以看到控制台输出了 index.css 中定义的样式字符串。</p><h1 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 css-loader 的使用方法和 css-loader 包含的几个常用参数配置。css-loader 可以将 js 中的 import 导入样式文件进行编译并且拿到导出内容供其他插件使用。</p><h3 id="Style-Loader"><a href="#Style-Loader" class="headerlink" title="Style-Loader"></a>Style-Loader</h3><h1 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h1><p>style-loader 一般和 css-loader 配合使用，css-loader 识别模块，通过特定的语法规则进行内容转换最后导出，style-loader 将 css-loader 导出的内容插入到 DOM。</p><h2 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h2><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>style-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>index.js</p><p>src&#x2F;index.js 文件中使用 import 导入 index.css。</p><div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> indexCss <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;</code></pre></div><p>index.css</p><p>设置一个长宽均为 200 像素的带红色边框的正方形</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;&#125;</code></pre></div><p>安装 style-loader</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> style-loader -D</code></pre></div><p>安装成功后，将 style-loader 配置到 webpack.config.js 中，配置中我们使用 css-loader 和 style-loader 两个加载器，webpack 中 loader 的解析一般由右向左，由下向上解析，所以 webpack 会先执行 css-loader，css-loader 导出内容传给 style-loader，最后在执行 style-loader。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...   <span class="hljs-keyword">module</span>: &#123;    rules: [      &#123;        test: /\.css$/,        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>,<span class="hljs-string">&#x27;css-loader&#x27;</span>]      &#125;    ]  &#125;&#125;;</code></pre></div><p>执行打包命令，此时在浏览器中打开 dist&#x2F;index.html 发现页面可以正常展示我们设置的样式，我们在控制台可以看到样式被插入到 head 标签中。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655715388-rMhlfZ-1.png" alt="1.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655710417-NiFgBX-2.png" alt="2.png"></p><h2 id="配置项-4"><a href="#配置项-4" class="headerlink" title="配置项"></a>配置项</h2><p>style-loader 包含下面几个配置项</p><table><thead><tr><th>参数名称</th><th>支持类型</th><th>默认值</th><th>功能描述</th></tr></thead><tbody><tr><td>injectType</td><td>String</td><td>styleTag</td><td>如何将样式注入到 DOM 中</td></tr><tr><td>attributes</td><td>Object</td><td>{}</td><td>向标签添加自定义属性</td></tr><tr><td>insert</td><td>String、Function</td><td>head</td><td>在 DOM 中给定的位置插入标签</td></tr><tr><td>styleTagTransform</td><td>String、Function</td><td>undefined</td><td>当插入 style 标签到 DOM 时转换标签和 css</td></tr><tr><td>esModule</td><td>Boolean</td><td>true</td><td>使用 ES 模块语法</td></tr><tr><td>base</td><td>Number</td><td>true</td><td>设置模块ID基数(DLLPlugin)</td></tr></tbody></table><h3 id="injectType"><a href="#injectType" class="headerlink" title="injectType"></a>injectType</h3><p>设置样式如何注入 DOM，默认为 styleTag，即使用多个<style></style> 模式。</p><table><thead><tr><th>模式配置</th><th>功能描述</th></tr></thead><tbody><tr><td>styleTag</td><td>多个 <style></style> 模式</td></tr><tr><td>singletonStyleTag</td><td>单个 <style></style> 模式</td></tr><tr><td>autoStyleTag</td><td>与 styleTag 相同，但如果在 IE6-9 中执行，则打开 singletonStyleTag 模式。</td></tr><tr><td>lazyStyleTag</td><td>按需加载模式插入多个 <style></style> 模式</td></tr><tr><td>lazySingletonStyleTag</td><td>按需加载模式插入单个 <style></style> 模式</td></tr><tr><td>lazyAutoStyleTag</td><td>与 lazyStyleTag 相同，但如果在 IE6-9 中执行，则打开 lazySingletonStyleTag 模式。</td></tr><tr><td>linkTag</td><td>多个 <link rel="stylesheet" href="path/to/file.css"> 形式插入 DOM</td></tr></tbody></table><h4 id="styleTag"><a href="#styleTag" class="headerlink" title="styleTag"></a>styleTag</h4><p>src&#x2F;index.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&#x27;style.css&#x27;</span>);<span class="hljs-selector-class">.bar</span> &#123;    <span class="hljs-attribute">color</span>: blue;&#125;</code></pre></div><p>src&#x2F;style.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.foo</span> &#123;    <span class="hljs-attribute">color</span>: red;&#125;</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs gradle">module.exports = &#123;  ...  &#123;    test: <span class="hljs-regexp">/\.(css)$/</span>,    use: [      &#123;        loader: <span class="hljs-string">&#x27;style-loader&#x27;</span>,        <span class="hljs-keyword">options</span>: &#123; injectType: <span class="hljs-string">&quot;styleTag&quot;</span> &#125;      &#125;, <span class="hljs-string">&#x27;css-loader&#x27;</span>    ]  &#125;&#125;;</code></pre></div><p>index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> index <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;foo&quot;</span>;divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;style-loader&#x27;</span><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement)</code></pre></div><p>执行打包命令，在浏览器中打开 dist&#x2F;index.html 文件，我们可以看到 head 中插入了两个 style 标签，div 中的文字颜色可以正常显示。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655704064-BOjtxr-3.png" alt="3.png"></p><h4 id="singletonStyleTag"><a href="#singletonStyleTag" class="headerlink" title="singletonStyleTag"></a>singletonStyleTag</h4><p>将多个样式文件内容在一个 style 标签中插入 DOM。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs gradle">module.exports = &#123;  ...  &#123;    test: <span class="hljs-regexp">/\.(css)$/</span>,    use: [      &#123;        loader: <span class="hljs-string">&#x27;style-loader&#x27;</span>,        <span class="hljs-keyword">options</span>: &#123; injectType: <span class="hljs-string">&quot;singletonStyleTag&quot;</span> &#125;      &#125;, <span class="hljs-string">&#x27;css-loader&#x27;</span>    ]  &#125;&#125;;</code></pre></div><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655704064-QFOJaJ-4.png" alt="4.png"></p><h4 id="lazyStyleTag"><a href="#lazyStyleTag" class="headerlink" title="lazyStyleTag"></a>lazyStyleTag</h4><style></style> 按需注入到 DOM 。建议遵循 .lazy.css 惰性样式的命名约定和 .css 基本style-loader用法。当使用 lazyStyleTag 时，可以通过 style-loader 的 style.use()、style.unuse() 按需使用。<p>src&#x2F;style.lazy.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.foo</span> &#123;    <span class="hljs-attribute">color</span>: red;&#125;</code></pre></div><p>src&#x2F;index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./style.lazy.css&quot;</span>;styles.<span class="hljs-title function_">use</span>();<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;foo&quot;</span>;divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;style-loader&#x27;</span><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement)</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs gradle">module.exports = &#123;... &#123;    test: <span class="hljs-regexp">/\.(css)$/</span>,    use: [      &#123;        loader: <span class="hljs-string">&#x27;style-loader&#x27;</span>,        <span class="hljs-keyword">options</span>: &#123; injectType: <span class="hljs-string">&quot;lazyStyleTag&quot;</span> &#125;      &#125;, <span class="hljs-string">&#x27;css-loader&#x27;</span>    ]  &#125;&#125;;</code></pre></div><p>打包后，可以看到样式被插入到 DOM，并且颜色已生效，如果 index.js 中没有调用 styles.use()，则样式不会被插入到 DOM。</p><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><p>将指定的属性值附加到 <style> 或 <link> 标签</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs css">&#123;  loader: <span class="hljs-string">&#x27;style-loader&#x27;</span>,  options: &#123; attributes: &#123;id: <span class="hljs-string">&#x27;styleLoader&#x27;</span>&#125; &#125;&#125;</code></pre></div><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655704064-PSQoUz-5.png" alt="5.png"></p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>默认情况下 style-loader 会将<style>、<link> 标签插入到 <head> 标签尾部，设置 insert 后，可以将样式标签插入到其他位置。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs css">&#123;  loader: <span class="hljs-string">&#x27;style-loader&#x27;</span>,  options: &#123; insert: <span class="hljs-string">&#x27;body&#x27;</span> &#125;&#125;</code></pre></div><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655704064-YppEjv-6.png" alt="6.png"></p><h3 id="styleTagTransform"><a href="#styleTagTransform" class="headerlink" title="styleTagTransform"></a>styleTagTransform</h3><p>当插入 style 标签到 DOM 时转换标签和 css，可以设置自定义方法解析 style 标签插入方式。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs javascript">&#123;  ...    <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;style-loader&#x27;</span>,    <span class="hljs-attr">options</span>: &#123; <span class="hljs-attr">styleTagTransform</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">css, style</span>) &#123;      style.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;css&#125;</span>.modify&#123;&#125;\n`</span>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(style)    &#125; &#125;</code></pre></div><p>打包后，在浏览器中打开 dist&#x2F;index.html，我们可以看到 css 样式后面添加了我们在方法中书写的内容。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655704064-uATShJ-7.png" alt="7.png"></p><h3 id="esModule-2"><a href="#esModule-2" class="headerlink" title="esModule"></a>esModule</h3><p>style-loader 中生成 esModule 模块化的形式是有益的，比如 tree-shacking 时必须使用 esModule 模式才会生效。如果想启用 CommonJS 模块语法，则 esModule 设置为 false。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs yaml">&#123;  <span class="hljs-string">...</span>  <span class="hljs-attr">options:</span> &#123;    <span class="hljs-attr">esModule:</span> <span class="hljs-literal">true</span>  &#125;&#125;</code></pre></div><h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><p>当使用一个或多个 DllPlugin 时，此设置主要用作 css 冲突的解决方法。允许您通过指定大于 DllPlugin1 使用的范围的 css 模块 ID 基数来防止 app 的 css（或DllPlugin2 的 css）覆盖 DllPlugin1 的 css</p><p>webpack.dll1.config.js</p><div class="code-wrapper"><pre><code class="hljs prolog">&#123;  ...  use: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],&#125;</code></pre></div><p>webpack.dll2.config.js</p><div class="code-wrapper"><pre><code class="hljs yaml">&#123;  <span class="hljs-string">...</span>  <span class="hljs-attr">use:</span> [    &#123; <span class="hljs-attr">loader:</span> <span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-attr">options:</span> &#123; <span class="hljs-attr">base:</span> <span class="hljs-number">1000</span> &#125; &#125;,    <span class="hljs-string">&quot;css-loader&quot;</span>,  ],&#125;</code></pre></div><p>webpack.app.config.js</p><div class="code-wrapper"><pre><code class="hljs yaml">&#123;  <span class="hljs-string">...</span>  <span class="hljs-attr">use:</span> [    &#123; <span class="hljs-attr">loader:</span> <span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-attr">options:</span> &#123; <span class="hljs-attr">base:</span> <span class="hljs-number">2000</span> &#125; &#125;,    <span class="hljs-string">&quot;css-loader&quot;</span>,  ],&#125;</code></pre></div><h1 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 style-loader 的使用方法和 style-loader 包含的几个常用参数配置。style-loader 一般和 css-loader 配合使用。</p><h3 id="Postcss-Loader"><a href="#Postcss-Loader" class="headerlink" title="Postcss-Loader"></a>Postcss-Loader</h3><h1 id="postcss-loader"><a href="#postcss-loader" class="headerlink" title="postcss-loader"></a>postcss-loader</h1><p>在使用 postcss-loader 之前，我们先来了解下 <a href="https://leetcode.cn/link/?target=https://postcss.org/">PostCSS</a>。以下摘自 PostCSS 简介。</p><div class="code-wrapper"><pre><code class="hljs gams">PostCSS 是一个允许使用 JS 插件转换样式的工具。 这些插件可以检查（lint）你的 CSS，支持 CSS <span class="hljs-keyword">Variables</span> 和 Mixins， 编译尚未被浏览器广泛支持的先进的 CSS 语法，内联图片，以及其它很多优秀的功能。<span class="hljs-comment">PostCSS</span> 的 <span class="hljs-comment">Autoprefixer</span> 插件是最流行的 <span class="hljs-comment">CSS</span> 处理工具之一。</code></pre></div><p>由此我们可以知道通过使用 PostCSS 和 相应的插件，我们可以完成样式格式化、自动根据浏览器的支持情况增加样式前缀、使用先进的 CSS 特性等很多优秀的功能，截止到目前，PostCSS 有 200 多个插件。你可以在 <a href="https://leetcode.cn/link/?target=https://github.com/postcss/postcss/blob/main/docs/plugins.md">插件列表</a> 找到他们。如果我们想在 webpack 中使用 PostCSS 及 相应插件完成我们想要的功能，这时就需要通过 postcss-loader 来处理。</p><h2 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h2><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>postcss-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>index.js</p><p>src&#x2F;index.js 文件中使用 import 导入 index.css 并输出导入的样式内容。</p><div class="code-wrapper"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> indexCss <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;</code></pre></div><p>index.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">display</span>: flex;&#125;</code></pre></div><p>安装 postcss-loader 和 postcss</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> postcss-loader postcss -D</code></pre></div><p>安装成功后，将 postcss-loader 配置到 webpack.config.js 中，postcss-loader 通过加载插件转换 css 内容，转换后的内容虽然是 .css 文件，但是仍需传递给 css-loader 做后续处理。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...   <span class="hljs-keyword">module</span>: &#123;    rules: [      &#123;        test: /\.(css)$/,        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;postcss-loader&#x27;</span>]      &#125;    ]  &#125;&#125;;</code></pre></div><p>以上只是将 postcss-loader 配置到了 webpack 中，执行打包命令可以正常打包，但 css 内容不会发生变化，postcss-loader 需要通过插件来达到我们想要的效果，下面我们以自动添加前缀为例看下效果。</p><p>安装 autoprefixer</p><div class="code-wrapper"><pre><code class="hljs angelscript">npm install <span class="hljs-built_in">auto</span>prefixer -D</code></pre></div><p>postcss.config.js</p><p>项目根目录下新建 postcss.config.js 文件，配置 autoprefixer 插件，和要对应的浏览器版本。其中 browsers 的配置可以配置到 package.json 或者 .browserslistrc 文件下，如果配置到 postcss.config.js 中打包时会有警告，不过我们为了演示 autoprefixer 效果，不对此做处理。</p><div class="code-wrapper"><pre><code class="hljs coffeescript">module.<span class="hljs-built_in">exports</span> = &#123;    plugins: [      <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;autoprefixer&#x27;</span>)(&#123;        <span class="hljs-string">&#x27;browsers&#x27;</span>: [<span class="hljs-string">&#x27;&gt; 1%&#x27;</span>, <span class="hljs-string">&#x27;last 2 versions&#x27;</span>]      &#125;)    ]&#125;;</code></pre></div><p>配置完成后，执行打包命令，打包成功后在浏览器中打开 dist&#x2F;index.html 文件，在控制台中我们可以看到，样式代码已经自动增加前缀。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655704774-Lklqfv-1.png" alt="1.png"></p><h2 id="配置项-5"><a href="#配置项-5" class="headerlink" title="配置项"></a>配置项</h2><p>postcss-loader 包含下面几个配置项</p><ul><li>execute</li><li>postcssOptions</li><li>sourceMap</li><li>implementation</li></ul><h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><p>默认：undefined</p><p>值类型：Boolean</p><p>作用：在 CSS-in-JS 中，如果您想要处理在 JavaScript 中书写的样式，需要使用 postcss-js 解析器，添加 execute 选项并设置为 true。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>  ...   <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;postcss-loader&quot;</span>,<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        postcssOptions:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">          parser:</span> <span class="hljs-string">&quot;postcss-js&quot;</span>,        <span class="hljs-punctuation">&#125;</span>,<span class="hljs-symbol">        execute:</span> true,      <span class="hljs-punctuation">&#125;</span>,    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;;</span></code></pre></div><h3 id="postcssOptions"><a href="#postcssOptions" class="headerlink" title="postcssOptions"></a>postcssOptions</h3><p>默认：undefined</p><p>值类型：Object | Function</p><p>作用：允许设置 PostCSS options 和插件。支持所有PostCSS选项。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>  ...   <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;postcss-loader&quot;</span>,<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-comment">// object</span><span class="hljs-symbol">        postcssOptions:</span> <span class="hljs-punctuation">&#123;</span>          ...        <span class="hljs-punctuation">&#125;</span>        <span class="hljs-comment">// function</span><span class="hljs-symbol">        postcssOptions:</span> (loaderContext) =&gt; <span class="hljs-punctuation">&#123;</span>          <span class="hljs-title class_">return</span> <span class="hljs-punctuation">&#123;</span>            ...          <span class="hljs-punctuation">&#125;</span>        <span class="hljs-punctuation">&#125;</span>      <span class="hljs-punctuation">&#125;</span>,    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;;</span></code></pre></div><h3 id="sourceMap-1"><a href="#sourceMap-1" class="headerlink" title="sourceMap"></a>sourceMap</h3><p>默认：取决于 <a href="https://leetcode.cn/link/?target=https://webpack.js.org/configuration/devtool/">devtool</a> 选项</p><p>值类型：Boolean</p><p>作用：是否开启 sourceMap</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>  ...   <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;postcss-loader&quot;</span>,<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        sourceMap:</span> true      <span class="hljs-punctuation">&#125;</span>,    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;;</span></code></pre></div><h3 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h3><p>默认：postcss</p><p>值类型：Function | String</p><p>作用：implementation 选项决定使用哪个 PostCSS 实现。覆盖本地安装的 postcss 的 peerDependency 版本</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs ada">module.exports = &#123;  ...   &#123;      loader: <span class="hljs-string">&quot;postcss-loader&quot;</span>,      options : &#123;  <span class="hljs-type">implementation</span> : <span class="hljs-type">require</span> ( <span class="hljs-string">&quot;postcss&quot;</span> )  &#125;    &#125;&#125;;</code></pre></div><h1 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 postcss-loader 的使用方法，postcss-loader 主要是 PostCSS 在 webpack 环境下的使用方法，通过加载不同的插件来达到处理样式文件的效果，PostCSS 支持的插件非常丰富，本文只是通过自动添加前缀的例子做一个展示，想看其他插件的使用方法可以去 PostCSS 官网查看。</p><h3 id="Sass-Loader"><a href="#Sass-Loader" class="headerlink" title="Sass-Loader"></a>Sass-Loader</h3><h1 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h1><h2 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a><a href="https://leetcode.cn/link/?target=https://www.sasscss.com/documentation">Sass</a></h2><div class="code-wrapper"><pre><code class="hljs gams">sass 是一种 css 的预编译语言。它提供了 变量（<span class="hljs-keyword">variables</span>）、嵌套（nested <span class="hljs-comment">rules</span>）、 混合（<span class="hljs-comment">mixins</span>）、 函数（<span class="hljs-comment">functions</span>）等功能，并且完全兼容 <span class="hljs-comment">css</span>，<span class="hljs-comment">sass</span> 能够帮助复杂的样式表更有条理，并且易于在项目内部或跨项目共享设计。</code></pre></div><p>当 css 变得越来越臃肿、 越来越复杂、越来越难以维护时 sass 为我们提供了 css 中不存在的特性辅助我们编写健壮、 可维护的 css 代码。</p><p>在使用 sass 之前，需要在项目中安装它，而 sass-loader 的作用是加载 sass&#x2F;scss 文件并将其编译为 css，通过将 style-loader 和 css-loader 与 sass-loader 链式调用，可以立刻将样式作用在 DOM 元素。</p><h2 id="使用-6"><a href="#使用-6" class="headerlink" title="使用"></a>使用</h2><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>sass-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello sass<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>index.js</p><p>src&#x2F;index.js 文件中使用 import 导入 index.scss。</p><div class="code-wrapper"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> indexCss <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.scss&quot;</span>;</code></pre></div><p>index.scss</p><p>sass 和 scss 其实是同一种东西，我们平时都称之为 sass，不过两者之间写法也存在些区别，感兴趣的小伙伴儿可自行查阅，我们本案例都以 scss 为例。</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-variable">$primary</span>-<span class="hljs-attribute">color</span>: <span class="hljs-number">#f00</span>;<span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$primary</span>-color;&#125;</code></pre></div><p>安装 sass-loader 和 sass</p><div class="code-wrapper"><pre><code class="hljs q">npm install sass-loader sass --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div><p>安装成功后，将 sass-loader 配置到 webpack.config.js 中。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...   <span class="hljs-keyword">module</span>: &#123;    rules: [      &#123;        test: /\.scss$/,        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]      &#125;    ]  &#125;&#125;;</code></pre></div><p>执行打包命令后，在浏览器打开 dist&#x2F;index.html 文件，我们可以看到我们在 index.scss 文件中定义的颜色常量被正确的显示到了标签上面，在控制台可以看到，color 的颜色属性已由定义的变量转换成了定义的颜色值。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655972361-xCPFRy-4.png" alt="4.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655972355-lPHDnq-5.png" alt="5.png"></p><h2 id="配置项-6"><a href="#配置项-6" class="headerlink" title="配置项"></a>配置项</h2><p>sass-loader 可以通过指定 options 参数，向 sass 传递选项参数。</p><ul><li>implementation</li><li>sassOptions</li><li>sourceMap</li><li>additionalData</li><li>webpackImporter</li><li>warnRuleAsWarning</li></ul><h3 id="implementation-1"><a href="#implementation-1" class="headerlink" title="implementation"></a>implementation</h3><p>默认值：sass</p><p>值类型：Object | String</p><p>作用：sass-loader 要使用的 sass 实现。默认情况下，sass-loader 会根据你的依赖解析需要使用的实现。 只需将必需的实现添加到 package.json（sass 或 node-sass 包）中并安装依赖项即可。</p><p>package.json</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> sass-loader 将会使用 sass 实现&#123;  <span class="hljs-string">&quot;devDependencies&quot;</span>: &#123;    <span class="hljs-string">&quot;sass-loader&quot;</span>: <span class="hljs-string">&quot;^7.2.0&quot;</span>,    <span class="hljs-string">&quot;sass&quot;</span>: <span class="hljs-string">&quot;^1.22.10&quot;</span>  &#125;&#125;</code></pre></div><p>package.json</p><div class="code-wrapper"><pre><code class="hljs crmsh">// sass-loader 将会使用 <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span> 实现&#123;  <span class="hljs-string">&quot;devDependencies&quot;</span>: &#123;    <span class="hljs-string">&quot;sass-loader&quot;</span>: <span class="hljs-string">&quot;^7.2.0&quot;</span>,    <span class="hljs-string">&quot;node-sass&quot;</span>: <span class="hljs-string">&quot;^5.0.0&quot;</span>  &#125;&#125;</code></pre></div><p>同时安装 node-sass 和 sass 的情况下，sass-loader 默认会选择 sass。 为了避免这种情况，你可以使用 implementation 选项。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">module</span>.exports = &#123;  ...   &#123;      loader: <span class="hljs-string">&quot;sass-loader&quot;</span>,      options: &#123;        <span class="hljs-comment">// Object</span>        <span class="hljs-keyword">implementation</span>: require(<span class="hljs-string">&#x27;sass&#x27;</span>)        <span class="hljs-comment">// String</span>        <span class="hljs-keyword">implementation</span>: require.resolve(<span class="hljs-string">&#x27;sass&#x27;</span>)      &#125;,    &#125;&#125;;</code></pre></div><h3 id="sassOptions"><a href="#sassOptions" class="headerlink" title="sassOptions"></a>sassOptions</h3><p>默认值：sass 实现的默认值</p><p>值类型：Object | Function</p><p>作用：设置 sass 实现的启动选项。</p><p>在使用他们之前，请查阅有关文档：<a href="https://leetcode.cn/link/?target=https://github.com/sass/dart-sass#javascript-api">Dart Sass</a> 文档提供了所有可用的 sass 选项。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;  ...  &#123;    &#123;      loader: <span class="hljs-string">&quot;sass-loader&quot;</span>,      options: &#123;        <span class="hljs-regexp">//</span> Object        sassOptions: &#123;          includePaths: [<span class="hljs-string">&#x27;absolute/a&#x27;</span>, <span class="hljs-string">&#x27;absolute/b&#x27;</span>],        &#125;,        <span class="hljs-regexp">//</span> Function        sassOptions: (loaderContext) =&gt; &#123;          <span class="hljs-regexp">//</span> 有关可用属性的更多信息 https:<span class="hljs-regexp">//</span>webpack.js.org<span class="hljs-regexp">/api/</span>loaders/          ...          return &#123;            includePaths: [<span class="hljs-string">&#x27;absolute/a&#x27;</span>, <span class="hljs-string">&#x27;absolute/b&#x27;</span>],          &#125;;        &#125;,      &#125;,    &#125;  &#125;&#125;;</code></pre></div><h3 id="sourceMap-2"><a href="#sourceMap-2" class="headerlink" title="sourceMap"></a>sourceMap</h3><p>默认值：取决于 complier.devtool值，值为 false 和 eval 时，不会生成 source map。</p><p>值类型：Boolean</p><p>作用：是否开启 sourceMap</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>  ...   <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;sass-loader&quot;</span>,<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        sourceMap:</span> true      <span class="hljs-punctuation">&#125;</span>,    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;;</span></code></pre></div><h3 id="additionalData"><a href="#additionalData" class="headerlink" title="additionalData"></a>additionalData</h3><p>默认值：undefined</p><p>值类型： String | Function</p><p>作用：在实际的文件之前要添加的 sass &#x2F; scss 代码。下面的示例中，����ℎ、<em>w<strong>i</strong>d<strong>t</strong>h</em>、value 可以在 index.scss 中直接引用。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs coffeescript">module.<span class="hljs-built_in">exports</span> = &#123;  ...  &#123;    loader: <span class="hljs-string">&quot;sass-loader&quot;</span>,    options : &#123;        <span class="hljs-regexp">//</span> <span class="hljs-built_in">String</span>      additionalData: <span class="hljs-string">&#x27;$width:&#x27;</span> + process.env.NODE_ENV + <span class="hljs-string">&#x27;;&#x27;</span>,      <span class="hljs-regexp">//</span> <span class="hljs-built_in">Function</span> sync      additionalData: <span class="hljs-function"><span class="hljs-params">(content, loaderContext)</span> =&gt;</span> &#123;        ...        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;$value: 100px;&#x27;</span> + content;      &#125;      <span class="hljs-regexp">//</span> <span class="hljs-built_in">Function</span> <span class="hljs-keyword">async</span>       additionalData: <span class="hljs-keyword">async</span> (content, loaderContext) =&gt; &#123;        ...        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;$value: 100px;&#x27;</span> + content;      &#125;    &#125;  &#125;&#125;;</code></pre></div><h3 id="webpackImporter"><a href="#webpackImporter" class="headerlink" title="webpackImporter"></a>webpackImporter</h3><p>默认值：true</p><p>值类型： Boolean</p><p>作用：开启 &#x2F; 关闭默认的 Webpack importer。在某些情况下，可以提高性能。但是请谨慎使用，因为 aliases 和以 〜 开头的 @import 规则将不起作用。 你可以传递自己的 importer 来解决这个问题（参阅 <a href="https://leetcode.cn/link/?target=https://github.com/sass/node-sass#importer--v200---experimental">importer docs</a>）。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  &#123;    loader: <span class="hljs-string">&quot;sass-loader&quot;</span>,    options : &#123;        webpackImporter: <span class="hljs-literal">false</span>,    &#125;  &#125;&#125;;</code></pre></div><h3 id="warnRuleAsWarning"><a href="#warnRuleAsWarning" class="headerlink" title="warnRuleAsWarning"></a>warnRuleAsWarning</h3><p>默认值：false (在下一个大版本发布中它将默认设置为 true)</p><p>值类型： Boolean</p><p>作用：将 @warn 规则视为 webpack 警告而不是日志。</p><p>index.scss</p><div class="code-wrapper"><pre><code class="hljs mel">$known-prefixes: webkit, moz, ms, o;@mixin prefix($property, $value, $prefixes) &#123;  @each $prefix <span class="hljs-keyword">in</span> $prefixes &#123;    @if not index($known-prefixes, $prefix) &#123;      @warn <span class="hljs-string">&quot;Unknown prefix #&#123;$prefix&#125;.&quot;</span>;    &#125;    -#&#123;$prefix&#125;-#&#123;$property&#125;: $value;  &#125;  #&#123;$property&#125;: $value;&#125;body &#123;  @include prefix(<span class="hljs-string">&#x27;display&#x27;</span>, <span class="hljs-string">&#x27;flex&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>);&#125;</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...   &#123;      loader: <span class="hljs-string">&quot;sass-loader&quot;</span>,      options : &#123;          warnRuleAsWarning: <span class="hljs-literal">true</span>,      &#125;    &#125;&#125;;</code></pre></div><p>在上面的例子中，我们 $prefixes 值传入 a，执行打包命令，虽然可以打包成功，但是控制台会输出警告，如果我们将 $prefixes 值传入 $known-prefixes 中定义的 o，则控制台不会显示警告。</p><h1 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 sass-loader 的使用方法和一些配置参数。通过使用 sass-loader 和 sass 可以让我们让我们的样式表更有条理并且易于维护。</p><h3 id="Svg-URL-Loader"><a href="#Svg-URL-Loader" class="headerlink" title="Svg-URL-Loader"></a>Svg-URL-Loader</h3><h1 id="svg-url-loader"><a href="#svg-url-loader" class="headerlink" title="svg-url-loader"></a>svg-url-loader</h1><p>svg-url-loader 可以将 svg 文件加载为 utf-8 编码的 data-uri 字符串。url-loader 也可以加载 svg 文件，和 svg-url-loader 的区别是 url-loader 将 svg 文件加载为 base64 编码的字符串。</p><p>utf-8 编码相对于 base64 编码有一些优势。</p><ul><li><p>编译结果字符串更短（对于 2K 大小的图标，可以缩短约 2 倍）；</p></li><li><p>使用 gzip 压缩时，生成的字符串将被更好地压缩；</p></li><li><p>浏览器解析 utf-8 编码的字符串比 base64 编码的字符串更快；</p></li></ul><h2 id="使用-7"><a href="#使用-7" class="headerlink" title="使用"></a>使用</h2><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>svg-url-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;svg-loader&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>index.js</p><div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> svgContent from <span class="hljs-string">&#x27;./img/headIcon.svg&#x27;</span>;<span class="hljs-built_in">window</span>.<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;svg-loader&#x27;</span>).src = svgContent;</code></pre></div><p>安装 svg-url-loader</p><div class="code-wrapper"><pre><code class="hljs q">npm install svg-url-loader --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div><p>安装成功后，将 svg-url-loader 配置到 webpack.config.js 中。</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>  ...<span class="hljs-symbol">   module:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">    rules:</span> [      <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        test:</span> /\.svg/,<span class="hljs-symbol">        use:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">          loader:</span> <span class="hljs-string">&quot;svg-url-loader&quot;</span>,        <span class="hljs-punctuation">&#125;</span>,      <span class="hljs-punctuation">&#125;</span>    ]  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;;</span></code></pre></div><p>执行打包命令后，在浏览器打开 dist&#x2F;index.html 文件，我们可以看到 svg 图片被展示在页面是上，打开 dist&#x2F;main-[hash].js 文件可以看到 svg 图片被编译成了 utf-8 编码的字符串。</p><h2 id="配置项-7"><a href="#配置项-7" class="headerlink" title="配置项"></a>配置项</h2><p>svg-url-loader 包含下面参数。</p><ul><li><p>limit</p></li><li><p>stripdeclarations</p></li><li><p>iesafe</p></li><li><p>encoding</p></li></ul><h3 id="limit-1"><a href="#limit-1" class="headerlink" title="limit"></a>limit</h3><p>默认值：无</p><p>值类型：Number</p><p>作用：当设置 limit，如果源文件的内容大于这个限制，svg-url-loader 将不编码源文件。如果文件大于 limit 设置的限制，将使用 file-loader 加载文件，svg-url-loader 中设置的参数会传递给 file-loader。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>  ...  <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">    test:</span> /\.svg/,<span class="hljs-symbol">    use:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;svg-url-loader&quot;</span>,<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        limit:</span> <span class="hljs-number">1024</span> <span class="hljs-comment">// 文件大小 1M</span>      <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">&#125;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;;</span></code></pre></div><h3 id="stripdeclarations"><a href="#stripdeclarations" class="headerlink" title="stripdeclarations"></a>stripdeclarations</h3><p>默认值：true</p><p>值类型：Boolean</p><p>作用：它将在下一个主要版本中被删除，删除所有 XML 声明。例如：svg 图片开头的 <?xml version="1.0" encoding="UTF-8"?>。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>  ...  <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">    test:</span> /\.svg/,<span class="hljs-symbol">    use:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;svg-url-loader&quot;</span>,<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        stripdeclarations:</span> false      <span class="hljs-punctuation">&#125;</span>    <span class="hljs-punctuation">&#125;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;;</span></code></pre></div><h3 id="iesafe"><a href="#iesafe" class="headerlink" title="iesafe"></a>iesafe</h3><p>默认值：无</p><p>值类型：Boolean</p><p>作用：当 iesafe 选项设置为 true，svg-url-loader 在编译文件时，如果文件包含一个样式元素并且编码大小超过 4kB，则无论指定的限制如何，都使用 file-loader 编译。因为 ie 浏览器包括 ie11 已经停止解析 svg 数据中的样式元素和大小超过 4kb 的文件，会导致所有样式的形状都是黑色填充。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>  ...   <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;svg-url-loader&quot;</span>,<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        iesafe:</span> true      <span class="hljs-punctuation">&#125;</span>,    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;;</span></code></pre></div><h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>默认值：”none”</p><p>值类型：”none” ｜ “base64”</p><p>作用：设置 svg-url-loader 构造数据 URI 时要使用的编码。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>  ...  <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">    loader:</span> <span class="hljs-string">&quot;svg-url-loader&quot;</span>,<span class="hljs-symbol">    options:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">      encoding:</span> <span class="hljs-string">&quot;base64&quot;</span>    <span class="hljs-punctuation">&#125;</span>,  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;;</span></code></pre></div><h1 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 svg-url-loader 的使用方法和一些配置参数。svg-url-loader 主要用来编译 svg 格式文件，默认采用 utf-8 编码。</p><h3 id="Svg-Sprite-Loader"><a href="#Svg-Sprite-Loader" class="headerlink" title="Svg-Sprite-Loader"></a>Svg-Sprite-Loader</h3><h1 id="svg-sprite-loader"><a href="#svg-sprite-loader" class="headerlink" title="svg-sprite-loader"></a>svg-sprite-loader</h1><p>svg-sprite-loader 作用是合并多个单个的 svg 图片为一个 sprite 雪碧图，并把合成好的内容，插入到 html 内，其原理是利用 svg 的 symbol 元素，将每个 svg 图片 包括在 symbol 中，通过 use 元素使用该 symbol。<a href="https://leetcode.cn/link/?target=https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element">svg</a> 元素参考。</p><h2 id="使用-8"><a href="#使用-8" class="headerlink" title="使用"></a>使用</h2><p>index.html</p><p>在 index.html 中，通过使用 svg 的 use 元素渲染两张 svg 图片，分别对应 img 文件夹下的 headIcon.svg 和 home.svg。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>svg-sprite-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#headIcon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#home&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>index.js</p><p>导入 index.html 中 use 元素加载的两张 svg 图片。</p><div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> svgContent <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./img/headIcon.svg&#x27;</span>;<span class="hljs-keyword">import</span> svgHome <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./img/home.svg&#x27;</span>;</code></pre></div><p>安装 svg-sprite-loader</p><div class="code-wrapper"><pre><code class="hljs q">npm install svg-sprite-loader --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div><p>安装成功后，将 svg-sprite-loader 配置到 webpack.config.js 中。</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>  ...<span class="hljs-symbol">   module:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">    rules:</span> [      <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        test:</span> /\.svg/,<span class="hljs-symbol">        use:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">          loader:</span> <span class="hljs-string">&quot;svg-sprite-loader&quot;</span>        <span class="hljs-punctuation">&#125;</span>,      <span class="hljs-punctuation">&#125;</span>    ]  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;;</span></code></pre></div><p>执行打包命令后，在浏览器打开 dist&#x2F;index.html 文件，我们可以看到 svg 图片被展示在页面上，在控制台查看 elements 选项，可以看到两个 svg 图片被包裹在 两个 symbol 标签中，使用时通过 use 标签传入 symbol 元素 id 来显示不同的 svg 图片。</p><h2 id="配置项-8"><a href="#配置项-8" class="headerlink" title="配置项"></a>配置项</h2><p>svg-sprite-loader 包含下面基础参数配置。</p><ul><li><p>symbolId</p></li><li><p>symbolRegExp</p></li><li><p>esModule</p></li></ul><h3 id="symbolId"><a href="#symbolId" class="headerlink" title="symbolId"></a>symbolId</h3><p>默认值：[name]</p><p>值类型：String | Function</p><p>作用：设置 svg 标签中 symbol 元素的 id 值。</p><p>html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#icon-headIcon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;  ...  &#123;    test: <span class="hljs-regexp">/\.svg/</span>,    use: &#123;      loader: <span class="hljs-string">&quot;svg-sprite-loader&quot;</span>,      options: &#123;        <span class="hljs-regexp">//</span> string        symbolId: <span class="hljs-string">&#x27;icon-[name]&#x27;</span>        <span class="hljs-regexp">//</span> <span class="hljs-keyword">function</span>        symbolId: filePath =&gt; path.basename(filePath)      &#125;              &#125;  &#125;&#125;;</code></pre></div><h3 id="symbolRegExp"><a href="#symbolRegExp" class="headerlink" title="symbolRegExp"></a>symbolRegExp</h3><p>默认值：’’</p><p>值类型：String</p><p>作用：传递给 symbolId 插值器以支持 loader-utils 名称插值器中的 [N] 模式。</p><h3 id="esModule-3"><a href="#esModule-3" class="headerlink" title="esModule"></a>esModule</h3><p>默认值：true</p><p>值类型：Boolean</p><p>作用：是否使用 esModule 语法。如果使用 CommonJS 语法则参数设置为 false。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>  ...   <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">      loader:</span> <span class="hljs-string">&quot;svg-sprite-loader&quot;</span>,<span class="hljs-symbol">      options:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        esModule:</span> true      <span class="hljs-punctuation">&#125;</span>,    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;;</span></code></pre></div><p>svg-sprite-loader 还支持<a href="https://leetcode.cn/link/?target=https://github.com/JetBrains/svg-sprite-loader#runtime-configuration">运行时配置</a>和<a href="https://leetcode.cn/link/?target=https://github.com/JetBrains/svg-sprite-loader#extract-configuration">提取配置</a>，想了解的小伙伴儿可自行查阅文档。</p><h1 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h1><p>本节我们介绍了 svg-sprite-loader 的使用方法和一些配置参数。svg-sprite-loader 主要用来将从 css&#x2F;scss&#x2F;sass&#x2F;less&#x2F;styl&#x2F;html 导入的图像生成外部 sprite 文件，通过使用 svg 的 use 元素展示 图像内容。达到统一管理的目的。</p><h3 id="VUE-Loader"><a href="#VUE-Loader" class="headerlink" title="VUE-Loader"></a>VUE-Loader</h3><h1 id="vue-loader"><a href="#vue-loader" class="headerlink" title="vue-loader"></a>vue-loader</h1><p>Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件。</p><p>Vue Loader 还提供了很多酷炫的特性：</p><ul><li>允许为 Vue 组件的每个部分使用其它的 webpack loader，例如在 <style> 的部分使用 Sass 和在 <template> 的部分使用 Pug；</li><li>允许在一个 .vue 文件中使用自定义块，并对其运用自定义的 loader 链；</li><li>使用 webpack loader 将 <style> 和 <template> 中引用的资源当作模块依赖来处理；</li><li>为每个组件模拟出 scoped CSS；</li><li>在开发过程中使用热重载来保持状态；</li></ul><h2 id="使用-9"><a href="#使用-9" class="headerlink" title="使用"></a>使用</h2><p>在下面的例子中，正常要使用 <a href="https://leetcode.cn/link/?target=https://cn.vuejs.org/">Vue.js</a> 将组件渲染到页面上。但是这样会增加一些额外的代码，容易混淆，所以下面的例子只是完成打包不报错即认为 vue-loader 起到了作用。</p><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>vue-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>index.vue</p><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">msg</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">  data () &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Hello world!&#x27;</span></span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span></span><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.demo</span> &#123;</span></span><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">color</span>: blue;</span></span><span class="language-css"><span class="language-xml">&#125;</span></span><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span></code></pre></div><p>安装 vue-loader</p><p>vue-loader 需要配合 <a href="https://leetcode.cn/link/?target=https://www.npmjs.com/package/vue-template-compiler">vue-template-compiler</a> 一起使用。</p><div class="code-wrapper"><pre><code class="hljs pgsql">npm install vue-loader vue-<span class="hljs-keyword">template</span>-compiler <span class="hljs-comment">--save-dev</span></code></pre></div><p>安装成功后，将 vue-loader 配置到 webpack.config.js 中。</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;...<span class="hljs-regexp">//</span> webpack.config.jsconst &#123; VueLoaderPlugin &#125; = require(<span class="hljs-string">&#x27;vue-loader&#x27;</span>);module.exports = &#123;    ...    module: &#123;        rules: [            &#123;                test: <span class="hljs-regexp">/\.vue$/</span>,                loader: <span class="hljs-string">&#x27;vue-loader&#x27;</span>,            &#125;,            <span class="hljs-regexp">//</span> 它会应用到普通的 `.css` 文件            <span class="hljs-regexp">//</span> 以及 `.vue` 文件中的 `&lt;style&gt;` 块            &#123;                test: <span class="hljs-regexp">/\.css$/</span>,                use: [                    <span class="hljs-string">&#x27;style-loader&#x27;</span>,                    <span class="hljs-string">&#x27;css-loader&#x27;</span>                ]            &#125;        ]    &#125;,    plugins: [         <span class="hljs-regexp">//</span> 请确保引入这个插件！         <span class="hljs-regexp">//</span> 这个插件是必须的！它的职责是将你定义过的其它规则复制并应用到 .vue 文件里相应语言的块。例如，如果你有一条匹配 <span class="hljs-regexp">/\.js$/</span> 的规则，那么它会应用到 .vue 文件里的 &lt;script&gt; 块。         new VueLoaderPlugin()    ]&#125;;</code></pre></div><p>执行打包命令后，控制台显示编译成功。</p><h2 id="配置项-9"><a href="#配置项-9" class="headerlink" title="配置项"></a>配置项</h2><p>vue-loader 参数配置。</p><ul><li>transformAssetUrls</li><li>compiler</li><li>compilerOptions</li><li>transpileOptions</li><li>optimizeSSR</li><li>hotReload</li><li>productionMode</li><li>shadowMode</li><li>cacheDirectory &#x2F; cacheIdentifier</li><li>prettify</li><li>exposeFilename</li></ul><p>vue-loader 的配置项官网显示很清楚，大家可以去官网查看，<a href="https://leetcode.cn/link/?target=https://vue-loader.vuejs.org/zh/options.html#transformasseturls">vue-loader配置</a>。</p><h1 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h1><p>vue-loader 的总结大部分源自<a href="https://leetcode.cn/link/?target=https://vue-loader.vuejs.org/">官网介绍</a>，通过上面的使用我们可以完成一个简单的 vue-loader 配置及使用。</p><h3 id="VUE-Style-Loader"><a href="#VUE-Style-Loader" class="headerlink" title="VUE-Style-Loader"></a>VUE-Style-Loader</h3><h1 id="vue-style-loader"><a href="#vue-style-loader" class="headerlink" title="vue-style-loader"></a>vue-style-loader</h1><p>vue-style-loader 是基于 style-loader 的分支，功能与 style-loader 类似，都可以与 css-loader 链接将 style 标签注入到文档中，vue-style-loader 一般不需要自己配置加载，因为他已经作为依赖项包含在 vue-loader 中。vue-style-loader 除了将 style 注入到文档中，还做了一些服务端渲染的支持，所以如果我们 vue 项目中需要做服务端渲染，可能就要使用 vue-style-loader 来插入样式了。</p><h2 id="使用-10"><a href="#使用-10" class="headerlink" title="使用"></a>使用</h2><p>vue-style-loader 的使用方法与 style-loader 类似。都是与 css-loader 链接起来使用。</p><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>vue-style-loader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> indexCss <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;demo&quot;</span>;divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;vue-style-loader&#x27;</span>;<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div><p>index.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;    <span class="hljs-attribute">color</span>: red;&#125;</code></pre></div><p>安装 vue-style-loader</p><div class="code-wrapper"><pre><code class="hljs maxima">npm install vue-<span class="hljs-built_in">style</span>-loader --<span class="hljs-built_in">save</span>-dev</code></pre></div><p>安装成功后，将 vue-style-loader 配置到 webpack.config.js 中。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;...  <span class="hljs-attr">rules</span>: [    &#123;      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,      <span class="hljs-attr">use</span>: [          <span class="hljs-string">&#x27;vue-style-loader&#x27;</span>,          <span class="hljs-string">&#x27;css-loader&#x27;</span>      ]    &#125;  ]&#125;;</code></pre></div><p>打包成功后，打开 dist&#x2F;index.html 可以看到浏览器中文字颜色已经变成红色，在控制台 element 中可以看到 index.css 中的样式属性已经被包裹了 style 标签并插入到 head 中。</p><h2 id="配置项-10"><a href="#配置项-10" class="headerlink" title="配置项"></a>配置项</h2><p>vue-style-loader 参数配置。</p><ul><li><p>manualInject</p></li><li><p>ssrId</p></li></ul><h3 id="manualInject"><a href="#manualInject" class="headerlink" title="manualInject"></a>manualInject</h3><p>默认值：无</p><p>值类型：Boolean</p><p>作用：当 manualInject 参数值为 true 时，导入的样式对象会提供一个__inject__方法，然后可以在适当的时间手动调用该方法。此方法接收一个对象参数，最后将样式文件内容绑定到传入的对象上。</p><div class="code-wrapper"><pre><code class="hljs reasonml">注意：只有运行环境为 <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Node</span>.</span></span>js 且 manualInject 为 <span class="hljs-literal">true</span> 时，样式对象才会提供__inject__方法。</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">module.exports</span> <span class="hljs-string">=</span> &#123;  <span class="hljs-string">...</span>  &#123;    <span class="hljs-attr">test:</span> <span class="hljs-string">/\.svg/</span>,    <span class="hljs-attr">use:</span> [      &#123;        <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;vue-style-loader&#x27;</span>,        <span class="hljs-attr">options:</span> &#123;          <span class="hljs-attr">manualInject:</span> <span class="hljs-literal">true</span>,        &#125;      &#125;,    ]  &#125;&#125;<span class="hljs-string">;</span></code></pre></div><h3 id="ssrId"><a href="#ssrId" class="headerlink" title="ssrId"></a>ssrId</h3><p>默认值：无</p><p>值类型：Boolean</p><p>作用：向 style 标签添加 data-vue-ssr-id 属性，可以用作预渲染避免样式重复注入。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">module.exports</span> <span class="hljs-string">=</span> &#123;  <span class="hljs-string">...</span>  &#123;    <span class="hljs-attr">test:</span> <span class="hljs-string">/\.svg/</span>,    <span class="hljs-attr">use:</span> [      &#123;        <span class="hljs-attr">loader:</span> <span class="hljs-string">&#x27;vue-style-loader&#x27;</span>,        <span class="hljs-attr">options:</span> &#123;          <span class="hljs-attr">ssrId:</span> <span class="hljs-literal">true</span>        &#125;      &#125;,    ]  &#125;&#125;<span class="hljs-string">;</span></code></pre></div><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655707832-TLxisk-1.png" alt="1.png"></p><h2 id="区别于-style-loader"><a href="#区别于-style-loader" class="headerlink" title="区别于 style-loader"></a>区别于 style-loader</h2><ul><li>如果你正在构建一个 Vue SSR 应用程序，你可能也应该使用这个加载器来处理从 JavaScript 文件导入的 CSS</li><li>不支持 url 模式和引用计数模式。还删除了 singleton 和insertAt 查询选项。不支持样式懒加载。如果您需要这些功能，您可能应该使用原始功能 style-loader。</li></ul><h1 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h1><p>本章节我们介绍了 vue-style-loader 的使用、配置和它与 style-loader 的区别，vue-style-loader 支持 vue 中的 ssr（服务端渲染），所以如果需要支持服务端渲染的 vue 项目，就需要用到 vue-style-loader 了。但是如果是一般的项目，style-laoder 的功能会更多些。</p><h1 id="核心概念-Plugin"><a href="#核心概念-Plugin" class="headerlink" title="核心概念-Plugin"></a>核心概念-Plugin</h1><h3 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h3><h1 id="DefinePlugin-1"><a href="#DefinePlugin-1" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h1><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">DefinePlugin</span> 允许在编译时将你代码中的变量替换为其他值或表达式。这在需要根据开发模式与生产模式进行不同的操作时，非常有用。例如，如果想在开发构建中进行日志记录，而不在生产构建中进行，就可以定义一个全局常量去判断是否记录日志。这就是 DefinePlugin 的发光之处，设置好它，就可以忘掉开发环境和生产环境的构建规则。</code></pre></div><h2 id="使用-11"><a href="#使用-11" class="headerlink" title="使用"></a>使用</h2><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DefinePlugin<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>index.js</p><p>我们将 webpack 中传入 DefinePlugin 中的参数打印出来。</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(PRODUCTION)<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(DEVELOPMENT)<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(VERSION)<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(BROWSER_SUPPORTS_HTML5)<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(TWO)<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> window)<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(process.env.NODE_ENV)</code></pre></div><p>webpack.config.js</p><p>DefinePlugin 是 webpack 提供的插件，所以不需要单独安装，直接在 webpack 包中引入即可。</p><div class="code-wrapper"><pre><code class="hljs javascript">...<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  ...  <span class="hljs-attr">plugins</span>: [        ...        <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DefinePlugin</span>(&#123;            <span class="hljs-attr">PRODUCTION</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>)&#125;,            <span class="hljs-attr">DEVELOPMENT</span>: &#123;                <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>,                <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>            &#125;,            <span class="hljs-attr">VERSION</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&#x27;5fa3b9&#x27;</span>),            <span class="hljs-attr">BROWSER_SUPPORTS_HTML5</span>: <span class="hljs-literal">true</span>,            <span class="hljs-string">&#x27;TWO&#x27;</span>: <span class="hljs-string">&#x27;1+1&#x27;</span>,            <span class="hljs-string">&#x27;typeof window&#x27;</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&#x27;object&#x27;</span>),            <span class="hljs-string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&quot;development&quot;</span>)        &#125;)    ]&#125;;</code></pre></div><p>执行打包命令后，我们在浏览器查看输出结果。</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(PRODUCTION) <span class="hljs-comment">// ƒ () &#123;console.log(111)&#125;</span><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(DEVELOPMENT) <span class="hljs-comment">// &#123;name: 1, value: 2&#125;</span><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(VERSION) <span class="hljs-comment">// 5fa3b9 </span><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(BROWSER_SUPPORTS_HTML5) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(TWO) <span class="hljs-comment">// 2</span><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> window) <span class="hljs-comment">// object</span><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(process.env.NODE_ENV) <span class="hljs-comment">// development</span></code></pre></div><h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><p>传递给 DefinePlugin 的每个键都是一个标识符或多个以 . 连接的标识符。</p><ul><li>如果该值为字符串，它将被作为代码片段来使用。</li><li>如果该值不是字符串，则将被转换成字符串（包括函数方法）。</li><li>如果值是一个对象，则它所有的键将使用相同方法定义。</li><li>如果键添加 typeof 作为前缀，它会被定义为 typeof 调用。</li></ul><div class="code-wrapper"><pre><code class="hljs powershell">警告：在为 <span class="hljs-keyword">process</span> 定义值时，<span class="hljs-string">&#x27;process.env.NODE_ENV&#x27;</span>: JSON.stringify(<span class="hljs-string">&#x27;production&#x27;</span>) 会比 <span class="hljs-keyword">process</span>: &#123; env: &#123; NODE_ENV: JSON.stringify(<span class="hljs-string">&#x27;production&#x27;</span>) &#125; &#125; 更好，后者会覆盖 <span class="hljs-keyword">process</span> 对象，这可能会破坏与某些模块的兼容性，因为这些模块会在 <span class="hljs-keyword">process</span> 对象上定义其他值。</code></pre></div><p>DefinePlugin 插件提供的功能在实际项目中将非常实用，通过传入标识符可以在生产&#x2F;开发构建中开启&#x2F;关闭不同特性。通过标识符传入的参数经过 webpack 压缩后可以只保留标识符为 true 的代码片段。可以通过传入服务地址来区分生产&#x2F;开发。</p><p>开启&#x2F;关闭特性</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-comment">// NICE_FEATURE: JSON.stringify(true),</span><span class="hljs-keyword">if</span> (!NICE_FEATURE) &#123;  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;bad feature info&#x27;</span>);&#125;<span class="hljs-keyword">if</span> (NICE_FEATURE) &#123;  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;nice feature log&#x27;</span>);&#125;<span class="hljs-comment">// 经过压缩后：</span><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;nice feature log&#x27;</span>);</code></pre></div><p>区分服务地址</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&#x27;development&#x27;</span>) &#123;  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;development service url&#x27;</span>);&#125;<span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">&#x27;product&#x27;</span>) &#123;  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;product service url&#x27;</span>);&#125;</code></pre></div><h1 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h1><p>通过上面的例子，我们可以看到 DefinePlugin 就是帮助我们将传入的参数值替换到代码中，通过传入的内容做判断，最后保留下正确的代码片段。可以让我们针对不同环境和不同特性做不同的处理。</p><h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><h1 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h1><p>DllPlugin 是一个 webpack 插件，html-webpack-plugin 可以自动创建 html 文件，也支持使用 html 文件模版。html-webpack-plugin 会自动将所有必要的 css、javascript、manifest 和 favicon 文件注入到生成的 html 文件中。html-webpack-plugin 还提供了 <a href="https://leetcode.cn/link/?target=https://github.com/jantimon/DllPlugin#events">hooks</a> 来扩展功能。已经有很多零配置的插件可以继承进来。<a href="https://leetcode.cn/link/?target=https://github.com/jantimon/DllPlugin">插件列表</a>。</p><h2 id="使用-12"><a href="#使用-12" class="headerlink" title="使用"></a>使用</h2><p>使用下面的例子我们完成使用 DllPlugin 插件自动生成 index.html 文件。</p><p>安装 DllPlugin</p><div class="code-wrapper"><pre><code class="hljs q">npm install DllPlugin --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div><p>index.js</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;DllPlugin&#x27;</span>);</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs lasso">module.exports = &#123;<span class="hljs-params">...</span>  const HtmlWebpackPlugin = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;DllPlugin&#x27;</span>);  entry: &#123;      index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,  &#125;,  output: &#123;    <span class="hljs-params">...</span>    filename: <span class="hljs-string">&#x27;[name]-[hash].js&#x27;</span>  &#125;  plugins: <span class="hljs-meta">[</span>        <span class="hljs-params">...</span>        <span class="hljs-literal">new</span> HtmlWebpackPlugin()    <span class="hljs-meta">]</span>&#125;;</code></pre></div><p>执行打包命令后，在 dist 文件及下可以看到生成了一个 index.html 文件，入口文件 index.js 被编译成 index-[hash].js 文件名的文件，并且在 index-[hash].js 通过 script 标签插入到了 index.html 中。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="title-filename-template"><a href="#title-filename-template" class="headerlink" title="title | filename | template"></a>title | filename | template</h3><p>默认值：Webpack App ｜ ‘index.html’ ｜ ‘’</p><p>值类型：String | String、Function | String</p><p>作用：title 配置项传入的内容会插入到生成的 html 文件的 title 标签中，即 html 文件的标题。filename 配置项传入的内容为生成的 html 文件的名字，默认为 index.html。template 配置项传入的内容为使用的模版 html，如本地存在 index.html 则 DllPlugin 将以本地 index.html 作为模版生成新的 html 文件。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;  ...module: &#123;  loaders: [    &#123; test: <span class="hljs-regexp">/\.hbs$/</span>, loader: <span class="hljs-string">&quot;handlebars-loader&quot;</span> &#125;  ]&#125;,  plugins: [    new HtmlWebpackPlugin(&#123;        <span class="hljs-regexp">//</span> string        filename: <span class="hljs-string">&#x27;index.[contenthash].html&#x27;</span>,        <span class="hljs-regexp">//</span> <span class="hljs-keyword">function</span>        filename: (entryName) =&gt; entryName + <span class="hljs-string">&#x27;-test.html&#x27;</span>,        title: <span class="hljs-string">&#x27;DllPlugin&#x27;</span>,        template: <span class="hljs-string">&#x27;./index.html&#x27;</span>,        <span class="hljs-regexp">//</span> 使用 handlebars-loader 加载器解析 hbs 模版        template: <span class="hljs-string">&#x27;index.hbs&#x27;</span>    &#125;)  ]&#125;;</code></pre></div><p>在使用本地模版并且定义了 title 的情况下，本地模版的 html 文件中的 title 标签要使用下面的写法，生成的 html 文件中 title 才会生效。</p><p>本地 index.html 模版</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="templateContent"><a href="#templateContent" class="headerlink" title="templateContent"></a>templateContent</h3><p>默认值：false</p><p>值类型：string | Function | false</p><p>作用：templateContent 传入内容可作为生成的 html 文件的模版，可替换 template 使用，但是 templateContent 不允许为您的模板使用 webpack 加载器，并且不会监视模板文件的更改。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs xquery"><span class="hljs-keyword">module</span>.exports = &#123;  ...  plugins: [    new HtmlWebpackPlugin(&#123;      title: <span class="hljs-string">&#x27;DllPlugin&#x27;</span>,      templateContent: `          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><span class="language-xml">          </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">          </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml">              </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="language-xml"></span><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span>      `    &#125;)  ]&#125;;</code></pre></div><h3 id="templateParameters"><a href="#templateParameters" class="headerlink" title="templateParameters"></a>templateParameters</h3><p>默认值：false</p><p>值类型：Boolean | Object | Function</p><p>作用：覆盖模板中使用的参数。</p><p>本地 index.html 模版</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&lt;%= foo %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;        template: <span class="hljs-string">&#x27;./index.html&#x27;</span>,        templateParameters: &#123;            <span class="hljs-string">&#x27;foo&#x27;</span>: <span class="hljs-string">&#x27;DllPlugin&#x27;</span>        &#125;,    &#125;)  ]&#125;;</code></pre></div><p>打包成功后，生成的 index.html 文件中的 &lt;%&#x3D; foo %&gt; 被替换成了 ”html-webpack-plugin“。</p><h3 id="inject"><a href="#inject" class="headerlink" title="inject"></a>inject</h3><p>默认值：true</p><p>值类型：Boolean | String</p><p>作用：通过设置 inject 不同的参数，来指定 CSS、JS、manifest 和 favicon 等文件注入到模版文件的位置。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs gradle">module.exports = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;        <span class="hljs-keyword">inject</span>: <span class="hljs-keyword">false</span> <span class="hljs-comment">// 不注入</span>        <span class="hljs-keyword">inject</span>: <span class="hljs-string">&#x27;head&#x27;</span> <span class="hljs-comment">// 注入到 head 标签中</span>        <span class="hljs-keyword">inject</span>: <span class="hljs-string">&#x27;body&#x27;</span> <span class="hljs-comment">// 注入到 body 标签中</span>    &#125;)  ]&#125;;</code></pre></div><h3 id="publicPath-2"><a href="#publicPath-2" class="headerlink" title="publicPath"></a>publicPath</h3><p>默认值：’auto’</p><p>值类型：’auto’ | String</p><p>作用：脚本文件注入到模版中时，增加 publicPath 传入的路径</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;      <span class="hljs-comment">// &lt;script defer src=&quot;/javascript/index-059c24f59da85973176b.js&quot;&gt;&lt;/script&gt;</span>      publicPath: <span class="hljs-string">&#x27;/javascript&#x27;</span>     &#125;)  ]&#125;;</code></pre></div><h3 id="scriptLoading"><a href="#scriptLoading" class="headerlink" title="scriptLoading"></a>scriptLoading</h3><p>默认值：’defer’</p><p>值类型：’blocking’ | ‘defer’ | ‘module’</p><p>作用：现代浏览器支持非阻塞 javascript 加载 (‘defer’) 以提高页面启动性能。传入 scriptLoading 配置可以给 script 标签设置 type 属性。设置为 ‘module’ 添加属性 type&#x3D;”module”</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs xquery"><span class="hljs-keyword">module</span>.exports = &#123;  ...  plugins: [    new HtmlWebpackPlugin(&#123;      scriptLoading: <span class="hljs-string">&#x27;module&#x27;</span> // <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index-059c24f59da85973176b.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>      scriptLoading: <span class="hljs-string">&#x27;defer&#x27;</span> // &lt;script defer src=<span class="hljs-string">&quot;index-059c24f59da85973176b.js&quot;</span>&gt;&lt;/script&gt;      scriptLoading: <span class="hljs-string">&#x27;blocking&#x27;</span> // <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index-059c24f59da85973176b.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>    &#125;)  ]&#125;;</code></pre></div><h3 id="favicon"><a href="#favicon" class="headerlink" title="favicon"></a>favicon</h3><p>默认值：’’</p><p>值类型：String</p><p>作用：将给定的 favicon 路径添加到输出的 HTML 中。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs sas">module.exports = &#123;  ...  plugins: [    new HtmlWebpackPlugi<span class="hljs-meta">n</span>(&#123;      // 生成的 <span class="hljs-keyword">index</span>.html 中增加了 &lt;<span class="hljs-keyword">link</span> rel=<span class="hljs-string">&quot;icon&quot;</span> href=<span class="hljs-string">&quot;headIcon.svg&quot;</span>&gt;      favicon: <span class="hljs-string">&#x27;./src/headIcon.svg&#x27;</span>    &#125;)  ]&#125;;</code></pre></div><h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><p>默认值：{}</p><p>值类型：Object</p><p>作用：允许注入 meta-tags。例如 meta: {viewport: ‘width&#x3D;device-width, initial-scale&#x3D;1, shrink-to-fit&#x3D;no’}</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;  ...  plugins: [    new HtmlWebpackPlugin(&#123;      <span class="hljs-regexp">//</span> 生成的 index.html 中增加了 &lt;meta name=<span class="hljs-string">&quot;keywords&quot;</span> content=<span class="hljs-string">&quot;HTML,CSS,XML,JavaScript&quot;</span>&gt;      meta: &#123;        keywords: <span class="hljs-string">&#x27;HTML,CSS,XML,JavaScript&#x27;</span>      &#125;    &#125;)  ]&#125;;</code></pre></div><h3 id="base-1"><a href="#base-1" class="headerlink" title="base"></a>base</h3><p>默认值：false</p><p>值类型：Object | String | false</p><p>作用：允许注入注入 base 标签</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs roboconf">module.exports = &#123;  ...  <span class="hljs-attribute">plugins</span>: [    new HtmlWebpackPlugin(&#123;      // 生成的 index<span class="hljs-variable">.html</span> 中增加了 &lt;base href=&quot;http://www<span class="hljs-variable">.example</span><span class="hljs-variable">.com</span>/&quot;&gt;      base: &#123;          href: &quot;http://www<span class="hljs-variable">.example</span><span class="hljs-variable">.com</span>/&quot;      &#125;    &#125;)  ]&#125;;</code></pre></div><h3 id="minify"><a href="#minify" class="headerlink" title="minify"></a>minify</h3><p>默认值：mode 是 ‘production’ 为 true，否则为 false</p><p>值类型：Boolean | Object</p><p>作用：是否压缩输出内容，并且以何种方式压缩。当 minify 值为 true，生成的 HTML 将使用 html-minifier-terser 和以下选项进行缩小：</p><div class="code-wrapper"><pre><code class="hljs yaml">&#123;  <span class="hljs-attr">collapseWhitespace:</span> <span class="hljs-literal">true</span>,  <span class="hljs-attr">keepClosingSlash:</span> <span class="hljs-literal">true</span>,  <span class="hljs-attr">removeComments:</span> <span class="hljs-literal">true</span>,  <span class="hljs-attr">removeRedundantAttributes:</span> <span class="hljs-literal">true</span>,  <span class="hljs-attr">removeScriptTypeAttributes:</span> <span class="hljs-literal">true</span>,  <span class="hljs-attr">removeStyleLinkTypeAttributes:</span> <span class="hljs-literal">true</span>,  <span class="hljs-attr">useShortDoctype:</span> <span class="hljs-literal">true</span>&#125;</code></pre></div><p>要使用自定义 <a href="https://leetcode.cn/link/?target=https://github.com/terser/html-minifier-terser#options-quick-reference">html-minifier</a> 选项，请将对象传递给minify。此对象不会与上述默认值合并。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;      minify: <span class="hljs-literal">false</span> <span class="hljs-comment">// 生产环境不做压缩</span>    &#125;)  ]&#125;;</code></pre></div><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>默认值：false</p><p>值类型：Boolean</p><p>作用：如果 hash 值为 true，将哈希值附加到所有包含的脚本和 CSS 文件路径后。这对更新静态文件很有效。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;      <span class="hljs-comment">// 生成的 index.html 中 script 文件地址后面增加了 hash</span>      <span class="hljs-comment">// &lt;script defer src=&quot;index-77c62f233f4dc40c523c.js?77c62f233f4dc40c523c&quot;&gt;&lt;/script&gt;</span>      hash: <span class="hljs-literal">true</span>    &#125;)  ]&#125;;</code></pre></div><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>默认值：true</p><p>值类型：Boolean</p><p>作用：传入参数为 true，将调用 webpack 生成资源方法，传入缓存中之前生成的 html，反之，总是重新编译并更新缓存，调用 webpack 生成资源方法，传入生成的 html。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;      cache: <span class="hljs-literal">false</span>    &#125;)  ]&#125;;</code></pre></div><h3 id="showErrors"><a href="#showErrors" class="headerlink" title="showErrors"></a>showErrors</h3><p>默认值：true</p><p>值类型：Boolean</p><p>作用：将错误信息输出到 html 文件中。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;      showErrors: <span class="hljs-literal">false</span>    &#125;)  ]&#125;;</code></pre></div><h3 id="chunks"><a href="#chunks" class="headerlink" title="chunks"></a>chunks</h3><p>默认值：? | ‘’</p><p>值类型：{?} | {Array.<string>}</p><p>作用：允许生成的 html 文件中包含哪些 chunk。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs sas">module.exports = &#123;    entry: &#123;        <span class="hljs-keyword">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,        main: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>    &#125;,    <span class="hljs-keyword">output</span>: &#123;        path: path.<span class="hljs-meta">resolve</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),         <span class="hljs-keyword">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>    &#125;,    plugins: [        ...        new HtmlWebpackPlugi<span class="hljs-meta">n</span>(&#123;             chunks: [<span class="hljs-string">&#x27;main&#x27;</span>]        &#125;)    ]&#125;;</code></pre></div><p>上面的代码中，我们使用多入口打包，打包后生成 index.js 和 main.js 两个文件，chunks 传入 main，则生成的 html 模版中只插入了 main.js。</p><h3 id="excludeChunks"><a href="#excludeChunks" class="headerlink" title="excludeChunks"></a>excludeChunks</h3><p>默认值：’’</p><p>值类型：{Array.<string>}</p><p>作用：允许生成的 html 文件中不包含哪些 chunk。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;      excludeChunks: [<span class="hljs-string">&#x27;main&#x27;</span>] <span class="hljs-comment">// 生成的 html 文件中没有插入 main.js 文件</span>    &#125;)  ]&#125;;</code></pre></div><h3 id="xhtml"><a href="#xhtml" class="headerlink" title="xhtml"></a>xhtml</h3><p>默认值：false</p><p>值类型：Boolean</p><p>作用：如果传入 xhtml 为 true，则生成的 html 文件兼容 xhtml 规则。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;      xhtml: <span class="hljs-literal">true</span>    &#125;)  ]&#125;;</code></pre></div><h2 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h2><p>DllPlugin 还为其他插件提供了一些 <a href="https://leetcode.cn/link/?target=https://github.com/jantimon/DllPlugin#events">hooks</a>，感兴趣的小伙伴可自行查看。</p><h1 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h1><p>DllPlugin 帮助我们自动生成 html 模版，并且会自动将脚本样式等文件插入到模版，同时又提供了很多配置让我们修改生成的模版，这在项目中将非常实用。</p><h3 id="DllPlugin-1"><a href="#DllPlugin-1" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><h1 id="DllPlugin-2"><a href="#DllPlugin-2" class="headerlink" title="DllPlugin"></a>DllPlugin</h1><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">DllPlugin</span> 和 DllReferencePlugin 用某种方法实现了拆分 bundles，同时还大幅度提升了构建的速度。<span class="hljs-string">&quot;DLL&quot;</span> 一词代表微软最初引入的动态链接库。</code></pre></div><p>通过使用 DllPlugin 可以拆分项目中版本不经常变更的或者包大小比较大的三方依赖。将依赖拆分成单独的 bundles，这样可以提升项目打包速度、减少包体积来加快加载速度。</p><h2 id="使用-13"><a href="#使用-13" class="headerlink" title="使用"></a>使用</h2><p>本章中主要介绍 DllPlugin 的使用及配置，由于需要打包第三方依赖库，所以下面以 lodash 为例。</p><p>安装 lodash</p><div class="code-wrapper"><pre><code class="hljs q">npm install loadsh --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div><p>webpack.config.dll.js</p><p>新建一个 webpack.config.dll.js 文件，用来添加 dll 配置，在执行打包命令之前先生成 dll 文件。</p><div class="code-wrapper"><pre><code class="hljs lua">const webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-built_in">module</span>.exports = &#123;    entry: &#123;        lodash: [<span class="hljs-string">&#x27;lodash&#x27;</span>]    &#125;,    <span class="hljs-built_in">output</span>: &#123;        filename: <span class="hljs-string">&#x27;[name]_dll.js&#x27;</span>,        library: <span class="hljs-string">&quot;[name]&quot;</span>,        <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist/dll&#x27;</span>)    &#125;,    plugins: [        new webpack.DllPlugin(&#123;            context: __dirname,            <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&#x27;dist/dll&#x27;</span>, <span class="hljs-string">&#x27;[name]-mainfest.json&#x27;</span>),            name: <span class="hljs-string">&#x27;[name]&#x27;</span>        &#125;),    ]&#125;</code></pre></div><p>在上面的配置中，entry 为项目入库文件，output 为项目输出文件名称及输出目录。其中要注意的是 output 中的 library 参数，增加 library 配置后 mainfest.json 会暴露 dll 库的全局名称。此参数定义的名称要与 DllPlugin 插件中的 name 属性定义名称一致。</p><p>在命令行执行 npx webpack –config webpack.config.dll.js 命令，打包成功后在 dist 文件下可以看到生成了一个 dll.js 一个 mainfest.json 文件。</p><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><h3 id="context-2"><a href="#context-2" class="headerlink" title="context"></a>context</h3><p>默认值：webpack 的 context</p><p>值类型：String</p><p>作用：生成的 manifest.json 文件中 content 对象中的文件映射地址。</p><p>webpack.config.dll.js</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;  plugins: [    new webpack.DllPlugin(&#123;      <span class="hljs-regexp">//</span> &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;vendors&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:&#123;<span class="hljs-string">&quot;./node_modules/lodash/lodash.js&quot;</span>:&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">486</span>,<span class="hljs-string">&quot;buildMeta&quot;</span>:&#123;&#125;&#125;&#125;&#125;      context: __dirname <span class="hljs-regexp">//</span> 根目录地址      <span class="hljs-regexp">//</span> 下面的 mainfest.json 文件将找不到 lodash.js，映射地址错误      <span class="hljs-regexp">//</span> &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;vendors&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:&#123;<span class="hljs-string">&quot;../node_modules/lodash/lodash.js&quot;</span>:&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">486</span>,<span class="hljs-string">&quot;buildMeta&quot;</span>:&#123;&#125;&#125;&#125;&#125;      <span class="hljs-regexp">//</span> context: <span class="hljs-string">&#x27;src&#x27;</span>    &#125;),  ]&#125;;</code></pre></div><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>默认值：false</p><p>值类型：Boolean</p><p>作用：如果值为 true，生成的 mainfest.json 文件将被格式化。</p><p>webpack.config.dll.js</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;  plugins: [    new webpack.DllPlugin(&#123;      <span class="hljs-regexp">//</span> &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;vendors&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:&#123;<span class="hljs-string">&quot;./node_modules/lodash/lodash.js&quot;</span>:&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">486</span>,<span class="hljs-string">&quot;buildMeta&quot;</span>:&#123;&#125;&#125;&#125;&#125;      format: false,      <span class="hljs-regexp">//</span> &#123;      <span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;vendors&quot;</span>,      <span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;content&quot;</span>: &#123;      <span class="hljs-regexp">//</span>     <span class="hljs-string">&quot;./node_modules/lodash/lodash.js&quot;</span>: &#123;      <span class="hljs-regexp">//</span>       <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">486</span>,      <span class="hljs-regexp">//</span>       <span class="hljs-string">&quot;buildMeta&quot;</span>: &#123;&#125;      <span class="hljs-regexp">//</span>     &#125;      <span class="hljs-regexp">//</span>   &#125;      <span class="hljs-regexp">//</span> &#125;      format: true    &#125;),  ]&#125;;</code></pre></div><h3 id="name-1"><a href="#name-1" class="headerlink" title="name"></a>name</h3><p>默认值：’’</p><p>值类型：String</p><p>作用：生成的 mainfest.json 文件中的 name 属性值。</p><p>webpack.config.dll.js</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;  ...  plugins: [    new webpack.DllPlugin(&#123;      <span class="hljs-regexp">//</span> &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;lodash-name&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:&#123;<span class="hljs-string">&quot;./node_modules/lodash/lodash.js&quot;</span>:&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">486</span>,<span class="hljs-string">&quot;buildMeta&quot;</span>:&#123;&#125;&#125;&#125;&#125;      name: <span class="hljs-string">&quot;lodash-name&quot;</span>    &#125;)  ]&#125;;</code></pre></div><h3 id="path-1"><a href="#path-1" class="headerlink" title="path"></a>path</h3><p>默认值：无（必须）</p><p>值类型：String</p><p>作用：生成 mainfest.json 文件的路径。</p><p>webpack.config.dll.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">webpack</span>.DllPlugin(&#123;      <span class="hljs-comment">// 在根目录的 dist/dll 文件夹下生成 [name]-mainfest.json</span>      path: path.join(__dirname, <span class="hljs-string">&#x27;dist/dll&#x27;</span>, <span class="hljs-string">&#x27;[name]-mainfest.json&#x27;</span>),    &#125;)  ]&#125;;</code></pre></div><h3 id="entryOnly"><a href="#entryOnly" class="headerlink" title="entryOnly"></a>entryOnly</h3><p>默认值：true</p><p>值类型：Boolean</p><p>作用：如果为 true，则仅暴露入口。</p><p>webpack.config.dll.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">DllPlugin</span>(&#123;      entryOnly: <span class="hljs-literal">false</span>    &#125;)  ]&#125;;建议 DllPlugin 只在 entryOnly: <span class="hljs-literal">true</span> 时使用，否则 DLL 中的 tree shaking 将无法工作，因为所有 <span class="hljs-keyword">exports</span> 均可使用。</code></pre></div><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>类型：”var” | “module” | “assign” |”assign-properties” | “this” | “window” | “self” | “global” | “commonjs” | “commonjs2” | “commonjs-module” |”commonjs-static” | “amd” | “amd-require” | “umd” | “umd2” | “jsonp” | “system”</p><p>作用：配置 dll 库暴露的方式。</p><p>webpack.config.dll.js</p><div class="code-wrapper"><pre><code class="hljs ada">module.exports = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> DllPlugin(&#123;      // &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;lodash-name&quot;</span>,<span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;window&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:&#123;<span class="hljs-string">&quot;./node_modules/lodash/lodash.js&quot;</span>:&#123;<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">486</span>,<span class="hljs-string">&quot;buildMeta&quot;</span>:&#123;&#125;&#125;&#125;&#125;      <span class="hljs-keyword">type</span>: <span class="hljs-symbol">&#x27;window</span>&#x27;    &#125;)  ]&#125;;</code></pre></div><h1 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h1><p>此章节演示了 DllPlugin 的用法和包含的配置参数。生成的 dll.js 和 mainfest.json 文件，在下个 DllReferencePlugin 章节来展示如何使用。</p><h3 id="DllReferencePlugin"><a href="#DllReferencePlugin" class="headerlink" title="DllReferencePlugin"></a>DllReferencePlugin</h3><h1 id="DllReferencePlugin-1"><a href="#DllReferencePlugin-1" class="headerlink" title="DllReferencePlugin"></a>DllReferencePlugin</h1><p>在上一章节的 DllPlugin 插件中，DllPlugin 插件会将第三方依赖生成一个 [name]-dll.js 文件和一个 [name]-manifest.json 文件，其中 [name]-dll.js 文件包含第三方依赖所有的源码，[name]-manifest.json 文件包含所有第三方依赖的名称位置和与 [name]-dll.js 映射的索引 ID，执行相应命令生成了 [name]-dll.js 和 [name]-manifest.json 后，就可以执行工程的打包命令。在 webpack 打包过程中，通过 DllReferencePlugin 插件，可以将 [name]-manifest.json 文件中的第三方依赖的映射关系进行解析，当检索到有第三方依赖的映射关系时，会将三方依赖索引 ID 值注入到使用依赖的文件中。如果没有检索到三方依赖映射关系，将去 node_modules 或者项目中查找并将检索内容添加到需要使用依赖的文件中。</p><h2 id="使用-14"><a href="#使用-14" class="headerlink" title="使用"></a>使用</h2><p>index.js</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-type">name</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./main.js&#x27;</span>;console.log(_.<span class="hljs-keyword">join</span>([<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>], <span class="hljs-string">&#x27;-&#x27;</span>))console.log(<span class="hljs-type">name</span>);</code></pre></div><p>main.js</p><div class="code-wrapper"><pre><code class="hljs delphi"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">&#x27;dll&#x27;</span>;</code></pre></div><p>webpack.config.dll.js</p><div class="code-wrapper"><pre><code class="hljs lua">const webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-built_in">module</span>.exports = &#123;    entry: &#123;        vendors: [<span class="hljs-string">&#x27;lodash&#x27;</span>, <span class="hljs-string">&#x27;./src/main.js&#x27;</span>],    &#125;,    <span class="hljs-built_in">output</span>: &#123;        filename: <span class="hljs-string">&#x27;[name]-dll.js&#x27;</span>,        library: <span class="hljs-string">&quot;[name]&quot;</span>,        <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist/dll&#x27;</span>)    &#125;,    plugins: [        new webpack.DllPlugin(&#123;            context: __dirname,            <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&#x27;dist/dll&#x27;</span>, <span class="hljs-string">&#x27;[name]-manifest.json&#x27;</span>),            name: <span class="hljs-string">&#x27;[name]&#x27;</span>,            <span class="hljs-built_in">format</span>: <span class="hljs-literal">true</span>        &#125;),    ]&#125;</code></pre></div><p>在上面的配置中，将 lodash 和本地 main.js 生成 dll 文件。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,    <span class="hljs-attr">entry</span>: &#123;        <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,    &#125;,    <span class="hljs-attr">output</span>: &#123;        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),         <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>    &#125;,    <span class="hljs-attr">plugins</span>: [        <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DllReferencePlugin</span>(&#123;            <span class="hljs-comment">// 对动态链接库的文件内容的描述或者映射关系，非 dll 本身</span>            <span class="hljs-attr">manifest</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./dist/dll/vendors-manifest.json&#x27;</span>),        &#125;)    ]&#125;</code></pre></div><p>在 webpack.config.js 的 DllReferencePlugin 插件中引入 DllPlugin 插件生成的 manifest.json 文件。执行 npm run build 打包命令。我们看下生成的 index.js 文件内容。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655707974-pZSKII-1.png" alt="1.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655708324-MmeVkB-2.png" alt="2.png"></p><p>从上面的截图我们可以看到 DllReferencePlugin 插件解析了 manifest.json 中的第三方依赖对应的映射关系，将 ID 值传入到 index.js 的方法中，我们接下来需要手动将 dll&#x2F;vendors-dll.js 通过 <code>&lt;script&gt;</code> 标签添加到 index.html 中。vendors-dll.js 文件中包含第三方依赖的代码和 manifest.json 中的 ID 值，index.js 中通过加载 ID 值来使用第三方依赖方法。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Webpack App<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./dll/vendors-dll.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>在浏览器中打开 index.html 文件，在控制台可以看到输出的内容，main.js 和 lodash 方法均可正常使用。</p><p>DllReferencePlugin 在解析 manifest.json 文件时，虽然 manifest.json 包含多个第三方依赖的映射关系，但是插件会根据 index.js 中的引用来注入对应的代码。即当 index.js 中只引用了 main.js 文件时，打包后生成的 index.js 文件则只包含 main.js 的映射关系。在实际的项目中，就可以将不常改动的第三方依赖打包成 dll，将 dll 的链接通过 CDN 等方式引入到项目中，这样可以减少主包的大小，加快打包速度。</p><div class="code-wrapper"><pre><code class="hljs delphi">注意：[<span class="hljs-keyword">name</span>]-dll.js 可以通过插件动态插入到 <span class="hljs-keyword">index</span>.html，小伙伴儿可自行查阅。</code></pre></div><h2 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h2><h3 id="context-3"><a href="#context-3" class="headerlink" title="context"></a>context</h3><p>类型：String</p><p>默认值：webpack 的 context</p><p>作用：(绝对路径) manifest 中请求的上下文。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;  plugins: [    new webpack.DllReferencePlugin(&#123;      ...      context: __dirname <span class="hljs-regexp">//</span> 根目录地址      <span class="hljs-regexp">//</span> 下面的配置会在 dist 文件夹下查找 manifest 的地址，当找不到 manifest.json 文件时，会将依赖代码打包到 bundle.js 中      <span class="hljs-regexp">//</span> path.resolve(__dirname, <span class="hljs-string">&quot;dist&quot;</span>)    &#125;),  ]&#125;;</code></pre></div><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655709393-wsvekM-4.png" alt="4.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655709393-nMFiXo-3.png" alt="3.png"></p><h3 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h3><p>类型：String</p><p>作用：用于加载 manifest.json 路径。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">webpack</span>.DllReferencePlugin(&#123;      <span class="hljs-comment">// 动态链接库的文件内容</span>      manifest: require(<span class="hljs-string">&#x27;./dist/dll/vendors-manifest.json&#x27;</span>),    &#125;),  ]&#125;;</code></pre></div><h3 id="name-2"><a href="#name-2" class="headerlink" title="name"></a>name</h3><p>类型：String</p><p>默认值：manifest.json 的 name 属性。</p><p>作用：[name]-dll.js 暴露的全局变量方法名称，将 manifest.json 中的 索引 ID 传入全局方法中，可返回对应模块方法。</p><p>index.js</p><p>其中的 vendors(225)，vendors 为 dll 暴露的全局变量，225 为 manifest.json 中 main.js 依赖的 ID 索引值。</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-type">name</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./main.js&#x27;</span>;console.log(_.<span class="hljs-keyword">join</span>([<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>], <span class="hljs-string">&#x27;-&#x27;</span>))console.log(vendors(<span class="hljs-number">225</span>));console.log(vendors(<span class="hljs-number">225</span>).plugin);</code></pre></div><p>main.js</p><div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> plugin = <span class="hljs-string">&#x27;dll&#x27;</span>;</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">webpack</span>.DllReferencePlugin(&#123;      ...      name: <span class="hljs-string">&#x27;vendors&#x27;</span>    &#125;)  ]&#125;;</code></pre></div><p>打包成功后，控制台打开 dist&#x2F;index.html，可以看到 输出了 hello-world、 main.js 模块代码和 main.js 代码中的 plugin 变量。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655708137-OwpPBR-5.png" alt="5.png"></p><h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>类型：Object</p><p>默认值：manifest.json 的 content 属性。</p><p>作用：传入请求依赖到模块 ID 的映射关系。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">webpack</span>.DllReferencePlugin(&#123;      content: &#123;        <span class="hljs-string">&quot;./src/main.js&quot;</span>: &#123;          <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">225</span>,          <span class="hljs-string">&quot;exports&quot;</span>: [            <span class="hljs-string">&quot;plugin&quot;</span>          ]        &#125;,      &#125;    &#125;)  ]&#125;;</code></pre></div><h3 id="sourceType"><a href="#sourceType" class="headerlink" title="sourceType"></a>sourceType</h3><p>类型：”var” | “assign” | “this” | “window” | “global” | “commonjs” | “commonjs2” | “commonjs-module” | “amd” | “amd-require” | “umd” | “umd2” | “jsonp” | “system”</p><p>作用：dll 中的模块代码以哪种模式暴露给外部调用 <a href="https://leetcode.cn/link/?target=https://webpack.js.org/configuration/output/#outputlibrarytype">output.library.type</a></p><p>index.js</p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> &#123; <span class="hljs-type">name</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./main.js&#x27;</span>;console.log(<span class="hljs-keyword">window</span>.vendors(<span class="hljs-number">225</span>));</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;      ...      sourceType: <span class="hljs-string">&#x27;window&#x27;</span>    &#125;)  ]&#125;;</code></pre></div><h1 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h1><p>此章节演示了 DllReferencePlugin 的用法和包含的配置参数。DllReferencePlugin 通过解析 manifest.json 将依赖的映射索引注入到需要的依赖中。通过将不常变动的依赖打包成 dll 的方式，可以减少 bundle 的大小，同时能加快打包速度。</p><h3 id="MiniCssExtractPlugin"><a href="#MiniCssExtractPlugin" class="headerlink" title="MiniCssExtractPlugin"></a>MiniCssExtractPlugin</h3><h1 id="MiniCssExtractPlugin-1"><a href="#MiniCssExtractPlugin-1" class="headerlink" title="MiniCssExtractPlugin"></a>MiniCssExtractPlugin</h1><p>MiniCssExtractPlugin 插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件。这个插件需要在 webpack 5 中才能正常工作，webpack 4 中使用 extract-text-webpack-plugin 插件做 CSS 分离。之前的文章中我们介绍了 style-loader 的使用，style-loader 是将 JS 中包含的 CSS 内容以 <code>&lt;style&gt;</code> 标签的形式插入到 DOM 中，而 MiniCssExtractPlugin 插件则是将 JS 中包含的 CSS 创建一个新的文件，并且以 <code>&lt;link&gt;</code> 标签的形式插入链接到加载依赖的文件中。MiniCssExtractPlugin 作用与 style-loader 类似，但是实现方式却完全不同。MiniCssExtractPlugin 一般与 css-loader 同时使用。</p><div class="code-wrapper"><pre><code class="hljs autohotkey">注意：下面【使用】模块的案例，index.css 分离是 MiniCssExtractPlugin 做的，而通过 `&lt;link&gt;` 标签插入index.html 是 HtmlWebpackPlugin 插件做的，MiniCssExtractPlugin 插件可以将非入口文件通过 `&lt;link&gt;` 标签插入到加载依赖的文件中，即 MiniCssExtractPlugin 插入 `&lt;link&gt;` 仅适用于非初始（异步）块。</code></pre></div><h2 id="使用-15"><a href="#使用-15" class="headerlink" title="使用"></a>使用</h2><p>index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;<span class="hljs-keyword">import</span> main <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./main.css&quot;</span>;<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;demo&quot;</span>;divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>;<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div><p>index.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;    <span class="hljs-attribute">color</span>: red;&#125;</code></pre></div><p>main.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;&#125;</code></pre></div><p>安装 mini-css-extract-plugin</p><div class="code-wrapper"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>mini-css-<span class="hljs-keyword">extract-plugin </span>-D</code></pre></div><p>安装成功后，将 mini-css-extract-plugin 配置到 webpack.config.js 的 plugins 和 module 中。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs javascript">...<span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    ...    <span class="hljs-attr">module</span>: &#123;        <span class="hljs-attr">rules</span>: [          &#123;            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>,            <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],          &#125;,        ],    &#125;,    <span class="hljs-attr">plugins</span>: [        ...        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>()    ]&#125;</code></pre></div><p>我们在入口文件 index.js 中导入了 main.css 和 index.css 两个样式文件。一个改变字体，一个改变字体颜色。执行打包命令，可以看到在 dist 文件夹下除了 index.js 和 index.html 文件之外还生成了一个 index.css 文件。index.css 文件中包含 main.css 和 index.css 的内容。在 index.html 中通过 <code>&lt;link&gt;</code> 标签的形式引入了 index.css 文件。在浏览器中打开 dist&#x2F;index.html 可以看到样式被正常展示。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132739-yLUVon-1.png" alt="1.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132739-bWqEsK-2.png" alt="2.png"></p><p>上面的例子中在 index.js 中导入了两个样式文件，接下来我们试一下在入口文件 index.js 中导入 main.js 和 index.css，其中 main.js 中导入 main.css。其他配置保持不变。</p><p>index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> mainElement &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./main&#x27;</span>;<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;demo&quot;</span>;divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>;divElement.<span class="hljs-title function_">appendChild</span>(mainElement);<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div><p>main.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> main <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./main.css&quot;</span>;<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;demo-main&quot;</span>;divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;demo-main&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> divElement;</code></pre></div><p>main.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo-main</span> &#123;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;&#125;</code></pre></div><p>执行打包命令后，dist 文件夹下依然只有 index.html，index.js，index.css 文件。查看后发现虽然在 main.js 中导入的 main.css，但由于 main.js 被 index.js 依赖。所以 css 文件内容依然都打包到了 index.css 中。</p><h2 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h2><p>MiniCssExtractPlugin 包含两部分配置，plugin 配置和 loader 配置。</p><h3 id="Plugin-Options"><a href="#Plugin-Options" class="headerlink" title="Plugin Options"></a>Plugin Options</h3><h4 id="filename-1"><a href="#filename-1" class="headerlink" title="filename"></a>filename</h4><p>类型：string | ((pathData: PathData, assetInfo?: AssetInfo) &#x3D;&gt; string);</p><p>默认值：[name].css</p><p>作用：输出的 css 文件的名称，默认为 chunkName 值。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;  plugins: [    new MiniCssExtractPlugin(&#123;      ...       filename: <span class="hljs-string">&#x27;[name].css&#x27;</span> <span class="hljs-regexp">//</span> index.css      <span class="hljs-regexp">//</span>  filename: (pathData) =&gt; &#123;      <span class="hljs-regexp">//</span>     return pathData.hash + <span class="hljs-string">&#x27;-index.css&#x27;</span>;      <span class="hljs-regexp">//</span>  &#125;, <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>de455759e47e7f4d53b-index.css    &#125;),  ]&#125;;</code></pre></div><h4 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h4><p>类型：string | ((pathData: PathData, assetInfo?: AssetInfo) &#x3D;&gt; string);</p><p>默认值：基于 filename</p><p>作用：修改非入口文件的打包后的名称。</p><p>index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;<span class="hljs-comment">// 将 main.js 打包到单独文件</span><span class="hljs-keyword">const</span> mainElement = <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;main&quot; */</span> <span class="hljs-string">&#x27;./main&#x27;</span>);...</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;      chunkFilename: <span class="hljs-string">&#x27;chunk-[id].css&#x27;</span>, <span class="hljs-comment">// chunk-main.css</span>    &#125;),  ]&#125;;</code></pre></div><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132739-gWZpeT-3.png" alt="3.png"></p><p>打开 dist 我们可以看到 main.js 文件已经单独打包，并且生成了一个 chunk-name.css 文件。</p><h4 id="ignoreOrder"><a href="#ignoreOrder" class="headerlink" title="ignoreOrder"></a>ignoreOrder</h4><p>类型：boolean</p><p>默认值：false</p><p>作用：模块中加载 css 文件顺序不一致是否发出警告，例如：1.js 中加载 css 的顺序是 a.css、b.css，2.js 中加载顺序是 b.css、a.css，就会发出警告，详细可看下官网 <a href="https://leetcode.cn/link/?target=https://github.com/webpack-contrib/mini-css-extract-plugin/issues/250">issue</a></p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;      ignoreOrder: <span class="hljs-literal">false</span>,    &#125;)  ]&#125;;</code></pre></div><h4 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h4><p>类型：string | ((linkTag: HTMLLinkElement) &#x3D;&gt; void)</p><p>默认值：document.head.appendChild(linkTag)，即默认插入到 DOM 文件的 head 中</p><p>作用：打包的 CSS 文件，通过 <code>&lt;link&gt;</code> 标签插入的位置。</p><p>index.js</p><div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> styles from <span class="hljs-string">&quot;./index.css&quot;</span>;<span class="hljs-keyword">const</span> divElement = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<span class="hljs-comment">// import 方法导入的模块为异步加载</span><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;main&quot; */</span> <span class="hljs-string">&#x27;./main&#x27;</span>).then(res =&gt; &#123;  divElement.appendChild(res.<span class="hljs-keyword">default</span>)&#125;);divElement.className = <span class="hljs-string">&quot;demo&quot;</span>;divElement.innerHTML = <span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>;<span class="hljs-built_in">document</span>.body.appendChild(divElement);</code></pre></div><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml">...<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div-element&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;      insert: <span class="hljs-string">&#x27;#div-element&#x27;</span>    &#125;)  ]&#125;;</code></pre></div><p>执行打包命令后，在 dist&#x2F;index.html 文件中，只包含了 index.css 的 <code>&lt;link&gt;</code> 标签，在浏览器中运行 index.html，在控制台可以看到 chunk-main.css 的 <code>&lt;link&gt;</code> 标签被插入到选择器为 <code>#div-element</code> 元素的后面。在生成的 index.js 文件中可以看到创建 link 标签的源码。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132739-xZlArH-5.png" alt="5.png"><br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132739-jgrsql-6.png" alt="6.png"></p><h4 id="attributes-1"><a href="#attributes-1" class="headerlink" title="attributes"></a>attributes</h4><p>类型：object</p><p>默认值：{}</p><p>作用：在 <code>&lt;link&gt;</code> 标签中添加属性</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs llvm"><span class="hljs-keyword">module</span>.exports <span class="hljs-operator">=</span> &#123;  ...<span class="hljs-symbol">  plugins:</span> [    ...    new MiniCssExtractPlugin(&#123;<span class="hljs-symbol">        attributes:</span> &#123;            <span class="hljs-string">&quot;data-target&quot;</span>: <span class="hljs-string">&quot;data&quot;</span> // &lt;link data-<span class="hljs-keyword">target</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;data&quot;</span> rel<span class="hljs-operator">=</span><span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-keyword">type</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;text/css&quot;</span> href<span class="hljs-operator">=</span><span class="hljs-string">&quot;.../dist/main.css&quot;</span>&gt;        &#125;<span class="hljs-punctuation">,</span>    &#125;)  ]&#125;<span class="hljs-comment">;</span></code></pre></div><h4 id="linkType"><a href="#linkType" class="headerlink" title="linkType"></a>linkType</h4><p>类型：string | boolean</p><p>默认值：text&#x2F;css</p><p>作用：修改 <code>&lt;link&gt;</code> 标签中 type 属性，type 的默认值为 text&#x2F;css。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;  ...  plugins: [    ...    new MiniCssExtractPlugin(&#123;        linkType: <span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-regexp">//</span> &lt;link type=<span class="hljs-string">&quot;text/css&quot;</span> ...&gt;        <span class="hljs-regexp">//</span> linkType: false <span class="hljs-regexp">//</span> &lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> href=<span class="hljs-string">&quot;.../dist/main.css&quot;</span>&gt;    &#125;)  ]&#125;;</code></pre></div><h4 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h4><p>类型：boolean</p><p>默认值：true</p><p>作用：允许启用&#x2F;禁用运行时生成。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  plugins: [    ...    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>(&#123;        runtime: <span class="hljs-literal">false</span> <span class="hljs-comment">// 运行 index.html 时，main.css 不会被插入到 DOM 中。</span>    &#125;)  ]&#125;;</code></pre></div><h3 id="Loader-Options"><a href="#Loader-Options" class="headerlink" title="Loader Options"></a>Loader Options</h3><h4 id="publicPath-3"><a href="#publicPath-3" class="headerlink" title="publicPath"></a>publicPath</h4><p>类型：string | ((resourcePath: string, rootContext: string) &#x3D;&gt; string)</p><p>默认值：webpackOptions.output 选项的值</p><p>作用：输出的 CSS 文件中，为图像、文件等外部资源指定自定义公共路径。</p><p>main.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo-main</span> &#123;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">./img/1.png</span>);&#125;</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;  ...  module: &#123;        rules: [          &#123;            test: <span class="hljs-regexp">/\.css$/i</span>,            use: [                &#123;                    loader: MiniCssExtractPlugin.loader,                    options: &#123;                      publicPath: <span class="hljs-string">&quot;/public/path/to/&quot;</span>, <span class="hljs-regexp">//</span> main.css background: url(<span class="hljs-regexp">/public/</span>path<span class="hljs-regexp">/to/</span>e30cb9c395cbb5ae00e9.png);                    &#125;,                &#125;, <span class="hljs-string">&quot;css-loader&quot;</span>],          &#125;,        ],    &#125;,&#125;;</code></pre></div><p>打包成功后，查看生成的 main.css 文件，background 地址已经被替换成传入的 publicPath，通过传入 publicPath 可以引用外部资源。</p><h4 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h4><p>类型：boolean</p><p>默认值：true</p><p>作用：提取的 CSS 是否生成对应文件。当 emit 值为 true 会生成 CSS 文件，值为 false 不生成 CSS 文件。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>  ...<span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        rules:</span> [          <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">            test:</span> /\.css$/i,<span class="hljs-symbol">            use:</span> [                <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">                    loader:</span> MiniCssExtractPlugin.loader,<span class="hljs-symbol">                    options:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">                      emit:</span> false, <span class="hljs-comment">// 打包后的 dist 中没有生成 index.css 和 main.css，运行 index.html 样式不生效</span>                    <span class="hljs-punctuation">&#125;</span>,                <span class="hljs-punctuation">&#125;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],          <span class="hljs-punctuation">&#125;</span>,        ],    <span class="hljs-punctuation">&#125;</span>,<span class="hljs-punctuation">&#125;;</span></code></pre></div><h4 id="esModule-4"><a href="#esModule-4" class="headerlink" title="esModule"></a>esModule</h4><p>类型：boolean</p><p>默认值：true</p><p>作用：生成的文件是否使用 ES 模块语法，开启 ES 语法对 tree-shaking 将非常有用。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs dts">module.<span class="hljs-attr">exports</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span>  ...<span class="hljs-symbol">  module:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">        rules:</span> [          <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">            test:</span> /\.css$/i,<span class="hljs-symbol">            use:</span> [                <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">                    loader:</span> MiniCssExtractPlugin.loader,<span class="hljs-symbol">                    options:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-symbol">                      esModule:</span> false, <span class="hljs-comment">// 启用CommonJS 语法</span>                    <span class="hljs-punctuation">&#125;</span>,                <span class="hljs-punctuation">&#125;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],          <span class="hljs-punctuation">&#125;</span>,        ],    <span class="hljs-punctuation">&#125;</span>,<span class="hljs-punctuation">&#125;;</span></code></pre></div><h1 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h1><p>此章节演示了 MiniCssExtractPlugin 的用法和包含的配置参数。MiniCssExtractPlugin 还有一些推荐的例子，感兴趣的同学可查看<a href="https://leetcode.cn/link/?target=https://www.npmjs.com/package/mini-css-extract-plugin">官方</a>。</p><h3 id="WebpackManifestPlugin"><a href="#WebpackManifestPlugin" class="headerlink" title="WebpackManifestPlugin"></a>WebpackManifestPlugin</h3><h1 id="WebpackManifestPlugin-1"><a href="#WebpackManifestPlugin-1" class="headerlink" title="WebpackManifestPlugin"></a>WebpackManifestPlugin</h1><p>WebpackManifestPlugin 是一个 webpack 插件，此插件的作用是生成资产清单即 manifest.json 文件，在使用此插件前，我们先看下什么是 manifest 以及 manifest 的作用，以下引自 webpack 官网。</p><blockquote><p>一旦你的应用在浏览器中以 index.html 文件的形式被打开，一些 bundle 和应用需要的各种资源都需要用某种方式被加载与链接起来。在经过打包、压缩、&gt;为延迟加载而拆分为细小的 chunk 这些 webpack 优化 之后，你精心安排的 &#x2F;src 目录的文件结构都已经不再存在。所以 webpack 如何管理所有所需模 &gt;块之间的交互呢？这就是 manifest 数据用途的由来……</p></blockquote><p>总结来说，manifest.json 就是记录项目中生成的 bundle 之间的映射关系。有了这份清单，我们可以通过特定的方法加载资源，如服务端渲染或通过遍历 manifest.json 将记录输出到页面上等。在当前流行的微前端框架中，通过引入不同子项目的 manifest.json 文件，并遍历文件内容动态输出到 DOM 中，从而实现加载不同子项目工程，这会比手动获取子项目资源清单减少出错概率和省事的多。</p><h2 id="使用-16"><a href="#使用-16" class="headerlink" title="使用"></a>使用</h2><p>index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./index.css&quot;</span>;<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&quot;demo&quot;</span>;divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;webpack-manifest-plugin&#x27;</span>;<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div><p>index.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;    <span class="hljs-attribute">color</span>: red;    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">./img/1.png</span>);&#125;</code></pre></div><p>安装 webpack-manifest-plugin</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> webpack-manifest-plugin -D</code></pre></div><p>安装成功后，将 webpack-manifest-plugin 配置到 webpack.config.js 的 plugins 中。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs lasso"><span class="hljs-params">...</span>const &#123; WebpackManifestPlugin &#125; = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;webpack-manifest-plugin&#x27;</span>);module.exports = &#123;    <span class="hljs-params">...</span>    plugins: <span class="hljs-meta">[</span>        <span class="hljs-params">...</span>        <span class="hljs-literal">new</span> WebpackManifestPlugin(&#123;            publicPath: <span class="hljs-string">&#x27;./&#x27;</span>        &#125;)    <span class="hljs-meta">]</span>&#125;</code></pre></div><p>我们在 index.js 文件中创建了一个 div 标签，在 index.css 中设置了 div 标签的字体颜色和背景图片，此时执行打包命令，打包成功后在 dist 中可以看到除了项目资源文件外还有一个 manifest.json 文件。打开 manifest.json 文件看下内容。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132966-dqklgB-1.png" alt="1.png"></p><p>manifest.json 包含了资源的映射关系，我们需要遍历 manifest.json 对象的内容，将需要的如 js 资源通过 createElement 等方式挂载到 index.html 中项目即可正常使用。</p><h2 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h2><p>以下为包含部分常用配置，全部配置可查看<a href="https://leetcode.cn/link/?target=https://github.com/shellscape/webpack-manifest-plugin">官网</a></p><h3 id="basePath"><a href="#basePath" class="headerlink" title="basePath"></a>basePath</h3><p>类型：String</p><p>默认值：’’</p><p>作用：生成的 manifest.json 文件中，basePath 参数传入的值将添加到对象的 key 值前面。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;  plugins: [    new WebpackManifestPlugin(&#123;      ...      basePath: <span class="hljs-string">&#x27;src&#x27;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;src/index.js&quot;</span>: <span class="hljs-string">&quot;.../index.js&quot;</span>,      basePath: <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;index.js&quot;</span>: <span class="hljs-string">&quot;.../index.js&quot;</span>,    &#125;),  ]&#125;;</code></pre></div><h3 id="fileName"><a href="#fileName" class="headerlink" title="fileName"></a>fileName</h3><p>类型：String</p><p>默认值：manifest.json</p><p>作用：fileName 传入的值作为输出的文件清单的名称。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebpackManifestPlugin</span>(&#123;        fileName: <span class="hljs-string">&#x27;manifest-filename.json&#x27;</span> <span class="hljs-comment">// manifest.json -&gt; manifest-filename.json</span>    &#125;)  ]&#125;;</code></pre></div><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>类型：(file: FileDescriptor) &#x3D;&gt; Boolean</p><p>默认值：undefined</p><p>作用：执行 filter 回调函数，返回 true 则 manifest.json 中包含 bundle 的映射关系，返回 false 则不包含此 bundle 映射关系。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs coffeescript">module.<span class="hljs-built_in">exports</span> = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> WebpackManifestPlugin(&#123;      filter: <span class="hljs-function"><span class="hljs-params">(file)</span> =&gt;</span> &#123;          <span class="hljs-keyword">return</span> file?.name?.endsWith(<span class="hljs-string">&#x27;.js&#x27;</span>) <span class="hljs-regexp">//</span> manifest.json 中只包含 js 拓展名的文件      &#125;    &#125;)  ]&#125;;</code></pre></div><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132966-mPOfFh-2.png" alt="2.png"></p><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>类型：(seed: Object, files: FileDescriptor[], entries: string[]) &#x3D;&gt; Object</p><p>默认值：undefined</p><p>作用：自定义修改生成的 manifest.json 中的键值对内容，generate 传入的函数返回值需要为对象。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs arcade">module.exports = &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> WebpackManifestPlugin(&#123;      <span class="hljs-attr">generate</span>: <span class="hljs-function">(<span class="hljs-params">seed, files, entries</span>) =&gt;</span> &#123;          <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(seed, <span class="hljs-string">&#x27;seed&#x27;</span>)          <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(files, <span class="hljs-string">&#x27;files&#x27;</span>)          <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(entries, <span class="hljs-string">&#x27;entries&#x27;</span>)          <span class="hljs-keyword">return</span> &#123; <span class="hljs-string">&#x27;main-index&#x27;</span>: <span class="hljs-string">&#x27;index.js&#x27;</span> &#125;      &#125;    &#125;) <span class="hljs-comment">// manifest.json 中内容 &#123; &quot;main-index&quot;: &quot;index.js&quot; &#125;</span>  ]&#125;;</code></pre></div><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>类型：(file: FileDescriptor) &#x3D;&gt; FileDescriptor</p><p>默认值：undefined</p><p>作用：自定义修改生成的 manifest.json 中的键值对内容。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs sas">module.exports = &#123;  ...  plugins: [    ...    new WebpackManifestPlugi<span class="hljs-meta">n</span>(&#123;        map: (<span class="hljs-keyword">file</span>) =&gt; &#123;            const <span class="hljs-keyword">fileName</span> = <span class="hljs-keyword">file</span>?.name;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">file</span>?.name?.endsWith(<span class="hljs-string">&#x27;.js&#x27;</span>)) &#123;                <span class="hljs-keyword">file</span>.name = <span class="hljs-string">&#x27;assets.&#x27;</span> + <span class="hljs-keyword">fileName</span>            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">file</span>        &#125;    &#125;)     // &#123; <span class="hljs-string">&quot;assets.main.js&quot;</span>: <span class="hljs-string">&quot;auto/main.js&quot;</span> ... &#125;  ]&#125;;</code></pre></div><h3 id="publicPath-4"><a href="#publicPath-4" class="headerlink" title="publicPath"></a>publicPath</h3><p>类型：String</p><p>默认值：webpack.config.js 中的 output.publicPath 值</p><p>作用：publicPath 传入的内容将添加到 manifest.json 对象的值前面。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs awk">module.exports = &#123;  ...  plugins: [    ...     new WebpackManifestPlugin(&#123;        <span class="hljs-regexp">//</span> &#123;        <span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;index.js&quot;</span>: <span class="hljs-string">&quot;./dist-public/index.js&quot;</span>,        <span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;1.png&quot;</span>: <span class="hljs-string">&quot;./dist-public/2b2001bb98465dd14a87.png&quot;</span>,        <span class="hljs-regexp">//</span>   <span class="hljs-string">&quot;index.html&quot;</span>: <span class="hljs-string">&quot;./dist-public/index.html&quot;</span>        <span class="hljs-regexp">//</span> &#125;        publicPath: <span class="hljs-string">&#x27;./dist-public&#x27;</span>        &#125;)  ]&#125;;</code></pre></div><h3 id="serialize"><a href="#serialize" class="headerlink" title="serialize"></a>serialize</h3><p>类型：(Object) &#x3D;&gt; string</p><p>默认值：undefined</p><p>作用：格式化 manifest.json 中的内容。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs coffeescript">module.<span class="hljs-built_in">exports</span> = &#123;  ...  plugins: [    ...    <span class="hljs-keyword">new</span> WebpackManifestPlugin(&#123;        serialize: <span class="hljs-function"><span class="hljs-params">(obj)</span> =&gt;</span> &#123;            console.log(obj)            <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(obj) <span class="hljs-regexp">//</span> &#123;<span class="hljs-string">&quot;index.js&quot;</span>:<span class="hljs-string">&quot;auto/index.js&quot;</span>,<span class="hljs-string">&quot;1.png&quot;</span>:<span class="hljs-string">&quot;auto/2b2001bb98465dd14a87.png&quot;</span>,<span class="hljs-string">&quot;index.html&quot;</span>:<span class="hljs-string">&quot;auto/index.html&quot;</span>&#125;        &#125;    &#125;)  ]&#125;;</code></pre></div><h1 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h1><p>此章节演示了 WebpackManifestPlugin 的用法和包含的部分常用配置参数，通过 WebpackManifestPlugin 生成的资源清单可以让我们在项目中快速找到引用的依赖文件路径，这对于服务端渲染或微前端等将非常有用。</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><h1 id="开发环境调优"><a href="#开发环境调优" class="headerlink" title="开发环境调优"></a>开发环境调优</h1><p>在之前的章节中我们介绍了 Webpack 的基础配置，一些 Loader 和 Plugin 的使用方法，到此我们应该对 Webpack 有了一定的认识，Webpack 作为打包工具的重要使命之一就是提升效率，下面我们介绍一些对日常开发有一定帮助的 Webpack 插件、配置。</p><ul><li><p>source map</p></li><li><p>插件介绍</p></li><li><p>使用 webpack-dev-server</p></li><li><p>模块热替换</p></li></ul><h2 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h2><p>Webpack 打包编译后的代码基本不具备可读性，工程发布或启动后此时若代码跑出一个错误，想要回溯它的调用栈是非常困难的。而有了 source map 在加上浏览器的调试工具，要做到追踪错误和警告就容易的多了。source map 指的是将编译、打包、压缩等操作后的代码映射回原文件的过程。开发环境通过 source map 我们可以直接看到源代码调试，生产环境通过 source map 我们可以通过工具回溯到报错的代码位置。为我们进一步分析错误提供了便利。</p><p>在开发环境即 mode 选项设置为 development 模式下，Webpack 将自动生成映射文件，source map 除了将 Javascript 映射回原文件外，还同样适用于样式文件。</p><h3 id="source-map-配置"><a href="#source-map-配置" class="headerlink" title="source map 配置"></a>source map 配置</h3><p>Javascript 的 source map 通过配置项 devtool 来启用，只要在 webpack.config.js 中添加 devtool 即可。</p><p>index.js</p><div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> divElement = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);divElement.className = <span class="hljs-string">&quot;demo&quot;</span>;divElement.innerHTML = <span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>;<span class="hljs-built_in">document</span>.body.appendChild(divElement);</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">const</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;    <span class="hljs-comment">// ...</span>    devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>,&#125;</code></pre></div><p>对于 CSS、SCSS、Less 来说，需要在 loader 中添加 source map 配置。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    <span class="hljs-comment">// ...</span>     <span class="hljs-attr">module</span>: &#123;        <span class="hljs-attr">rules</span>: [            &#123;            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(css)$/</span>,            <span class="hljs-attr">use</span>: [                <span class="hljs-string">&#x27;style-loader&#x27;</span>,                &#123;                    <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;css-loader&#x27;</span>,                    <span class="hljs-attr">options</span>: &#123;                        <span class="hljs-attr">sourceMap</span>: <span class="hljs-literal">true</span>                    &#125;                &#125;              ]            &#125;        ]    &#125;,&#125;</code></pre></div><p>打包后，在 dist 文件夹下除了 index.js 外还生成了一个 index.js.map 文件。在生成 mapping 文件的同时，还为 index.js 添加了一个引用注释，以便开发工具知道在哪里可以找到它。</p><p>dist&#x2F;index.js</p><div class="code-wrapper"><pre><code class="hljs awk">(<span class="hljs-keyword">function</span>() &#123;  <span class="hljs-regexp">//</span> 内容&#125;)();<span class="hljs-regexp">//</span><span class="hljs-comment"># sourceMappingURL=index.js.map</span></code></pre></div><p>当我们打开浏览器的开发者工具时，map 文件会同时被加载，这时浏览器会使用它来对打包后的 bundle 进行解析。分析出源码的内容。当我们打断点进行调试时，可以直接调试源码。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133154-bhTBwe-1.png" alt="1.png"></p><h3 id="source-map-分类"><a href="#source-map-分类" class="headerlink" title="source map 分类"></a>source map 分类</h3><p>Webpack 支持的 source map 大概分为两种，inline（内连） 和 separate（独立）两种方式。inline 类型即生成的映射关系内容保存在 bundle 中不生成单独的文件，separate 类型即可生成单独的 map 文件可以独立使用。source map 支持类型很多，下面只介绍其中几种，详细信息可官网查看，<a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/configuration/devtool">source map官网</a></p><h4 id="inline-source-map-类型"><a href="#inline-source-map-类型" class="headerlink" title="inline source map 类型"></a>inline source map 类型</h4><p>Webpack 提供了多种内联映射文件类型。通常 eval 是起点，因为它是速度和质量之间的良好折衷，同时在 Chrome 和 Firefox 浏览器中可以可靠地工作。下面我们介绍两个内连类型的例子。</p><div class="code-wrapper"><pre><code class="hljs stylus">注意：为了查看效果我们去掉 webpack<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span> 中的 mode 配置。</code></pre></div><h5 id="devtool-“eval”"><a href="#devtool-“eval”" class="headerlink" title="devtool: “eval”"></a>devtool: “eval”</h5><p>eval生成代码，其中每个模块都包装在一个eval函数中。并且都包含 &#x2F;&#x2F;# sourceURL，此选项会非常快的构建。</p><div class="code-wrapper"><pre><code class="hljs coffeescript">(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;var __webpack_modules__=&#123;  <span class="hljs-number">138</span>:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;    <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;const divElement = document.createElement(&quot;div&quot;);\ndivElement.className = &quot;demo&quot;;\ndivElement.innerHTML = \&#x27;mini-css-extract-plugin\&#x27;;\ndocument.body.appendChild(divElement);\n\n//# sourceURL=webpack://6.1/./src/index.js?&#x27;</span>)  &#125;&#125;,__webpack_exports__=&#123;&#125;;__webpack_modules__[<span class="hljs-number">138</span>]()&#125;)();</code></pre></div><h5 id="devtool-“eval-source-map”"><a href="#devtool-“eval-source-map”" class="headerlink" title="devtool: “eval-source-map”"></a>devtool: “eval-source-map”</h5><p>每个模块使用 eval() 执行，并且 source map 转换为 DataUrl 后添加到 eval() 中。初始化 source map 时比较慢，但是会在重新构建时提供比较快的速度，并且生成实际的文件。</p><div class="code-wrapper"><pre><code class="hljs coffeescript">(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>  &#123;var __webpack_modules__=&#123;    <span class="hljs-number">138</span>: <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;      <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;const divElement = document.createElement(&quot;div&quot;);\ndivElement.className = &quot;demo&quot;;\ndivElement.innerHTML = \&#x27;mini-css-extract-plugin\&#x27;;\ndocument.body.appendChild(divElement);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vNi4xLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZGl2RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5kaXZFbGVtZW50LmNsYXNzTmFtZSA9IFwiZGVtb1wiO1xuZGl2RWxlbWVudC5pbm5lckhUTUwgPSAnbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4nO1xuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXZFbGVtZW50KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///138\n&#x27;</span>)  &#125;&#125;,__webpack_exports__=&#123;&#125;;__webpack_modules__[<span class="hljs-number">138</span>]()&#125;)();</code></pre></div><h4 id="separate-source-map-类型"><a href="#separate-source-map-类型" class="headerlink" title="separate source map 类型"></a>separate source map 类型</h4><p>Webpack 提供了多种独立映射文件类型。我们常用的为 source-map 类型，source-map 类型可以生成单独的 map 文件，有了 source map 也就意味着任何人都可以通过浏览器调试工具看到工程源码，这对于安全性来说有了极大隐患。那么如何能保证线上问题可以追踪又能防止源码泄漏，Webpack 提供了 hidden-source-map 和 nosources-source-map 两种策略来提升 source map 的安全性。</p><h5 id="devtool-“hidden-source-map”"><a href="#devtool-“hidden-source-map”" class="headerlink" title="devtool: “hidden-source-map”"></a>devtool: “hidden-source-map”</h5><p>hidden-source-map 与 source-map 作用相同都会生成一个 map 文件，唯一区别是不会为 bundle 添加引用注释。我们在浏览器中直接打开工程，是看不到原文件的，生成的 map 文件只是作为我们追踪错误信息的依据。</p><div class="code-wrapper"><pre><code class="hljs dart">(()=&gt;&#123;<span class="hljs-keyword">const</span> e=<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);e.className=<span class="hljs-string">&quot;demo&quot;</span>,e.innerHTML=<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>,<span class="hljs-built_in">document</span>.body.appendChild(e)&#125;)();警告：你不应将 source map 文件部署到 web 服务器。而是只将其用于错误报告工具。</code></pre></div><h5 id="devtool-“nosources-source-map”"><a href="#devtool-“nosources-source-map”" class="headerlink" title="devtool: “nosources-source-map”"></a>devtool: “nosources-source-map”</h5><p>nosources-source-map 创建的 source map 不包含 sourcesContent(源代码内容)。虽然在 bundle 中增加了 &#x2F;&#x2F;# sourceMappingURL，但是当我们在浏览器中打开源码文件时是看不到源码内容的。</p><p>index.js</p><div class="code-wrapper"><pre><code class="hljs dart">(()=&gt;&#123;<span class="hljs-keyword">const</span> e=<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);e.className=<span class="hljs-string">&quot;demo&quot;</span>,e.innerHTML=<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>,<span class="hljs-built_in">document</span>.body.appendChild(e)&#125;)();<span class="hljs-comment">//# sourceMappingURL=index.js.map</span>这仍然会暴露反编译后的文件名和结构，但它不会暴露原始代码。</code></pre></div><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658132966-mPOfFh-2-1674980279528150.png" alt="2.png"><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133154-IlbFXK-2.png" alt="2.png"></p><h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p>Webpack 拥有非常强大的生态系统，社区中相关的工具也是数不胜数，这里我们介绍两个项目中常用的插件，可以节省开发效率和减少我们操作步骤。</p><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>html-webpack-plugin 可以自动创建 html 文件，也支持使用 html 文件模版。html-webpack-plugin 会自动将所有必要的 css、javascript、manifest 和 favicon 文件注入到生成的 html 文件中。之前在 5.2 章节做过 html-webpack-plugin 的介绍，所以这里不在详细介绍。</p><p>安装 html-webpack-plugin</p><div class="code-wrapper"><pre><code class="hljs css">npm install <span class="hljs-selector-tag">html</span>-webpack-plugin <span class="hljs-attr">--save-dev</span></code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">const</span> <span class="hljs-variable">HtmlWebpackPlugin</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;...  plugins: [        ...        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>()    ]&#125;;</code></pre></div><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>clean-webpack-plugin 插件用于在每次构建工程时清除上次构建生成的文件，有了这个插件我们再也不用手动清除构建目录了。</p><p>安装 clean-webpack-plugin</p><div class="code-wrapper"><pre><code class="hljs q">npm install clean-webpack-plugin --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;...  <span class="hljs-attr">plugins</span>: [        ...        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>()    ]&#125;;</code></pre></div><h2 id="使用-webpack-dev-server"><a href="#使用-webpack-dev-server" class="headerlink" title="使用 webpack-dev-server"></a>使用 webpack-dev-server</h2><p>在之前的案例中，我们一直都是更改代码后执行打包命令，然后手动去打包文件中打开 html 文件查看效果，这种方式在实际的项目发开中会增加很多额外的重复工作，并且打包后的内容需要发布到服务上才能被其他伙伴访问。为了提升开发效率，在构建代码并部署到生产环境之前，我们需要一个本地环境，用于运行我们开发的代码。这个环境相当于提供了一个简单的服务器，用于访问 webpack 构建好的静态文件，我们日常开发时可以使用它来调试前端代码。webpack-dev-server 可以很好的帮我们解决这个需求，webpack-dev-server 是 webpack 官方提供的一个工具，可以基于当前的 webpack 构建配置快速启动一个静态服务。当 mode 为 development 时，会具备 hot reload 的功能，即当源码文件变化时，会即时更新当前页面，以便我们实时看到效果。webpack-dev-server 仅应用于开发环境。下面简单介绍下 <a href="https://leetcode.cn/link/?target=https://github.com/webpack/webpack-dev-server#readme">webpack-dev-server</a> 的使用，详细配置可查看官网。</p><p>安装</p><div class="code-wrapper"><pre><code class="hljs axapta">npm install webpack-dev-<span class="hljs-keyword">server</span> -D</code></pre></div><p>package.json 中增加 scripts</p><div class="code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;  <span class="hljs-string">...</span>  <span class="hljs-string">&quot;serve&quot;</span>: <span class="hljs-string">&quot;webpack serve&quot;</span>&#125;,</code></pre></div><p>配置成功后，命令行执行 npm run serve，项目启动成功并在控制台输出了网址，打开此网址即可运行我们现有代码。当我们修改 index.js 内容时页面会自动刷新。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133154-wZhRjN-3.png" alt="3.png"></p><h2 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h2><p>当项目功能体量很大页面元素较多时，使用 webpack-dev-server 实现页面整体刷新会影响开发体验，这时我们会考虑使用模块热替换。</p><p>模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。HMR 功能会在应用程序运行过程中，替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：</p><ul><li>重新加载页面期间保留应用程序状态。</li><li>只更新变更部分内容，节省开发时间。</li><li>在源代码 CSS&#x2F;JS 内容产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。</li></ul><h3 id="使用-HMR"><a href="#使用-HMR" class="headerlink" title="使用 HMR"></a>使用 HMR</h3><p>HMR 是 Webpack 内置的插件，我们可以通过 webpack-dev-server 配置来开启 HMR。</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;    ...    devServer: &#123;        hot: <span class="hljs-literal">true</span>,    &#125;&#125;</code></pre></div><p>上面的配置产生的结果是 Webpack 为每个模块绑定一个 module.hot 对象，这个对象可以调用 HMR 的 API。通过这些 API 我们可以对特定模块开启或关闭热替换。</p><p>index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> a + b;&#125;;<span class="hljs-keyword">const</span> addRes = <span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);divElement.<span class="hljs-property">innerHTML</span> = addRes;<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>) &#123;  <span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">accept</span>()&#125;</code></pre></div><p>启动项目后可以在页面上看到结果 8，当修改 add 函数中的参数时，页面上 8 并没有清空，HMR 会使应用在当前浏览器环境下又执行来一遍 index.js (包括其依赖的模块)内容，但是页面本身并没有刷新。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133154-debqqW-4.png" alt="4.png"></p><p>调用 HMR API 可以如上面例子中手动调用，我们还可以借助现成的工具去调用，如 react-hot-loader、vue-loader 等。喜欢的小伙伴可以自行研究。</p><h1 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h1><p>本章我们介绍了 Webpack 开发环境下的常用的配置和插件以及如何使用 HMR。篇幅有限只写了些项目中用到的，Webpack 周边实用插件很多，感兴趣的小伙伴儿可以选择一些去使用一下，这对于了解 Webpack 也会有很大帮助。</p><h3 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h3><h1 id="生产环境调优"><a href="#生产环境调优" class="headerlink" title="生产环境调优"></a>生产环境调优</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>在实际的项目中，我们经常会有区分环境的需求，如本地环境、测试环境、生产环境。不同的环境往往对应一些不同的配置，如 mode、环境变量等，如何通过 webpack 按照不同环境采用不同配置呢？一般有以下两种方式。</p><p>1、使用同一个配置文件，不同环境传入不同变量来控制配置</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java">...<span class="hljs-type">const</span> <span class="hljs-variable">NODE_ENV</span> <span class="hljs-operator">=</span> process.env.NODE_ENV;<span class="hljs-type">const</span> <span class="hljs-variable">isDev</span> <span class="hljs-operator">=</span> NODE_ENV === <span class="hljs-string">&#x27;development&#x27;</span>;<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;    mode: NODE_ENV,    devtool: isDev ? <span class="hljs-string">&#x27;source-map&#x27;</span> : <span class="hljs-string">&#x27;inline-source-map&#x27;</span>,    ...&#125;</code></pre></div><p>package.json</p><div class="code-wrapper"><pre><code class="hljs awk">&#123;  ...  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;    <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;NODE_ENV=development webpack&quot;</span>, <span class="hljs-regexp">//</span> 开发环境    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;NODE_ENV=production webpack&quot;</span> <span class="hljs-regexp">//</span> 生产环境  &#125;&#125;</code></pre></div><p>上面的配置中，通过在 package.json 中修改 NPM Scripts，传入 NODE_ENV 变量。开发环境参数值为 development，生产环境参数值为 production。在 webpack 配置文件中使用 Node.js 的 process 对象获取传入的参数。执行 npm run dev 即执行开发环境配置，生成的打包文件中包含 source map 文件同时 index.js 中包含 source map 映射路径。执行 npm run build 同理执行生产环境配置，生成的打包文件中 index.js 文件不包含 source map 映射路径。至此我们成功的区分了不同环境。</p><p>2、为不同环境创建各自的配置文件</p><p>生产环境创建一个 prod.config.js 文件，开发环境配置一个 dev.config.js 文件，修改 package.json 中的 scripts，不同命令执行不同的配置文件。</p><p>prod.config.js</p><div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-built_in">module</span>.exports = &#123;  mode: <span class="hljs-string">&#x27;production&#x27;</span>,  devtool: <span class="hljs-string">&#x27;hidden-source-map&#x27;</span>,  entry: &#123;    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,  &#125;,  <span class="hljs-built_in">output</span>: &#123;    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,  &#125;,&#125;</code></pre></div><p>dev.config.js</p><div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-built_in">module</span>.exports = &#123;  mode: <span class="hljs-string">&#x27;development&#x27;</span>,  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>,  entry: &#123;    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,  &#125;,  <span class="hljs-built_in">output</span>: &#123;    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,  &#125;,&#125;</code></pre></div><p>package.json</p><div class="code-wrapper"><pre><code class="hljs awk">&#123;  ...  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;    <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack --config=dev.config.js&quot;</span>, <span class="hljs-regexp">//</span> 开发环境    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --config=prod.config.js&quot;</span> <span class="hljs-regexp">//</span> 生产环境  &#125;&#125;</code></pre></div><p>上面的两个配置文件中，项目入口出口都一样，只有打包模式和 source map 模式不同，分别执行 npm run dev 和 npm run build 可以看到生成文件内容不同。对于需要多种环境配置的文件中，我们可以将环境中共用的部分如入口、出口等配置提取出来放在一个公共配置中，将公共配置提取到 common.config.js 中，个性化配置放在不同环境对应的配置中，通过 webpack-merge 插件将配置组合起来。下面以生产环境配置为例。</p><p>prod.config.js</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">commonConfig</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;./common.config.js&#x27;</span>);<span class="hljs-keyword">const</span> &#123; merge &#125; = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);module.exports = <span class="hljs-title function_ invoke__">merge</span>(commonConfig, &#123;  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;production&#x27;</span>,  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;hidden-source-map&#x27;</span>&#125;);</code></pre></div><p>common.config.js</p><div class="code-wrapper"><pre><code class="hljs lua">...<span class="hljs-built_in">module</span>.exports = &#123;  entry: &#123;    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,  &#125;,  <span class="hljs-built_in">output</span>: &#123;    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,  &#125;,  ...&#125;;</code></pre></div><p>执行打包命令后查看输出文件，可以看到输出内容与单独配置无异。</p><h2 id="区分环境变量"><a href="#区分环境变量" class="headerlink" title="区分环境变量"></a>区分环境变量</h2><p>通常我们需要为生产环境和本地环境添加不同的环境变量，在 Webpack 中可以使用 DefinePlugin 进行设置，在 5.1 章节我们已经对 DefinePlugin 配置做过详细的介绍，所以下面我们只加一个区分服务地址的配置。</p><p>prod.config.js</p><div class="code-wrapper"><pre><code class="hljs lasso"><span class="hljs-params">...</span>const webpack = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);module.exports = &#123;   <span class="hljs-params">...</span>    plugins: <span class="hljs-meta">[</span>        <span class="hljs-params">...</span>        <span class="hljs-literal">new</span> webpack.DefinePlugin(&#123;            BASE_URL: <span class="hljs-string">&#x27;http://ip:8201&#x27;</span>        &#125;)    <span class="hljs-meta">]</span>&#125;</code></pre></div><p>dev.config.js</p><div class="code-wrapper"><pre><code class="hljs lasso"><span class="hljs-params">...</span>const webpack = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);module.exports = &#123;   <span class="hljs-params">...</span>    plugins: <span class="hljs-meta">[</span>        <span class="hljs-params">...</span>        <span class="hljs-literal">new</span> webpack.DefinePlugin(&#123;            BASE_URL: <span class="hljs-string">&#x27;http://localhost:8201&#x27;</span>        &#125;)    <span class="hljs-meta">]</span>&#125;</code></pre></div><p>index.js</p><div class="code-wrapper"><pre><code class="hljs arcade">...<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(BASE_URL)</code></pre></div><p>执行不同环境的打包命令，即可区分不同的服务地址。</p><h2 id="资源压缩"><a href="#资源压缩" class="headerlink" title="资源压缩"></a>资源压缩</h2><p>在将项目资源发布到线上环境前，我们通常会进行代码压缩，或者叫 uglify，意思是移除空格并混淆代码，一般在压缩后代码体积会变小同时代码变得不可读，在一定程度上增加了安全性。</p><h3 id="压缩-JavaScript"><a href="#压缩-JavaScript" class="headerlink" title="压缩 JavaScript"></a>压缩 JavaScript</h3><p>Webpack 5 中已经集成了 terser-webpack-plugin 来压缩我们的代码，当我们在 webapck.config.js 中 mode 设置为 production 时，打包后的代码会被压缩。如果想自定义添加压缩配置，我们需要安装 <a href="https://leetcode.cn/link/?target=https://www.npmjs.com/package/terser-webpack-plugin">terser-webpack-plugin</a>，下面以删除代码中 console.log 为例。</p><p>安装 terser-webpack-plugin</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> terser-webpack-plugin -D</code></pre></div><p>prod.config.js</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TerserPlugin</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;terser-webpack-plugin&#x27;</span>);...module.exports = <span class="hljs-title function_ invoke__">merge</span>(commonConfig, &#123;  ...  <span class="hljs-attr">optimization</span>: &#123;    // 在不设置 mode 的情况下，minimize 设置为 <span class="hljs-literal">true</span> 也会开启压缩    // <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">minimizer</span>: [      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>(&#123;        <span class="hljs-attr">terserOptions</span>: &#123;          <span class="hljs-attr">compress</span>: &#123;            <span class="hljs-attr">pure_funcs</span>: [<span class="hljs-string">&#x27;console.log&#x27;</span>],          &#125;,        &#125;,      &#125;),    ],  &#125;,&#125;);</code></pre></div><p>index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;   <span class="hljs-keyword">return</span> a + b&#125;<span class="hljs-keyword">const</span> addRes = <span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>);<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);divElement.<span class="hljs-property">innerHTML</span> = addRes;<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(addRes);</code></pre></div><p>执行打包命令后，可以看到生成的 bundle 文件中已经移除了 console.log 代码。</p><h3 id="压缩-CSS"><a href="#压缩-CSS" class="headerlink" title="压缩 CSS"></a>压缩 CSS</h3><p>在压缩 CSS 文件之前，我们要先使用 MiniCssExtractPlugin 插件将样式文件提取出来，接着使用 <a href="https://leetcode.cn/link/?target=https://github.com/webpack-contrib/css-minimizer-webpack-plugin">css-minimizer-webpack-plugin</a> 插件进行压缩。</p><p>css-minimizer-webpack-plugin 插件开启压缩的配置方式也是传入到 minimizer 中，与 terser-webpack-plugin 类似，只是传入压缩插件本身的配置不同。</p><p>安装 css-minimizer-webpack-plugin</p><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> css-minimizer-webpack-plugin -D</code></pre></div><p>prod.config.js</p><div class="code-wrapper"><pre><code class="hljs php">...<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MiniCssExtractPlugin</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CssMinimizerPlugin</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;css-minimizer-webpack-plugin&#x27;</span>);module.exports = <span class="hljs-title function_ invoke__">merge</span>(commonConfig, &#123;  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;hidden-source-map&#x27;</span>,  <span class="hljs-attr">module</span>: &#123;    <span class="hljs-attr">rules</span>: [      &#123;        <span class="hljs-attr">test</span>: /\.css$/i,        <span class="hljs-attr">use</span>: [          &#123;            <span class="hljs-attr">loader</span>: MiniCssExtractPlugin.loader,            <span class="hljs-attr">options</span>: &#123;              <span class="hljs-attr">esModule</span>: <span class="hljs-literal">true</span>,            &#125;,          &#125;,          <span class="hljs-string">&#x27;css-loader&#x27;</span>,        ],      &#125;,    ],  &#125;,  <span class="hljs-attr">optimization</span>: &#123;    <span class="hljs-attr">minimizer</span>: [      <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>(),    ],  &#125;,  plugins: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>()],&#125;);</code></pre></div><p>index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;demo&#x27;</span>;divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;demo&#x27;</span>;<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div><p>index.css</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;    <span class="hljs-attribute">color</span>: red;&#125;</code></pre></div><p>执行 npm run build，可以看到打包文件中的 index.css 文件内容已被压缩。</p><h2 id="资源体积监控"><a href="#资源体积监控" class="headerlink" title="资源体积监控"></a>资源体积监控</h2><p>在实际的项目开发中，webpack 打包的体积速度往往是我们比较关注的问题，我们可以通过打包后输出文件包的大小来分析每个模块的体积，但这种反向分析往往会花费很多时间。VS Code 中有一个插件 Import Cost 可以帮助我们持续监控引入模块（主要是node_module中的模块）的大小。它会为我们计算该模块压缩后及 gzip 后将占多大体积。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658308914-XbQYTe-1.png" alt="1.png"></p><p>当我们发现某些包过大就可以采取一些措施，比如 lodash 中只引入使用到的子模块。</p><p>另外一个很有用的工具是 <a href="https://leetcode.cn/link/?target=https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a>，它能帮助我们分析 bundle 的构成，webpack-bundle-analyzer 可以帮我们生成一张 bundle 的模块组成结构图，每个模块所占的体积一目了然。</p><p>安装 webpack-bundle-analyzer</p><div class="code-wrapper"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>webpack-<span class="hljs-keyword">bundle-analyzer </span>-D</code></pre></div><p>prod.config.js</p><div class="code-wrapper"><pre><code class="hljs java">...<span class="hljs-type">const</span> <span class="hljs-variable">BundleAnalyzerPlugin</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&#x27;webpack-bundle-analyzer&#x27;</span>).BundleAnalyzerPlugin;<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = merge(commonConfig, &#123;  ...  plugins: [    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>()  ]&#125;);</code></pre></div><p>执行打包命令后，浏览器中会启动 bundle 组成结构图，包括各模块体积。</p><p>最后我们还可以自动化的对资源体积进行监控，<a href="https://leetcode.cn/link/?target=https://github.com/siddharthkp/bundlesize">bundlesize</a> 可以帮我们做到这一点。</p><p>安装 bundlesize</p><div class="code-wrapper"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span><span class="hljs-keyword">bundlesize </span>-D</code></pre></div><p>package.json</p><div class="code-wrapper"><pre><code class="hljs prolog">&#123;  ...  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;    <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;bundlesize&quot;</span>,    <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack --config dev.config.js&quot;</span>,    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack  --config prod.config.js&quot;</span>  &#125;,  <span class="hljs-string">&quot;bundlesize&quot;</span>: [    &#123;      <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;./dist/index.js&quot;</span>,      <span class="hljs-string">&quot;maxSize&quot;</span>: <span class="hljs-string">&quot;1 kB&quot;</span>    &#125;  ],&#125;</code></pre></div><p>执行 npm test 控制台中可以看到检测结果。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658308914-tVnWpa-2.png" alt="2.png"></p><h1 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h1><p>本章我们介绍了在生产环境下可以做哪些配置。我们介绍了使用配置文件区分环境、传入不同环境变量、如何开启压缩并且如何做自定义压缩、监控输出资源体积等方法。对于使用的插件都只是简单介绍了如何使用，详细的配置可以参照官网。</p><h3 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h3><h1 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h1><p>所谓 tree-shaking 就是 “摇树” 的意思，可以将应用程序想象成一棵树。绿色表示实际用到的 source code(源码) 和 library(库)，是树上活的树叶。灰色表示未引用代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。</p><div class="code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">tree</span> shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-<span class="hljs-meta">code</span>)。它依赖于 ES2015 模块语法的静态结构特性，例如 <span class="hljs-meta">import</span> 和 <span class="hljs-meta">export</span>。这个术语和概念实际上是由 ES2015 模块打包工具 rollup 普及起来的。<span class="hljs-symbol">webpack</span> <span class="hljs-number">2</span> 正式版本内置支持 ES2015 模块（也叫做 harmony modules）和未使用模块检测能力。新的 webpack <span class="hljs-number">4</span> 正式版本扩展了此检测能力，通过 package.json 的 <span class="hljs-string">&quot;sideEffects&quot;</span> 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 <span class="hljs-string">&quot;pure(纯正 ES2015 模块)&quot;</span>，由此可以安全地删除文件中未使用的部分。</code></pre></div><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>tree shaking 会在编译过程中将未使用的代码进行标记，在 uglify 时移除被标记的无效代码，在 mode 设置为 production 时，webpack 会开启压缩和 tree-shaking 等优化，下面的例子如果配置为生产模式，打包后未使用的引用会被移除掉。</p><p>1、将 mode 设置为 none（不使用任何打包优化），optimization 配置中增加 usedExports 。</p><p>index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// add 只是导入没有使用</span><span class="hljs-keyword">import</span> &#123; add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./util.js&#x27;</span>;<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);divElement.<span class="hljs-property">innerHTML</span> = addRes;divElement.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;demo&#x27;</span>;<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div><p>util.js</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 导出 add 函数<span class="hljs-keyword">export</span> const add = <span class="hljs-function"><span class="hljs-params">(a, b)</span> =&gt;</span> &#123;   <span class="hljs-keyword">return</span> a + b&#125;</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java">...<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  mode: <span class="hljs-string">&#x27;none&#x27;</span>, <span class="hljs-comment">// 不使用任何默认优化选项</span>  optimization: &#123;    <span class="hljs-comment">// 告诉 Webpack 去决定每一个模块所用到的导出</span>    usedExports: <span class="hljs-literal">true</span>,  &#125;,&#125;;</code></pre></div><p>执行打包命令后，查看 dist&#x2F;index.js 中的代码。可以看到 index.js 中只做了导入但是没有调用的方法 add 被打了 unused harmony export 的注释。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133349-fQAuwK-1.png" alt="1.png"><br>2、package.json 中增加 sideEffects: false</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;sideEffects&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span></code></pre></div><p>webpack.config.js 中移除 optimization 配置，index.js 与 util.js 中内容不变，执行打包命令后，可以看到打包后的 index.js 中 add 函数已经被移除。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133349-VbRkfR-2.png" alt="2.png"></p><h2 id="sideEffects-与-usedExports"><a href="#sideEffects-与-usedExports" class="headerlink" title="sideEffects 与 usedExports"></a>sideEffects 与 usedExports</h2><p>在了解上面两个参数区别之前，我们先来看下函数的副作用。</p><div class="code-wrapper"><pre><code class="hljs">函数副作用是指函数在正常工作任务之外对外部环境所施加的影响。具体地说，函数副作用是指函数被调用，完成了函数既定的计算任务，但同时因为访问了外部数据，尤其是因为对外部数据进行了写操作，从而一定程度地改变了系统环境。</code></pre></div><p>在上面例子中我们在 index.js 中导入的 util.js 中导出了一个 add 函数，我们来看下这个函数。</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">export</span> const add = <span class="hljs-function"><span class="hljs-params">(a, b)</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> a + b&#125;</code></pre></div><p>add 函数中接收了 a 和 b 两个参数，函数体中返回了 a 与 b 的和，此函数返回的结果只依赖于传入的值并且没有其他影响，如修改全局变量等操作，则此函数即为无副作用函数。</p><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">export</span> const add = <span class="hljs-function"><span class="hljs-params">(a, b)</span> =&gt;</span> &#123;  window.userName = <span class="hljs-string">&#x27;***&#x27;</span>  <span class="hljs-keyword">return</span> a + b&#125;</code></pre></div><p>上面的 add 函数除了返回了 a 与 b 的和的同时还修改了 window对象中属性的值，则此函数即为有副作用的函数。</p><p>简单了解了函数副作用，我们来看下 sideEffects 和 usedExports（更多被认为是 tree shaking）的两种不同的优化方式。</p><ul><li>usedExports 依赖于 terser 去检测语句中的副作用，对未使用的函数增加标记，之后交由压缩工具去移除死代码。</li></ul><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java">...<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  ...  mode: <span class="hljs-string">&#x27;none&#x27;</span>, <span class="hljs-comment">// 不使用任何默认优化选项</span>  optimization: &#123;    <span class="hljs-comment">// 告诉 Webpack 去决定每一个模块所用到的导出</span>    usedExports: <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 开启压缩</span>    minimize: <span class="hljs-literal">true</span>  &#125;,&#125;;</code></pre></div><p>index.js 与 util.js 内容保持不变，在 webpack.config.js 的 optimization 配置中增加参数 minimize 为 true，打包成功后查看输出文件，可以看到之前被打了 unused harmony export 注释的代码被移除掉了。</p><p>下面我们来写一个带有副作用的方法，看看 usedExports 会如何处理。</p><p>index.js</p><div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./util.js&#x27;</span>;<span class="hljs-keyword">const</span> divElement = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);divElement.innerHTML = <span class="hljs-string">&#x27;demo&#x27;</span>;divElement.className = <span class="hljs-string">&#x27;demo&#x27;</span>;<span class="hljs-built_in">document</span>.body.appendChild(divElement);</code></pre></div><p>util.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">custom</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;custom&#x27;</span>);&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> a + b;&#125;;</code></pre></div><p>util.js 中修在 Array 原型链上增加了方法，所以是 util.js 是有副作用的，在 index.js 中我们不只导入 add 方法而是导入整个 util.js 文件，执行打包命令后可以查看 dist&#x2F;index.js 文件中 add 方法已被删除，有副作用的部分依然在打包文件中。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133349-ptzduw-3.png" alt="3.png"></p><ul><li>sideEffects 更为有效 是因为它允许跳过整个模块&#x2F;文件和整个文件子树</li></ul><p>在一个纯粹的 ESM 模块世界中，很容易识别出哪些文件有副作用。然而，我们的项目无法达到这种纯度，所以，此时有必要提示 webpack compiler 哪些代码是“纯粹部分”。</p><p>通过 package.json 的 “sideEffects” 属性，来实现这种方式。如果所有代码都不包含副作用，我们就可以将 sideEffects 标记为 false，来告诉 webpack 它可以跳过安全检测删除未用到的 export。</p><p>依然使用上面包含副作用的代码。来看下增加 sideEffects: false 的效果。</p><p>package.json</p><div class="code-wrapper"><pre><code class="hljs jboss-cli">&#123;  <span class="hljs-string">//</span> <span class="hljs-string">...</span>  <span class="hljs-string">&quot;sideEffects&quot;</span>: <span class="hljs-literal">false</span>,  <span class="hljs-string">//</span> <span class="hljs-string">...</span>&#125;</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-built_in">module</span>.exports = &#123;  mode: <span class="hljs-string">&#x27;none&#x27;</span>,  entry: &#123;    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,  &#125;,  <span class="hljs-built_in">output</span>: &#123;    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,  &#125;&#125;;</code></pre></div><p>执行打包命令后查看 dist&#x2F;index.js 文件，可以看到包含副作用的代码也被移除，即 util.js 导入部分被全部移除。</p><p>项目中包含副作用的函数被移除在打包后会导致部分功能不可用，所以 sideEffects 支持传入参数，告知 webpack 传入的文件包含副作用不要移除。</p><p>上面的例子中修改 package.json 的配置，将包含副作用的文件传入进去。此数组支持简单的 glob 模式匹配相关文件。其内部使用了 glob-to-regexp（支持：*，**，{a,b}，[a-z]）。如果匹配模式为 *.css，且不包含 &#x2F;，将被视为 **&#x2F;*.css。</p><p>package.json</p><div class="code-wrapper"><pre><code class="hljs awk">&#123; <span class="hljs-regexp">//</span> ...  <span class="hljs-string">&quot;sideEffects&quot;</span>: [<span class="hljs-string">&quot;./src/util.js&quot;</span> ],  <span class="hljs-regexp">//</span> ...&#125;</code></pre></div><p>执行打包命令后查看输出文件，可以看到只有导入但是没使用的 add 函数和 Array 方法都被保留了下来。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133349-FHjQKm-4.png" alt="4.png"></p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="tree-shaking-开启条件"><a href="#tree-shaking-开启条件" class="headerlink" title="tree shaking 开启条件"></a>tree shaking 开启条件</h2><p>tree shaking 需要使用 ES2015 模块语法（即 import 和 export）才能生效，有时我们会发现只引用了某个库中的一个方法，却把整个库都加载进来了，同时 bundle 的体积也并没有因为 tree shaking 而减少。这可能是该库不是使用 ESModule 模式导出的，所以在使用某个库时，我们尽量引入 es 版，按需加载，这样 tree shaking 才能将无用代码删除掉。</p><h1 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a>总结</h1><p>为了利用 tree shaking 的优势， 我们必须</p><ul><li>使用 ES2015 模块语法（即 import 和 export）。</li><li>确保没有编译器将您的 ES2015 模块语法转换为 CommonJS 的（顺带一提，这是现在常用的 @babel&#x2F;preset-env 的默认行为，详细信息请参阅文档）。</li><li>在项目的 package.json 文件中，添加 “sideEffects” 属性。</li><li>使用 mode 为 “production” 的配置项以启用更多优化项，包括压缩代码与 tree shaking。</li></ul><h1 id="代码分离及懒加载"><a href="#代码分离及懒加载" class="headerlink" title="代码分离及懒加载"></a>代码分离及懒加载</h1><p>前端性能优化一直是围绕在每一个前端周围的话题，减少网络请求、减少加载 bundle 体积、外部资源放在 CDN 等等。对于性能优化 webpack 也提供了一些手段。下面让我们来了解下代码分离、缓存和懒加载。</p><h2 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h2><p>代码分离是 webpack 最引人注目的特性之一，试想如果项目中所有代码都打包到一个 bundle 中，那 bundle 的体积将会变大，这对首次访问页面来说，加载资源的请求时间会变长，将影响用户体验。所以前端性能优化的一个方向是将代码按照一定规则拆分到不同的 bundle 中，触发不同的功能加载不同的资源，这样除了减少资源体积外还能增快请求响应速度。不过拆分的粒度大小还是要看实际的项目需求，无限拆分资源包也会造成资源请求过多。所以对于代码分离我们要结合项目情况合理使用，这会极大影响加载时间。</p><p>常用的代码分离方法有三种：</p><ul><li><p>入口分离：使用 entry 配置手动地分离代码。</p></li><li><p>去重分离：使用 Entry dependencies 或者 SplitChunksPlugin 去重和分离 chunk。</p></li><li><p>动态导入：通过模块的内联函数调用来分离代码。</p></li></ul><h3 id="入口分离"><a href="#入口分离" class="headerlink" title="入口分离"></a>入口分离</h3><p>入口分离即从 webpack 入口文件配置处分离 bundle。这种分离方式根据项目的多个入口拆分出多个 bundle，这是所有分离方式中最简单的分离方式，不过这种方式也存在弊端即 输出的 bundle 会同时包含导入的三方依赖代码（重复代码），在后面的分离方式讲解中会解决这个问题。我们先来看看入口分离的例子。</p><p>src&#x2F;index.js</p><p>index.js 文件中引入依赖包 lodash 的 join 方法。创建 div 标签并将内容添加到 body 中。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; join &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-title function_">join</span>([<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;index&#x27;</span>], <span class="hljs-string">&#x27;-&#x27;</span>);<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div><p>src&#x2F;main.js</p><p>main.js 文件中同样引入依赖包 lodash 的 join 方法。创建 div 标签并将内容添加到 body 中，只是展示内容与 index.js 不一致。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; join &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<span class="hljs-keyword">const</span> divElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);divElement.<span class="hljs-property">innerHTML</span> = <span class="hljs-title function_">join</span>([<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>], <span class="hljs-string">&#x27;-&#x27;</span>);<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(divElement);</code></pre></div><p>webpack.config.js</p><p>在 entry 配置中传入两个入口，chunk 的名字分别是 index 和 main。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);...<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,  <span class="hljs-attr">entry</span>: &#123;    <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,    <span class="hljs-attr">main</span>: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>  &#125;,  <span class="hljs-attr">output</span>: &#123;    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>,  &#125;,  <span class="hljs-attr">plugins</span>: [    ...    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./index.html&#x27;</span>,    &#125;),  ],&#125;;</code></pre></div><p>执行打包命令后，在 dist 文件夹下可以看到，同时输出了 mian.js 和 index.js 文件，通过配置 entry 实现了代码分离。我们分别打开 dist&#x2F;index.js 和 dist&#x2F;main.js 后可以看到两个 bundle 中都包含了 lodash 的源码。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133449-RzyRnm-1.png" alt="1.png"></p><h3 id="去重分离"><a href="#去重分离" class="headerlink" title="去重分离"></a>去重分离</h3><p>在入口分离的基础上，我们继续优化将重复的部分单独分离出一个 bundle，在 entry 中配置 dependOn 选项，这样可以在多个 chunk 之间共享模块。</p><p>webpack.config.js</p><p>在 entry 配置中将两个入口文件按照对象的形式定义，除定义入口之外，增加了一个 dependOn 选项，传入的 vendor 为共享模块的 chunk 名称。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">const</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-type">const</span> <span class="hljs-variable">HtmlWebpackPlugin</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);...<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123; ... entry: &#123;    index: &#123;      <span class="hljs-keyword">import</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,      dependOn: <span class="hljs-string">&#x27;vendor&#x27;</span>,    &#125;,    main: &#123;      <span class="hljs-keyword">import</span>: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,      dependOn: <span class="hljs-string">&#x27;vendor&#x27;</span>,    &#125;,    vendor: <span class="hljs-string">&#x27;lodash&#x27;</span>  &#125;,&#125;;</code></pre></div><p>执行打包命令后，在 dist 文件夹下除了两个入口文件外还多了一个 vendor.js 文件，文件的内容即为 lodash 源码。HtmlWebpackPlugin 插件将三个 js 文件都注入到了 index.html 中。项目可以正常运行。</p><p>通过在入口配置 dependOn 属性，虽然可以实现公共代码抽离，但是还存在一个问题是，在我们的项目中会有很多公共代码，难道我们要手动的都添加到 dependOn 中吗？这将会增加非常多的工作量并且容易出错。这时我们可以考虑使用 webpack 的 SplitChunksPlugin 插件了。</p><h4 id="SplitChunksPlugin"><a href="#SplitChunksPlugin" class="headerlink" title="SplitChunksPlugin"></a>SplitChunksPlugin</h4><p><a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/plugins/split-chunks-plugin">SplitChunksPlugin</a> 插件不需要单独安装，是 webpack 提供的开箱即用的插件。我们通过 optimization 配置即可。</p><p>默认情况下，SplitChunksPlugin 它只会影响到按需加载的 chunks，不过我们可以通过传入 chunks 属性不同变量来决定影响哪些 chunk 。</p><p>webpack 将根据以下条件自动拆分 chunks：</p><ul><li>新的 chunk 可以被共享，或者模块来自于 node_modules 文件夹</li><li>新的 chunk 体积大于 20kb（在进行压缩和 gzip 之前的体积）</li><li>当按需加载 chunks 时，并行请求的最大数量小于或等于 30</li><li>当加载初始化页面时，并发请求的最大数量小于或等于 30</li></ul><p>我们使用 SplitChunksPlugin 来拆分下上个例子中的 lodash，关于 SplitChunksPlugin 的各项配置参数含义，感兴趣的伙伴可以查看<a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/plugins/split-chunks-plugin">官网</a></p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs java">...<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;  entry: &#123;    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,    main: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,  &#125;,  optimization: &#123;    splitChunks: &#123;      <span class="hljs-comment">// 设置为 all 意味着 chunk 可以在异步和非异步 chunk 之间共享</span>      chunks: <span class="hljs-string">&#x27;all&#x27;</span>,    &#125;,  &#125;,  ...&#125;;</code></pre></div><p>执行打包命令后，在 dist 文件夹下可以看到除了 index.js 和 main.js 外还输出了一个文件，打开文件可以看到内容正是 lodash。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133449-TQNPfm-2.png" alt="2.png"></p><h2 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h2><p>动态导入也叫资源异步加载，当模块数量过多时，可以把一些暂时用不到的模块延迟加载，以此来减少用户初次加载页面的体积，后续模块等到恰当的时机再去加载，因此也把这种加载方式叫懒加载。</p><p>在 webpack 中提供了两种类似的技术来实现动态加载。import 函数及 require.ensure。require.ensure 是 Webpack 1 支持的异步加载方式，从 Webpack 2 开始引入了 import 函数，并且官方更推荐使用 import 函数的方式实现异步加载，因此下面我们只介绍 import 函数的使用。</p><p>通过 import 函数加载的模块会被异步的进行加载，并且返回一个 Primise 对象。</p><p>main.js</p><div class="code-wrapper"><pre><code class="hljs arcade">export const add = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a + b);&#125;</code></pre></div><p>index.js</p><p>index 文件中通过 import 函数导入 main 文件内容并赋值给 addFunc，在 index 中通过 setTimeout 定时任务 2 秒钟后执行 addFunc 回调函数，在回调函数返回值中通过 ES6 的对象解构语法获取到 add 函数。</p><div class="code-wrapper"><pre><code class="hljs coffeescript">const addFunc = <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./main&#x27;</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  addFunc.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(&#123;add&#125;)</span> =&gt;</span> &#123;    add(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>);  &#125;);&#125;, <span class="hljs-number">2000</span>);</code></pre></div><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs lua">...<span class="hljs-built_in">module</span>.exports = &#123;  mode: <span class="hljs-string">&#x27;development&#x27;</span>,  entry: &#123;    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>  &#125;,  <span class="hljs-built_in">output</span>: &#123;    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.join(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,  &#125;,  ...&#125;;</code></pre></div><p>通过 webpack.config.js 配置我们可以看到入口文件只有 index.js，执行打包命令后在生成的 dist 文件夹中可以看到除了入口文件 index.js 外，还生成了一个 src_main_js.js 的文件，内容即为 src&#x2F;main.js 中内容对应的编译后代码。</p><p>通过 import 函数异步加载文件也可以实现拆分代码的功能，这种方式在实际的项目开发中非常实用，非主页面加载的内容都可以通过 import 函数动态加载，在点击到对应页面时在加载相应资源。</p><p>上面的例子中还可以进一步优化下异步加载文件的 chunk 名称。其他配置不变，我们修改下 import 导入函数部分。</p><p>index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> addFunc = <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;main&quot; */</span> <span class="hljs-string">&#x27;./main&#x27;</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;  addFunc.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123;add&#125;</span>) =&gt;</span> &#123;    <span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>);  &#125;);&#125;, <span class="hljs-number">2000</span>);</code></pre></div><p>通过在 import 函数中增加注释 &#x2F;* webpackChunkName: “main” *&#x2F; 其中的 main 即为生成的 chunk 名称。这样在项目中通过定义语义化的名称，可以增加代码的可读性。</p><p><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1658133449-eDWOYE-3.png" alt="3.png"></p><h1 id="总结-24"><a href="#总结-24" class="headerlink" title="总结"></a>总结</h1><p>上面的示例中，我们总结了代码分离的几种方式，分别是入口分离、去重分离、动态导入，其中的动态导入就是我们常说的懒加载。代码分离对于减少主包体积，优化项目加载速度，减少白屏时间来说将非常有用。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端通关手册-React</title>
    <link href="/2023/01/28/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/"/>
    <url>/2023/01/28/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h3 id="Hello-React"><a href="#Hello-React" class="headerlink" title="Hello, React :-)"></a>Hello, React :-)</h3><p>React 是用于构建用户界面的 JavaScript 库，React 核心只关注视图，不断优化算法，改进性能，提高开发和交互体验。</p><p>React 迭代稳定，重视兼容和过渡，在国内外，尤其是南方，都有相当多的公司在使用 React。</p><p>渐进式的思想同样表现在 React 的学习曲线上，能够与传统的 Web 技术共存，灵活的 JSX 语法等都会让 React 上手很快， 而庞大生态赋予了 React 更强能力的同时，也让开发者感叹花费了更多时间在社区里遨游。</p><h3 id="React-应用"><a href="#React-应用" class="headerlink" title="React 应用"></a>React 应用</h3><p>React 在前端开发领域应用广泛，使用 React 可以构建 Web，插件，单页应用，App，小程序，桌面端，服务端等，微服务，Serverless，低代码，虚拟现实等都有 React 的用武之地。</p><h3 id="React-面试注意事项"><a href="#React-面试注意事项" class="headerlink" title="React 面试注意事项"></a>React 面试注意事项</h3><p>React 面试题可以分为以下 4 个方面</p><ul><li>基础：ES5+ 作用域，class，箭头函数，this 指向，异步编程，高阶函数的循环等常问</li><li>会用：state，副作用，Hook，加载渲染过程，路由、测试、调试、TS、Redux 等常问</li><li>原理：Virtual DOM，Diff 算法，设计组件，优化性能，原理和实现等高级岗位、大厂常问</li><li>项目：项目结构，技术栈，工具链，解决问题，担任角色，亮点等常问，也是面试问题来源</li></ul><p>新手最好先熟练 ES5+ 的使用，再上手 React 时，可以边阅读边写代码，适当练习若干项目，再看原来生涩的表述，会有亲切的画面感。带着项目去看面试题，联想练习或工作中遇到的实际问题，加上自己的理解，你的回答一定可以比手册总结得更自然，更能得到面试官的肯定。</p><h3 id="对比-React-和-Vue-？"><a href="#对比-React-和-Vue-？" class="headerlink" title="对比 React 和 Vue ？"></a>对比 React 和 Vue ？</h3><p>相同点</p><ul><li>支持 Virtual DOM</li><li>支持响应式和组件化的视图组件</li><li>核心库、路由和状态管理分离</li><li>支持 JSX，移动端都支持原生渲染</li></ul><p>不同点</p><ul><li><p>预编译</p><ul><li>React 可以通过 Prepack 优化 JavaScript 源代码，在编译时执行原本在运行时的计算过程，通过简单的赋值序列提高 JavaScript 代码的执行效率，消除中间计算过程及分配对象操作。缓存 JavaScript 解析结果，优化效果最佳</li><li>Vue 可以静态分析 template，构造 AST 树，通过 PatchFlags 标记节点变化类型</li></ul></li><li><p>渲染</p><ul><li>React 通过 shouldComponentUpdate &#x2F; setState，使用 PureCompoent 等对比前后状态和属性，手动决定是否渲染来优化</li><li>Vue 推荐模板语法，自动追踪组件依赖，精确渲染状态改变的组件</li></ul></li><li><p>事件处理</p><ul><li><p>React</p><ul><li>React 17前，事件委托到 document，之后委托到 根节点</li><li>所有事件被合并为合成事件并兼容不同浏览器</li><li>事件处理函数中的 this 需要手动绑定或使用箭头函数声明</li></ul></li><li><p>Vue</p><ul><li><p>原生事件</p></li><li><p>this 自动绑定执行上下文</p></li></ul></li></ul></li></ul><h3 id="什么是-React"><a href="#什么是-React" class="headerlink" title="什么是 React ?"></a>什么是 React ?</h3><p>React 是用于构建用户界面的 JavaScript 库</p><ul><li>声明式编写 UI，代码可靠，便于调试</li><li>组件化开发，组件逻辑使用 JavaScript 编写而非模板，遵循单向数据流和数据绑定，状态与 DOM 分离</li><li>一次学习，随处编写，使用 Virtual DOM，支持 浏览器、Node 服务器等多种渲染方式 和 React Native 开发原生应用</li></ul><h3 id="对比-React-和-Angular"><a href="#对比-React-和-Angular" class="headerlink" title="对比 React 和 Angular ?"></a>对比 React 和 Angular ?</h3><ul><li>核心功能<ul><li>React 核心库只提供构建 UI 组件的方法，其他功能通过社区提供</li><li>Angular 集成了 路由、异步请求、表单、模块化 CSS 等功能</li></ul></li><li>组件<ul><li>React 组件推荐使用 JSX，可以一个文件包含 HTML、CSS 和 JS，也可以分开</li><li>Angular 组件 HTML、CSS 和 TS 分别是一个文件</li></ul></li><li>DOM<ul><li>React 基于 Virtual DOM，组件会被编译成 JS 对象，数据更改时通过 Diff 算法更新</li><li>Angular 基于 Incremental DOM，组件会被编译成指令，数据更改时就地更新。没有使用规定指令的组件可以被 Tree Shaking</li></ul></li><li>数据绑定<ul><li>React 单向数据绑定，声明状态，更新视图</li><li>Angular 双向数据绑定，数据改变，更新视图</li></ul></li><li>全局状态管理<ul><li>Angualr 可以用 Service 依赖注入实现</li><li>React 可以用全局对象或 Redux 实现</li></ul></li><li>上手成本<ul><li>React 推荐了解 JSX，是库，可以渐进式使用</li><li>Angluar 需要了解 TypeScript，Rxjs，OOP 和装饰器等，是框架，推荐独立使用</li></ul></li></ul><h3 id="你认为-React-的缺点是什么？"><a href="#你认为-React-的缺点是什么？" class="headerlink" title="你认为 React 的缺点是什么？"></a>你认为 React 的缺点是什么？</h3><ul><li>React 核心是 UI 库，路由，状态管理等由社区维护。细粒度需求和问题依赖社区解决</li><li>React 概念和约束较少，容易上手并与现有项目整合。代码风格和项目结构容易产生差别</li><li>React JSX 灵活性高，预编译时可以做的优化相对其他 HTML 分离的库有限</li><li>React setState 提供基于队列异步更新，手动优化渲染流程，需要关注业务之外的逻辑</li><li>React17 以前基于事件委托的合成事件，表现和使用与原生事件存在差异</li></ul><h3 id="什么是声明式编程？"><a href="#什么是声明式编程？" class="headerlink" title="什么是声明式编程？"></a>什么是声明式编程？</h3><ul><li>声明式编程是一种编程范式，描述目标，而不是流程</li><li>通过函数、推理规则或者重写规则，来描述变量间关系</li><li>通过编译器采用固定算法，使得这些关系产生结果</li></ul><h3 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h3><ul><li>函数式编程是一种编程范式，它是声明式编程的子集</li><li>避免使用状态、异变对象，最小化副作用</li><li>基于 lambda 演算，函数可以作为入参和出参</li></ul><h3 id="MVC-和-MVVM-的区别是？"><a href="#MVC-和-MVVM-的区别是？" class="headerlink" title="MVC 和 MVVM 的区别是？"></a>MVC 和 MVVM 的区别是？</h3><p>相同点</p><ul><li>目的相同：分离模型 Model 和视图 View</li></ul><p>不同点</p><ul><li>MVC<ul><li>构成：模型 Model - 视图 View - 控制器 Controller</li><li>分为主动 MVC 和 被动 MVC<ul><li>主动 MVC：视图订阅数据更新</li><li>被动 MVC：控制器操作视图</li></ul></li><li>渲染<ul><li>后端返回 HTML，利于 SEO</li><li>后端返回数据，前端使用模板引擎或操作 DOM</li></ul></li></ul></li><li>MVVM<ul><li>构成：模型 Model - 视图 View - 视图模型 ViewModel</li><li>ViewModel 单向或双向数据绑定 View 和 Model 层，实现自动同步</li><li>渲染<ul><li>后端减少关心视图，前端 SSR 利于 SEO</li><li>前端减少操作 DOM</li></ul></li></ul></li></ul><h3 id="如何组织-React-项目文件结构？"><a href="#如何组织-React-项目文件结构？" class="headerlink" title="如何组织 React 项目文件结构？"></a>如何组织 React 项目文件结构？</h3><p>React 建议</p><ul><li>项目目录嵌套最多3到4个层级</li><li>不要过度思考</li><li>没有官方推荐的组织方式，常见组织方式包括<ul><li>按功能和路由组织：相同功能或路由的 CSS、JS 和 测试文件放入同一目录</li><li>按文件类型组织：组件、页面、API、状态管理、静态文件分类存放</li></ul></li></ul><h3 id="如何组织-React-项目文件结构？-1"><a href="#如何组织-React-项目文件结构？-1" class="headerlink" title="如何组织 React 项目文件结构？"></a>如何组织 React 项目文件结构？</h3><p>React 建议</p><ul><li>项目目录嵌套最多3到4个层级</li><li>不要过度思考</li><li>没有官方推荐的组织方式，常见组织方式包括<ul><li>按功能和路由组织：相同功能或路由的 CSS、JS 和 测试文件放入同一目录</li><li>按文件类型组织：组件、页面、API、状态管理、静态文件分类存放</li></ul></li></ul><h3 id="React-18-都有哪些新特性？"><a href="#React-18-都有哪些新特性？" class="headerlink" title="React 18 都有哪些新特性？"></a>React 18 都有哪些新特性？</h3><ul><li>新的 Root API：ReactDom.creatRoot<ul><li>React 17 及之前版本<ul><li>通过 ReactDom.render 将应用渲染到页面的根元素</li><li>有限的自动批量处理<ul><li>如在浏览器事件触发多个状态更改，自动批量更新</li><li>而在异步函数中多个状态更改，不会批量更新</li></ul></li></ul></li><li>React 18<ul><li>可选通过 ReactDom.creatRoot 将应用渲染到页面的根元素</li><li>确保安全的前提下<ul><li>如对于每个用户触发的事件，在下一个事件前完成渲染</li><li>尽可能地多应用自动批量处理，包括异步函数中的多个状态更新</li></ul></li><li>可选 ReactDom.flushSync 退出批量更新</li></ul></li></ul></li><li>SSR 支持 React.lazy 和 React.Suspense<ul><li>React 17 及之前版本<ul><li>React.lazy() 和 React.Suspense 尚未在 ReactDOMServer 中支持</li></ul></li><li>React 18<ul><li>全新的 SSR 架构内置支持 React.lazy() 和 React.Suspense</li></ul></li></ul></li><li>startTransition<br>* React 17 及以前版本<br>* 所有更新都被紧急渲染<br>* 使用 <code>setTimeout</code> 和 防抖等方式，避免频繁更新<br>* React 18<br>* 所有渲染分为紧急和非紧急<br>* 非紧急渲染使用 <code>startTransition</code> 包裹<br>* 非紧急渲染的延迟时间由设备决定<br>* 非紧急渲染可中断，不会影响响应用户输入、动画等紧急渲染</li></ul><h3 id="什么是-JSX-？"><a href="#什么是-JSX-？" class="headerlink" title="什么是 JSX ？"></a>什么是 JSX ？</h3><ul><li><p>JSX 是 JavaScript 的语法扩展，生成 React 元素</p></li><li><p>JSX 是</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(component, props, ...children)</code></pre></div><p>函数的语法糖</p><ul><li>React 17 RC 开始，由编辑器自动引入 <code>import &#123; jsx &#125; from &#39;react/jsx-runtime&#39;</code></li></ul></li><li><p>JSX 支持 HTML 模板语法 和 表达式，支持条件和循环渲染，支持点语法和展开运算符</p></li><li><p>JSX 转义所有输入内容，防止注入攻击</p></li><li><p>JSX 忽略渲染 <code>false</code>，<code>null</code>，<code>undefined</code>，<code>true</code> 子元素</p></li></ul><h3 id="为什么推荐在-React-中使用-JSX-？"><a href="#为什么推荐在-React-中使用-JSX-？" class="headerlink" title="为什么推荐在 React 中使用 JSX ？"></a>为什么推荐在 React 中使用 JSX ？</h3><ul><li>React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合<ul><li>UI 中绑定处理事件</li><li>状态更新时通知 UI</li><li>UI 中展示数据</li></ul></li><li>React 将标记和逻辑共同存放在组件，实现关注点分离</li><li>React 不强制要求使用 JSX，但 JSX 与 UI 一起有视觉辅助作用</li><li>React 通过 JSX 可以显示更多有用错误和警告消息</li></ul><h3 id="为什么-JSX-可以有效降低-XSS-风险？"><a href="#为什么-JSX-可以有效降低-XSS-风险？" class="headerlink" title="为什么 JSX 可以有效降低 XSS 风险？"></a>为什么 JSX 可以有效降低 XSS 风险？</h3><ul><li>React DOM 在渲染所有输入内容前，默认会将它们转义成字符串，有效降低 XSS 风险</li><li>可以通过<code>dangerouslySetInnerHTML = &#123;&#123; __html: HTML &#125;&#125;</code>来显示转义前的内容</li></ul><h3 id="如何在-JSX-中条件渲染？"><a href="#如何在-JSX-中条件渲染？" class="headerlink" title="如何在 JSX 中条件渲染？"></a>如何在 JSX 中条件渲染？</h3><ul><li><p>if &#x2F; else 语句</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">if</span> (condition) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span></span><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>&#125;</code></pre></div><ul><li><p>三元运算符</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> condition ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span></span> : <span class="hljs-literal">null</span>&#125;</code></pre></div><ul><li><p>逻辑运算符</p></li><li><p>plain</p></li></ul><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> condition &amp;&amp; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span></span>&#125;</code></pre></div><ul><li><p>条件渲染组件</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs jsx">render () &#123;<span class="hljs-keyword">const</span> <span class="hljs-title function_">Condition</span> = props =&gt; &#123;<span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">If</span>, children &#125; = props<span class="hljs-keyword">return</span> <span class="hljs-title class_">If</span> &amp;&amp; children&#125;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Condition</span> <span class="hljs-attr">If</span>=<span class="hljs-string">&#123;true&#125;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Condition</span>&gt;</span></span>&#125;</code></pre></div><h3 id="如何在-JSX-中循环控制？"><a href="#如何在-JSX-中循环控制？" class="headerlink" title="如何在 JSX 中循环控制？"></a>如何在 JSX 中循环控制？</h3><ul><li>map 将数组每一项转成 UI，flatMap filter 等能返回数组的循环方法也被支持</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> &#123; data &#125; = props<span class="hljs-keyword">return</span> data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span>)&#125;</code></pre></div><ul><li>使用 javaScript 的循环（for &#x2F; while &#x2F; do while），将结果存储到变量，将变量代入 JSX</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> &#123; data &#125; = props<span class="hljs-keyword">const</span> datas = <span class="hljs-title class_">Array</span>(data.<span class="hljs-property">length</span>)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">const</span> item = data[i]datas[i] = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span>&#125;<span class="hljs-keyword">return</span> datas&#125;</code></pre></div><ul><li>使用 lodash 等第三方库或自定义可以返回数组的方法，以 lodash 为例</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> &#123; data &#125; = props<span class="hljs-keyword">return</span> _.<span class="hljs-title function_">times</span>(data.<span class="hljs-property">length</span>, <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;data[i].id&#125;</span>&gt;</span>&#123;data[i].text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span>)&#125;</code></pre></div><h3 id="为什么-JSX-中-class-变成了-className"><a href="#为什么-JSX-中-class-变成了-className" class="headerlink" title="为什么 JSX 中 class 变成了 className ?"></a>为什么 JSX 中 class 变成了 className ?</h3><ul><li>JSX 语法上更接近 JavaScript 而不是 HTML<ul><li>HTML 属性值通常为字符串</li><li>HTML DOM 对象属性值可以是任意数据类型</li></ul></li><li>JSX 的 className 更接近 HTML DOM 对象的属性，并且支持属性拓展运算符</li><li>JSX 通过匹配闭合标签提升可读性，而不是代替 HTML<ul><li>JSX 与 HTML 需要转换，直接使用 class 也无法避免其它转换工作</li></ul></li></ul><h3 id="什么是-React-组件？"><a href="#什么是-React-组件？" class="headerlink" title="什么是 React 组件？"></a>什么是 React 组件？</h3><ul><li>React 组件允许用户将 UI 拆分成独立可复用的代码片段，并对每个片段进行独立构思</li><li>React 组件从概念上类似于 JavaScript 函数</li><li>React 组件接受任意的入参 Props，返回用于描述页面展示内容的 React 元素</li></ul><h3 id="React-组件分成哪几类？"><a href="#React-组件分成哪几类？" class="headerlink" title="React 组件分成哪几类？"></a>React 组件分成哪几类？</h3><ul><li>按定义分类<ul><li>类组件，使用 ES6 的 class 定义，维护 state，有生命周期</li><li>函数组件，使用普通函数定义，可以通过 hooks 维护状态和副作用</li></ul></li><li>按状态分<ul><li>有状态组件，组件返回结果，受时间、空间或上下文影响</li><li>无状态组件，通常是纯展示 UI 组件，容易复用</li></ul></li><li>按定位分<ul><li>展示型组件，接收 props，负责 UI 展示</li><li>容器组件，管理 states，负责数据获取和组件间通信，多用于状态提升</li></ul></li><li>按 React 内置类型分类<ul><li>有状态组件<ul><li>ClassComponent，由 class 创建</li><li>ContextProvider，由 createContext 创建</li></ul></li><li>无状态组件<ul><li>IndeterminateComponent，FunctionCompoent 挂载前的初始类型</li><li>FunctionComponent，即函数组件</li><li>ForwardRef，由 React.forwardRef 创建，接收 ref 并转发给子组件</li><li>MemoComponent，由 React.memo 创建，条件渲染子组件</li><li>SimpleMemoCompoent，由 React.memo 创建且不指定条件</li></ul></li><li>FiberNode<ul><li>HostRoot，由 ReactDOM.render 创建</li><li>HostPortal，由 React.createPortal 创建，多用于模态框</li><li>HostComponent，对应元素节点</li><li>HostText，对应文本节点</li></ul></li><li>内置类型<ul><li>Fragment，分组子列表，无需向 DOM 添加额外节点，可用短语法 &lt;&gt;</li><li>Profiler，测量 React 应用多久渲染一次以及渲染一次的“代价”</li><li>StrictMode，严格模式，用来突出显示应用程序中潜在问题的工具</li><li>Suspense，等待目标代码加载，并且可以指定一个加载界面，在用户等待时显示</li><li>PureCompoent，浅层对比 prop 和 state 实现了 shouldComponentUpdate</li></ul></li></ul></li></ul><h3 id="类组件和函数组件的区别是？"><a href="#类组件和函数组件的区别是？" class="headerlink" title="类组件和函数组件的区别是？"></a>类组件和函数组件的区别是？</h3><table><thead><tr><th align="left"></th><th align="left">类组件</th><th align="left">函数组件</th></tr></thead><tbody><tr><td align="left">回调钩子</td><td align="left">生命周期</td><td align="left">useEffect &#x2F; useLayoutEffect</td></tr><tr><td align="left">this</td><td align="left">有，事件处理函数需绑定 this</td><td align="left">无</td></tr><tr><td align="left">state</td><td align="left">有，this.setState 更新</td><td align="left">无，useState &#x2F; useReducer 引入</td></tr><tr><td align="left">实例化</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">性能</td><td align="left">现代浏览器中，闭包和类的原始性能只有在极端场景才会有明显差别</td><td align="left">使用 Hooks 某些情况更加高效,避免了 class 需要的额外成本，如创建类实例和在构造函数绑定事件处理器的成本,符合语言习惯的代码不需要很深的组件库嵌套</td></tr></tbody></table><h3 id="受控组件和非受控组件的区别是？"><a href="#受控组件和非受控组件的区别是？" class="headerlink" title="受控组件和非受控组件的区别是？"></a>受控组件和非受控组件的区别是？</h3><h4 id="面试高频指数：★-★-★-★-☆"><a href="#面试高频指数：★-★-★-★-☆" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul><li>受控组件<ul><li>React 的 state 是表单元素的“唯一数据源”，控制用户输入过程中表单发生的操作</li><li>表单元素的 value 跟随 state 变化，默认值由 defaultValue 设置</li><li>表单元素需要被 React 组件包裹</li><li>每种数据变化都需要编写事件处理函数</li><li>不支持 value 只读的表单元素，如 <code>&lt;input type=&quot;file&quot; /&gt;</code> 的 value 由用户设置</li></ul></li><li>非受控组件<ul><li>表单数据交由 DOM 节点处理</li><li>使用 <code>ref</code> 从 DOM 节点获取表单数据</li><li>表单元素无需被 React 组件包裹</li><li>只关心业务需要的数据变化，减少代码量</li><li>集成 React 和 非 React 代码，不推荐使用</li></ul></li></ul><h3 id="什么是高阶组件？"><a href="#什么是高阶组件？" class="headerlink" title="什么是高阶组件？"></a>什么是高阶组件？</h3><ul><li>高阶组件是参数为组件，返回值为新组件的函数，某种角度上就是高阶函数</li><li>高阶组件是 React 中复用组件逻辑的一种高级技巧</li><li>高阶组件不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式</li></ul><h3 id="什么是-Pure-Components-？"><a href="#什么是-Pure-Components-？" class="headerlink" title="什么是 Pure Components ？"></a>什么是 Pure Components ？</h3><p>React.PureComponent 与 React.Component 相似，区别是</p><ul><li>React.Component 并未实现 shouldComponentUpdate</li><li>React.PureComponent 以浅层对比 prop 和 state 方式实现了 shouldComponentUpdate<ul><li>React.PureComponent 无法检查对象的深层差别</li><li>prop 和 state 使用深层数据结构时<ul><li>调用 <code>forceUpdate()</code> 来确保组件正确更新</li><li>使用 <code>immutable 对象</code> 加速嵌套数据的比较</li></ul></li></ul></li></ul><h3 id="展示组件和容器组件的区别是？"><a href="#展示组件和容器组件的区别是？" class="headerlink" title="展示组件和容器组件的区别是？"></a>展示组件和容器组件的区别是？</h3><p>React 组件按照用途可以分为展示组件和容器组件</p><p>React 推荐所有新组件，无论是展示组件，还是容器组件，都采用函数组件 + Hook 方式编写</p><ul><li>展示组件<ul><li>关心页面 UI，有自己的 HTML 标签和样式</li><li>如果有状态，仅与 UI 相关。与其他组件、store 无关</li><li>不关心数据源，通过 props 获取数据，并执行回调</li></ul></li><li>容器组件<ul><li>关心功能实现，无自己的 HTML 标签和样式</li><li>有状态。包含请求数据源等副作用。状态提升时，维护多个子组件的状态</li><li>可以由第三方库生成，如 React Redux 的 <code>connect()</code> 和 Relay 的 <code>createFragmentContainer</code></li></ul></li></ul><p>React 分离展示组件和容器组件的优势</p><ul><li>关注点分离，便于维护</li><li>提高展示组件的复用度，便于调整 UI</li><li>便于通过如 this.props.children 传递组件本身，减少相同 props 层层传递</li></ul><h3 id="如何劫持-React-组件提高组件复用度？"><a href="#如何劫持-React-组件提高组件复用度？" class="headerlink" title="如何劫持 React 组件提高组件复用度？"></a>如何劫持 React 组件提高组件复用度？</h3><p>劫持 React 组件又被称为渲染劫持</p><p>将已有组件包装，注入新属性和功能，输出高阶组件，来实现组件复用</p><p>劫持需要遵守高阶组件的约定</p><ul><li>不要改变原始组件，仅组合组件</li><li>保持组件的接口与已有组件相似，透传与自身无关的 props 给已有组件</li><li>最大化可组合性，确保函数签名类型一致，输入函数，返回函数，输入组件，返回组件</li><li>包装显示名称便于调试，如 <code>withSubscription(CommentList)</code></li></ul><h3 id="如何设计一个-React-组件？"><a href="#如何设计一个-React-组件？" class="headerlink" title="如何设计一个 React 组件？"></a>如何设计一个 React 组件？</h3><ul><li>根据数据源和原型和 UI 稿，了解数据结构和 UI 视图</li><li>划分组件层级<ul><li>根据单一功能原则分离 UI 与数据源的结构一一对应</li><li>明确组件的包含关系</li></ul></li><li>构建静态版本<ul><li>将静态数据通过 props 父组件到子组件单向传递</li><li>构建应用<ul><li>简单应用，自上而下，从高层组件到低层组件构建</li><li>大型应用，自下而上，从低层组件到高层组件构建，同时为低层组件编写测试</li></ul></li><li>确定 UI state 最小且完整表示<ul><li>排除通过 props 传递来的数据</li><li>排除不随时间变化的数据</li><li>排除可以由其他 state 或 props 计算得出的数据</li></ul></li><li>确定 state 放置位置<ul><li>找出根据 state 渲染的所有组件</li><li>找出这些组件的共同上级组件</li><li>state 应该放置在共同上级组件或者更高层级的组件中</li></ul></li><li>添加反向数据流<ul><li>state 只能由拥有它们的组件更改</li><li>在该组件添加修改 state 的回调函数</li><li>将该回调函数通过 props 传递给子组件，在子组件中，如事件处理函数中调用</li></ul></li></ul></li></ul><h3 id="React-组件与-Web-Components-共存的最佳实践是？"><a href="#React-组件与-Web-Components-共存的最佳实践是？" class="headerlink" title="React 组件与 Web Components 共存的最佳实践是？"></a>React 组件与 Web Components 共存的最佳实践是？</h3><ul><li>访问 Web Components 的命令式 API：使用 <code>ref</code>与 DOM 节点进行交互</li><li>引入第三方 Web Components：编写 React 组件包装该 Web Components</li><li>Web Components 触发事件：React 组件中手动添加事件处理器来处理事件</li></ul><h3 id="什么是-React-的状态？"><a href="#什么是-React-的状态？" class="headerlink" title="什么是 React 的状态？"></a>什么是 React 的状态？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆"><a href="#面试高频指数：★-☆-☆-☆-☆" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li>React 的状态 state 是一个对象<ul><li>类组件中，状态通过 this.state 创建，通过 this.setState 合并更改，异步更新</li><li>React Hook 中，状态通过 this.useState 或 this.useReducer 使用</li></ul></li><li>React 将组件看做状态机，状态改变触发渲染</li><li>React 建议减少有状态的组件，提高组件复用度，利于维护<ul><li>只将无法从 props 传递，无法从其他数据计算，并且随时间可能变化的数据作为 state</li><li>多个组件 state 的数据源相同，应将状态提升到父组件或容器组件</li><li>避免使用 context，仅在 React 的状态管理无法满足需求时使用 Redux</li></ul></li></ul><h3 id="什么是-React-的状态提升？"><a href="#什么是-React-的状态提升？" class="headerlink" title="什么是 React 的状态提升？"></a>什么是 React 的状态提升？</h3><ul><li>React 中，任何可变数据应当只有一个相对应的唯一“数据源”</li><li>多个组件反映相同的变化数据时，共享状态提升到最近的共同父组件<ul><li>state 应首先添加到需要渲染数据的组件</li><li>其他组件也需要这个 state，将它提升至这些组件的最近共同父组件</li></ul></li><li>state 只能由拥有它们的组件修改，bug 排查范围被大大缩减</li></ul><h3 id="状态和属性的区别是什么？"><a href="#状态和属性的区别是什么？" class="headerlink" title="状态和属性的区别是什么？"></a>状态和属性的区别是什么？</h3><p>相同点</p><ul><li>state 和 props 都是原生的 JavaScript 对象</li><li>state 和 props 的变化都会触发生命周期、useEffect &#x2F; useLayoutEffect、和渲染</li><li>state 和 props 相同，渲染结果相同</li><li>state 和 props 都可以在组件内部设置默认值</li></ul><p>不同点</p><ul><li>获取<ul><li>state 由当前组件声明</li><li>props 由父组件传入</li></ul></li><li>更新<ul><li>state<ul><li>由所在组件通过 useState &#x2F; useReducer 或 setState 方法更新</li><li>由子组件通过 state 所在组件传入的回调函数间接更新</li></ul></li><li>props 不允许修改</li></ul></li><li>数据<ul><li>state 通常存储可变数据，避免多层嵌套或使用不可变对象便于优化渲染</li><li>props 除数据外，还多用于回调函数，组件 ( children )，路由 ( history ) 的传递</li></ul></li></ul><h3 id="如何创建动态的状态名称？"><a href="#如何创建动态的状态名称？" class="headerlink" title="如何创建动态的状态名称？"></a>如何创建动态的状态名称？</h3><ul><li>状态是一个 JavaScript 对象，状态名称即对象的属性名称</li><li>从 ECMAScript 2015 开始，对象初始化语法开始支持计算属性名。在 [] 放入表达式，计算结果当做属性名。例如</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> h = &#123;&#125;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>h[i + <span class="hljs-number">1</span>] = i <span class="hljs-comment">// h = &#123;&#x27;1&#x27;: 0&#125;</span></code></pre></div><ul><li>计算属性名支持对象字面量，例：</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; i &#125; = props <span class="hljs-comment">// props = &#123; i : 0 &#125;</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;[i + <span class="hljs-number">1</span>] : i&#125; <span class="hljs-comment">// this.state = &#123; &#x27;1&#x27; : 0 &#125;</span></code></pre></div><h3 id="setState-支持哪些用法？"><a href="#setState-支持哪些用法？" class="headerlink" title="setState 支持哪些用法？"></a>setState 支持哪些用法？</h3><h4 id="面试高频指数：★-★-☆-☆-☆"><a href="#面试高频指数：★-★-☆-☆-☆" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>setState(updater, [callback])<ul><li>updater 函数带有形式参数，基于 state 和 props 构建新对象表示变化</li><li>(state, props) &#x3D;&gt; stateChange，适合后续状态取决于当前状态的情况</li></ul></li><li>setState(stateChange[, callback])<ul><li>stateChange 为传入对象，会浅层合并到新的 state</li><li>同一周期内，后调用的 setState 会覆盖先调用的 setState</li></ul></li><li>setState 的第二参数为可选回调函数<ul><li>回调函数将在 setState 完成合并并重新渲染组件后执行</li><li>React 官方推荐使用 componentDidUpdate() 生命周期代替 setState 的回调函数</li></ul></li></ul><h3 id="setState-和-replaceState-的区别是？"><a href="#setState-和-replaceState-的区别是？" class="headerlink" title="setState 和 replaceState 的区别是？"></a>setState 和 replaceState 的区别是？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-1"><a href="#面试高频指数：★-☆-☆-☆-☆-1" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li>setState 会合并当前状态与之前状态</li><li>replaceState 会丢弃之前状态，用新状态替代</li><li>replaceState 等同于先在 setState 中将状态设置为 false &#x2F; null，再设置新状态</li></ul><h3 id="如何优化-setState，减少不必要更新？"><a href="#如何优化-setState，减少不必要更新？" class="headerlink" title="如何优化 setState，减少不必要更新？"></a>如何优化 setState，减少不必要更新？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-1"><a href="#面试高频指数：★-★-☆-☆-☆-1" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>通过 setState(updater, [callback]) 的用法，第一参数使用带有形式参数的函数</li><li>通过 updater 函数 (state, props) &#x3D;&gt; stateChange 的第一参数，接受原来的 state 状态值</li><li>对比新旧状态值<ul><li>相同，返回 null，不渲染</li><li>不同，返回新状态值，触发异步合并渲染</li></ul></li></ul><p>示例：</p><div class="code-wrapper"><pre><code class="hljs JavaScript">getData = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<span class="hljs-keyword">const</span> &#123; time &#125; = data<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;<span class="hljs-keyword">return</span> state.<span class="hljs-property">time</span> === time ?  <span class="hljs-literal">null</span> : &#123; time &#125;&#125;)&#125;</code></pre></div><h3 id="当-State-值为-Object-时，如何优化？"><a href="#当-State-值为-Object-时，如何优化？" class="headerlink" title="当 State 值为 Object 时，如何优化？"></a>当 State 值为 Object 时，如何优化？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-2"><a href="#面试高频指数：★-★-☆-☆-☆-2" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>避免使用 Object 作为 State 值，使用 PureComponent 的浅比较的自动优化失效</li><li>必要使用 Object 作为 State 值<ul><li>避免嵌套过多层级</li><li>设置更新 state 的前置条件或使用 shouldComponent 手动优化</li></ul></li><li>已经使用 Object 作为 State 值，并且嵌套层级过多<ul><li>拆分 State 到子组件</li><li>使用不可变对象 Immutable，只要 State 更新，返回对象新引用，重新渲染修改节点</li></ul></li></ul><h3 id="什么是-React-的属性？"><a href="#什么是-React-的属性？" class="headerlink" title="什么是 React 的属性？"></a>什么是 React 的属性？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-2"><a href="#面试高频指数：★-☆-☆-☆-☆-2" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li>属性是组件的入参，用法同 HTML 自定义属性，可将任意类型数据从父组件传给子组件</li><li>属性的改变可以触发组件的生命周期流程和渲染</li><li>建议从组件自身的角度，不依赖于调用中间的上下文命名 Props</li><li>属性具有只读性，所有 React 组件必须像纯函数一样保护它们的 props 不被更改</li><li>请避免使用匿名函数作为属性值，避免引起重复渲染</li><li>具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑</li></ul><h3 id="为什么不能直接修改属性？"><a href="#为什么不能直接修改属性？" class="headerlink" title="为什么不能直接修改属性？"></a>为什么不能直接修改属性？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-3"><a href="#面试高频指数：★-☆-☆-☆-☆-3" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li>React 是“单向”数据流，数据通过 props 传递</li><li>从 state 派生数据或 UI 只能影响“低于”它们的组件，设计简单高效，便于调试</li><li>所有 React 组件必须像纯函数一样保护它们的 props 不被更改，保证组件没有副作用</li></ul><h3 id="通过属性传递组件本身的方法有哪些？"><a href="#通过属性传递组件本身的方法有哪些？" class="headerlink" title="通过属性传递组件本身的方法有哪些？"></a>通过属性传递组件本身的方法有哪些？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-3"><a href="#面试高频指数：★-★-☆-☆-☆-3" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>props.children<ul><li>子组件可以获取父组件开始标签和结束标签之间的内容</li></ul></li><li>render props<ul><li>向子组件传入函数，返回组件需要渲染什么内容</li><li>直接在父组件的标签之间，调用函数返回组件</li><li>避免使用匿名函数返回组件，避免重复渲染</li></ul></li></ul><h3 id="使用-key-属性有哪些注意事项？"><a href="#使用-key-属性有哪些注意事项？" class="headerlink" title="使用 key 属性有哪些注意事项？"></a>使用 key 属性有哪些注意事项？</h3><h4 id="面试高频指数：★-★-★-☆-☆"><a href="#面试高频指数：★-★-★-☆-☆" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul><li>key 用来帮助 React 识别哪些元素改变</li><li>key 在数组列表及兄弟节点之间必须唯一</li><li>不建议使用索引作为 key 值，如果不显示指定 key 值，默认使用索引作为 key 值</li><li>key 只有放在就近的数组上下文中才有意义</li><li>key 不会传递给子组件，需要使用 key 属性的值，需使用其他属性显式传递</li></ul><h3 id="如何在-React-中进行静态类型检查？"><a href="#如何在-React-中进行静态类型检查？" class="headerlink" title="如何在 React 中进行静态类型检查？"></a>如何在 React 中进行静态类型检查？</h3><h4 id="面试高频指数：★-★-★-☆-☆-1"><a href="#面试高频指数：★-★-★-☆-☆-1" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul><li>React.PropTypes 或 prop-types 库<ul><li>提供一系列验证器，确保组件接收到的数据类型有效</li><li>PropTypes 仅在开发模下进行检查并在控制台显示警告</li><li>通过特定的 defaultProps 属性来定义 props 的默认值</li></ul></li><li>Flow<ul><li>Flow 是一个针对 JavaScript 代码的静态类型检测器</li><li>Facebook 开发，经常与 React 一起使用</li><li>Flow 通过特殊类型语法为变量、函数以及 React 组件提供注解</li><li>Flow 添加方法<ul><li>将 Flow 添加到项目依赖</li><li>确保编译后的代码已经去除 Flow 语法</li><li>添加类型注解并且运行 Flow 来检查</li></ul></li></ul></li><li>TypeScript<ul><li>TypeScript 是微软开发的编程语言，它是 JavaScript 的类型超集，包含独立编译器</li><li>类型语言，构建时可以发现 bug 和错误</li><li>TypeScript 添加方法<ul><li>将 TypeScript 添加到项目依赖</li><li>配置 TypeScript 编译选项</li><li>使用正确的文件扩展名，React 的 JSX 使用<code>.tsx</code>作为扩展名</li><li>为已经使用的库添加定义，现实其他包的错误和提示</li></ul></li></ul></li><li>新语法和工具链<ul><li>Reason，由 Facebook 开发，经过实战验证的 OCaml 语言</li><li>Kotlin，由 JetBrains 开发的静态类型语言</li></ul></li></ul><h3 id="如何限制某个属性是必须的？"><a href="#如何限制某个属性是必须的？" class="headerlink" title="如何限制某个属性是必须的？"></a>如何限制某个属性是必须的？</h3><p>React 中，可以在任何 PropTypes 属性后加上 isRequired，声明该属性必须</p><ul><li>当必须属性没有被提供值时，控制台打印警告信息</li><li>表示该属性必须，而不限制属性类型，可以使用 PropTypes.any.isRequired</li><li>表示必须包含一个元素，可以使用 PropTypes.element.isRequired</li></ul><h3 id="如何设置属性的默认值？"><a href="#如何设置属性的默认值？" class="headerlink" title="如何设置属性的默认值？"></a>如何设置属性的默认值？</h3><h4 id="面试高频指数：★-★-★-☆-☆-2"><a href="#面试高频指数：★-★-★-☆-☆-2" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>React 中，通过特定 defaultProps 属性来定义 props 默认值</p><ul><li>设置类组件或函数组件的静态属性 defaultProps</li><li>类组件，参考 proposal-class-fields 提案，在 class 内声明静态属性 defaultProps</li><li>当传入属性值为 undefined 时，使用属性的默认值</li></ul><h3 id="React-是否支持-HTML-属性？"><a href="#React-是否支持-HTML-属性？" class="headerlink" title="React 是否支持 HTML 属性？"></a>React 是否支持 HTML 属性？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-4"><a href="#面试高频指数：★-★-☆-☆-☆-4" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>React16 中，任何标准和自定义的 DOM 属性都是完全支持</li><li>React 为 DOM 提供了一套以 JavaScript 为中心的 API<ul><li>标准 DOM 属性采用小驼峰命名</li><li>自定义属性全部小写</li></ul></li><li>React 与 HTML 之间部分属性存在差异<ul><li>checked<ul><li>受控组件 checked</li><li>非受控组件用 defaultChecked 设置组件首次挂载时是否被选中</li></ul></li><li>classNmae<ul><li>用于指定 DOM 节点和 SVG 元素的 class</li><li>React 中，使用 Web Components，使用 class 属性代替</li></ul></li><li>dangerouslySetInnerHTML<ul><li>React 为浏览器 DOM 提供 innerHTML 的替换方案</li><li>需要向该属性传入 key 为 __html 的对象，用来警示跨站脚本（XSS）攻击风险</li></ul></li><li>htmlFor<ul><li>for 是 JavaScript 关键字</li><li>React 元素使用 htmlFor 代替</li></ul></li><li>onChange<ul><li>onChange 事件与预期行为一致：表单字段变化时，事件都会被触发</li><li>与浏览器已有的默认行为不一致：<ul><li>用户更改 <code>&lt;input&gt;</code>,<code>&lt;select&gt;</code> 和 <code>&lt;textarea&gt;</code> 元素的值并提交更改时 <code>change</code> 事件在这些元素上触发</li><li>与 <code>input</code> 事件不一样，<code>change</code> 事件不是每次元素的 <code>value</code> 改变时都会被触发</li></ul></li><li>React 依靠该事件实时处理用户输入</li></ul></li><li>selected<ul><li>将 <code>&lt;option&gt;</code> 标记为已选中状态，请在 <code>select</code> 的 <code>value</code> 中引用该选项的值</li></ul></li><li>style<ul><li>接受小驼峰命名属性的 JavaScript 对象，而不是 CSS 字符串</li><li>与 JavaScript 属性一致，同时会更高效，且能预防跨站脚本（XSS）的安全漏洞</li><li>样式不会自动补齐浏览器私有前缀，除 <code>ms</code> 外，浏览器引擎前缀都应以大写字母开头</li><li>React 自动添加 “px” 后缀到内联样式为数字的属性<ul><li>本来没有单位的属性 <code>zoom</code>,<code>order</code>,<code>flex</code> 不会转换像素字符串</li><li>需使用 “px” 以外单位，请将值设为数字与所需单位组成的字符串</li></ul></li></ul></li><li>suppressContentEditableWaring<ul><li>禁止拥有子节点的元素比标记为 contentEditable 时 React 发出警告</li></ul></li><li>suprressHydrationWarning<ul><li>禁止 React 服务端渲染与客户端渲染不同内容时发出警告</li><li>只会对元素一级深度有效，应急方案使用，不过过度使用</li></ul></li><li>value<ul><li><code>&lt;input&gt;</code>,<code>&lt;select&gt;</code>,<code>&lt;textarea&gt;</code> 组件支持 <code>value</code> 属性</li><li>非受控组件使用 <code>dafaultValue</code> 属性设置组件第一次挂载时的 <code>value</code></li></ul></li></ul></li></ul><h3 id="React-是否支持自定义属性？"><a href="#React-是否支持自定义属性？" class="headerlink" title="React 是否支持自定义属性？"></a>React 是否支持自定义属性？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-5"><a href="#面试高频指数：★-★-☆-☆-☆-5" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>React 16 前会忽略未知的 DOM 属性。JSX 属性 React 无法识别，将被跳过</li><li>React 16 中任何未知的属性都会在 DOM 显示，适用于<ul><li>非标准属性</li><li>尝试实验中的 DOM 接口</li><li>集成第三方库或 Web Components</li></ul></li></ul><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><h3 id="React-父子组件通信有哪些方法？"><a href="#React-父子组件通信有哪些方法？" class="headerlink" title="React 父子组件通信有哪些方法？"></a>React 父子组件通信有哪些方法？</h3><h4 id="面试高频指数：★-★-★-★-★"><a href="#面试高频指数：★-★-★-★-★" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><ul><li>props<ul><li>父组件将需要传递的数据，更改 state 的方法或组件本身通过 props 传递给子组件</li><li>子组件通过 props 传来的回调函数向父组件传递数据或更改状态</li></ul></li><li>refs<ul><li>适合在典型数据流之外强制修改子组件的场景，例如<ul><li>管理焦点，文本选择或媒体播放</li><li>触发强制动画</li><li>集成第三方 DOM 库</li></ul></li><li>DOM refs 打破组件封装，ref 转发更改开发者预期<ul><li>应避免过度使用，用声明式实现和状态提升代替</li><li>一定要使用时，建议添加注释和说明</li></ul></li><li>被修改的子组件可以是 React 组件实例或 DOM 元素</li><li>包含向子组件添加 ref、回调 refs 和 ref 转发三种方式</li></ul></li><li>context<ul><li>适合在组件之间共享如地区偏好，主题等数据，避免逐层传递 props</li><li>存在 context 的 value 更新，内部所有消费组件都重新渲染问题</li><li>过度使用组件的状态与上下文相关，复用度降低</li></ul></li><li>事件订阅发布<ul><li>实现并使用 Event Bus<ul><li>在需要数据的组件监听自定义事件，并传入改变状态更新组件的回调函数</li><li>在获取数据的组件触发自定义事件，并传入数据，执行回调函数</li></ul></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Eventbus</span> &#123;<span class="hljs-title function_">constructor</span> () &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">fns</span> = []&#125;emit (type, ...args) &#123;<span class="hljs-keyword">const</span> fns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">fns</span>[type]<span class="hljs-keyword">if</span> (fns) fns.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args))&#125;addListener (type, fn) &#123;<span class="hljs-keyword">const</span> fns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">fns</span>[type]fns ? fns.<span class="hljs-title function_">push</span>(fn) : (<span class="hljs-variable language_">this</span>.<span class="hljs-property">fns</span>[type] = [fn])&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>使用 Node.js 的 events</code></pre></div><ul><li>使用状态管理，举例说明特点<ul><li>Redux<ul><li>单一数据源 store</li><li>state 只能通过 action 更改</li><li>使用 reducer 纯函数返回新 state 来更改 state</li></ul></li><li>Recoil<ul><li>任意地方灵活共享 state，并保持高性能</li><li>高效可靠地根据变化的 state 进行计算</li><li>支持持久化日志</li><li>支持 undo</li></ul></li><li>hox<ul><li>只有一个 API</li><li>使用 custom Hooks 定义 model</li><li>支持 TS</li><li>支持多数据源</li></ul></li></ul></li></ul><h3 id="为什么-React-是单向数据流？"><a href="#为什么-React-是单向数据流？" class="headerlink" title="为什么 React 是单向数据流？"></a>为什么 React 是单向数据流？</h3><h4 id="面试高频指数：★-★-★-☆-☆-3"><a href="#面试高频指数：★-★-★-☆-☆-3" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul><li>React 组件不关心其他组件是否有状态和类型<ul><li>父组件可以把它的 state 作为 props 向下传递它的子组件中</li><li>子组件通过 props 接收父组件的数据，不关心数据来源于父组件的 state 或 props</li></ul></li><li>React 中这种自上而下的数据传递被称为单向数据流<ul><li>状态 state 总是所属于特定的组件</li><li>状态 state 派生的任何数据和 UI 只能影响树中“低于”它们的组件</li></ul></li><li>单向数据流单向绑定无关，对比双向绑定<ul><li>坏处：需要绑定更多“样板”代码</li><li>好处：排除和隔离 bug 所需的工作量将会减少<ul><li>状态 state 只有其所在组件自身可修改</li><li>Bug 可以使用 React 开发者工具来检查问题组件的 props</li><li>按照组件树结构逐级向上搜寻，直到定位到负责更新 state 的组件</li></ul></li></ul></li></ul><h3 id="什么是-Context-？"><a href="#什么是-Context-？" class="headerlink" title="什么是 Context ？"></a>什么是 Context ？</h3><h4 id="面试高频指数：★-★-★-★-☆-1"><a href="#面试高频指数：★-★-★-★-☆-1" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul><li>Context 提供了一种无需为每层组件手动添加 props，能在组件树间进行数据传递的方法</li><li>Context 设计目的是共享或缓存组件树的全局数据，如用户认证，地区偏好，主题和语言</li><li>Context 应用场景是不同层级组件访问同样数据，副作用是降低组件的复用性</li><li>Context API<ul><li>React.createContext 创建 Context 对象，订阅该对象的组件从组件树中离自身最近的匹配的 Provider 中读取当前的 context 值</li><li>Context.Provider 接收 value 属性，当其发生变化时，内部所有消费组件都会重新渲染，忽略 shouldComponentUpdate 函数</li><li>Class.contextType 订阅单一 context，在任何生命周期中，使用 this.context 访问</li><li>Context.Consumer<ul><li>在函数式组件中订阅 context 的变更</li><li>需要一个函数作为子元素。函数接收当前 context 值，并返回一个 React 节点<ul><li>context 值由最近的 Provider 提供</li><li>没有 Provider 时等同于 createContext() 的 defaultValue</li></ul></li></ul></li><li>Context.displayName 指定组件在 DevToools 中显示的名称</li></ul></li></ul><h3 id="什么是-ContextType"><a href="#什么是-ContextType" class="headerlink" title="什么是 ContextType ?"></a>什么是 ContextType ?</h3><h4 id="面试高频指数：★-★-★-☆-☆-4"><a href="#面试高频指数：★-★-★-☆-☆-4" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ol><li>ContextType 用于订阅单一的 context</li></ol><ul><li><p>设置 class.contextType 为 React.createContext() 创建的 context 对象</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(defaultValue)<span class="hljs-keyword">class</span> <span class="hljs-title class_">NewClass</span> extend <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> &#123;<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>&#125;&#125;<span class="hljs-title class_">NewClass</span>.<span class="hljs-property">contextType</span> = <span class="hljs-title class_">MyContext</span></code></pre></div><ul><li><p>类组件参考 proposal-class-fields 提案</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> MyContext = React.createContext(defaultValue)<span class="hljs-keyword">class</span> <span class="hljs-title">NewClass</span> <span class="hljs-title">extend</span> <span class="hljs-title">React.Component</span> &#123;<span class="hljs-keyword">static</span> contextType = <span class="hljs-function">MyContext</span><span class="hljs-function"><span class="hljs-title">render</span>()</span> &#123;<span class="hljs-keyword">const</span> <span class="hljs-keyword">value</span> = <span class="hljs-keyword">this</span>.context&#125;&#125;</code></pre></div><ol><li>在 React 组件中，使用 this.context 访问通过 contextType 指定的 Context</li></ol><h3 id="如何优化-Context-？"><a href="#如何优化-Context-？" class="headerlink" title="如何优化 Context ？"></a>如何优化 Context ？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-6"><a href="#面试高频指数：★-★-☆-☆-☆-6" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>为什么要优化 Context ?</li></ul><p>Context 的 value 更新，它内部所有消费组件都会重新渲染，并且不受制于 shouldComponentUpdate 函数</p><ul><li>优化 Context 的方法<ul><li>避免使用对象字面量作为 value</li></ul></li></ul><p>context 使用参考标识（reference identity) 来决定渲染时机，当 Provider 接收 value 为对象字面量时，每次 value 都会被赋值新对象，建议将 value 状态提升到父节点的 state 里</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>拆分 Context</code></pre></div><p>将原来同一个 Context 频繁变化的值拆分出来，分别放入不同的 Context</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>记忆化</code></pre></div><p>使用 React.memo 或 useMemo 包裹组件，指定需要比较的值，只有值变化时重新渲染</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>使用 createContext 的第二参数，不稳定，不推荐</code></pre></div><p>createContext 为函数，两个形参分别为更新前后值，接收 Number 类型作为返回值</p><p>在订阅 context 变化的组件上，使用 unstable_observedBits 设置重新渲染组件的条件</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Consumer</span>, <span class="hljs-title class_">Provider</span> &#125; = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>, <span class="hljs-function">(<span class="hljs-params">prev, next</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (prev.<span class="hljs-property">value1</span> !== next.<span class="hljs-property">value1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><span class="hljs-keyword">if</span> (prev.<span class="hljs-property">value2</span> !== next.<span class="hljs-property">value2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>&#125;)<span class="hljs-keyword">const</span> <span class="hljs-title class_">Consumer1</span> =&gt; &#123; <span class="hljs-comment">// 只有当 value1 变化重新渲染</span><span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Consumer</span> <span class="hljs-attr">unstable_observedBits</span>=<span class="hljs-string">&#123;1&#125;</span> <span class="hljs-attr">children</span>=<span class="hljs-string">&#123;value</span> =&gt;</span> (</span><span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/&gt;</span></span>)&#125;/&gt;&#125;<span class="hljs-keyword">const</span> <span class="hljs-title class_">Consumer2</span> =&gt; &#123;<span class="hljs-comment">// 只有当 value2 变化重新渲染</span><span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Consumer</span> <span class="hljs-attr">unstable_oberverdBits</span>=<span class="hljs-string">&#123;10&#125;</span> <span class="hljs-attr">children</span>=<span class="hljs-string">&#123;value</span> =&gt;</span> (</span><span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/&gt;</span></span>)&#125;/&gt;&#125;* 使用第三方库    * use-context-selector        * 使用 createContext 创建支持 useContextSelector 的特殊 context        * 使用 useContextSelector 选择 context 某个值，当且仅当该值变化时，重新渲染    * <span class="hljs-title class_">React</span> <span class="hljs-title class_">Tracke</span></code></pre></div><h3 id="什么是-Ref-转发？"><a href="#什么是-Ref-转发？" class="headerlink" title="什么是 Ref 转发？"></a>什么是 Ref 转发？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-7"><a href="#面试高频指数：★-★-☆-☆-☆-7" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li><p>Ref 转发可以将</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">ref</span></code></pre></div><p>传递到子组件</p><ul><li>由 <code>React.forwardRef</code> 实现</li><li>向 <code>ref</code> 传入回调函数，函数第一参数是 React 组件实例或 HTML DOM 元素</li></ul></li><li><p>Ref 转发适合应用场景</p><ul><li>转发表单组件的 ref 到 DOM 节点，便于访问 DOM 节点，来管理焦点、选中或动画</li><li>在高阶组件内，转发外层组件的 ref 到 被包裹的组件</li></ul></li><li><p>Ref 转发更改了组件默认的 ref 指向，对组件使用者不可见，不建议使用</p><ul><li>不兼容之前同时使用组件和 ref 的应用</li><li>对组件使用者，ref 结果可能不符合直观预期</li></ul></li><li><p>由</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>forwardRef</code></pre></div><p>实现 Ref 转发，可以使用函数决定 ref 转发组件显示的内容</p><ul><li>设置传入 <code>React.forwardRef</code> 函数名称，例如</li></ul></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs reasonml">const newComponent = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>forward<span class="hljs-constructor">Ref(<span class="hljs-params">function</span> <span class="hljs-params">myName</span>(<span class="hljs-params">props</span>, <span class="hljs-params">ref</span>)</span> &#123;return &lt;innerComponent &#123;...props&#125; forwardedRef=&#123;<span class="hljs-built_in">ref</span>&#125; /&gt;&#125;)<span class="hljs-comment">// DevTools DisplayName: ForwardRef(myName)</span><span class="hljs-operator"></span><span class="hljs-operator">* </span>设置函数的 displayName 来包含被包裹组件的名称</code></pre></div><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> my<span class="hljs-constructor">Name(<span class="hljs-params">props</span>, <span class="hljs-params">ref</span>)</span> &#123;return &lt;innerComponent &#123;...props&#125; forwardedRef=&#123;<span class="hljs-built_in">ref</span>&#125;&#125;myName.displayName = &#x27;myDisplayName&#x27;const newComponent = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>forward<span class="hljs-constructor">Ref(<span class="hljs-params">myName</span>)</span><span class="hljs-comment">// DevTools DisplayName: ForwardRef(myDisplayName)</span></code></pre></div><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><h3 id="React-返回空对象有哪些方法？"><a href="#React-返回空对象有哪些方法？" class="headerlink" title="React 返回空对象有哪些方法？"></a>React 返回空对象有哪些方法？</h3><ul><li>false &#x2F; true &#x2F; null &#x2F; undefined 将被忽略，不被渲染</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> / <span class="hljs-literal">true</span> / <span class="hljs-literal">null</span> /<span class="hljs-literal">undefined</span>&#125;</code></pre></div><ul><li>React.Fragment &#x2F; &lt;&gt;</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span> /&gt;</span></span> <span class="hljs-regexp">/ &lt;/</span>&gt;&#125;</code></pre></div><h3 id="如何优化不必要的渲染？"><a href="#如何优化不必要的渲染？" class="headerlink" title="如何优化不必要的渲染？"></a>如何优化不必要的渲染？</h3><h4 id="面试高频指数：★-★-★-★-★-1"><a href="#面试高频指数：★-★-★-★-★-1" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><ul><li><p>优化状态 state</p><ul><li>避免使用多层嵌套对象作为 state，降低比较效率，提高比较难度<ul><li>如果超过3层，建议继续拆分组件，将每一层状态放置在更内层的组件中</li></ul></li><li>状态提升和隔离<ul><li>多个组件需要反映相同的变化数据，共享状态提升到最近的共同父组件</li><li>仅影响组件本身的状态隔离放置在组件内部<ul><li>状态管理库可以使用 Recoil，其使用 Atom 更灵活地管理状态</li></ul></li></ul></li><li>合并状态更新，分离计算和渲染<ul><li>出于性能考虑，React 可能会把多个 setState 调用合并成一个调用</li><li>如果状态更新后，需要根据新状态计算或判断，再更新状态<ul><li>那么更新计算前的状态引发的渲染很可能不必要</li><li>分离计算逻辑，先计算状态的最终值，直接更新状态到最终值</li></ul></li></ul></li></ul></li><li><p>优化属性 props</p><ul><li>除高阶组件等需保持接口一致的场景外，props 保持简单，仅与组件单一职责关联</li><li>避免使用多层嵌套对象作为 props，降低比较效率，提高比较难度</li><li>组件只关心自身相关的 props<ul><li>例如标识单选、复选的选中状态、列表的激活项<ul><li>为每一项添加是否选中，是否激活标识优于额外添加选中项，激活项列表属性</li></ul></li></ul></li><li>避免在 render 等渲染函数中重复创建对象和函数，先赋值到变量再引用<ul><li>避免使用对象字面量作为 props，每次 render 创建新对象，相应子组件重复渲染</li><li>避免使用匿名函数作为 props，每次 render 创建新函数，相应子组件重复渲染</li></ul></li></ul></li><li><p>先比较再更新</p><ul><li>类组件<ul><li>使用 PureComponent 执行一层浅比较 props 或 state，值变化时渲染</li><li>使用 shouldComponentUpdate 函数<ul><li>手动比较前后 props 或 state，返回 true 渲染，false 不渲染</li><li>若 state 为对象，使用不可变对象，简化并加速比较</li></ul></li></ul></li><li>函数式组件<ul><li>使用 React.memo 比较 props 再渲染组件<ul><li>不使用第二参数时，一层浅比较 props，变化时渲染</li><li>使用第二参数时，手动比较前后的 props，返回 false 渲染，true 不渲染</li></ul></li><li>使用 useMemo 指定依赖，细粒度渲染组件<ul><li>使用第二参数，传入依赖数组，当数组中的值发生变化时，更新返回值</li><li>通常包裹函数式组件的返回值，指定依赖的 props 或 state 的具体值</li><li>包裹任意需要复杂计算的函数，指定依赖的变量。能在同一组件中部分和多次使用</li></ul></li><li>使用 useCallback 避免函数重复创建引起渲染<ul><li>当函数式组件重新更新时，内部声明的函数可能会被重复创建<ul><li>将这些函数作为 props 传入的子组件会重复渲染</li><li>使用 useCallback 包裹函数，传入空数组，总是返回相同函数来避免重复创建引起的渲染</li></ul></li></ul></li></ul></li></ul></li><li><p>减少嵌套</p><ul><li>减少不必要的根组件<ul><li>返回一个组件列表数组</li><li>使用内置组件文档碎片<code>React.Fragement</code>或其缩写<code>&lt;&gt;</code></li></ul></li><li>谨慎使用 CSS-in-JS 方案<ul><li>Class + 样式表方案的渲染性能和 CSS 本身的复用度总体优于内联方案</li><li>避免仅为书写内联样式而频繁地创建嵌套组件</li></ul></li></ul></li><li><p>惰性渲染</p><ul><li><p>key 唯一</p><ul><li>使用唯一标识作为 key，而不是 索引，让 React 精确判断变化，复用不变元素</li></ul></li><li><p>条件渲染</p><ul><li>使用 <code>if</code>&#x2F;<code>else</code> 三元运算符或逻辑运算符，仅在条件满足时，渲染组件</li><li>渲染列表时，当条件不满足时，返回 null 或空组件，保留组件位置</li></ul></li><li><p>防抖和节流</p><ul><li><p>使用 <code>window.requestAnimationFrame</code> 或定时器构建防抖或节流函数</p></li><li><p>使用 <code>MutationObserver</code> 代替定时器</p></li><li><p>使用</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-built_in">Intersection</span> Observer</code></pre></div><p>代替</p><div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-built_in">window</span>.scroll</code></pre></div><ul><li>懒加载图片<ul><li>只渲染可视区域的图片</li></ul></li><li>懒加载 DOM<ul><li>只渲染可视区域的 DOM，如虚拟列表，商品详情<ul><li>虚拟列表库可以使用 react-virtualized 及其更新 react-window</li></ul></li></ul></li></ul></li></ul></li><li><p>异步路由</p></li></ul></li><li><p>优化 Context，减少 value 更新，内部所有消费组件的重新渲染</p><ul><li>拆分 Context<ul><li>将原属于同一 Context 的值拆分到不同的 Context</li></ul></li><li>记忆化<ul><li>使用 React.memo 或 useMemo 包裹组件，指定需要比较的值，只有值变化时重新渲染</li></ul></li><li>使用 createContext 的第二参数，不稳定，不推荐<ul><li>createContext 为函数，两个形参分别为更新前后值，接收 Number 类型作为返回值</li><li>在订阅 context 变化的组件上，使用 unstable_observedBits 设置重新渲染组件的条件</li></ul></li><li>使用第三方库<ul><li>use-context-selector</li><li>React Tracke</li></ul></li></ul></li></ul><h3 id="React-如何渲染-HTML-，有什么风险？"><a href="#React-如何渲染-HTML-，有什么风险？" class="headerlink" title="React 如何渲染 HTML ，有什么风险？"></a>React 如何渲染 HTML ，有什么风险？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-4"><a href="#面试高频指数：★-☆-☆-☆-☆-4" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li><p><code>dangerouslySetInnerHTML</code> 是 React 为浏览器 DOM 提供 <code>innerHTML</code> 的替换方案</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">newComponent</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">&#123;&#123;__html:</span> &#x27;&lt;<span class="hljs-attr">b</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>&#x27;&#125;&#125; /&gt;</span>&#125;</code></pre></div><ul><li>代码直接设置 HTML 存在风险，很容易无意中使用户暴露于跨站脚本（XSS）攻击</li><li>React 设计此替换方案，通过名称警示开发者</li></ul><h3 id="React-为什么要引入基于-Fiber-协调器的异步渲染？"><a href="#React-为什么要引入基于-Fiber-协调器的异步渲染？" class="headerlink" title="React 为什么要引入基于 Fiber 协调器的异步渲染？"></a>React 为什么要引入基于 Fiber 协调器的异步渲染？</h3><h4 id="面试高频指数：★-★-★-☆-☆-5"><a href="#面试高频指数：★-★-★-☆-☆-5" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul><li>在经典渲染模式下，React 一旦开始渲染一次更新，不能中断包括创建新 DOM 节点和运行组件中代码在内的工作，这种渲染方法为“阻塞渲染”</li><li>渲染阻塞响应用户输入和动画，使用防抖牺牲一定的响应即时性，使用节流降低更新频率，都不能提供最佳用户体验。</li><li>React 提供 Concurrent 模式，将人机交互研究的结果整合到真实 UI 中<ul><li>渲染可中断</li><li>有意的加载顺序<ul><li>React 可以在旧屏幕桑多停留一段时间，跳过不够好的加载状态，直接展示新屏幕</li></ul></li><li>并发，使用启发式方法决定更新紧急性，同时更新多个状态<ul><li>对于 CPU 密集型更新，例如创建新 DOM 节点和运行组件中代码，任意一个更急迫更新可以中断已经开始的渲染</li><li>对于 IO 密集型更新，例如从网络加载代码或数据，在全部数据到达前在内存中渲染，跳过令人不愉快的空白加载状态</li><li>对于超出屏幕显示的更新，延迟它的相关逻辑</li></ul></li></ul></li></ul><h3 id="什么是-React-Fiber"><a href="#什么是-React-Fiber" class="headerlink" title="什么是 React Fiber ?"></a>什么是 React Fiber ?</h3><h4 id="面试高频指数：★-★-☆-☆-☆-8"><a href="#面试高频指数：★-★-☆-☆-☆-8" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li><p>React 组件是数据的函数 <code>v = f(d)</code></p></li><li><p>计算机通过调用栈跟踪程序执行</p><ul><li>函数执行，栈会添加新堆栈结构，代表函数执行的事务</li><li>太多事务同时执行，会导致动画掉帧，用户输入无法及时响应</li><li>现代浏览器提供 API<ul><li><code>requestIdleCallback</code> 调度一个低优先级函数在空闲阶段执行</li><li><code>requestAnimationFrame</code> 调度一个高优先级函数在下一个动画帧执行</li></ul></li><li>需要自定义调用栈行为，来使用这些 API 优化 UI 渲染</li></ul></li><li><p>React Fiber 是专门为 React 组件实现的堆栈重构</p><ul><li><p>堆栈结构可以保存在内存中，手动调度和操作</p></li><li><p>单个 fiber 是虚拟的堆栈结构，对应一个组件实例</p><ul><li><p>包含组件及其输入、输出信息的 JavaScript 对象</p><ul><li><div class="code-wrapper"><pre><code class="hljs">type<pre><code class="hljs autohotkey">     是执行会被堆栈结构跟踪的函数  - 复合函数、组件类 class 或字符串- `key` 决定协调算法 Fiber 是否可重用- ```  child</code></pre></div> 指向- 类组件 class 的 `render` 方法返回值- 函数组件 的`return` 返回值</code></pre></li><li><div class="code-wrapper"><pre><code class="hljs">sibling<pre><code class="hljs markdown">     指向<span class="hljs-bullet">  -</span> 类组件 class 或函数组件返回数组，其中包含多个子节点的情况<span class="hljs-bullet">-</span> <span class="hljs-code">`return`</span> 返回父 fiber<span class="hljs-bullet">-</span> 属性，即函数参数，以下两者相等，则 fiber 可复用<span class="hljs-bullet">  -</span> <span class="hljs-code">`pendingProps`</span> fiber 开始时设置<span class="hljs-bullet">  -</span> <span class="hljs-code">`memoizedProps`</span> fiber 结束时设置<span class="hljs-bullet">-</span> <span class="hljs-code">```</span><span class="hljs-code">  pengdingWorkProiority</span></code></pre></div> 事务优先级数字- 0 表示 `NoWork`- 数字越大，优先级越低- 调度器使用该字段搜索下一个要执行的事务</code></pre></li><li><p>&#96;&#96;&#96;<br>alternate</p><div class="code-wrapper"><pre><code class="hljs autohotkey">  - `flush` 渲染输出结果到屏幕  - `work-in-progress` 进行中的 fiber 代表未返回堆栈结构的 fiber- ```  output</code></pre></div><ul><li><code>host component</code> 是 React 应用的叶子节点，浏览器环境是小写 HTML 标签</li><li>每个 fiber 输出结果由宿主组件创建，向上传递到整个树</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="React-Fiber-异步渲染分为哪几个阶段，对应生命周期是什么？"><a href="#React-Fiber-异步渲染分为哪几个阶段，对应生命周期是什么？" class="headerlink" title="React Fiber 异步渲染分为哪几个阶段，对应生命周期是什么？"></a>React Fiber 异步渲染分为哪几个阶段，对应生命周期是什么？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-9"><a href="#面试高频指数：★-★-☆-☆-☆-9" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>不同于 Stack renconciler，Fiber reconciler 过程分为两个阶段：</p><ul><li><p>render &#x2F; reconciliation 可中断阶段</p><ul><li><p>以 Fiber tree 为蓝本，每个 Fiber 为工作单元，自顶向下构造 workInProgress Tree</p><ul><li><p>判断节点是否需要更新</p><ul><li><p>需要更新，标记当前节点</p><ul><li><p>更新当前节点状态和属性</p></li><li><p>调用</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">shouldComponentUpdate</span></code></pre></div><ul><li><p>返回</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">ture</span></code></pre></div><p>需要更新</p><ul><li><p>调用</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">render</span></code></pre></div><ul><li>返回子节点，并创建对应 <code>fiber</code></li><li>无子节点</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>当前工作单元结束，返回副作用列表</p></li><li><p>检查 fiber 的 sibiling 或 child</p><ul><li>存在，作为下一个工作单元<ul><li>检查剩余可用时间<ul><li>有，立即开始下一个工作单元</li><li>无，等待下一次主线程空闲，开始下一个工作单元，通过 <code>requestIdleCallback</code> 实现</li></ul></li></ul></li><li>没有下一个工作单元，本阶段结束，进入 <code>pendingCommit</code> 状态</li></ul></li></ul></li><li><p><a href="https://leetcode.cn/leetbook/read/react-interview/nafqor/">∨∧Page 2</a></p></li><li><ul><li><a href="https://leetcode.cn/"><img src="/../imgs/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/logo-dark-cn.c42314a8.svg+xml" alt="logo"></a></li><li><a href="https://leetcode.cn/leetbook/">学习</a></li><li><a href="https://leetcode.cn/problemset/all/">题库</a></li><li><a href="https://leetcode.cn/circle/">讨论</a></li><li><a href="https://leetcode.cn/contest/">竞赛</a></li><li><a href="https://leetcode.cn/company/">求职</a></li><li>商店</li></ul></li><li></li><li></li><li></li><li><p><a href="https://leetcode.cn/problems/two-sum/">-</a></p></li><li><p><img src="/../imgs/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/avatar_1645205761.webp" alt="img"><img src="/../imgs/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/plus-light.594ca211.svg+xml" alt="img"></p></li><li><p><a href="https://leetcode.cn/leetbook/detail/react-interview/">返回</a></p></li><li></li></ul></li><li><p>commit 不可中断阶段</p><ul><li>执行副作用列表<ul><li>更新 DOM 树，更新 ref 指向</li><li>调用组件的生命周期函数或 useEffect 声明的钩子</li></ul></li></ul></li></ul><p>对应生命周期</p><ul><li>render &#x2F; reconciliation<ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>shouldComponentUpate</li><li>componentWillUpdate</li></ul></li><li>commit<ul><li>componentDidMount</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="React-组件有哪些生命周期方法？"><a href="#React-组件有哪些生命周期方法？" class="headerlink" title="React 组件有哪些生命周期方法？"></a>React 组件有哪些生命周期方法？</h3><h4 id="面试高频指数：★-★-★-☆-☆-6"><a href="#面试高频指数：★-★-★-☆-☆-6" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>React 每个组件都包含“生命周期”方法</p><p>开发者可以重写这些方法，便于在运行过程中特定阶段执行这些方法</p><ul><li>constructor(props)<ul><li>React 组件挂载之前调用</li><li>用于初始化 state 和 方法绑定，例如绑定事件处理函数的 this</li></ul></li><li>static getDerivedStateFromProps(props, state)<ul><li>React 组件调用 render 方法前，初始挂载及后续更新都会被调用</li><li>用于返回一个对象来更新 state，返回 null 不更新任何内容</li><li>每次渲染都会触发，包括父组件重新渲染以及组件本身调用 setState</li><li>以下场景不使用 getDerivedStateFromProps<ul><li>执行副作用应用 componentDidUpdate</li><li>prop 更改时重新计算某些数据，请使用 memoization helper 代替</li><li>prop 更改时“重置”某些 state<ul><li>请考虑使组件完全受控或使用 key 使组件完全不受控 代替</li></ul></li></ul></li></ul></li><li>shouldComponentUpdate(nextProps, nextState)<ul><li>props 或 state 发生变化时，渲染执行之前被调用</li><li>首次渲染及 forceUpdate() 调用，React 参考返回 true &#x2F; false，决定是否重新渲染</li></ul></li><li>render()<ul><li>class 组件中唯一必须实现的方法，纯函数，每次调用应返回相同结果</li><li>当 render 被调用时，它会检查 this.props 和 this.state 变化，并返回<ul><li>React 元素：通过 JSX 创建</li><li>数组或 fragements：使得 render 方法可以返回多个元素</li><li>Portals：可以渲染子节点到不同 DOM 子树</li><li>字符串或数值类型：可以在 DOM 中被渲染为文本节点</li><li>布尔类型或 null：什么都不渲染</li></ul></li></ul></li><li>getSnapshotBeforeUpdate(prevProps, prevState)<ul><li>在最近一次渲染输出（提交到 DOM 节点）之前调用</li><li>能在组件发生更改之前从 DOM 中捕获信息，例如滚动位置</li><li>此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate 的第三参数</li></ul></li><li>componentDidMount()<ul><li>组件挂载后（插入 DOM 树中），即首次渲染时，立即调用</li><li>适用于放置依赖 DOM 节点、网络请求获取数据、添加订阅等</li><li>可以直接调用 setState()，触发依赖于 DOM 节点大小或位置的渲染</li></ul></li><li>componentDidUpdate(prevProps, prevState, snapshot)<ul><li>组件更新后立即调用，首次渲染不会执行此方法</li><li>可以执行 DOM 操作，比较前后 props，网络请求</li><li>可以直接调用 setState()，它必须被包裹在一个条件语句里，避免死循环</li><li>如果组件实现了 getSnapshotBeforeUpdate() 生命周期，则生命周期的返回值将作为 componentDidUpdate 的第三个参数</li></ul></li><li>componentWillUnmount()<ul><li>组件卸载及销毁之前直接调用</li><li>用于执行必要的清理操作，清除定时器、取消网络请求以及在 componentDidMount() 中创建的订阅等</li><li>不应调用 setState()，避免组件永远不会重新渲染</li></ul></li></ul><h3 id="React-组件的生命周期可分为哪些阶段？"><a href="#React-组件的生命周期可分为哪些阶段？" class="headerlink" title="React 组件的生命周期可分为哪些阶段？"></a>React 组件的生命周期可分为哪些阶段？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-10"><a href="#面试高频指数：★-★-☆-☆-☆-10" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>React 组件的生命周期可以分为三个阶段</p><ul><li>“Render”阶段：纯净且不包含副作用，可能会被 React 暂停、中止或重新启动<ul><li>constructor(props)</li><li>getDerivedStateFromPorps(props, state)</li><li>shouldComponentUpdate(nextProps, nextState)</li><li>render()</li></ul></li><li>“Pre-commit”阶段：可以读取DOM<ul><li>getSnapshotBeforeUpdate(prevProps, prevState)</li></ul></li><li>“Commit”阶段：可以使用 DOM，运行副作用，安排更新<ul><li>挂载时：componentDidMount()</li><li>更新时：componentDidUpdate(prevProps, prevState, snapshot)</li><li>卸载时：componentWillUnmount()</li></ul></li></ul><h3 id="异步数据请求应在哪些生命周期里调用？"><a href="#异步数据请求应在哪些生命周期里调用？" class="headerlink" title="异步数据请求应在哪些生命周期里调用？"></a>异步数据请求应在哪些生命周期里调用？</h3><h4 id="面试高频指数：★-★-★-★-☆-2"><a href="#面试高频指数：★-★-★-★-☆-2" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul><li>通过网络请求获取数据或订阅数据更新<ul><li>componentDidMount()</li><li>原因<ul><li>首次挂载时执行</li><li>不会重复请求或订阅数据更新</li><li>无需条件不容易触发重复渲染</li></ul></li></ul></li><li>有条件地通过网络请求数据<ul><li>componentDidUpdate(prevProps, prevState, snapshot)</li><li>原因<ul><li>可对比更新前后的 props 或 states</li><li>设置条件<ul><li>当且仅当条件满足时，通过网络请求数据</li><li>避免触发重复渲染</li></ul></li></ul></li></ul></li><li>取消网络请求或者清除在 componentDidMount() 中创建的订阅<ul><li>componentWillUnmount()</li></ul></li></ul><h3 id="useEffect-useLayoutEffect-与生命周期的对应关系是？"><a href="#useEffect-useLayoutEffect-与生命周期的对应关系是？" class="headerlink" title="useEffect useLayoutEffect 与生命周期的对应关系是？"></a>useEffect useLayoutEffect 与生命周期的对应关系是？</h3><h4 id="面试高频指数：★-★-★-★-☆-3"><a href="#面试高频指数：★-★-★-★-☆-3" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><p>useLayoutEffect</p><ul><li>执行时机是组件挂载或更新之后，浏览器执行绘制之前<ul><li>与 componentDidMount + componentDidUpdate 一致</li></ul></li><li>支持返回清除函数，函数执行时机是组件卸载之前<ul><li>与 componentWillUnmout 一致</li></ul></li></ul><p>useEffect</p><ul><li>执行时机是组件挂载或更新之后，浏览器完成布局和绘制之后，在一个延迟事件中被调用<ul><li>与 componentDidMount + componentDidUpdate 不同</li></ul></li><li>支持返回清除函数，函数执行时机是组件卸载之前<ul><li>与 componentWillUnmout 一致</li></ul></li></ul><p>两者都适用于在函数组件主体内，即 React 渲染阶段改变 DOM，添加订阅，设置定时器，记录日志以及执行其他包含副作用的操作</p><p>优先使用 useEffect 避免阻塞视觉更新，只在需要读取 DOM 布局，在浏览器绘制前，同步触发重渲染的场景使用 useLayoutEffect</p><h3 id="在-constructor-中使用-super-的意义是？"><a href="#在-constructor-中使用-super-的意义是？" class="headerlink" title="在 constructor 中使用 super 的意义是？"></a>在 constructor 中使用 super 的意义是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-11"><a href="#面试高频指数：★-★-☆-☆-☆-11" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>JavaScript 中，super 指向父类构造函数，React 类组件可以是 React.Component 等</li><li>JavaScript 中，调用 super 前不能用 this。React 中不能声明 this.state 或读取 this.props</li><li>React 中，调用 super(props) 后，可以在 constructor 中访问 this.props</li><li>React 中，调用 super() 不传参，不能在 constructor 中访问 this.props<ul><li>React 在调用构造函数后，将 props 赋值到实例</li><li>可以在其他生命周期中，访问 this.props</li></ul></li><li>不调用 super，参考 proposal-class-fields 提案，可以将 state 等实例属性写在 class 内</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;state = &#123; time : <span class="hljs-number">0</span> &#125;&#125;</code></pre></div><h3 id="对比-React-Hook-与生命周期"><a href="#对比-React-Hook-与生命周期" class="headerlink" title="对比 React Hook 与生命周期"></a>对比 React Hook 与生命周期</h3><h4 id="面试高频指数：★-★-☆-☆-☆-12"><a href="#面试高频指数：★-★-☆-☆-☆-12" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li><p>什么是 React Hook</p><ul><li>React Hook 是 React 16.8 的新增特性</li><li>开发者可以在不编写 Class 的情况下使用 State 以及其他的 React 特性</li></ul></li><li><p>为什么要用 React Hook 代替拥有生命周期的类组件</p><ul><li><p>类组件的弊端</p><ul><li><p>组件之间复用状态逻辑很难</p><ul><li><p>React 没有提供将可复用性行为“附加”到组件的途径</p></li><li><p>使用</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">render props</span></code></pre></div><p>和</p><div class="code-wrapper"><pre><code class="hljs">高阶组件</code></pre></div><ul><li>需要重新组织组件结构，使得代码难以理解</li><li>形成“嵌套地域”，难以调试和维护</li></ul></li></ul></li><li><p>复杂组件变得难以理解</p><ul><li>组件被状态逻辑和副作用充斥</li><li>不相关逻辑被放在同一生命周期，相关逻辑被分散在不同生命周期<ul><li><code>componentDidMount</code>&#x2F;<code>componentDidUpdate</code> 获取数据</li><li><code>componentDidMount</code> 可能还包含事件监听，需在 <code>componentWillUnmount</code> 清除</li></ul></li><li>大量的状态逻辑，许多人使用状态管理库，组件复用和调试都比较困难</li></ul></li><li><p>难以理解的类组件</p><ul><li>大量的 this 绑定，较高学习成本，区分函数组件和类组件的使用场景</li><li>类组件会无意中鼓励开发者使用一些让 <code>Prepack</code> 等组件预编译优化措施无效的方案</li><li>类组件不能被很好的压缩，热重载不稳定，实例化类组件有轻微额外性能消耗</li></ul></li><li><p>有限的是否渲染控制</p><ul><li>使用 PureComponent 执行一层浅比较 props 或 state，值变化时渲染</li><li>使用 shouldComponentUpdate 函数<ul><li>手动比较前后 props 或 state，返回 true 渲染，false 不渲染</li><li>若 state 为对象，使用不可变对象，简化并加速比较</li></ul></li><li>在 setState 前设置判断条件，满足条件后再 setState</li></ul></li></ul></li><li><p>React Hook 解决的问题</p><ul><li>提高组件复用<ul><li>Hook 在无需修改组件结构的情况下，复用状态逻辑，共享 Hook 变得更便捷</li></ul></li><li>简化组件<ul><li>Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</li><li>非按照生命周期划分，可以使用 Reducer 来管理组件内部状态，使其更加可预测</li></ul></li><li>函数组件代替类组件<ul><li>Hook 在不使用类组件的情况下使用 State 以及其他的 React 特性</li><li>Hook 改造类组件为函数组件，容易理解 this 和学习，便于预编译等优化措施</li><li>Hook 拥抱函数式声明式编程，而无需学习复杂的函数式或响应式编程技术</li></ul></li><li>丰富的更细粒度的是否渲染控制<ul><li>使用 React.memo 比较 props 再渲染组件<ul><li>不使用第二参数时，一层浅比较 props，变化时渲染</li><li>使用第二参数时，手动比较前后的 props，返回 false 渲染，true 不渲染</li></ul></li><li>使用 useMemo 指定依赖，细粒度渲染组件<ul><li>使用第二参数，传入依赖数组，当数组中的值发生变化时，更新返回值</li><li>通常包裹函数式组件的返回值，指定依赖的 props 或 state 的具体值</li><li>包裹任意需要复杂计算的函数，指定依赖的变量。能在同一组件中部分和多次使用</li></ul></li><li>使用 useCallback 避免函数重复创建引起渲染<ul><li>当函数式组件重新更新时，内部声明的函数可能会被重复创建<ul><li>将这些函数作为 props 传入的子组件会重复渲染</li><li>使用 useCallback 包裹函数，传入空数组，总是返回相同函数来避免重复创建引起的渲染</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>React 元素的事件处理和 DOM 元素的不同点</p><ul><li>事件命名<ul><li>React：小驼峰式</li><li>DOM：纯小写</li></ul></li><li>事件处理函数传参<ul><li>React：接受函数</li><li>DOM：字符串</li></ul></li><li>阻止默认行为<ul><li>React：显式的使用 preventDefault</li><li>DOM：return false</li></ul></li><li>事件处理函数，第一参数 e<ul><li>React：e 是一个合成事件。React 根据 W3C 规范来定义合成事件</li><li>DOM：e &#x3D; window.event</li></ul></li><li>添加事件监听<ul><li>React：元素初始渲染的时候添加监听器</li><li>DOM：使用 addEventListener</li></ul></li><li>this 指向<ul><li>React：在 class 组件中，手动 bind this，使用匿名箭头函数或者 class fields 语法来让 this 指向组件本身</li><li>DOM：触发事件的目标对象</li></ul></li><li>向事件处理程序传递参数<ul><li>React：通过箭头函数和 Function.prototype.bind 来实现</li><li>DOM：经常通过 DOM attribute 传参，读取参数时，先获取目标对象，再获取目标对象的 attribute</li></ul></li><li>事件委托<ul><li>React：16 及更早版本，对大多数事件执行 <code>document.addEventListener()</code> 17 后调用 <code>rootNode.addEventListener()</code></li><li>DOM：自行添加事件委托</li></ul></li></ul><h3 id="什么是-React-合成事件？"><a href="#什么是-React-合成事件？" class="headerlink" title="什么是 React 合成事件？"></a>什么是 React 合成事件？</h3><h4 id="面试高频指数：★-★-★-★-☆-4"><a href="#面试高频指数：★-★-★-★-☆-4" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul><li>React 合成事件是浏览器的原生事件的跨浏览器包装器<ul><li>兼容所有浏览器</li><li>接口与浏览器原生事件相同，包括 <code>stopPropagation()</code> 和 <code>preventDefault()</code></li><li>合成事件实例将被传递给事件处理函数</li></ul></li><li>事件池<ul><li>React 16 及更早版本，合成事件是合并而来，放入事件池统一管理<ul><li>事件对象可能会被重用<ul><li>在事件回调函数被调用后，所有属性失效</li><li>不能通过异步访问事件属性</li></ul></li><li>异步访问事件属性<ul><li>调用 <code>e.persist()</code>，从事件池中移除合成事件，允许用户代码保留对事件的引用</li><li>通过实例的 <code>nativeEvent</code>属性来使用浏览器的底层事件</li></ul></li></ul></li><li>React 17 合成事件不再放入事件池<ul><li><code>e.persist()</code> 存在，但不再生效</li><li>可以通过异步访问事件属性</li></ul></li></ul></li><li>事件执行顺序<ul><li>原生事件先执行</li><li>合成事件后执行<ul><li>默认事件处理函数在冒泡阶段触发</li><li>注册捕获阶段事件处理函数，应为事件名添加 Capture</li></ul></li></ul></li><li>合成事件会冒泡<ul><li>React 16 及更早版本，冒泡绑定到 document 上</li><li>React 17，冒泡到 rootNode 上，onScroll 事件不再冒泡</li></ul></li></ul><h3 id="如何在-React-事件处理阻止默认行为？"><a href="#如何在-React-事件处理阻止默认行为？" class="headerlink" title="如何在 React 事件处理阻止默认行为？"></a>如何在 React 事件处理阻止默认行为？</h3><p>调用 <code>e.preventDefault</code> 阻止默认行为。</p><h3 id="如何解决-类组件-中，事件处理的-this-为-undefined-的问题？"><a href="#如何解决-类组件-中，事件处理的-this-为-undefined-的问题？" class="headerlink" title="如何解决 类组件 中，事件处理的 this 为 undefined 的问题？"></a>如何解决 类组件 中，事件处理的 this 为 undefined 的问题？</h3><ul><li>使用 Function.pototype.bind，添加事件处理函数时，给函数绑定 this</li><li>使用 public class fields 语法，可以使用 class fields 正确的绑定回调函数</li><li>使用 匿名回调函数 添加事件，不推荐，原因是<ul><li>匿名回调函数成为组件的 prop 传入子组件，可能导致额外的重新渲染</li></ul></li></ul><h3 id="如何传参给事件处理函数？"><a href="#如何传参给事件处理函数？" class="headerlink" title="如何传参给事件处理函数？"></a>如何传参给事件处理函数？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-5"><a href="#面试高频指数：★-☆-☆-☆-☆-5" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>两种方式</p><ul><li>箭头函数<ul><li>声明一个匿名箭头函数，在其中调用事件处理函数并传参</li><li>不推荐，原因是：<ul><li>匿名回调函数成为组件的 prop 传入子组件，可能导致额外的重新渲染</li></ul></li></ul></li><li>Function.pototype.bind<ul><li>bind 将返回一个新函数，新函数的 this 是 bind 的一个参数，其余参数将作为函数的参数，供调用时使用</li></ul></li></ul><h3 id="如何阻止事件处理函数被频繁调用？"><a href="#如何阻止事件处理函数被频繁调用？" class="headerlink" title="如何阻止事件处理函数被频繁调用？"></a>如何阻止事件处理函数被频繁调用？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-13"><a href="#面试高频指数：★-★-☆-☆-☆-13" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li><p>节流</p><ul><li>一定时间内一定调用一次事件处理函数</li><li>核心区别：定时器不重置</li><li>连续重复调用，定时器不重置，只有第一次调用生效，忽略后面调用</li><li>手写代码<ul><li>原生</li></ul></li></ul></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> throttle = (fn, delay) =&gt; &#123;let timer = <span class="hljs-literal">null</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span>timer = setTimeout(() =&gt; &#123;timer = <span class="hljs-literal">null</span>fn.apply(<span class="hljs-keyword">this</span>, args)&#125;, (delay + <span class="hljs-string">&#x27;&#x27;</span>) | <span class="hljs-number">0</span> || <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>)&#125;&#125;    * 原生  + React Hook</code></pre></div><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs zephir"><span class="hljs-keyword">const</span> useThrottle (<span class="hljs-function"><span class="hljs-keyword">fn</span>, <span class="hljs-title">delay</span>) =&gt; </span>&#123;<span class="hljs-keyword">const</span> ref = useRef(<span class="hljs-function"><span class="hljs-keyword">fn</span>)</span><span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">(<span class="hljs-params">()</span> =&gt; &#123;</span></span><span class="hljs-params"><span class="hljs-function">ref.current = fn</span></span><span class="hljs-params"><span class="hljs-function">&#125;)</span></span><span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-title">useCallback</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">throttle<span class="hljs-params">(<span class="hljs-params">(...args)</span> =&gt; ref.current<span class="hljs-params">(...args)</span>, delay)</span>,</span></span><span class="hljs-params"><span class="hljs-function">[delay]</span></span><span class="hljs-params"><span class="hljs-function">)</span></span><span class="hljs-function">&#125;</span></code></pre></div><ul><li><p>防抖</p><ul><li>一定时间内最多调用一次事件处理函数</li><li>核心区别：定时器重置</li><li>连续重复调用，定时器重置，只有最后一次调用生效，忽略前面调用</li><li>手写代码<ul><li>原生</li></ul></li></ul></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> debounce = (fn, delay) =&gt; &#123;let timer = <span class="hljs-literal">null</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<span class="hljs-keyword">if</span> (timer) clearTimeout(timer)timer = setTimeout(() =&gt; &#123;timer = <span class="hljs-literal">null</span>fn.apply(<span class="hljs-keyword">this</span>, args)&#125;, (delay + <span class="hljs-string">&#x27;&#x27;</span>) | <span class="hljs-number">0</span> || <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>)&#125;&#125;    * 原生 + React Hook</code></pre></div><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs zephir"><span class="hljs-keyword">const</span> useDebounce (<span class="hljs-function"><span class="hljs-keyword">fn</span>, <span class="hljs-title">delay</span>) =&gt; </span>&#123;<span class="hljs-keyword">const</span> ref = useRef(<span class="hljs-function"><span class="hljs-keyword">fn</span>)</span><span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">(<span class="hljs-params">()</span> =&gt; &#123;</span></span><span class="hljs-params"><span class="hljs-function">ref.current = fn</span></span><span class="hljs-params"><span class="hljs-function">&#125;)</span></span><span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-title">useCallback</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">debounce<span class="hljs-params">(<span class="hljs-params">(...args)</span> =&gt; ref.current<span class="hljs-params">(...args)</span>, delay)</span>,</span></span><span class="hljs-params"><span class="hljs-function">[delay]</span></span><span class="hljs-params"><span class="hljs-function">)</span></span><span class="hljs-function">&#125;</span></code></pre></div><h3 id="React-17-对事件处理做了哪些改进？"><a href="#React-17-对事件处理做了哪些改进？" class="headerlink" title="React 17 对事件处理做了哪些改进？"></a>React 17 对事件处理做了哪些改进？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-14"><a href="#面试高频指数：★-★-☆-☆-☆-14" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>更改事件委托<ul><li>更加安全地进行新旧版本 React 树嵌套，多版本都必须为 17 或更高版本<ul><li>React 16 及之前版本<ul><li>向 document 附加事件处理器</li><li>大多数事件执行 <code>document.addEventListener</code></li></ul></li><li>React 17<ul><li>向 React 树的根 DOM 容器附加事件处理器</li><li>大多数事件执行 <code>rootNode.addEventListener</code></li></ul></li></ul></li><li>React 嵌入使用其他技术构建的应用程序变得更加容易<ul><li>React 16 及之前版本<ul><li><code>e.stopPropagation()</code> 将被多 React 版本破坏，嵌套树结构中阻止了事件冒泡，但外部树依然能接收到它</li><li><code>e.stopPropagation()</code> 不会阻止其它技术构建应用的冒泡</li></ul></li><li>React 17 的事件冒泡更接近常规 DOM，更符合预期<ul><li><code>e.stopPropagation()</code> 将阻止多 React 版本的事件冒泡，包括前套树和外部树</li><li><code>e.stopPropagation()</code> 将阻止其它技术构建应用的冒泡</li></ul></li></ul></li></ul></li><li>对标浏览器<ul><li>React 16 及之前版本<ul><li><code>onScroll</code> 事件冒泡，<code>onFocus</code> 事件冒泡</li><li><code>onFocus</code> 和 <code>onBlur</code> 事件底层由 React 实现</li><li>捕获事件（例如 <code>onClickCapture</code>）由 React 实现</li></ul></li><li>React 17 与浏览器行为更接近，并提高了互操作性<ul><li><code>onScroll</code> 事件不再冒泡</li><li><code>onFoucs</code> 和 <code>onBlur</code> 事件底层切换为原生的 <code>focusin</code> 和 <code>focusout</code> 事件</li><li>捕获事件（例如 <code>onClickCapture</code>）现在使用的是实际浏览器中的捕获监听器</li></ul></li></ul></li><li>去除事件池<ul><li>React 16 及以前版本<ul><li>使用 event pooling（事件池）</li><li>重用不同事件的事件对象，以提高性能</li><li>所有事件字段会被重置为 <code>null</code>，必须调用 <code>e.persist()</code> 才能正确使用事件，或者读取需要的属性</li></ul></li><li>React 17 去除事件池，事件对象行为符合预期<ul><li>去除事件池</li><li>不再重用事件对象，避免对现代浏览器的负优化</li><li>所有事件对象不会被重置为 <code>null</code>，无需调用 <code>e.persist()</code>，使用和读取属性与原生事件一致。<code>e.persist()</code> 为兼容而保留，已无实际作用</li></ul></li></ul></li></ul><h2 id="样式管理"><a href="#样式管理" class="headerlink" title="样式管理"></a>样式管理</h2><h3 id="如何在-React-中使用样式？"><a href="#如何在-React-中使用样式？" class="headerlink" title="如何在 React 中使用样式？"></a>如何在 React 中使用样式？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-6"><a href="#面试高频指数：★-☆-☆-☆-☆-6" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li>Style<ul><li><code>style</code> 属性接收含有驼峰命名的 javaScript 对象</li><li>属性名与 JS DOM API 一致，防止 XSS</li><li>React 自动添加 px 后缀到内联样式为数字的属性之后</li><li><code>style</code> 多用于在渲染过程中添加动态计算的样式</li><li>从性能角度来说，通常不推荐将 <code>style</code> 属性作为设置元素样式的主要方式，应使用<code>className</code> 属性来引用外部 CSS 样式表中定义的 class</li></ul></li><li>Class<ul><li><code>className</code> 支持字符串</li><li><code>className</code> 支持大括号包裹的 JS 表达式</li></ul></li><li>CSS-in-JS<ul><li>CSS 由 JavaScript 生成而不是在外部文件中定义</li><li>常用的库包括styled-componentsemotion radium 和 aphrodite 等</li><li>React 对样式如何定义没有明确态度<ul><li>存在疑惑时，比较好的方式是使用 <code>*.css</code> 定义样式，通过 <code>className</code> 指定它们</li></ul></li></ul></li><li>动画<ul><li>渐变效果，可选 <code>React Transition Group</code></li><li>动画效果，可选 <code>React Motion</code> 和 <code>React Spring</code></li></ul></li></ul><h3 id="如何按条件加载样式？"><a href="#如何按条件加载样式？" class="headerlink" title="如何按条件加载样式？"></a>如何按条件加载样式？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-7"><a href="#面试高频指数：★-☆-☆-☆-☆-7" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li>Style</li></ul><p><code>style</code> 采用小驼峰命名属性的 JavaScript 对象，可以按照 JavaScript 对象的方式，有条件地改变属性名和属性值</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> style = &#123;[<span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">&#x27;fontSize&#x27;</span> : <span class="hljs-string">&#x27;lineHeight&#x27;</span>] : <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">12</span> : <span class="hljs-number">1</span>&#125; <span class="hljs-comment">// &#123; fontSize: 12 &#125;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;style&#125;</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> <span class="hljs-comment">// style=&quot;font-size: 12px&quot;</span>&#125;</code></pre></div><ul><li>Class</li></ul><p><code>className</code> 属性，可以传入 JavaScript 表达式，有条件改变的类名</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> className = <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">&#x27;menu-active&#x27;</span> : <span class="hljs-string">&#x27;menu&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;className&#125;</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> <span class="hljs-comment">// class=&quot;menu-active&quot;</span>&#125;</code></pre></div><ul><li>CSS-in-JS</li></ul><p>以styled-components 为例</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>模板字符串</code></pre></div><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = styled.<span class="hljs-property">button</span><span class="hljs-string">`</span><span class="hljs-string">background: <span class="hljs-subst">$&#123;props =&gt; props.primary ? <span class="hljs-string">&#x27;palevioletred&#x27;</span> : <span class="hljs-string">&#x27;white&#x27;</span>&#125;</span>,</span><span class="hljs-string">`</span> <span class="hljs-comment">// background: palevioletred</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>&#125;* <span class="hljs-title class_">JavaScript</span> 对象</code></pre></div><p>- </p><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = styled.<span class="hljs-title function_">div</span>(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> (&#123;<span class="hljs-attr">background</span>: props.<span class="hljs-property">primary</span> ? <span class="hljs-string">&#x27;palevioletred&#x27;</span> : <span class="hljs-string">&#x27;white&#x27;</span>&#125;)); <span class="hljs-comment">// background: palevioletred</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>&#125;</code></pre></div><h3 id="如何合并多个内联样式"><a href="#如何合并多个内联样式" class="headerlink" title="如何合并多个内联样式?"></a>如何合并多个内联样式?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-8"><a href="#面试高频指数：★-☆-☆-☆-☆-8" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p><code>style</code>采用小驼峰命名属性的 JavaScript 对象</p><p>任何合并 JavaScript 对象的方法都可以用于合并内联样式</p><ul><li><p>拓展运算符</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> backgroundStyle = &#123; <span class="hljs-attr">background</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<span class="hljs-keyword">const</span> colorStyle = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">...backgroundStyle</span>, <span class="hljs-attr">...colorStyle</span> &#125;&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;</code></pre></div><ul><li><p>Object.assign</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> backgroundStyle = &#123; <span class="hljs-attr">background</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<span class="hljs-keyword">const</span> colorStyle = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;Object.assign(backgroundStyle,</span> <span class="hljs-attr">colorStyle</span>)&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;</code></pre></div><ul><li><p>遍历赋值</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> backgroundStyle = &#123; <span class="hljs-attr">background</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<span class="hljs-keyword">const</span> colorStyle = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(colorStyle).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> backgroundStyle[key] = colorStyle[key])<span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;backgroundStyle&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;</code></pre></div><h3 id="如何模块化样式，如何避免样式名冲突-？"><a href="#如何模块化样式，如何避免样式名冲突-？" class="headerlink" title="如何模块化样式，如何避免样式名冲突 ？"></a>如何模块化样式，如何避免样式名冲突 ？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-15"><a href="#面试高频指数：★-★-☆-☆-☆-15" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>（1）什么是 CSS 模块化？</p><p>CSS 模块化是将 CSS 规则 拆分成相对独立的模块，便于开发者在项目中更有效率地组织 CSS</p><ul><li>管理层叠关系</li><li>避免命名冲突</li><li>提高复用度，减少冗余</li><li>便于维护或扩展</li></ul><p>CSS 模块化的方式</p><ul><li>基于文件拆分</li><li>不拆分但设置作用域</li><li>CSS in JS</li><li>内联样式、Shadow DOM 等</li></ul><p>无论哪种方式，核心都是通过 保证CSS类命名唯一，或者 避免命名使用内联样式，来模拟出CSS模块作用域的效果</p><p>（2）基于文件的 CSS 模块的加载</p><ul><li><code>&lt;link&gt;</code><br>将不同模块的 CSS 分文件存放，通过 <code>&lt;link&gt;</code> 标签按需引入</li><li><code>@import</code><br>@规则，将其它 CSS 嵌入当前 CSS<br>除现代浏览器外，也得到了 CSS 预处理器 Less、Sass 和 Stylus 的支持</li><li><code>import</code><br>在 Webpack 中，将 CSS 作为资源引入，通过 CSS Modules 生成独一无二的类名</li></ul><p>（3）CSS 模块化的实现方式</p><ul><li><p>分层拆分</p><p>将 CSS规则 分层存放，并约束不同层次间的命名规则</p><ul><li>SMACSS：按功能分成 Base Layout Module State Theme 五层</li><li>ITCSS：按从通用到具体分成 Settings Tools Generic Base Objects Components 七层</li></ul></li><li><p>分块拆分</p><p>将页面中视觉可复用的块独立出来，仅使用类选择器，并确保类名唯一</p><ul><li>OOCSS<ul><li>将盒模型规则与颜色、背景等主题规则拆分</li><li>将视觉可复用的块类名与页面结构解耦</li></ul></li><li>BEM<ul><li>将页面按 Block Element Modifier 划分</li><li>类名规则 block-name__element-name–modifier-name</li></ul></li></ul></li><li><p>原子化拆分</p><p>每个选择器只包含 1 个或少量属性，通过组合选择器定义复杂样式</p><ul><li>ACSS：属性名像函数，属性值像函数参数，像写内联样式一样组合类名</li><li>Utility-First CSS：提供一套可配置的 CSS 实用类库，使用时按需编译</li></ul></li><li><p>CSS in JS</p><ul><li>CSS Modules<ul><li>将 CSS 作为资源引入</li><li>根据内容的哈希字符串，计算出独一无二类名，CSS 规则 只对该类名下的元素生效</li></ul></li><li>styled-components Aphrodite Emotion 等<ul><li>通过 JS 创建包含属性定义的组件</li><li>生成独一无二的类名</li></ul></li><li>Radium 等<ul><li>通过 JS 创建包含属性定义的组件</li><li>生成内联样式</li></ul></li></ul></li><li><p>Shadow DOM<br>通过<code>attachShadow</code>给元素的影子DOM，附加<code>&lt;style&gt;</code>标签，其中规则不会影响外部元素。代表的框架有 Ionic 等</p></li></ul><p>（4）React 中的样式模块化</p><p>React 对样式如何定义，没有明确的态度，如果存在疑虑，比较好的方式是和平常一样，在一个单独的 <code>*.css</code> 定义你的样式，并通过 <code>className</code> 指定它们。此时，你可以参考 CSS 模块化的方案，通过文件或样式命名规则，来实现样式模块化</p><p>行内样式 <code>style</code> 是避免样式命名冲突的经典策略，但由于性能比 <code>className</code> 低，React 通常不推荐将 style 属性作为设置元素样式的主要方式。在多数情况下，应使用 <code>className</code> 属性来引用外部 CSS 样式表重定义的 <code>class</code>。<code>style</code> 在 React 应用中多用于在渲染过程中添加动态计算的样式</p><p>同样地，在 CSS-in-JS 中，早期有基于 <code>style</code> 实现的 Radium 库，现在比较流行的是基于随机 <code>className</code> 的 style-components 库，与之类似的有 Emotion 和 Glamor，还有面向愿意将 CSS 和 JavaScript 分开存放开发者的 JSS 等。</p><h2 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h2><h3 id="什么是-React-Hook"><a href="#什么是-React-Hook" class="headerlink" title="什么是 React Hook?"></a>什么是 React Hook?</h3><p>Hook 是 React 16.8 的新增特性</p><ul><li>允许开发者在函数组件里“钩入”React state 及生命周期等特性的函数<ul><li>React 内置如 useState、useEffect 等 Hook</li></ul></li><li>Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）<ul><li>非强制按照生命周期划分，避免每个生命周期包含不相关的逻辑</li></ul></li><li>开发者可以在不编写 class 的情况下使用 state 以及其他的 React 特性<ul><li>无需考虑 this，无需考虑函数和 class 组件的区别和应用场景</li><li>便于使用 Prepack 试验 component folding，使代码更易于优化</li><li>拥抱函数式编程</li></ul></li><li>Hook 和现有代码可以同时工作，渐进式地使用</li></ul><h3 id="什么是-State-Hook？"><a href="#什么是-State-Hook？" class="headerlink" title="什么是 State Hook？"></a>什么是 State Hook？</h3><h4 id="面试高频指数：★-★-★-☆-☆-7"><a href="#面试高频指数：★-★-★-☆-☆-7" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul><li>State Hook 允许开发者在 React 函数组件中添加 state 的 Hook</li><li>这种 Hook 在 React 的原生实现是 useState，它是一种函数调用时保存变量的方式，它与 class 里面的 this.state 提供的功能完全相同</li><li>useState 的唯一参数是初始 state，支持数字、字符串、对象等类型</li><li>useState 方法的返回值分别是当前 state 以及更新 state 的函数，使用数组解构获取赋值</li><li>state 只在组件首次渲染时创建，下次重新渲染时，返回当前的 state</li></ul><h3 id="什么是-Effect-Hook？"><a href="#什么是-Effect-Hook？" class="headerlink" title="什么是 Effect Hook？"></a>什么是 Effect Hook？</h3><h4 id="面试高频指数：★-★-★-☆-☆-8"><a href="#面试高频指数：★-★-★-☆-☆-8" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul><li>Effect Hook 允许开发者在函数组件中执行副作用操作，包括数据获取、设置订阅以及手动更改 React 组件中的 DOM。分为需要清除和不需要清除的</li><li>这种 Hook 在 React 的原生实现是 useEffect</li><li>useEfect 支持两个参数<ul><li>第一个参数为函数，默认在组件第一次渲染和每次更新、浏览器完成画面渲染之后执行，调用时机可以看作 class 组件的 componentDidMount、componentDidUpdate 生命周期 + 浏览器完成画面渲染时</li><li>第二个参数为数组，只有数组元素发生变化时，才会调用第一个参数的函数<ul><li>当第二个参数为空数组 [] 时，第一个参数的函数仅会在组件挂载和卸载时执行</li></ul></li></ul></li><li>useEffect 可以返回一个函数，用于移除订阅等副作用，区别 class 组件的 componetWillUnMount，React 会在执行当前 effect 之前对上一个 effect 进行清除</li><li>useEffect 放在最贱内部可以直接访问 state 和 props</li></ul><h3 id="如何清除-Effect-Hook-的副作用？"><a href="#如何清除-Effect-Hook-的副作用？" class="headerlink" title="如何清除 Effect Hook 的副作用？"></a>如何清除 Effect Hook 的副作用？</h3><h4 id="面试高频指数：★-★-★-★-☆-5"><a href="#面试高频指数：★-★-★-★-☆-5" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul><li>在 useEffect 的 effect 函数中，返回一个清除函数<ul><li>可以将添加和清除副作用的逻辑放在一起</li></ul></li><li>effect 在每次渲染的时候会执行，<ul><li>React 会在执行当前 effect 之前对上一个 effect 进行清除</li></ul></li></ul><h3 id="使用-Hook-需要遵循的规则是？"><a href="#使用-Hook-需要遵循的规则是？" class="headerlink" title="使用 Hook 需要遵循的规则是？"></a>使用 Hook 需要遵循的规则是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-16"><a href="#面试高频指数：★-★-☆-☆-☆-16" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>Hook 本质是 JavaScript 函数，使用 Hook 时需要遵循两条规则</p><ul><li>只在最顶层使用 Hook<ul><li>不要在循环，条件或嵌套函数中调用 Hook<ul><li>确保总在 React 函数的最顶层调用 Hook</li><li>确保 Hook 在每一次渲染都按照相同的顺序被调用<ul><li>多次的 useState 和 useEffect 调用中间保持 Hook 状态正确</li></ul></li></ul></li></ul></li><li>只在 React 函数中调用 Hook<ul><li>仅在 React 的函数组件，而不要在普通的 JavaScript 函数中调用 Hook</li><li>在自定义 Hook 中调用其他 Hook</li></ul></li></ul><h3 id="如何校验-Hook-是否遵循规则？"><a href="#如何校验-Hook-是否遵循规则？" class="headerlink" title="如何校验 Hook 是否遵循规则？"></a>如何校验 Hook 是否遵循规则？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-17"><a href="#面试高频指数：★-★-☆-☆-☆-17" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>React 提供了一个名为 eslint-plugin-react-hooks 的 ESLint 插件来校验 Hook 是否遵循规则</p><ul><li><p>安装</p></li><li><p>shell</p></li></ul><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> eslint-plugin-react-hooks -D</code></pre></div><ul><li><p>ESLint 配置</p></li><li><p>JSON</p></li></ul><div class="code-wrapper"><pre><code class="hljs awk">&#123;<span class="hljs-string">&quot;plugin&quot;</span>: [<span class="hljs-regexp">//</span> ...<span class="hljs-string">&quot;react-hooks&quot;</span>],<span class="hljs-string">&quot;rules&quot;</span>: &#123;<span class="hljs-regexp">//</span> ...<span class="hljs-string">&quot;react-hooks/rules-of-hooks&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-regexp">//</span> 检查 Hook 规则<span class="hljs-string">&quot;react-hooks/exhaustive-deps&quot;</span>: <span class="hljs-string">&quot;warn&quot;</span> <span class="hljs-regexp">//</span> 检查 effect 依赖&#125;&#125;</code></pre></div><h3 id="useMemo-和-useCallback-的区别是？"><a href="#useMemo-和-useCallback-的区别是？" class="headerlink" title="useMemo 和 useCallback 的区别是？"></a>useMemo 和 useCallback 的区别是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-18"><a href="#面试高频指数：★-★-☆-☆-☆-18" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>useMemo</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs reasonml">const memoizedValue = use<span class="hljs-constructor">Memo(()</span> =&gt; compute<span class="hljs-constructor">ExpensiveValue(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>, <span class="hljs-literal">[<span class="hljs-identifier">a</span>, <span class="hljs-identifier">b</span>]</span>)</code></pre></div><p>返回一个<code>memoized</code>值，把”创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销计算。<br>useCallback</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs reasonml">const memoizedCallback = use<span class="hljs-constructor">Callback(()</span> =&gt; &#123; <span class="hljs-keyword">do</span><span class="hljs-constructor">Something(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span> &#125;, <span class="hljs-literal">[<span class="hljs-identifier">a</span>, <span class="hljs-identifier">b</span>]</span>)</code></pre></div><p>返回一个<code>memoized</code>回调函数，把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。<br>useCallback 可看作函数组件的<code>shouldCompoentUpdate</code>，使用引用相等性避免非必要渲染</p><p>useCallback 返回的是函数，useMemo 返回的是值，也可以是函数</p><p>useCallback(fn, deps) 相当于 useMemo(() &#x3D;&gt; fn, deps)</p><h3 id="useReducer-和-useState-的区别是？"><a href="#useReducer-和-useState-的区别是？" class="headerlink" title="useReducer 和 useState 的区别是？"></a>useReducer 和 useState 的区别是？</h3><h4 id="面试高频指数：★-★-★-☆-☆-9"><a href="#面试高频指数：★-★-★-☆-☆-9" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>useReducer</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialArg, init)</code></pre></div><p>useReducer 是 useState 的替代方案，它接收一个形如<code>(state, action) =&gt; newState</code>的 reducer，返回当前的 state 及其配套的<code>dispatch</code>方法<br>useReducer 比 useState 更适用于某些场景</p><ul><li>state 逻辑较复杂，并且包含多个子值</li><li>下一个 state 依赖于之前的 state</li></ul><p>useReducer 第二个返回值是 dispatch 而不是回调函数</p><ul><li>可以向子组件传递 dispatch 而不是函数<ul><li>容易会触发深更新的组件做性能优化</li></ul></li></ul><h3 id="useLayoutEffect-和-useEffect-的区别是？"><a href="#useLayoutEffect-和-useEffect-的区别是？" class="headerlink" title="useLayoutEffect 和 useEffect 的区别是？"></a>useLayoutEffect 和 useEffect 的区别是？</h3><h4 id="面试高频指数：★-★-★-☆-☆-10"><a href="#面试高频指数：★-★-★-☆-☆-10" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>useLayoutEffect</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// add effect</span><span class="hljs-keyword">return</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// clean effect</span>&#125;&#125;)</code></pre></div><p>相同</p><ul><li>useLayoutEffect 的签名与 useEffect 相同</li><li>服务端渲染时，useLayoutEffect 和 useEffect 都无法在 Javascript 代码加载完成前执行<ul><li>服务端渲染组件引入 useLayoutEffect 触发 React 告警，解决<ul><li>使用 useEffect 替代 useLayoutEffect</li><li>或将该组件延迟到客户端渲染完成后再显示</li></ul></li></ul></li></ul><p>区别</p><ul><li>useLayoutEffect<ul><li>在所有 DOM 变更之后同步调用 effect，用来读取 DOM 布局并同步触发重渲染</li><li>在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新</li></ul></li><li>useEffect<ul><li>在所有 DOM 变更并且浏览器完成渲染后调用 effect</li><li>尽可能使用标准的 useEffect 以避免阻塞视觉更新<ul><li>只有 useEffect 有问题时，再尝试 useLayoutEffect</li></ul></li></ul></li></ul><h3 id="useRef-和-Refs-的区别是？"><a href="#useRef-和-Refs-的区别是？" class="headerlink" title="useRef 和 Refs 的区别是？"></a>useRef 和 Refs 的区别是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-19"><a href="#面试高频指数：★-★-☆-☆-☆-19" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>useRef</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">ref</span>Container = useRef(initialValue)</code></pre></div><p>useRef 返回一个可变的 ref 对象，其<code>.current</code>属性被初始化传入参数<code>initialValue</code><br>返回的 ref 对象在组件的整个生命周期保持不变</p><p>Refs</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;constructor(props) &#123;<span class="hljs-keyword">super</span>(props)<span class="hljs-keyword">this</span>.myRef = <span class="hljs-type">React</span>.createRef()&#125;render() &#123;<span class="hljs-keyword">return</span> &lt;div ref=&#123;<span class="hljs-keyword">this</span>.myRef&#125; /&gt;&#125;&#125;</code></pre></div><p>Refs 使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素<br>当 ref 被传递给 <code>render</code> 中的元素时，对节点的引用可以在 ref 的 <code>current</code> 属性中被访问</p><p>区别</p><p>useRef</p><ul><li><p>函数组件可用</p></li><li><p>用途多样，</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">useRef</span><span class="hljs-params">()</span></span></code></pre></div><p>创建一个普通 Javascript 对象，每次渲染时返回同一个 ref 对象</p><ul><li>可以在其<code>.current</code> 属性保存任何可变值</li></ul></li></ul><p>Refs</p><ul><li><p>class 组件或 HTML 元素，函数组件无实例，不可用</p></li><li><p>用途单一，</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-title">.current</span></code></pre></div><p>属性为实例的引用，根据节点的类型不同</p><ul><li>当 <code>ref</code> 属性用于 HTML 元素时，构造函数中使用 <code>React.createRef()</code> 创建的<code>ref</code>接收底层 DOM 元素作为 <code>current</code> 属性</li><li>当 <code>ref</code> 属性用于自定义 class 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性</li></ul></li></ul><h3 id="如何自定义-Hook？"><a href="#如何自定义-Hook？" class="headerlink" title="如何自定义 Hook？"></a>如何自定义 Hook？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-20"><a href="#面试高频指数：★-★-☆-☆-☆-20" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>（1）自定义 Hook 定义</p><p>自定义 Hook，是将组件逻辑提取到可重用的函数，它可以像 <code>render props</code> 和高阶组件来共享组件之间的状态逻辑，而不增加组件</p><p>（2）如何自定义 Hook</p><p>自定义 Hook 是一个函数，可以调用其他的 Hook</p><ul><li>名称以 “use” 开头，表示这是一个 Hook<ul><li>便于 React 判断函数函数内部是否包含对其内部 Hook 的调用</li><li>自动检查 Hook 是否违法 Hook 规则</li></ul></li><li>参数和返回可以自定义，可以像使用函数一样在不同 Hook 间传递信息</li><li>其中所有 state 和副作用完全隔离，每次调用 Hook，都会获取独立的 state</li></ul><p>将两个函数组件的共同的状态逻辑提取到自定义 Hook 中，自定义 Hook 是一种自然遵循 Hook 设计的约定，而不是 React 的特性</p><p>（3）自定义 Hook 作用</p><p>自定义 Hook 解决了以前在 React 组件中无法灵活共享逻辑的问题</p><p>自定义 Hook 可以用于表单处理、动画、订阅声明、计时器等场景</p><p>尽量避免过早地增加抽象逻辑，当函数组件代码行数增多时，可以通过自定义 Hook 简化代码逻辑，解决组件杂乱无章。</p><h3 id="是否有必要使用-Hook-API-重写所有类组件？"><a href="#是否有必要使用-Hook-API-重写所有类组件？" class="headerlink" title="是否有必要使用 Hook API 重写所有类组件？"></a>是否有必要使用 Hook API 重写所有类组件？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-9"><a href="#面试高频指数：★-☆-☆-☆-☆-9" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>不，React 推荐称为编写 React 组件的主要方式，并且提供了自定义 Hook 等 class 组件无法实现的功能，更利于自动代码优化。但是</p><ul><li>Hook 暂时不能覆盖 class 组件的所有场景，比如生命周期<code>getSnapshotBeforeUpdate</code>，<code>getDerivedStateFromError</code> 和 <code>componentDidCatch</code> 暂无 Hook 等价写法</li><li>没有计划从 React 中移除 class</li></ul><p>所以，React 鼓励写新组件的时候开始尝试 Hook，不推荐用 Hook 重写已有的 class，除非开发者本来就打算重写它们（例如：为了修复 bug）</p><h3 id="useState-返回更新-state-的函数是同步，还是异步的？"><a href="#useState-返回更新-state-的函数是同步，还是异步的？" class="headerlink" title="useState 返回更新 state 的函数是同步，还是异步的？"></a>useState 返回更新 state 的函数是同步，还是异步的？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-21"><a href="#面试高频指数：★-★-☆-☆-☆-21" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>useState 返回更新 state 函数式异步的，接收参数可以是新状态的值，也可以是回调函数</p><p>可以通过两种方式，获取上一个 state 的状态值</p><ul><li>回调函数的第一个参数是上一个状态的值，可以像使用 useReducer 的 reducer 函数一样，基于上一个 state 来生成新的 state</li><li>或者可以在 useEffect 或 useLayoutEffect 中获取更新后的状态，将 useEffect 或 useLayoutEffect 封装到自定义 Hook 同样有效</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="什么是-Virtual-DOM"><a href="#什么是-Virtual-DOM" class="headerlink" title="什么是 Virtual DOM ?"></a>什么是 Virtual DOM ?</h3><h4 id="面试高频指数：★-★-★-★-★-2"><a href="#面试高频指数：★-★-★-★-★-2" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><p>Virtual DOM 是一编程概念</p><ul><li>UI 以一种理想化的，或者说“虚拟的”表现形式被保存在内存中<ul><li>支持可以优化的 Diff 算法</li></ul></li><li>通过 ReactDOM 等类库使之与“真实的” DOM 同步，这一过程叫做协调<ul><li>支持优先级，并行可中断的协调策略</li><li>支持 ReactCanvas 和 ReactNative 等其他渲染方式，甚至非浏览器环境</li></ul></li></ul><p>Virtual DOM 赋予 React 声明式的 API</p><ul><li>告诉 React 希望让 UI 是什么状态，React 就确保 DOM 匹配该状态</li><li>开发者不必关心属性操作、事件处理和手动 DOM 更新这些构建应用程序必要的操作</li></ul><p>Virtual DOM 是一种模式，在 React 中</p><ul><li>Virtual DOM 通常与 React 元素关联，代表用户界面的对象</li><li>fibers 内部对象来存放组件树的附加信息</li><li>React Fiber 是协调引擎，主要目的是使 Virtual DOM 可以增量式渲染</li></ul><h3 id="什么是-React-Diff，对比-Vue-Diff-？"><a href="#什么是-React-Diff，对比-Vue-Diff-？" class="headerlink" title="什么是 React Diff，对比 Vue Diff ？"></a>什么是 React Diff，对比 Vue Diff ？</h3><h4 id="面试高频指数：★-★-★-★-★-3"><a href="#面试高频指数：★-★-★-★-★-3" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><p>虚拟 DOM 的 Diff 算法</p><ul><li>将新旧虚拟 DOM 看作两棵节点树，节点个数为 n<ul><li>左侧树的节点需要与右侧树的节点一一对比，需要 O(n²) 复杂度</li><li>删除未找到的节点，需要再找合适节点放到被删除位置，需要 O(n) 复杂度</li><li>添加新节点，需要 O(n) 复杂度</li></ul></li><li>综上，Diff 虚拟 DOM 的复杂度是 O(n³)</li></ul><p>React 基于以下两个假设的基础之上提出 O(n) 的启发式算法</p><ul><li>两个不同类型的元素会产生不同的树</li><li>可以通过设置 <code>key</code> 属性，来告知渲染哪些子元素在不同的渲染下可以保存不变</li></ul><p>React Diffing 算法</p><ul><li>Tree Diff<ul><li>对比两棵树时，首选比较两棵树的根节点。不同类型的根节点元素会有不同的形态<ul><li>根节点为不同类型的元素<ul><li>React 会拆卸原有的树并且建立起新的树</li><li>当卸载一棵树时<ul><li>对应的 DOM 节点会被销毁<ul><li>建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中</li></ul></li><li>组件实例将执行 <code>componentWillUnmount()</code> 方法</li></ul></li></ul></li><li>根节点为相同类型的元素<ul><li>React 会保留节点</li><li>仅比对及更新有改变的属性</li></ul></li><li>处理完根节点，React 继续对子节点进行递归</li></ul></li><li>通过 updateDepth 控制 Virtual Dom 树层级</li><li>只比较同一个父节点的子节点</li><li>通过删除和创建节点实现跨层级移动</li><li>避免跨层级移动，优先 CSS 控制显示隐藏</li></ul></li><li>Component Diff<ul><li>同类型组件<ul><li>组件实例会保持不变，因此可以在不同的渲染时保持 state 一致</li><li>React 将更新该组件实例的 props 以及保证与最新的元素保持一致</li><li>调用该实例的 <code>UNSAFE_componentWillReceiveProps</code>、 <code>UNSAFE_componentWillUpdate()</code> 以及 <code>componentDidUpdate()</code> 方法</li><li>调用 <code>render()</code> 方法，diff 算法将在之前的结果以及新的结果中进行递归</li><li>通过 shouldComponentUpdate、useMemo、useCallback 手动优化</li><li>不同类型组件，输出内容相似<ul><li>建议改成同一类型，避免重新渲染组件</li></ul></li></ul></li><li>不同类型组件<ul><li>删除和创建</li></ul></li></ul></li><li>Element Diff<ul><li>默认情况下，React 会同时遍历两个子元素的列表，递归 DOM 节点的子元素<ul><li>产生差异时，生成一个 mutation</li></ul></li><li>用 key 标识节点<ul><li>避免使用索引 index，而应使用例如 id 唯一标识来作为 key</li></ul></li><li>只顺序移动位置变到前面的节点</li><li>相同类型 React 元素，保留 DOM 节点，仅对比及更新改变的属性</li></ul></li></ul><p>Vue 2.x 优化 Diff 算法</p><ul><li>基本优化与 React 相同</li><li>pathNode<ul><li>新老节点相同，不更新</li><li>新老节点都是静态节点，key 相同<ul><li>新节点.elm &#x3D; 老节点.elm</li><li>新节点.componentInstance &#x3D; 老节点.componentInstance</li></ul></li><li>新老节点存在，不相同<ul><li>用 updateChildren 更新</li></ul></li></ul></li><li>updateChildren<ul><li>虚拟 DOM 双指针，真实 DOM 双指针，一一对应</li><li>两端到中间，直到虚拟 DOM 或真实 DOM，左指针 &gt; 右指针</li></ul></li></ul><p>Vue 3.x 优化 Diff 算法</p><ul><li>创建 VNode 确定类型，内容不会变化的 DOM 添加静态标记</li><li>在 mount &#x2F; patch 中用位运算判断 VNode 类型<ul><li>静态提升 hoistStatic<ul><li>不参与更新的元素，只创建一次，渲染时直接复用</li></ul></li><li>事件侦听器缓存 cacheHandlers<ul><li>缓存函数，不追踪变化，提升性能</li></ul></li></ul></li></ul><h3 id="什么是-React-Concurrent-模式"><a href="#什么是-React-Concurrent-模式" class="headerlink" title="什么是 React Concurrent 模式?"></a>什么是 React Concurrent 模式?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-10"><a href="#面试高频指数：★-☆-☆-☆-☆-10" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>Concurrent 模式是一组 React 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整</p><p>Concurrent 模式的特点包括</p><ul><li>可中断渲染<ul><li>中断一项正在执行的更新去做更重要的事情，然后再回到之前正在做的工作</li><li>减少防抖和节流在 UI 中的需求。因为渲染可以终端，不需要人为地延迟工作以避免卡顿</li></ul></li><li>有意的加载顺序<ul><li>React 首先在内存中准备新屏幕</li><li>之前，React 继续显示完全互动，带有内联加载指示器的旧屏幕</li><li>当新屏幕准备就绪之后，React 可以带我们跳转到新屏幕</li></ul></li><li>并发<ul><li>在 Concurrent 模式中，React 可以同时更新多个状态<ul><li>对于 CPU 密集更新（例如创建新的 DOM 节点和运行组件中的代码），并发意味着一个更急迫的更新可以“中断”已经开始的渲染</li><li>对于 IO 密集的更新（例如从网络加载代码或数据），并发意味着 React 甚至可以在全部数据到达之前就在内存中开始渲染</li></ul></li></ul></li></ul><p>Concurrent 模式的任务是帮助将人机交互研究的结果整合到真实的 UI 中</p><ul><li>避免在屏幕之间切换时显示过多的中间加载状态</li><li>对于用户输入、悬停、点击、页面转换等在内部使用不同的“优先级”，大致对应于人类感知研究中的交互类别</li></ul><p>Concurrent 模式的开启</p><ul><li><p>安装 React 实验版本</p></li><li><p>plain</p></li></ul><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install react@experimental react-dom@experimental</code></pre></div><ul><li>开启 Concurrent 模式<ul><li>blocking 模式：提供了 concurrent 模式的小部分功能，更接近于当前 React 的 legacy 模式<ul><li><code>ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)</code></li></ul></li><li>concurrent 模式：未来 React 默认开发模式<ul><li><code>ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code></li></ul></li></ul></li></ul><p>Concurrent 模式常用 API</p><ul><li>Suspense<ul><li>允许组件在渲染之前进行“等待”，并在等待时显示 fallback 的内容</li></ul></li><li>SuspenseList<ul><li>通过编排向用户显示这些组件的顺序，来帮助协调血多可以挂起的组件</li></ul></li><li>useTransition<ul><li>允许组件在切换到下一个界面之前等待内容加载，从而避免不必要的加载状态</li><li>允许组件将速度较慢的数据获取更新推迟到随后渲染，以便能够立即渲染更重要的更新</li></ul></li><li>useDeferredValue<ul><li>返回一个延迟响应的值，该值可能“延后”的最长时间为 timeoutMs</li><li>适合立即渲染用户输入内容，同时需要等待数据获取的内容，保持接口可响应性的场景</li></ul></li></ul><h3 id="什么是-Suspense"><a href="#什么是-Suspense" class="headerlink" title="什么是 Suspense ?"></a>什么是 Suspense ?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-11"><a href="#面试高频指数：★-☆-☆-☆-☆-11" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li>Suspense 让组件“等待”某个异步操作，直到该异步操作结束即可渲染</li><li>Suspense 不是一个数据请求的库，而是一个机制<ul><li>这个机制是用来给数据请求库向React通信说明某个组件正在读取的数据当前仍不可用</li><li>通信之后，React可以继续等待数据的返回并更新UI</li></ul></li><li>Suspense不是什么<ul><li>不是数据获取的一种实现</li><li>不是直接用于数据获取的客户端</li><li>不使数据获取与视图层代码耦合</li></ul></li><li>Suspense可做什么<ul><li>让数据获取库与React紧密整合</li><li>让开发者有针对性地安排加载状态的展示</li><li>它能够消除 raceconditions，避免由于代码运行顺序的错误假设而导致的bug<ul><li>不是等到响应报文被接收之后，才去更新 State</li><li>反过来，发出请求之后，马上更新 State（外加开始渲染）</li></ul></li></ul></li><li>Suspense 可以不必等到数据全部返回才开始渲染<ul><li>一发送网络请求，马上开始渲染<ul><li>读取的数据没获取完毕，组件会处于“挂起”状态</li><li>React 会跳过“挂起”组件，继续渲染组件树中的其他组件</li></ul></li><li>随着更多数据的到来，React 将尝试重新渲染，并且每次都可能渲染出更加完整的组件树</li></ul></li></ul><h3 id="React-如何定义任务的优先级？"><a href="#React-如何定义任务的优先级？" class="headerlink" title="React 如何定义任务的优先级？"></a>React 如何定义任务的优先级？</h3><h4 id="面试高频指数：★-★-★-☆-☆-11"><a href="#面试高频指数：★-★-★-☆-☆-11" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>任务优先级是产生更新对象之后，React去执行一个更新任务，这个任务的优先级</p><p>任务优先级被用来区分多个更新任务的紧急程度，对比前后两次更新的任务优先级</p><ul><li>后者 &gt; 前者，React会取消前者的任务调度</li><li>后者&#x3D;前者，React 会将同等优先级的更新收敛到一次任务中</li><li>后者 &lt; 前者，React会在前者更新完成后，再对后者发起任务调度</li></ul><p>简而言之，任务优先级存在的意义</p><ul><li>保证高优先级任务及时响应</li><li>收敛同等优先级的任务调度</li></ul><p>React定义的任务优先级分为三类</p><ul><li>同步优先级：React的 legacy 同步渲染模式产生的更新任务的优先级</li><li>同步批量优先级：React的 blocking模式产生的更新任务的优先级</li><li>Concurrent 模式优先级：对于用户输入、悬停、点击、页面转换等在内部使用不同的“优先级”，大致对应于人类感知研究中的交互类别</li></ul><p><code>LanePriority</code> 越大，优先级越高</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">export</span> const SyncLanePriority: LanePriority = <span class="hljs-number">17</span><span class="hljs-attribute">export</span> const SyncBatchedLanePriority: LanePriority = <span class="hljs-number">16</span><span class="hljs-attribute">const</span> InputDiscreteHydrationLanePriority: LanePriority = <span class="hljs-number">15</span><span class="hljs-attribute">export</span> const InputDiscreteLanePriority: LanePriority = <span class="hljs-number">14</span><span class="hljs-attribute">const</span> InputContinuousHydrationLanePriority: LanePriority = <span class="hljs-number">13</span><span class="hljs-attribute">export</span> const InputContinuousLanePriority: LanePriority = <span class="hljs-number">12</span><span class="hljs-attribute">const</span> DefaultHydrationLanePriority: LanePriority = <span class="hljs-number">11</span><span class="hljs-attribute">export</span> const DefaultLanePriority: LanePriority = <span class="hljs-number">10</span><span class="hljs-attribute">const</span> TransitionShortHydrationLanePriority: LanePriority = <span class="hljs-number">9</span><span class="hljs-attribute">export</span> const TransitionShortLanePriority: LanePriority = <span class="hljs-number">8</span><span class="hljs-attribute">const</span> TransitionLongHydrationLanePriority: LanePriority = <span class="hljs-number">7</span><span class="hljs-attribute">export</span> const TransitionLongLanePriority: LanePriority = <span class="hljs-number">6</span><span class="hljs-attribute">const</span> RetryLanePriority: LanePriority = <span class="hljs-number">5</span><span class="hljs-attribute">const</span> SelectiveHydrationLanePriority: LanePriority = <span class="hljs-number">4</span><span class="hljs-attribute">const</span> IdleHydrationLanePriority: LanePriority = <span class="hljs-number">3</span><span class="hljs-attribute">const</span> IdleLanePriority: LanePriority = <span class="hljs-number">2</span><span class="hljs-attribute">const</span> OffscreenLanePriority: LanePriority = <span class="hljs-number">1</span><span class="hljs-attribute">export</span> const NoLanePriority: LanePriority = <span class="hljs-number">0</span></code></pre></div><h3 id="什么是-Redux"><a href="#什么是-Redux" class="headerlink" title="什么是 Redux ?"></a>什么是 Redux ?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-12"><a href="#面试高频指数：★-☆-☆-☆-☆-12" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>Redux 是 JavaScript 应用的可预测状态容器</p><ul><li>可预测<ul><li>在不同环境（客户端、服务器和移动端）行为一致，易于测试</li></ul></li><li>集中<ul><li>集中应用状态和逻辑，支持撤销、重做和持久化</li></ul></li><li>可调试<ul><li>Redux DevTools 可以方便地跟踪应用的状态何时、何处、为什么及如何改变</li><li>Rddux 架构允许开发者记录更改，使用“时间旅行调试”，向服务器发送完整错误报告</li></ul></li><li>灵活<ul><li>Redux 可用于任何 UI 层，并拥有一个庞大的插件生态系统来满足您的需求</li></ul></li></ul><h3 id="Flux-和-Redux-的区别是？"><a href="#Flux-和-Redux-的区别是？" class="headerlink" title="Flux 和 Redux 的区别是？"></a>Flux 和 Redux 的区别是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-22"><a href="#面试高频指数：★-★-☆-☆-☆-22" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>Flux</p><ul><li>Flux 是用于构建用户界面的应用程序架构，通过单向数据流补充 React 可组合的视图组件</li><li>Flux 更像模式而非框架，没有任何硬依赖</li><li>Flux 架构的应用包含 4 部分<ul><li>Action<ul><li>通过 Action creators 创建</li><li>每个 Action 拥有 type 或类似属性</li><li>传递给 Dispatcher</li></ul></li><li>Dispatcher<ul><li>分发 Actions 给所有注册 Store 的回调函数</li></ul></li><li>Store<ul><li>接受 Action 更新数据后，触发 change 事件，通知 View</li><li>可以由多个 Store</li></ul></li><li>View 视图组件，即 Controller-View<ul><li>家庭 change 事件，从 Store 取回数据，将数据传递给子组件或更新组件状态</li><li>响应用户输入，生成新的 Action</li></ul></li></ul></li></ul><p>Redux</p><ul><li><p>Redux 是 JavaScript 应用的可预测状态容器</p></li><li><p>Redux 对不同框架都有完整实现，Facebook 官方推荐使用代替 Flux</p></li><li><p>Redux 架构与 Flux 基本一致，但做了简化</p><ul><li><p>State 只读，更改 State 的方式是返回新的对象，即引入 Reducer 纯函数</p></li><li><p>Action 与 Dispatcher ，只需返回包含 type 和 payload 属性的对象</p></li><li><p>Store</p><ul><li>唯一</li><li><code>createStore</code> 基于 Reducer 纯函数创建</li><li><code>store.dispatch()</code> 调用 Action</li></ul></li><li><p>View</p><ul><li><p>通过 <code>store.getState()</code> 获取最新状态</p></li><li><p>通过</p><div class="code-wrapper"><pre><code class="hljs gcode">store.subscribe<span class="hljs-comment">()</span></code></pre></div><p>订阅状态更新</p><ul><li><code>store.subscribe()</code> 返回函数可取消订阅</li></ul></li></ul></li></ul></li></ul><p>综上，Redux 与 Flux 都基于单向数据流，架构相似，但 Redux 默认应用只有唯一 Store，精简掉 Dispatcher，引入 Reducer 纯函数，通过返回新对象，而不是更改对象，更新状态。</p><p>对比 Flux 的官方实现，Redux 的 API 更简洁，并且提供了如 <code>combineReducers</code>等工具函数及 <code>React-Toolkit</code> 工具集，以及对状态的撤销、重做和持久化等更复杂的功能。提供如 <code>React-Redux</code> 等简化 Redux 与其他第三方库的连接。</p><p>Facebook 官方推荐在生产环境中使用代替 Flux。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML学习记录</title>
    <link href="/2023/01/28/HTML%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/28/HTML%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML5-简介"><a href="#HTML5-简介" class="headerlink" title="HTML5 简介"></a>HTML5 简介</h1><p>HTML5是HTML最新的修订版本，2014年10月由万维网联盟（W3C）完成标准制定。<br>HTML5的设计目的是为了在移动设备上支持多媒体。</p><h2 id="HTML5-的新特性"><a href="#HTML5-的新特性" class="headerlink" title="HTML5 的新特性"></a>HTML5 的新特性</h2><table><thead><tr><th align="center">绘画</th><th align="center">canvas</th></tr></thead><tbody><tr><td align="center">媒介</td><td align="center">video 和 audio</td></tr><tr><td align="center">本地离线存储</td><td align="center"></td></tr><tr><td align="center">新的特殊内容元素</td><td align="center">article、footer、header、nav、section</td></tr><tr><td align="center">表单控件</td><td align="center">calendar、date、time、email、url、search</td></tr></tbody></table><h1 id="HTML5概述"><a href="#HTML5概述" class="headerlink" title="HTML5概述"></a>HTML5概述</h1><h2 id="1-1、什么是HTML"><a href="#1-1、什么是HTML" class="headerlink" title="1.1、什么是HTML"></a>1.1、什么是HTML</h2><p>HTML（<strong>H</strong>yper<strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage，超文本标记语言）是用来描述网页的一种语言，它不是一种编程语言，而是一种<strong>标记</strong>语言。</p><h2 id="1-2、什么是HTML5"><a href="#1-2、什么是HTML5" class="headerlink" title="1.2、什么是HTML5"></a>1.2、什么是HTML5</h2><p>HTML5是构建Web内容的一种语言描述方式，HTML5是互联网的下一代标准，是构建以及呈现互联网内容的一种语言方式，被认为是互联网的核心技术之一。HTML产生于1990年，1997年HTML4成为互联网标准，并广泛应用于互联网应用的开发。</p><p>HTML5是Web中核心语言HTML的规范，用户使用任何手段进行网页浏览时看到的内容原本都是HTML格式的，在浏览器中通过一些技术处理将其转换成为了可识别的信息，HTML5在从前HTML4.01的基础上进行了一定的改进。</p><h2 id="1-3、本文重要说明"><a href="#1-3、本文重要说明" class="headerlink" title="1.3、本文重要说明"></a>1.3、本文重要说明</h2><p>由于HTML5只是在HTML的基础上进行了新增或者废弃一些标签或者特性，本文默认均为HTML5语法，被废弃的部分就不再提起，HTML一般用于描述网页的结构，所以一些样式和脚本方面的标签和属性以及关于JavaScript部分的特性也不再提及，重点在于梳理常用标签体系。</p><h2 id="1-4、浏览器的版本"><a href="#1-4、浏览器的版本" class="headerlink" title="1.4、浏览器的版本"></a>1.4、浏览器的版本</h2><p>现今浏览器的许多新功能都是从HTML5标准中发展而来的。目前常用的浏览器有IE、火狐、谷歌、Safari和Opera等等，通过对这些主流web浏览器的发展策略调查，发现它们都支持HTML5上采取了措施。</p><p><strong>（1）IE浏览器</strong></p><p>2010年3月16日，微软MIX10技术大会上宣布其推出的IE9浏览器已经支持HTML5。同时还声称，随后将会更多的支持HTML新标准和CSS3新特性。</p><p><strong>（2）FireFox浏览器</strong></p><p>2010年7月，Mozilla基金会发布了即将推出的Firefox4浏览器的第一个早期测试版，该版本中Firefox浏览器中进行了大幅改进，包括新的HTML5语法分析器，以及支持更多的HTML5语法分析器，以及支持更多的HTML5形式的控制等。从官方文档来看，Firefox4对HTML5是完全级别的支持。目前，包括在线视频，在线音频在内的多种应用都已经在版本中实现。</p><p><strong>（3）Google浏览器</strong></p><p>2010年2月19日，谷歌Gears项目经理通过微博宣布，谷歌将放弃对Gears浏览器插件项目的支持，以重点开发HTML5项目。据费特表示，目前在谷歌看来，Gears应用用于HTML5的诸多创新非常相似，并且谷歌一直积极发展HTML5项目。因此只要谷歌不断以加强网络标准的应用功能为工作重点，那么为Gears增加新功能就无太大意义了。另外，Gears面临的需求也在日益下降，这也是谷歌做出吊证的重要原因。</p><p><strong>（4）Safari浏览器</strong></p><p>2010年6月7日，苹果在开发者发布会公布Safari5，这款浏览器支持10个以上的HTML5新技术，包括全屏幕播放、HTML5视频、HTML5地理位置、HTML5切片元素、HTML5的可拖动属性、HTML5的形式验证、HTML5的Ruby、HTML5的Ajaxl.ishi和WebSocket字幕。</p><p><strong>（5）Opera浏览器</strong></p><p>2010年5月5日，Opera软件公司首席技术官，号称“CSS之父”的Hakon Wium Lie认为，HTML5和CSS3，将会是全球互联网发展的未来趋势，包括目前Opera在内的诸多浏览器厂商，纷纷研发HTML5的相关产品，web未来属于HTML5。</p><p>综上所述，目前这些浏览器纷纷朝着HTML5的方向迈进，HTML5的时代即将来临。</p><h2 id="1-5、选择开发工具"><a href="#1-5、选择开发工具" class="headerlink" title="1.5、选择开发工具"></a>1.5、选择开发工具</h2><ul><li><strong>Notepad++</strong><ul><li>官方地址：<a href="https://notepad-plus-plus.org/">点击打开</a></li><li>是否免费：免费</li></ul></li><li><strong>Visual Studio Code</strong><ul><li>官方地址：<a href="https://code.visualstudio.com/">点击打开</a></li><li>是否免费：免费</li></ul></li><li><strong>HBuilderX</strong><ul><li>官方地址：<a href="https://www.dcloud.io/hbuilderx.html">点击打开</a></li><li>是否免费：免费</li></ul></li><li><strong>Dreamweaver</strong><ul><li>官方地址：<a href="https://www.adobe.com/cn/products/dreamweaver.html">点击打开</a></li><li>是否免费：收费</li></ul></li><li><strong>Sublime Text</strong><ul><li>官方地址：<a href="http://www.sublimetext.com/">点击打开</a></li><li>是否免费：收费</li></ul></li><li><strong>Webstorm</strong><ul><li>官方地址：<a href="https://www.jetbrains.com/webstorm/">点击打开</a></li><li>是否免费：收费</li></ul></li></ul><p><strong>Webstorm</strong>为本文使用的工具，请自行购买激活，也可以使用以上的免费工具，安装步骤都较为简单，在此省略！</p><h1 id="HTML5语法"><a href="#HTML5语法" class="headerlink" title="HTML5语法"></a>HTML5语法</h1><h2 id="2-1、基本结构"><a href="#2-1、基本结构" class="headerlink" title="2.1、基本结构"></a>2.1、基本结构</h2><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="2-2、语法规范"><a href="#2-2、语法规范" class="headerlink" title="2.2、语法规范"></a>2.2、语法规范</h2><ul><li>HTML中不区分大小写，但是我们一般都使用小写</li><li>HTML中的注释不能嵌套</li><li>HTML标签必须结构完整，要么成对出现，要么自结束标签</li><li>HTML标签可以嵌套，但是不能交叉嵌套</li><li>HTML标签中的属性必须有值，且值必须加引号(双引号单引号都可以)</li></ul><h2 id="2-3、标签规范"><a href="#2-3、标签规范" class="headerlink" title="2.3、标签规范"></a>2.3、标签规范</h2><p><strong>单标签：</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">标签名</span> [<span class="hljs-attr">属性名</span>=<span class="hljs-string">属性值,...]</span>&gt;</span></code></pre></div><p><strong>成对标签：</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">标签名</span> [<span class="hljs-attr">属性名</span>=<span class="hljs-string">属性值,...]</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">标签名</span>&gt;</span></code></pre></div><h1 id="HTML5标签"><a href="#HTML5标签" class="headerlink" title="HTML5标签"></a>HTML5标签</h1><h2 id="3-1、标题标签"><a href="#3-1、标题标签" class="headerlink" title="3.1、标题标签"></a>3.1、标题标签</h2><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>这是一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>这是二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>这是三级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>这是四级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>这是五级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>这是六级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span></code></pre></div><h2 id="3-2、段落标签"><a href="#3-2、段落标签" class="headerlink" title="3.2、段落标签"></a>3.2、段落标签</h2><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><h2 id="3-3、链接标签"><a href="#3-3、链接标签" class="headerlink" title="3.3、链接标签"></a>3.3、链接标签</h2><p><strong>使用示例：</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>&gt;</span>打开百度，你就知道！<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><p><strong>常见属性：</strong></p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>href</td><td>URL</td><td>规定链接的目标 URL。</td></tr><tr><td></td><td>target</td><td>_blank</td></tr><tr><td>_parent</td><td></td><td></td></tr><tr><td>_self</td><td></td><td></td></tr><tr><td>_top</td><td></td><td></td></tr><tr><td>framename</td><td>规定在何处打开目标 URL。</td><td></td></tr><tr><td>仅在 href 属性存在时使用。</td><td></td><td></td></tr></tbody></table><h2 id="3-4、图像标签"><a href="#3-4、图像标签" class="headerlink" title="3.4、图像标签"></a>3.4、图像标签</h2><div class="code-wrapper"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;百度LOGO&quot;</span>&gt;</code></pre></div><h2 id="3-5、表格标签"><a href="#3-5、表格标签" class="headerlink" title="3.5、表格标签"></a>3.5、表格标签</h2><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1px&quot;</span> <span class="hljs-attr">cellpadding</span>=<span class="hljs-string">&quot;0px&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0px&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>表头一<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>表头二<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>表头三<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>表头四<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>单元格一<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>单元格二<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>单元格三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>单元格四<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre></div><h2 id="3-6、列表标签"><a href="#3-6、列表标签" class="headerlink" title="3.6、列表标签"></a>3.6、列表标签</h2><p><strong>无序列表：</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre></div><p><strong>有序列表：</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></code></pre></div><p><strong>自定义列表：</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>列表项<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>列表项<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>列表项<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span></code></pre></div><h2 id="3-7、分组标签"><a href="#3-7、分组标签" class="headerlink" title="3.7、分组标签"></a>3.7、分组标签</h2><div class="code-wrapper"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span>&gt;具体内容&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>具体内容<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><h2 id="3-8、语义标签"><a href="#3-8、语义标签" class="headerlink" title="3.8、语义标签"></a>3.8、语义标签</h2><p><strong>常见标签：</strong></p><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><header></td><td>规定文档或节的页眉。</td></tr><tr><td><footer></td><td>定义文档或节的页脚。</td></tr><tr><td><main></td><td>规定文档的主内容。</td></tr><tr><td><section></td><td>定义文档的节。</td></tr><tr><td><article></td><td>定义文档的文章。</td></tr><tr><td><aside></td><td>定义页面内容以外的内容。</td></tr><tr><td><nav></td><td>定义导航链接。</td></tr><tr><td><mark></td><td>定义重要的或强调的文本。</td></tr><tr><td><figure></td><td>规定自包含内容，比如图示、图表、照片、代码清单等。</td></tr><tr><td><figcaption></td><td>定义 <figure> 元素的标题。</td></tr><tr><td><details></td><td>定义用户能够查看或隐藏的额外细节。</td></tr><tr><td><summary></td><td>定义 <details> 元素的可见标题。</td></tr><tr><td><time></td><td>定义日期&#x2F;时间。</td></tr></tbody></table><p><strong>基本布局：</strong></p><p><img src="/../imgs/HTML%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/438a198f50ba388aa1fed83ff6bebb6d.png" alt="HTML5 语义元素"></p><h2 id="3-9、表单标签"><a href="#3-9、表单标签" class="headerlink" title="3.9、表单标签"></a>3.9、表单标签</h2><p><strong>常见标签：</strong></p><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><form></td><td>定义供用户输入的表单。</td></tr><tr><td><input></td><td>定义输入域。</td></tr><tr><td><label></td><td>定义了 <input> 元素的标签，一般为输入标题。</td></tr><tr><td><textarea></td><td>定义文本域 (一个多行的输入控件)。</td></tr><tr><td><fieldset></td><td>定义了一组相关的表单元素，并使用外框包含起来。</td></tr><tr><td><legend></td><td>定义了 <fieldset> 元素的标题。</td></tr><tr><td><select></td><td>定义了下拉选项列表。</td></tr><tr><td><optgroup></td><td>定义选项组。</td></tr><tr><td><option></td><td>定义下拉列表中的选项。</td></tr><tr><td><button></td><td>定义一个点击按钮。</td></tr><tr><td><datalist></td><td>指定一个预先定义的输入控件选项列表。</td></tr><tr><td><keygen></td><td>定义了表单的密钥对生成器字段。</td></tr><tr><td><output></td><td>定义一个计算结果。</td></tr></tbody></table><p><strong>案例演示：</strong></p><p>1、form、input、label演示</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>账户：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>密码：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><p>2、textarea演示</p><div class="code-wrapper"><pre><code class="hljs abnf">&lt;form action<span class="hljs-operator">=</span><span class="hljs-string">&quot;&quot;</span> method<span class="hljs-operator">=</span><span class="hljs-string">&quot;post&quot;</span>&gt;    &lt;textarea name<span class="hljs-operator">=</span><span class="hljs-string">&quot;mycontext&quot;</span> cols<span class="hljs-operator">=</span><span class="hljs-string">&quot;30&quot;</span> rows<span class="hljs-operator">=</span><span class="hljs-string">&quot;10&quot;</span>&gt;&lt;/textarea&gt;    &lt;input type<span class="hljs-operator">=</span><span class="hljs-string">&quot;submit&quot;</span>&gt;&lt;/form&gt;</code></pre></div><p>3、fieldset、legend、select、optgroup、option演示</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>请选择你的爱好：<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myhobby&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myhobby&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optgroup</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;运动&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;篮球&quot;</span>&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;足球&quot;</span>&gt;</span>足球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">optgroup</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optgroup</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;电子&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;看电影&quot;</span>&gt;</span>看电影<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;看电视&quot;</span>&gt;</span>看电视<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">optgroup</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><p>4、datalist演示</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">list</span>=<span class="hljs-string">&quot;browsers&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">datalist</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;browsers&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Internet Explorer&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Firefox&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Chrome&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Opera&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Safari&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">datalist</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><p>5、单选框演示</p><div class="code-wrapper"><pre><code class="hljs abnf">&lt;form action<span class="hljs-operator">=</span><span class="hljs-string">&quot;&quot;</span> method<span class="hljs-operator">=</span><span class="hljs-string">&quot;post&quot;</span>&gt;    &lt;input type<span class="hljs-operator">=</span><span class="hljs-string">&quot;radio&quot;</span> name<span class="hljs-operator">=</span><span class="hljs-string">&quot;sex&quot;</span> id<span class="hljs-operator">=</span><span class="hljs-string">&quot;male&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;male&quot;</span> checked&gt;    &lt;label for<span class="hljs-operator">=</span><span class="hljs-string">&quot;male&quot;</span>&gt;Male&lt;/label&gt;    &lt;input type<span class="hljs-operator">=</span><span class="hljs-string">&quot;radio&quot;</span> name<span class="hljs-operator">=</span><span class="hljs-string">&quot;sex&quot;</span> id<span class="hljs-operator">=</span><span class="hljs-string">&quot;female&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;female&quot;</span>&gt;    &lt;label for<span class="hljs-operator">=</span><span class="hljs-string">&quot;female&quot;</span>&gt;female&lt;/label&gt;&lt;/form&gt;</code></pre></div><p>6、复选框演示</p><div class="code-wrapper"><pre><code class="hljs abnf">&lt;form action<span class="hljs-operator">=</span><span class="hljs-string">&quot;&quot;</span> method<span class="hljs-operator">=</span><span class="hljs-string">&quot;post&quot;</span>&gt;    &lt;input type<span class="hljs-operator">=</span><span class="hljs-string">&quot;checkbox&quot;</span> name<span class="hljs-operator">=</span><span class="hljs-string">&quot;vehicle&quot;</span> id<span class="hljs-operator">=</span><span class="hljs-string">&quot;bike&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;bike&quot;</span>&gt;    &lt;label for<span class="hljs-operator">=</span><span class="hljs-string">&quot;bike&quot;</span>&gt;I have a bike&lt;/label&gt;    &lt;input type<span class="hljs-operator">=</span><span class="hljs-string">&quot;checkbox&quot;</span> name<span class="hljs-operator">=</span><span class="hljs-string">&quot;vehicle&quot;</span> id<span class="hljs-operator">=</span><span class="hljs-string">&quot;car&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;car&quot;</span>&gt;    &lt;label for<span class="hljs-operator">=</span><span class="hljs-string">&quot;car&quot;</span>&gt;I have a car&lt;/label&gt;&lt;/form&gt;</code></pre></div><h2 id="3-10、框架标签"><a href="#3-10、框架标签" class="headerlink" title="3.10、框架标签"></a>3.10、框架标签</h2><div class="code-wrapper"><pre><code class="hljs routeros">&lt;iframe <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://www.baidu.com&quot;</span> <span class="hljs-attribute">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;500px&quot;</span> <span class="hljs-attribute">height</span>=<span class="hljs-string">&quot;500px&quot;</span>&gt;&lt;/iframe&gt;</code></pre></div><h2 id="3-11、音频标签"><a href="#3-11、音频标签" class="headerlink" title="3.11、音频标签"></a>3.11、音频标签</h2><div class="code-wrapper"><pre><code class="hljs bash">&lt;audio controls&gt;    &lt;<span class="hljs-built_in">source</span> src=<span class="hljs-string">&quot;horse.ogg&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;audio/ogg&quot;</span>&gt;    &lt;<span class="hljs-built_in">source</span> src=<span class="hljs-string">&quot;horse.mp3&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;audio/mpeg&quot;</span>&gt;    您的浏览器不支持 Audio 标签。&lt;/audio&gt;</code></pre></div><h2 id="3-12、视频标签"><a href="#3-12、视频标签" class="headerlink" title="3.12、视频标签"></a>3.12、视频标签</h2><div class="code-wrapper"><pre><code class="hljs abnf">&lt;video width<span class="hljs-operator">=</span><span class="hljs-string">&quot;320&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;240&quot;</span> controls&gt;  &lt;source src<span class="hljs-operator">=</span><span class="hljs-string">&quot;movie.mp4&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;video/mp4&quot;</span>&gt;  &lt;source src<span class="hljs-operator">=</span><span class="hljs-string">&quot;movie.ogg&quot;</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;video/ogg&quot;</span>&gt;    您的浏览器不支持 Video 标签。&lt;/video&gt;</code></pre></div><h2 id="3-13、其它标签"><a href="#3-13、其它标签" class="headerlink" title="3.13、其它标签"></a>3.13、其它标签</h2><div class="code-wrapper"><pre><code class="hljs xml">水平线：<span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>换行：<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>粗体文本<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>计算机代码<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>强调文本<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>斜体文本<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">kbd</span>&gt;</span>键盘输入<span class="hljs-tag">&lt;/<span class="hljs-name">kbd</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>预格式化文本<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>更小的文本<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>重要的文本<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">abbr</span>&gt;</span>缩写词或者首字母缩略词<span class="hljs-tag">&lt;/<span class="hljs-name">abbr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span>联系信息<span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bdo</span>&gt;</span>文字方向<span class="hljs-tag">&lt;/<span class="hljs-name">bdo</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span>&gt;</span>从另一个源引用的部分<span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">cite</span>&gt;</span>工作的名称<span class="hljs-tag">&lt;/<span class="hljs-name">cite</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>删除的文本<span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ins</span>&gt;</span>插入的文本<span class="hljs-tag">&lt;/<span class="hljs-name">ins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>下标文本<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>上标文本<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span></code></pre></div><h2 id="3-14、头部标签"><a href="#3-14、头部标签" class="headerlink" title="3.14、头部标签"></a>3.14、头部标签</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><head></td><td>定义了文档的信息。</td></tr><tr><td><title></td><td>定义了文档的标题。</td></tr><tr><td><base></td><td>定义了页面链接标签的默认链接地址。</td></tr><tr><td><link></td><td>定义了一个文档和外部资源之间的关系。</td></tr><tr><td><meta></td><td>定义了HTML文档中的元数据。</td></tr><tr><td><script></td><td>定义了客户端的脚本文件。</td></tr><tr><td><style></td><td>定义了HTML文档的样式文件。</td></tr></tbody></table><h1 id="HTML5属性"><a href="#HTML5属性" class="headerlink" title="HTML5属性"></a>HTML5属性</h1><h2 id="4-1、属性概述"><a href="#4-1、属性概述" class="headerlink" title="4.1、属性概述"></a>4.1、属性概述</h2><p>HTML标签可以设置属性，属性总是以名称/值对的形式出现，比如：name=“value”，它的主要作用是控制或修饰标签。</p><h2 id="4-2、通用属性"><a href="#4-2、通用属性" class="headerlink" title="4.2、通用属性"></a>4.2、通用属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>accesskey</td><td>设置访问元素的键盘快捷键。</td></tr><tr><td>class</td><td>规定元素的类名（classname）。</td></tr><tr><td>contenteditable</td><td>规定是否可编辑元素的内容。</td></tr><tr><td>contextmenu</td><td>指定一个元素的上下文菜单。当用户右击该元素，出现上下文菜单。</td></tr><tr><td>data-*</td><td>用于存储页面的自定义数据。</td></tr><tr><td>dir</td><td>设置元素中内容的文本方向。</td></tr><tr><td>draggable</td><td>指定某个元素是否可以拖动。</td></tr><tr><td>dropzone</td><td>指定是否将数据复制，移动，或链接，或删除。</td></tr><tr><td>hidden</td><td>hidden 属性规定对元素进行隐藏。</td></tr><tr><td>id</td><td>规定元素的唯一 id。</td></tr><tr><td>lang</td><td>设置元素中内容的语言代码。</td></tr><tr><td>spellcheck</td><td>检测元素是否拼写错误。</td></tr><tr><td>style</td><td>规定元素的行内样式（inline style）。</td></tr><tr><td>tabindex</td><td>设置元素的 Tab 键控制次序。</td></tr><tr><td>title</td><td>规定元素的额外信息（可在工具提示中显示）。</td></tr><tr><td>translate</td><td>指定是否一个元素的值在页面载入时是否需要翻译。</td></tr></tbody></table><h1 id="HTML5事件"><a href="#HTML5事件" class="headerlink" title="HTML5事件"></a>HTML5事件</h1><h2 id="5-1、事件概述"><a href="#5-1、事件概述" class="headerlink" title="5.1、事件概述"></a>5.1、事件概述</h2><p>HTML事件可以触发浏览器中的行为，比方说当用户点击某个 HTML 元素时启动一段 JavaScript。</p><h2 id="5-2、窗口事件"><a href="#5-2、窗口事件" class="headerlink" title="5.2、窗口事件"></a>5.2、窗口事件</h2><p>由窗口触发该事件 (同样适用于 <body> 标签)：</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>onafterprint</td><td>script</td><td>在打印文档之后运行脚本。</td></tr><tr><td>onbeforeprint</td><td>script</td><td>在文档打印之前运行脚本。</td></tr><tr><td>onbeforeonload</td><td>script</td><td>在文档加载之前运行脚本。</td></tr><tr><td>onblur</td><td>script</td><td>当窗口失去焦点时运行脚本。</td></tr><tr><td>onerror</td><td>script</td><td>当错误发生时运行脚本。</td></tr><tr><td>onfocus</td><td>script</td><td>当窗口获得焦点时运行脚本。</td></tr><tr><td>onhashchange</td><td>script</td><td>当文档改变时运行脚本。</td></tr><tr><td>onload</td><td>script</td><td>当文档加载时运行脚本。</td></tr><tr><td>onmessage</td><td>script</td><td>当触发消息时运行脚本。</td></tr><tr><td>onoffline</td><td>script</td><td>当文档离线时运行脚本。</td></tr><tr><td>ononline</td><td>script</td><td>当文档上线时运行脚本。</td></tr><tr><td>onpagehide</td><td>script</td><td>当窗口隐藏时运行脚本。</td></tr><tr><td>onpageshow</td><td>script</td><td>当窗口可见时运行脚本。</td></tr><tr><td>onpopstate</td><td>script</td><td>当窗口历史记录改变时运行脚本。</td></tr><tr><td>onredo</td><td>script</td><td>当文档执行再执行操作（redo）时运行脚本。</td></tr><tr><td>onresize</td><td>script</td><td>当调整窗口大小时运行脚本。</td></tr><tr><td>onstorage</td><td>script</td><td>当 Web Storage 区域更新时（存储空间中的数据发生变化时）运行脚本。</td></tr><tr><td>onundo</td><td>script</td><td>当文档执行撤销时运行脚本。</td></tr><tr><td>onunload</td><td>script</td><td>当用户离开文档时运行脚本。</td></tr></tbody></table><h2 id="5-3、表单事件"><a href="#5-3、表单事件" class="headerlink" title="5.3、表单事件"></a>5.3、表单事件</h2><p>表单事件在HTML表单中触发 (适用于所有 HTML 元素，但该HTML元素需在form表单内)：</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>onblur</td><td>script</td><td>当元素失去焦点时运行脚本。</td></tr><tr><td>onchange</td><td>script</td><td>当元素改变时运行脚本。</td></tr><tr><td>oncontextmenu</td><td>script</td><td>当触发上下文菜单时运行脚本。</td></tr><tr><td>onfocus</td><td>script</td><td>当元素获得焦点时运行脚本。</td></tr><tr><td>onformchange</td><td>script</td><td>当表单改变时运行脚本。</td></tr><tr><td>onforminput</td><td>script</td><td>当表单获得用户输入时运行脚本。</td></tr><tr><td>oninput</td><td>script</td><td>当元素获得用户输入时运行脚本。</td></tr><tr><td>oninvalid</td><td>script</td><td>当元素无效时运行脚本。</td></tr><tr><td>onselect</td><td>script</td><td>当选取元素时运行脚本。</td></tr><tr><td>onsubmit</td><td>script</td><td>当提交表单时运行脚本。</td></tr></tbody></table><h2 id="5-4、键盘事件"><a href="#5-4、键盘事件" class="headerlink" title="5.4、键盘事件"></a>5.4、键盘事件</h2><p>通过键盘触发事件，类似用户的行为：</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>onkeydown</td><td>script</td><td>当按下按键时运行脚本。</td></tr><tr><td>onkeypress</td><td>script</td><td>当按下并松开按键时运行脚本。</td></tr><tr><td>onkeyup</td><td>script</td><td>当松开按键时运行脚本。</td></tr></tbody></table><h2 id="5-5、鼠标事件"><a href="#5-5、鼠标事件" class="headerlink" title="5.5、鼠标事件"></a>5.5、鼠标事件</h2><p>通过鼠标触发事件，类似用户的行为：</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>onclick</td><td>script</td><td>当单击鼠标时运行脚本</td></tr><tr><td>ondblclick</td><td>script</td><td>当双击鼠标时运行脚本</td></tr><tr><td>ondrag</td><td>script</td><td>当拖动元素时运行脚本</td></tr><tr><td>ondragend</td><td>script</td><td>当拖动操作结束时运行脚本</td></tr><tr><td>ondragenter</td><td>script</td><td>当元素被拖动至有效的拖放目标时运行脚本</td></tr><tr><td>ondragleave</td><td>script</td><td>当元素离开有效拖放目标时运行脚本</td></tr><tr><td>ondragover</td><td>script</td><td>当元素被拖动至有效拖放目标上方时运行脚本</td></tr><tr><td>ondragstart</td><td>script</td><td>当拖动操作开始时运行脚本</td></tr><tr><td>ondrop</td><td>script</td><td>当被拖动元素正在被拖放时运行脚本</td></tr><tr><td>onmousedown</td><td>script</td><td>当按下鼠标按钮时运行脚本</td></tr><tr><td>onmousemove</td><td>script</td><td>当鼠标指针移动时运行脚本</td></tr><tr><td>onmouseout</td><td>script</td><td>当鼠标指针移出元素时运行脚本</td></tr><tr><td>onmouseover</td><td>script</td><td>当鼠标指针移至元素之上时运行脚本</td></tr><tr><td>onmouseup</td><td>script</td><td>当松开鼠标按钮时运行脚本</td></tr><tr><td>onmousewheel</td><td>script</td><td>当转动鼠标滚轮时运行脚本</td></tr><tr><td>onscroll</td><td>script</td><td>当滚动元素的滚动条时运行脚本</td></tr></tbody></table><h2 id="5-6-媒体事件"><a href="#5-6-媒体事件" class="headerlink" title="5.6 媒体事件"></a>5.6 媒体事件</h2><p>通过视频（videos），图像（images）或音频（audio） 触发该事件，多应用于HTML媒体元素比如：<embed>，<object>，<img>，<audio>和<video>。</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>onabort</td><td>script</td><td>当发生中止事件时运行脚本。</td></tr><tr><td>oncanplay</td><td>script</td><td>当媒介能够开始播放但可能因缓冲而需要停止时运行脚本。</td></tr><tr><td>oncanplaythrough</td><td>script</td><td>当媒介能够无需因缓冲而停止即可播放至结尾时运行脚本。</td></tr><tr><td>ondurationchange</td><td>script</td><td>当媒介长度改变时运行脚本。</td></tr><tr><td>onemptied</td><td>script</td><td>当媒介资源元素突然为空时（网络错误、加载错误等）运行脚本。</td></tr><tr><td>onended</td><td>script</td><td>当媒介已抵达结尾时运行脚本。</td></tr><tr><td>onerror</td><td>script</td><td>当在元素加载期间发生错误时运行脚本。</td></tr><tr><td>onloadeddata</td><td>script</td><td>当加载媒介数据时运行脚本。</td></tr><tr><td>onloadedmetadata</td><td>script</td><td>当媒介元素的持续时间以及其他媒介数据已加载时运行脚本。</td></tr><tr><td>onloadstart</td><td>script</td><td>当浏览器开始加载媒介数据时运行脚本。</td></tr><tr><td>onpause</td><td>script</td><td>当媒介数据暂停时运行脚本。</td></tr><tr><td>onplay</td><td>script</td><td>当媒介数据将要开始播放时运行脚本。</td></tr><tr><td>onplaying</td><td>script</td><td>当媒介数据已开始播放时运行脚本。</td></tr><tr><td>onprogress</td><td>script</td><td>当浏览器正在取媒介数据时运行脚本。</td></tr><tr><td>onratechange</td><td>script</td><td>当媒介数据的播放速率改变时运行脚本。</td></tr><tr><td>onreadystatechange</td><td>script</td><td>当就绪状态（ready-state）改变时运行脚本。</td></tr><tr><td>onseeked</td><td>script</td><td>当媒介元素的定位属性不再为真且定位已结束时运行脚本。</td></tr><tr><td>onseeking</td><td>script</td><td>当媒介元素的定位属性为真且定位已开始时运行脚本。</td></tr><tr><td>onstalled</td><td>script</td><td>当取回媒介数据过程中（延迟）存在错误时运行脚本。</td></tr><tr><td>onsuspend</td><td>script</td><td>当浏览器已在取媒介数据但在取回整个媒介文件之前停止时运行脚本。</td></tr><tr><td>ontimeupdate</td><td>script</td><td>当媒介改变其播放位置时运行脚本。</td></tr><tr><td>onvolumechange</td><td>script</td><td>当媒介改变音量亦或当音量被设置为静音时运行脚本。</td></tr><tr><td>onwaiting</td><td>script</td><td>当媒介已停止播放但打算继续播放时运行脚本。</td></tr></tbody></table><h2 id="5-7、其它事件"><a href="#5-7、其它事件" class="headerlink" title="5.7、其它事件"></a>5.7、其它事件</h2><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>onshow</td><td>script</td><td>当 <menu> 元素在上下文显示时触发。</td></tr><tr><td>ontoggle</td><td>script</td><td>当用户打开或关闭 <details> 元素时触发。</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习路线</title>
    <link href="/2023/01/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2023/01/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p><strong>HTML &#x2F; CSS &#x2F; JavaScript 基础学习</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web">《Web 入门》</a> MDN 权威入门指南，HTML &#x2F; CSS &#x2F; JavaScript 快速上手</li><li><a href="https://leetcode-cn.com/leetbook/detail/html-css-interview/">《CSS 世界》</a> 讲解细腻，拓展延伸对 CSS 的认识</li><li><a href="https://leetcode.cn/link/?target=https://zh.javascript.info">《现代 JavaScript 教程》</a> 线上教程，简单明了，时效性强</li><li>《JavaScript 高级程序设计》 传说中的红宝书</li><li>《JavaScript 权威指南》 传说中的犀牛书</li></ul><p><strong>jQuery &#x2F; ES6+ &#x2F; 正则 &#x2F; Canvas 进阶学习</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://jquery.cuishifeng.cn">《jQuery 中文文档》</a> 翻译完整，结构清晰</li><li><a href="https://leetcode.cn/link/?target=https://es6.ruanyifeng.com/">《ES6 入门教程》</a> 线上教程，很多前端学习 ES6 的起点和字典</li><li><a href="https://leetcode.cn/link/?target=https://deerchao.cn/tutorials/regex/regex.htm">《正则表达式 30 分钟入门教程》 </a>30 分钟从入门到掌握正则的使用</li><li>《Web 前端开发精品课 HTML5 Canvas 开发详解》图文并茂，代码示例丰富</li><li><a href="https://leetcode-cn.com/leetbook/detail/javascript-interview/">《前端通关手册：JavaScript》</a> 大量面试真题检测 JavaScript 掌握水平</li></ul><p><strong>工程化及框架应用学习</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://nodejs.org/zh-cn/docs/">《Node.js 中文文档》</a></li><li><a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/concepts/">《Webpack 中文文档》</a></li><li><a href="https://leetcode.cn/link/?target=https://cn.vuejs.org/v2/guide/">《Vue.js 中文文档》</a> Vue &#x2F; React &#x2F; Angular 新手建议顺序阅读</li><li><a href="https://leetcode.cn/link/?target=https://zh-hans.reactjs.org/docs/getting-started.html">《React 中文文档》</a></li><li><a href="https://leetcode.cn/link/?target=https://angular.cn/docs">《Angular 中文文档》</a></li></ul><p><strong>网络学习</strong></p><ul><li><a href="https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/">《计算机网络面试突击》</a> 从面试出发学习计算机网络和协议相关知识</li><li><a href="https://leetcode-cn.com/leetbook/detail/illustrate-http/">《图解 HTTP》</a> 172 张图解轻松入门。从基础知识到最新动向，一本书掌握 HTTP 协议</li></ul><p><strong>算法和数据结构及设计模式学习</strong></p><ul><li>《我的第一本算法书》 481 张步骤图详解 26 个算法和 7 个数据结构的基本原理</li><li><a href="https://leetcode-cn.com/leetbook/detail/learn-data-sturcture-in-7-chapters/">《七章刷完数据结构》</a> 学透方法，高效掌握数据结构</li><li><a href="https://leetcode-cn.com/leetbook/detail/grokking-algorithms/">《算法图解》</a> 像小说一样有趣的算法入门书</li><li><a href="https://leetcode-cn.com/leetbook/detail/learning-algorithms-with-leetcode/">《零起步学算法》</a> 以初学者视角，重点讲解算法与数据结构的设计思想</li><li><a href="https://leetcode-cn.com/leetbook/detail/high-frequency-algorithm-exercise/">《高频算法实战》</a> 进阶版算法与数据结构教程，追踪原理，融会贯通</li><li><a href="https://leetcode-cn.com/leetbook/detail/design-patterns/">《深入浅出设计模式》</a> 用生动的例子详解 23 种设计模式</li></ul><p><strong>性能优化</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://developer.mozilla.org/zh-CN/docs/Web/Performance">《Web 性能》</a> MDN 权威文档罗列 Web 性能指标和测量方法</li><li>《高性能网站建设指南》 堪称前端工程师技能精髓，很多前端的性能优化入门书</li><li>《高性能网站建设进阶指南》 进一步学习性能优化，建设指南的进阶版</li><li>《高性能 JavaScript》 编写运行更快的 JavaScript 权威指南</li></ul><p><strong>原理</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://cn.vuejs.org/v2/guide/reactivity.html">《深入响应式原理》</a> Vue.js 权威说明响应式原理</li><li><a href="https://leetcode.cn/link/?target=https://zh-hans.reactjs.org/docs/implementation-notes.html">《React 实现说明》</a> React 实现原理资料汇总</li></ul><p><strong>安全</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://developer.mozilla.org/zh-CN/docs/Web/Security">《Web 安全》</a> MDN 权威文档说明 Web 攻击方式及防御策略</li><li>《Web 安全开发指南》详细介绍Web安全开发的必备知识和攻防实战</li><li><a href="https://leetcode.cn/link/?target=http://xss-quiz.int21h.jp/">《XSS Challenges》</a> 模拟 XSS 攻击并闯关</li></ul><p><strong>调试和测试</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://developer.mozilla.org/zh-CN/docs/Tools/Debugger">《调试器》</a> MDN 权威文档说明如何使用 JavaScript Debugge</li><li><a href="https://leetcode.cn/link/?target=https://jestjs.io/zh-Hans/docs/getting-started">《Jest中文文档》</a> 被广泛使用的测试框架的说明文档</li></ul><p><strong>项目管理</strong></p><ul><li><a href="https://leetcode.cn/link/?target=http://markdown.p2hp.com/getting-started/">《Markdown 入门》</a> 用轻量级的标记语言快速书写格式优雅的文档</li><li><a href="https://leetcode-cn.com/leetbook/detail/how-objects-work/">《面向对象是怎样工作的》</a> 「计算机程序设计思想」图解趣味版</li><li>《OKR 工作法》 如何激励不同团队一起工作，全力以赴实现一个有挑战性的目标</li><li>《敏捷软件开发》 豆瓣评分 9.0 的项目管理入门书</li></ul><p><strong>加分项</strong></p><p><strong>后端和客户端或更底层语言</strong></p><ul><li><a href="https://leetcode-cn.com/leetbook/detail/modern-java-in-action/">《Java 实战》</a> 通过示例全面讲解 Java 8、9、10 新特性</li><li><a href="https://leetcode-cn.com/leetbook/detail/deep-learning-with-python/">《Python 深度学习》</a> 通俗易懂，建立关于机器学习和深度学习核心思想的直觉</li><li><a href="https://leetcode-cn.com/leetbook/detail/java-interview-highlights/">《Java 面试突击》</a> Java 面试必备知识点整理，高效面试通关秘籍</li><li><a href="https://leetcode-cn.com/leetbook/detail/cpp-interview-highlights/">《C++ 面试突击》</a> C++ 面试高频知识点详解</li><li><a href="https://leetcode.cn/link/?target=https://www.wasm.com.cn/">《WebAssembly 中文文档》</a> 将 C、C++ 或 Rust 等编译进浏览器，在 JavaScript 中使用</li></ul><p><strong>操作系统</strong></p><ul><li><a href="https://leetcode-cn.com/leetbook/detail/awesome-linux-handbook/">《硬核 Linux 攻略》</a> 从使用 Linux 写命令，到了解这些指令背后的意义</li><li><a href="https://leetcode-cn.com/leetbook/detail/awesome-os-guide/">《硬核操作系统指南》</a> 进程线程、内存管理、文件系统、IO 流、死锁等角度全面剖析系统</li></ul><p><strong>机器学习</strong></p><ul><li><a href="https://leetcode-cn.com/leetbook/detail/machine-learning-101/">《机器学习 101》</a> 机器学习的基本概念</li></ul><p><strong>SEO</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://ziyuan.baidu.com/college#/type=4&cate=guides">《百度搜索学堂·搜索规范》</a> 百度官方 SEO 教学</li></ul><p><strong>UX</strong></p><ul><li>《点石成金》 面向 Web 设计和开发的技术人员的经典入门书</li><li>《设计师要懂心理学》 在网页和应用设计中，考虑周边视觉、色盲和目标趋近效应</li><li>《眼动追踪 用户体验优化操作指南》 通过眼动追踪方法实操用户体验优化</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出设计模式</title>
    <link href="/2023/01/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/01/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="概述-Introduction"><a href="#概述-Introduction" class="headerlink" title="概述 Introduction"></a>概述 Introduction</h3><p>设计模式在面试中的考点通常是介绍其原理并说出优缺点。或者对比几个比较相似的模式的异同点。在笔试中可能会出现画出某个设计模式的 UML 图这样的题。虽说面试中占的比重不大，但并不代表它不重要。恰恰相反，设计模式于程序员而言相当重要，它是我们写出优秀程序的保障。设计模式与程序员的架构能力与阅读源码的能力息息相关，非常值得我们深入学习。</p><p>面向对象的特点是 <strong>可维护、可复用、可扩展、灵活性好</strong>，它最强大的地方在于：随着业务变得越来越复杂，面向对象依然能够使得程序结构良好，而面向过程却会导致程序越来越臃肿。</p><p>让面向对象保持结构良好的秘诀就是设计模式，面向对象结合设计模式，才能真正体会到程序变得可维护、可复用、可扩展、灵活性好。设计模式对于程序员而言并不陌生，每个程序员在编程时都会或多或少的接触到设计模式。无论是在大型程序的架构中，亦或是在源码的学习中，设计模式都扮演着非常重要的角色。</p><p>今天我们就一起来探索设计模式的世界！</p><h3 id="设计模式的六大原则-Six-principles"><a href="#设计模式的六大原则-Six-principles" class="headerlink" title="设计模式的六大原则 Six principles"></a>设计模式的六大原则 Six principles</h3><p>设计模式的世界丰富多彩，比如生产一个个“产品”的工厂模式，衔接两个不相关接口的适配器模式，用不同的方式做同一件事的策略模式，构建步骤稳定、根据构建过程的不同配置构建出不同对象的建造者模式等等。</p><p>无论何种设计模式，都是基于六大设计原则：</p><ul><li>开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。</li><li>单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。</li><li>里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。</li><li>依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。</li><li>迪米特法则：又名“最少知道原则”，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。</li><li>接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。</li></ul><h3 id="第一章：构建型模式-Creational-Patterns"><a href="#第一章：构建型模式-Creational-Patterns" class="headerlink" title="第一章：构建型模式 Creational Patterns"></a>第一章：构建型模式 Creational Patterns</h3><h3 id="工厂模式-Factory"><a href="#工厂模式-Factory" class="headerlink" title="工厂模式 Factory"></a>工厂模式 Factory</h3><p>在平时编程中，构建对象最常用的方式是 new 一个对象。乍一看这种做法没什么不好，而实际上这也属于一种硬编码。每 new 一个对象，相当于调用者多知道了一个类，增加了类与类之间的联系，不利于程序的松耦合。其实构建过程可以被封装起来，工厂模式便是用于封装对象的设计模式。</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>举个例子，直接 new 对象的方式相当于当我们需要一个苹果时，我们需要知道苹果的构造方法，需要一个梨子时，需要知道梨子的构造方法。更好的实现方式是有一个水果工厂，我们告诉工厂需要什么种类的水果，水果工厂将我们需要的水果制造出来给我们就可以了。这样我们就无需知道苹果、梨子是怎么种出来的，只用和水果工厂打交道即可。</p><p>水果工厂：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitFactory</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Fruit</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> <span class="hljs-keyword">type</span></span>)&#123;        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">type</span>)&#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;苹果&quot;</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;梨子&quot;</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pear</span>();            <span class="hljs-attr">default</span>: <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;暂时没有这种水果&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><p>调用者：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">FruitFactory</span> <span class="hljs-variable">fruitFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FruitFactory</span>();        <span class="hljs-type">Fruit</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> fruitFactory.create(<span class="hljs-string">&quot;苹果&quot;</span>);        <span class="hljs-type">Fruit</span> <span class="hljs-variable">pear</span> <span class="hljs-operator">=</span> fruitFactory.create(<span class="hljs-string">&quot;梨子&quot;</span>);        apple.eat();        pear.eat();    &#125;&#125;</code></pre></div><p>事实上，将构建过程封装的好处不仅可以降低耦合，如果某个产品构造方法相当复杂，使用工厂模式可以大大减少代码重复。比如，如果生产一个苹果需要苹果种子、阳光、水分，将工厂修改如下：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitFactory</span> </span>&#123;    <span class="hljs-keyword">public</span> Fruit create(<span class="hljs-keyword">String</span> type) &#123;        <span class="hljs-keyword">switch</span> (type) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;苹果&quot;</span>:<span class="hljs-type"></span>                AppleSeed appleSeed = <span class="hljs-keyword">new</span> <span class="hljs-type">AppleSeed</span>();                Sunlight sunlight = <span class="hljs-keyword">new</span> <span class="hljs-type">Sunlight</span>();                Water water = <span class="hljs-keyword">new</span> <span class="hljs-type">Water</span>();                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Apple</span>(appleSeed, sunlight, water);            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;梨子&quot;</span>:<span class="hljs-type"></span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Pear</span>();            <span class="hljs-keyword">default</span>:<span class="hljs-type"></span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;暂时没有这种水果&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><p>调用者的代码则完全不需要变化，而且调用者不需要在每次需要苹果时，自己去构建苹果种子、阳光、水分以获得苹果。苹果的生产过程再复杂，也只是工厂的事。这就是封装的好处，假如某天科学家发明了让苹果更香甜的肥料，要加入苹果的生产过程中的话，也只需要在工厂中修改，调用者完全不用关心。</p><p>不知不觉中，我们就写出了简单工厂模式的代码。工厂模式一共有三种：</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><p>注：在 GoF 所著的《设计模式》一书中，简单工厂模式被划分为工厂方法模式的一种特例，没有单独被列出来。</p><p>总而言之，简单工厂模式就是让一个工厂类承担构建所有对象的职责。调用者需要什么产品，让工厂生产出来即可。它的弊端也显而易见：</p><ul><li>一是如果需要生产的产品过多，此模式会导致工厂类过于庞大，承担过多的职责，变成超级类。当苹果生产过程需要修改时，要来修改此工厂。梨子生产过程需要修改时，也要来修改此工厂。也就是说这个类不止一个引起修改的原因。违背了单一职责原则。</li><li>二是当要生产新的产品时，必须在工厂类中添加新的分支。而开闭原则告诉我们：类应该对修改封闭。我们希望在添加新功能时，只需增加新的类，而不是修改既有的类，所以这就违背了开闭原则。</li></ul><p><img src="/../imgs/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1604290966-DjcYge-1.gif" alt="1.gif"></p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>为了解决简单工厂模式的这两个弊端，工厂方法模式应运而生，它规定每个产品都有一个专属工厂。比如苹果有专属的苹果工厂，梨子有专属的梨子工厂，代码如下：</p><p>苹果工厂：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AppleFactory</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Fruit <span class="hljs-title">create</span>()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple();    &#125;&#125;</code></pre></div><p>梨子工厂：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PearFactory</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Fruit <span class="hljs-title">create</span>()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pear();    &#125;&#125;</code></pre></div><p>调用者：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">AppleFactory</span> <span class="hljs-variable">appleFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AppleFactory</span>();        <span class="hljs-type">Fruit</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> appleFactory.create();        <span class="hljs-type">PearFactory</span> <span class="hljs-variable">pearFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PearFactory</span>();        <span class="hljs-type">Fruit</span> <span class="hljs-variable">pear</span> <span class="hljs-operator">=</span> pearFactory.create();        apple.eat();        pear.eat();    &#125;&#125;</code></pre></div><p>有读者可能会开喷了，这样和直接 new 出苹果和梨子有什么区别？上文说工厂是为了减少类与类之间的耦合，让调用者尽可能少的和其他类打交道。用简单工厂模式，我们只需要知道 FruitFactory，无需知道 Apple 、Pear 类，很容易看出耦合度降低了。但用工厂方法模式，调用者虽然不需要和 Apple 、Pear 类打交道了，但却需要和 AppleFactory、PearFactory 类打交道。有几种水果就需要知道几个工厂类，耦合度完全没有下降啊，甚至还增加了代码量！</p><p>这位读者请先放下手中的大刀，仔细想一想，工厂模式的第二个优点在工厂方法模式中还是存在的。当构建过程相当复杂时，工厂将构建过程封装起来，调用者可以很方便的直接使用，同样以苹果生产为例：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleFactory</span> </span>&#123;    <span class="hljs-keyword">public</span> Fruit create()&#123;        AppleSeed appleSeed = <span class="hljs-keyword">new</span> <span class="hljs-type">AppleSeed</span>();        Sunlight sunlight = <span class="hljs-keyword">new</span> <span class="hljs-type">Sunlight</span>();        Water water = <span class="hljs-keyword">new</span> <span class="hljs-type">Water</span>();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Apple</span>(appleSeed, sunlight, water);    &#125;&#125;</code></pre></div><p>调用者无需知道苹果的生产细节，当生产过程需要修改时也无需更改调用端。同时，工厂方法模式解决了简单工厂模式的两个弊端。</p><ul><li>当生产的产品种类越来越多时，工厂类不会变成超级类。工厂类会越来越多，保持灵活。不会越来越大、变得臃肿。如果苹果的生产过程需要修改时，只需修改苹果工厂。梨子的生产过程需要修改时，只需修改梨子工厂。符合单一职责原则。</li><li>当需要生产新的产品时，无需更改既有的工厂，只需要添加新的工厂即可。保持了面向对象的可扩展性，符合开闭原则。</li></ul><p>OK，学以致用，接下来我们来做两个思考题。同样地，在以后的每一篇文章后面，都会附上几个小练习供大家思考。希望大家能够独立思考出问题的答案，当然，在必要时也可参考底部的解析。</p><p>问 1：现有医用口罩和 N95 口罩两种产品，都继承自 Mask 类：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mask</span> </span>&#123;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SurgicalMask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mask</span> </span>&#123;    <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@Override</span>    public <span class="hljs-type">String</span> toString() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是医用口罩&quot;</span>;    &#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">N95Mask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mask</span> </span>&#123;    <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@Override</span>    public <span class="hljs-type">String</span> toString() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是 N95 口罩&quot;</span>;    &#125;&#125;</code></pre></div><p>请使用简单工厂模式完成以下代码：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaskFactory</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Mask</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> <span class="hljs-keyword">type</span></span>)&#123;        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 使用简单工厂模式实现此处的逻辑</span>    &#125;&#125;</code></pre></div><p>使其通过以下客户端测试：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> &#123;    @Test    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>()</span> &#123;        MaskFactory factory = <span class="hljs-keyword">new</span> MaskFactory();        <span class="hljs-comment">// 输出：这是医用口罩</span>        System.<span class="hljs-keyword">out</span>.println(factory.create(<span class="hljs-string">&quot;Surgical&quot;</span>));        <span class="hljs-comment">// 输出：这是 N95 口罩</span>        System.<span class="hljs-keyword">out</span>.println(factory.create(<span class="hljs-string">&quot;N95&quot;</span>));    &#125;&#125;</code></pre></div><p>答案：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaskFactory</span> </span>&#123;    <span class="hljs-keyword">public</span> Mask create(<span class="hljs-keyword">String</span> type)&#123;        <span class="hljs-comment">// 使用简单工厂模式实现此处的逻辑</span>        <span class="hljs-keyword">switch</span> (type)&#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Surgical&quot;</span>:<span class="hljs-type"></span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">SurgicalMask</span>();            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;N95&quot;</span>:<span class="hljs-type"></span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">N95Mask</span>();            <span class="hljs-keyword">default</span>:<span class="hljs-type"></span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unsupported mask type&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><p>问 2：如何用工厂方法模式实现呢？</p><p>客户端测试代码：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">SurgicalMaskFactory</span> <span class="hljs-variable">surgicalMaskFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SurgicalMaskFactory</span>();        <span class="hljs-comment">// 输出：这是医用口罩</span>        System.out.println(surgicalMaskFactory.create());        <span class="hljs-type">N95MaskFactory</span> <span class="hljs-variable">N95MaskFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">N95MaskFactory</span>();        <span class="hljs-comment">// 输出：这是 N95 口罩</span>        System.out.println(N95MaskFactory.create());    &#125;&#125;</code></pre></div><p>答案：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SurgicalMaskFactory</span>&#123;    <span class="hljs-keyword">public</span> Mask <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SurgicalMask</span>();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">N95MaskFactory</span> &#123;    <span class="hljs-keyword">public</span> Mask <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">N95Mask</span>();    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>手撕代码-前端</title>
    <link href="/2023/01/28/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81-%E5%89%8D%E7%AB%AF/"/>
    <url>/2023/01/28/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81-%E5%89%8D%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-数组扁平化"><a href="#第一章-数组扁平化" class="headerlink" title="第一章 数组扁平化"></a>第一章 数组扁平化</h2><h3 id="ES6的flat方法"><a href="#ES6的flat方法" class="headerlink" title="ES6的flat方法"></a>ES6的flat方法</h3><p>flat() 方法将以指定的深度递归遍历数组，并将所有元素与遍历的子数组中的元素合并到一个新数组中以返回。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]],<span class="hljs-number">6</span>]<span class="hljs-keyword">const</span> res = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\[|\]/g</span>,<span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-keyword">const</span> res2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;[&#x27;</span> + res + <span class="hljs-string">&#x27;]&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res2)</code></pre></div><h3 id="方法二：使用正则"><a href="#方法二：使用正则" class="headerlink" title="方法二：使用正则"></a>方法二：使用正则</h3><p>首先是使用 JSON.stringify 把 arr 转为字符串接着使用正则把字符串里面的 [ 和 ] 去掉然后再拼接数组括号转为数组对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]],<span class="hljs-number">6</span>]<span class="hljs-keyword">const</span> res = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\[|\]/g</span>,<span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-keyword">const</span> res2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;[&#x27;</span> + res + <span class="hljs-string">&#x27;]&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res2)</code></pre></div><h3 id="方法三：使用递归"><a href="#方法三：使用递归" class="headerlink" title="方法三：使用递归"></a>方法三：使用递归</h3><p>递归，在数学和计算机科学中，是指在函数的定义中使用函数本身的方法。递归这个词经常用来描述以自相似的方式重复事物的过程。通俗的理解是：我调用我自己。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = []<span class="hljs-keyword">const</span>  <span class="hljs-title function_">fn</span> = (<span class="hljs-params">arr</span>)=&gt;&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>; i++)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr[i]))&#123;            <span class="hljs-title function_">fn</span>(arr[i])        &#125;        <span class="hljs-keyword">else</span> &#123;            array.<span class="hljs-title function_">push</span>(arr[i])        &#125;    &#125;&#125;<span class="hljs-title function_">fn</span>(arr)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array)</code></pre></div><h3 id="方法四：使用-reduce"><a href="#方法四：使用-reduce" class="headerlink" title="方法四：使用 reduce"></a>方法四：使用 reduce</h3><p>reduce 方法: 可以用来给数组求和</p><p>concat() 方法用于连接两个或多个数组。</p><p>concat() 方法不会更改现有数组，而是返回一个新数组，其中包含已连接数组的值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">newArr</span> = (<span class="hljs-params">arr</span>)=&gt;&#123;            <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;                <span class="hljs-keyword">return</span> pre.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(cur) ? <span class="hljs-title function_">newArr</span>(cur) : cur)            &#125;,[])        &#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">newArr</span>(arr),<span class="hljs-string">&quot;reduce方法&quot;</span>)</code></pre></div><h3 id="使用栈的思想实现-flat-函数"><a href="#使用栈的思想实现-flat-函数" class="headerlink" title="使用栈的思想实现 flat 函数"></a>使用栈的思想实现 flat 函数</h3><p>栈（stack）又名堆<em>栈</em>，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 栈思想function flat(arr) &#123;</span>  <span class="hljs-keyword">const</span> newArr = [];  <span class="hljs-keyword">const</span> stack = [].<span class="hljs-title function_">concat</span>(arr);  <span class="hljs-comment">// 将数组元素拷贝至栈，直接赋值会改变原数组//如果栈不为空，则循环遍历while (stack.length !== 0) &#123;</span>    <span class="hljs-keyword">const</span> val = stack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 删除数组最后一个元素，并获取它if (Array.isArray(val)) &#123;</span>      stack.<span class="hljs-title function_">push</span>(...val); <span class="hljs-comment">// 如果是数组再次入栈，并且展开了一层</span>    &#125; <span class="hljs-keyword">else</span> &#123;      newArr.<span class="hljs-title function_">unshift</span>(val); <span class="hljs-comment">// 如果不是数组就将其取出来放入结果数组中</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> newArr;&#125;<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">12</span>, <span class="hljs-number">23</span>, [<span class="hljs-number">34</span>, <span class="hljs-number">56</span>, [<span class="hljs-number">78</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>, [<span class="hljs-number">110</span>, <span class="hljs-number">120</span>, <span class="hljs-number">130</span>, <span class="hljs-number">140</span>]]]];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flat</span>(arr));<span class="hljs-comment">// [12, 23, 34, 56, 78, 90, 100, 110, 120, 130, 140]</span></code></pre></div><h2 id="第二章：深拷贝和浅拷贝"><a href="#第二章：深拷贝和浅拷贝" class="headerlink" title="第二章：深拷贝和浅拷贝"></a>第二章：深拷贝和浅拷贝</h2><h3 id="知识点讲解"><a href="#知识点讲解" class="headerlink" title="知识点讲解"></a>知识点讲解</h3><h4 id="1、什么是数据类型？"><a href="#1、什么是数据类型？" class="headerlink" title="1、什么是数据类型？"></a>1、什么是数据类型？</h4><p>数据分为基本数据类型 (String, Number, Boolean, Null, Undefined，Symbol) 和引用数据类型。</p><p>基本数据类型的特点：直接存储在栈 (stack) 中的数据</p><p>引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里</p><p>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。</p><h4 id="2、ES11新增了什么数据类型？"><a href="#2、ES11新增了什么数据类型？" class="headerlink" title="2、ES11新增了什么数据类型？"></a>2、ES11新增了什么数据类型？</h4><p>bigint!</p><p>bigint使用方式：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> max=<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">BigInt</span>(max))<span class="hljs-comment">//9007199254740991n </span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">BigInt</span>(max)+<span class="hljs-title class_">BigInt</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">//9007199254740992n 正确</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">BigInt</span>(max)+<span class="hljs-title class_">BigInt</span>(<span class="hljs-number">2</span>))<span class="hljs-comment">//9007199254740993n 正确</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">BigInt</span>(max)+<span class="hljs-title class_">BigInt</span>(<span class="hljs-number">4</span>))<span class="hljs-comment">//9007199254740995n 正确</span></code></pre></div><h4 id="3、为什么要使用深拷贝？"><a href="#3、为什么要使用深拷贝？" class="headerlink" title="3、为什么要使用深拷贝？"></a>3、为什么要使用深拷贝？</h4><p>我们希望在改变新的数组（对象）的时候，不改变原数组（对象）</p><h4 id="4、赋值和浅拷贝的区别？"><a href="#4、赋值和浅拷贝的区别？" class="headerlink" title="4、赋值和浅拷贝的区别？"></a>4、赋值和浅拷贝的区别？</h4><p>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</p><p><strong>JavaScript 数组复制操作创建浅拷贝。（所有 JavaScript 对象的标准内置复制操作都会创建浅拷贝，而不是深拷贝）。<br>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。</strong></p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝是一点一点地拷贝一个对象。它将创建一个新对象。此对象具有原始对象属性值的精确副本。如果属性是基本类型，它将复制基本类型的值；如果属性是内存地址（引用类型），则复制内存地址。因此，如果一个对象更改地址，另一个对象将受到影响。也就是说，默认复制构造函数只复制浅层复制中的对象（依次复制成员），即只复制对象空间，而不复制资源。</p><div class="code-wrapper"><pre><code class="hljs pgsql">var obj1 =&#123; <span class="hljs-type">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>, age:<span class="hljs-number">8</span>, pal:[<span class="hljs-string">&#x27;王五&#x27;</span>,<span class="hljs-string">&#x27;王六&#x27;</span>,<span class="hljs-string">&#x27;王七&#x27;</span>]&#125;var obj3 = shallowCopy(obj1)<span class="hljs-keyword">function</span> shallowCopy (src)&#123; var newObj = &#123;&#125;; <span class="hljs-keyword">for</span>(var prop <span class="hljs-keyword">in</span> src )&#123;     console.log(prop)     <span class="hljs-keyword">if</span>(src.hasOwnProperty(prop))&#123;         newObj[prop] = src[prop]     &#125; &#125; <span class="hljs-keyword">return</span> newObj&#125; obj3.name = <span class="hljs-string">&#x27;李四&#x27;</span> obj3.pal[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;王麻子&#x27;</span>   console.log(&quot;obj1&quot;, obj1); //&#123;age: <span class="hljs-number">8</span>, <span class="hljs-type">name</span>: &quot;张三&quot;, pal: [<span class="hljs-string">&#x27;王麻子&#x27;</span>, <span class="hljs-string">&#x27;王六&#x27;</span>, <span class="hljs-string">&#x27;王七&#x27;</span>]&#125;console.log(&quot;obj3&quot;, obj3); //&#123;age: <span class="hljs-number">8</span>, <span class="hljs-type">name</span>: &quot;李四&quot;, pal: [<span class="hljs-string">&#x27;王麻子&#x27;</span>, <span class="hljs-string">&#x27;王六&#x27;</span>, <span class="hljs-string">&#x27;王七&#x27;</span>]&#125;</code></pre></div><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="方法一：递归实现深拷贝"><a href="#方法一：递归实现深拷贝" class="headerlink" title="方法一：递归实现深拷贝"></a>方法一：递归实现深拷贝</h4><p>实现<strong>深拷贝</strong>原理的递归方法：遍历对象、数组甚至内部都是基本的数据类型，然后复制它们，即深度复制。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;   <span class="hljs-comment">//原数据，包含字符串、对象、函数、数组等不同的类型</span>       <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;test&quot;</span>,       <span class="hljs-attr">main</span>:&#123;           <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,           <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>       &#125;,       <span class="hljs-attr">fn</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;                  &#125;,        <span class="hljs-attr">friends</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">22</span>,<span class="hljs-number">33</span>]]   &#125;    <span class="hljs-keyword">function</span> <span class="hljs-title function_">copy</span>(<span class="hljs-params">obj</span>)&#123;        <span class="hljs-keyword">let</span> newobj = <span class="hljs-literal">null</span>;   <span class="hljs-comment">//声明一个变量用来储存拷贝之后的内容</span>             <span class="hljs-comment">//判断数据类型是否是复杂类型，如果是则调用自己，再次循环，如果不是，直接赋值即可，</span>     <span class="hljs-comment">//由于null不可以循环但类型又是object，所以这个需要对null进行判断</span>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_">typeof</span>(obj) == <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; obj !== <span class="hljs-literal">null</span>)&#123;                 <span class="hljs-comment">//声明一个变量用以储存拷贝出来的值,根据参数的具体数据类型声明不同的类型来储存</span>            newobj = obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>? [] : &#123;&#125;;                       <span class="hljs-comment">//循环obj 中的每一项，如果里面还有复杂数据类型，则直接利用递归再次调用copy函数</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> obj)&#123;                  newobj[i] = <span class="hljs-title function_">copy</span>(obj[i])            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            newobj = obj        &#125;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;77&#x27;</span>,newobj)      <span class="hljs-keyword">return</span> newobj;    <span class="hljs-comment">//函数必须有返回值，否则结构为undefined</span>   &#125;     <span class="hljs-keyword">var</span> obj2 = <span class="hljs-title function_">copy</span>(obj)    obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;修改成功&#x27;</span>    obj2.<span class="hljs-property">main</span>.<span class="hljs-property">a</span> = <span class="hljs-number">100</span>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2)作者：力扣 (<span class="hljs-title class_">LeetCode</span>)链接：<span class="hljs-attr">https</span>:<span class="hljs-comment">//leetcode.cn/leetbook/read/interview-coding-frontend/dqvyxd/</span>来源：力扣（<span class="hljs-title class_">LeetCode</span>）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h4 id="方法二：递归实现深拷贝"><a href="#方法二：递归实现深拷贝" class="headerlink" title="方法二：递归实现深拷贝"></a>方法二：递归实现深拷贝</h4><ul><li><p>递归处理 引用类型</p></li><li><p>保持数组类型</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">target</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;                <span class="hljs-keyword">const</span> newTarget = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) ? [] : <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> target) &#123;                        newTarget[key] = <span class="hljs-title function_">deepCopy</span>(target[key])                &#125;                <span class="hljs-keyword">return</span> newTarget        &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> target        &#125;&#125;作者：力扣 (<span class="hljs-title class_">LeetCode</span>)链接：<span class="hljs-attr">https</span>:<span class="hljs-comment">//leetcode.cn/leetbook/read/interview-coding-frontend/dqwshh/</span>来源：力扣（<span class="hljs-title class_">LeetCode</span>）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h4 id="方法三：递归实现深拷贝"><a href="#方法三：递归实现深拷贝" class="headerlink" title="方法三：递归实现深拷贝"></a>方法三：递归实现深拷贝</h4><ul><li><p>哈希表 Map 支持 循环引用</p><ul><li>Map 支持引用类型数据作为键</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">target, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span></span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;                <span class="hljs-keyword">if</span> (h.<span class="hljs-title function_">has</span>(target)) <span class="hljs-keyword">return</span> h.<span class="hljs-title function_">get</span>(target)                <span class="hljs-keyword">const</span> newTarget = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) ? [] : <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> target) &#123;                        newTarget[key] = <span class="hljs-title function_">deepCopy</span>(target[key], h)                &#125;                h.<span class="hljs-title function_">set</span>(target, newTarget)                <span class="hljs-keyword">return</span> newTarget        &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> target        &#125;&#125;作者：力扣 (<span class="hljs-title class_">LeetCode</span>)链接：<span class="hljs-attr">https</span>:<span class="hljs-comment">//leetcode.cn/leetbook/read/interview-coding-frontend/dqd6j3/</span>来源：力扣（<span class="hljs-title class_">LeetCode</span>）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h4 id="方法四：递归实现深拷贝"><a href="#方法四：递归实现深拷贝" class="headerlink" title="方法四：递归实现深拷贝"></a>方法四：递归实现深拷贝</h4><p>哈希表 WeakMap 代替 Map</p><p>WeakMap 的键是弱引用，告诉 JS 垃圾回收机制，当键回收时，对应 WeakMap 也可以回收，更适合大量数据深拷</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dq08bm/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dq08bm/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">target, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;      <span class="hljs-keyword">if</span> (h.<span class="hljs-title function_">has</span>(target)) <span class="hljs-keyword">return</span> h.<span class="hljs-title function_">get</span>(target)      <span class="hljs-keyword">const</span> newTarget = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) ? [] : <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> target) &#123;        newTarget[key] = <span class="hljs-title function_">deepCopy</span>(target[key], h)      &#125;      h.<span class="hljs-title function_">set</span>(target, newTarget)      <span class="hljs-keyword">return</span> newTarget    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> target    &#125;&#125;作者：力扣 (<span class="hljs-title class_">LeetCode</span>)链接：<span class="hljs-attr">https</span>:<span class="hljs-comment">//leetcode.cn/leetbook/read/interview-coding-frontend/dq08bm/</span>来源：力扣（<span class="hljs-title class_">LeetCode</span>）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h2 id="第三章-防抖节流"><a href="#第三章-防抖节流" class="headerlink" title="第三章 防抖节流"></a>第三章 防抖节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>防抖是指短时间内大量触发同一事件，只会在最后一次事件完成后延迟执行一次函数。例如，在输入用户名的过程中，需要反复验证用户名。此时，您应该等待用户停止输入，然后进行验证，否则将影响用户体验。 防抖实现的原理是在触发事件后设置计时器。在计时器延迟过程中，如果事件再次触发，则重置计时器。在没有触发事件之前，计时器将再次触发并执行相应的功能。</p><p>声明定时器</p><p>返回函数</p><p>一定时间间隔，执行回调函数</p><p>回调函数</p><p>已执行：清空定时器<br>未执行：重置定时器</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dq896c/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dq896c/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay</span>) &#123;        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;                <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer)                timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;                        timer = <span class="hljs-literal">null</span>                        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)                &#125;, (delay + <span class="hljs-string">&#x27;&#x27;</span>) | <span class="hljs-number">0</span> || <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>)        &#125;&#125;作者：力扣 (<span class="hljs-title class_">LeetCode</span>)链接：<span class="hljs-attr">https</span>:<span class="hljs-comment">//leetcode.cn/leetbook/read/interview-coding-frontend/dq896c/</span>来源：力扣（<span class="hljs-title class_">LeetCode</span>）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流是指每隔一段时间就执行一次函数。就像未拧紧的水龙头一样，水龙头每隔一段时间就会滴水。即使在这段时间管道里有更多的水，水龙头也不会掉更多的水。</p><p>节流的原理是在触发事件后设置计时器。在计时器延迟过程中，即使事件再次触发，计时器的延迟时间也不会改变。在计时器执行功能之前，计时器不会复位。</p><p>声明定时器</p><p>返回函数</p><p>一定时间间隔，执行回调函数</p><p>回调函数</p><p>已执行：清空定时器<br>未执行：返回</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dq3hqi/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dq3hqi/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, interval</span>) &#123;        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;                <span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span>                timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;                        timer = <span class="hljs-literal">null</span>                        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)                &#125;, (interval +<span class="hljs-string">&#x27;&#x27;</span>)| <span class="hljs-number">0</span> || <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>)        &#125;&#125;作者：力扣 (<span class="hljs-title class_">LeetCode</span>)链接：<span class="hljs-attr">https</span>:<span class="hljs-comment">//leetcode.cn/leetbook/read/interview-coding-frontend/dq3hqi/</span>来源：力扣（<span class="hljs-title class_">LeetCode</span>）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h2 id="第四章：for-in-和-for-of-用法"><a href="#第四章：for-in-和-for-of-用法" class="headerlink" title="第四章：for..in 和 for..of 用法"></a>第四章：for..in 和 for..of 用法</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for..in"></a>for..in</h3><p>for…in 循环只遍历可枚举属性（包括它的原型链上的可枚举属性）。像 Array 和 Object 使用内置构造函数所创建的对象都会继承自 Object.prototype 和 String.prototype 的不可枚举属性，例如 String 的 indexOf() 方法或 Object 的 toString() 方法。循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dq3b3e/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dq3b3e/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h3><p>Q: ES6 的 for of 可以遍历对象吗?</p><p>A: ES6 的 “for of” 不能遍历对象。</p><p>原因：ES6 中引入了 Iterator 接口，只有提供了 Iterator 接口的数据类型才可以使用 “for-of” 来循环遍历；而普通对象默认没有提供 Iterator 接口，因此无法用 “for-of” 来进行遍历。</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dqq1tg/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dqq1tg/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="第五章：从数组-1-2-3-4-5-6-中找出值为-2-的元素"><a href="#第五章：从数组-1-2-3-4-5-6-中找出值为-2-的元素" class="headerlink" title="第五章：从数组 [1,2,3,4,5,6] 中找出值为 2 的元素"></a>第五章：从数组 [1,2,3,4,5,6] 中找出值为 2 的元素</h2><p>本章讲实现数组中找值问题的 2 种方法。</p><h3 id="方法一：filter"><a href="#方法一：filter" class="headerlink" title="方法一：filter()"></a>方法一：filter()</h3><p>filter() 方法创建一个新数组, 包含通过所提供函数实现的测试的所有元素。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isBigEnough</span>(<span class="hljs-params">element</span>) &#123;  <span class="hljs-keyword">return</span> element == <span class="hljs-number">2</span>;&#125;<span class="hljs-keyword">var</span> filtered = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>].<span class="hljs-title function_">filter</span>(isBigEnough);</code></pre></div><h3 id="方法二：find"><a href="#方法二：find" class="headerlink" title="方法二：find()"></a>方法二：find()</h3><p>find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<span class="hljs-keyword">function</span> <span class="hljs-title function_">finds</span>(<span class="hljs-params">x</span>) &#123;    <span class="hljs-keyword">return</span> x === <span class="hljs-string">&#x27;2&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(finds));</code></pre></div><h3 id="常用方法总结："><a href="#常用方法总结：" class="headerlink" title="常用方法总结："></a>常用方法总结：</h3><table><thead><tr><th>方法名</th><th>参数</th><th>描述</th><th>返回值</th></tr></thead><tbody><tr><td>includes<br/></td><td>searchElement,fromlndex<br/></td><td>判断数组中是否包含指定的值<br/></td><td>布尔值<br/></td></tr><tr><td>indexOf<br/></td><td>searchElement,fromlndex<br/></td><td>查找元素在数组中首次出现的索引值<br/></td><td>索引值，或者-1<br/></td></tr><tr><td>lastIndexOf<br/></td><td>searchElement,fromlndex<br/></td><td>查找元素在数组中最后一次出现的索引值<br/></td><td>索引值，或者-1<br/></td></tr><tr><td>some<br/></td><td>callback[,thisArg]<br/></td><td>判断数组中是否有符合条件的元素<br/></td><td>布尔值<br/></td></tr><tr><td>every<br/></td><td>callback[,thisArg]<br/></td><td>判断数组中是否每个元素都符合条件<br/></td><td>布尔值<br/></td></tr><tr><td>filter<br/></td><td>callback[,thisArg]<br/></td><td>返回符合条件的所有元素组成的数组<br/></td><td>数组<br/></td></tr><tr><td>find<br/></td><td>callback[,thisArg]<br/></td><td>返回数组中符合条件的第一个元素<br/></td><td>数组中的元素，或者undefined<br/></td></tr><tr><td>findIndex<br/></td><td>callback[,thisArg]<br/></td><td>返回符合条件的第一个元素的索引<br/></td><td>索引值，或者-1</td></tr></tbody></table><h2 id="第六章：两栏布局和三栏布局"><a href="#第六章：两栏布局和三栏布局" class="headerlink" title="第六章：两栏布局和三栏布局"></a>第六章：两栏布局和三栏布局</h2><h3 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h3><p>两栏布局非常常见，往往是以一个定宽栏和一个自适应的栏并排展示存在。</p><p><img src="/../imgs/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81-%E5%89%8D%E7%AB%AF/image-20230128103818724.png" alt="image-20230128103818724"></p><h4 id="方法一：浮动布局"><a href="#方法一：浮动布局" class="headerlink" title="方法一：浮动布局"></a>方法一：浮动布局</h4><ul><li>使用 float 左浮左边栏</li><li>右边模块使用 margin-left 撑出内容块做内容展示</li><li>为父级元素添加 BFC，防止下方元素飞到上方内容</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.box</span>&#123;</span><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden; 添加BFC</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: gray;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">210px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: lightgray;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dq4vvd/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h4 id="方法二：flex-弹性布局"><a href="#方法二：flex-弹性布局" class="headerlink" title="方法二：flex 弹性布局"></a>方法二：flex 弹性布局</h4><p>flex 容器的一个默认属性值: align-items: stretch;</p><p>这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: align-items: flex-start。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.box</span>&#123;</span><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dq1anh/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><p><img src="/../imgs/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81-%E5%89%8D%E7%AB%AF/image-20230128104025419.png" alt="image-20230128104025419"></p><p>实现三栏布局中间自适应的布局方式有：</p><ol><li>两边使用 float，中间使用 margin</li><li>两边使用 absolute，中间使用 margin</li><li>两边使用 float 和负 margin</li><li>flex 实现</li><li>grid 网格布局</li></ol><h4 id="方法一：两边使用-float，中间使用-margin"><a href="#方法一：两边使用-float，中间使用-margin" class="headerlink" title="方法一：两边使用 float，中间使用 margin"></a>方法一：两边使用 float，中间使用 margin</h4><p>需要将中间的内容放在 <code>html</code> 结构最后，否则右侧会臣在中间内容的下方</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.wrap</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#eee</span>;</span><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden; &lt;!-- 生成BFC，计算高度时考虑浮动的元素 --&gt;</span><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">background</span>: coral;</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">120px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">float</span>: right;</span><span class="language-css">        <span class="hljs-attribute">background</span>: lightblue;</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.middle</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">220px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: lightpink;</span><span class="language-css">        <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">140px</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dqj1e5/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h4 id="方法二：两边使用-absolute，中间使用-margin"><a href="#方法二：两边使用-absolute，中间使用-margin" class="headerlink" title="方法二：两边使用 absolute，中间使用 margin"></a>方法二：两边使用 absolute，中间使用 margin</h4><p>基于绝对定位的三栏布局：注意绝对定位的元素脱离文档流，相对于最近的已经定位的祖先元素进行定位。无需考虑 HTML 中结构的顺序</p><p>左右两边使用绝对定位，固定在两侧。</p><p>中间占满一行，但通过 margin 和左右两边留出 10px 的间隔</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.container</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">position</span>: relative;</span><span class="language-css">  &#125;</span><span class="language-css">  </span><span class="language-css">  <span class="hljs-selector-class">.left</span>,</span><span class="language-css">  <span class="hljs-selector-class">.right</span>,</span><span class="language-css">  <span class="hljs-selector-class">.main</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">    <span class="hljs-attribute">text-align</span>: center;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">position</span>: absolute;</span><span class="language-css">    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><span class="language-css">    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">    <span class="hljs-attribute">background</span>: green;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">position</span>: absolute;</span><span class="language-css">    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><span class="language-css">    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">    <span class="hljs-attribute">background</span>: green;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.main</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">110px</span>;</span><span class="language-css">    <span class="hljs-attribute">background</span>: black;</span><span class="language-css">    <span class="hljs-attribute">color</span>: white;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左边固定宽度<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右边固定宽度<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>中间自适应<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h4 id="方法三：两边使用-float-和负-margin"><a href="#方法三：两边使用-float-和负-margin" class="headerlink" title="方法三：两边使用 float 和负 margin"></a>方法三：两边使用 float 和负 margin</h4><p>实现过程：</p><p>中间使用了双层标签，外层是浮动的，以便左中右能在同一行展示</p><p>左边通过使用负 margin-left:-100%，相当于中间的宽度，所以向上偏移到左侧</p><p>右边通过使用负 margin-left:-100px，相当于自身宽度，所以向上偏移到最右侧</p><p>缺点：</p><p>增加了 .main-wrapper 一层，结构变复杂</p><p>使用负 margin，调试也相对麻烦</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.left</span>,</span><span class="language-css">  <span class="hljs-selector-class">.right</span>,</span><span class="language-css">  <span class="hljs-selector-class">.main</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">    <span class="hljs-attribute">text-align</span>: center;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.main-wrapper</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.main</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">110px</span>;</span><span class="language-css">    <span class="hljs-attribute">background</span>: black;</span><span class="language-css">    <span class="hljs-attribute">color</span>: white;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.left</span>,</span><span class="language-css">  <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><span class="language-css">    <span class="hljs-attribute">background</span>: green;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>; <span class="hljs-comment">/* 同自身宽度 */</span></span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main-wrapper&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>中间自适应<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左边固定宽度<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右边固定宽度<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/d6h6x2/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h4 id="方法四：使用-flex-实现"><a href="#方法四：使用-flex-实现" class="headerlink" title="方法四：使用 flex 实现"></a>方法四：使用 flex 实现</h4><p>利用 flex 弹性布局，可以简单实现中间自适应。</p><p>实现过程：</p><p>仅需将容器设置为 display:flex; ，</p><p>盒内元素两端对其，将中间元素设置为 100% 宽度，或者设为 flex:1 ，即可填充空白</p><p>盒内元素的高度撑开容器的高度</p><p>优点：</p><p>结构简单直观</p><p>可以结合 flex 的其他功能实现更多效果，例如使用 order 属性调整显示顺序，让主体内容优先加载，但展示在中间</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/d6xtfc/">https://leetcode.cn/leetbook/read/interview-coding-frontend/d6xtfc/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.wrap</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><span class="language-css">        <span class="hljs-attribute">justify-content</span>: space-between;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.left</span>,</span><span class="language-css">    <span class="hljs-selector-class">.right</span>,</span><span class="language-css">    <span class="hljs-selector-class">.middle</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: coral;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">120px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: lightblue;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.middle</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#555</span>;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">20px</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/d6xtfc/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h4 id="方法五：grid-网格布局"><a href="#方法五：grid-网格布局" class="headerlink" title="方法五：grid 网格布局"></a>方法五：grid 网格布局</h4><p>跟 <code>flex</code> 弹性布局一样的简单</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.wrap</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">display</span>: grid;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">300px</span> auto <span class="hljs-number">300px</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.left</span>,</span><span class="language-css">    <span class="hljs-selector-class">.right</span>,</span><span class="language-css">    <span class="hljs-selector-class">.middle</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: coral;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: lightblue;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.middle</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#555</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/d65lji/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h2 id="第七章：实现多行文本溢出的省略"><a href="#第七章：实现多行文本溢出的省略" class="headerlink" title="第七章：实现多行文本溢出的省略"></a>第七章：实现多行文本溢出的省略</h2><p>本章讲实现多行文本溢出的省略问题的 2 种方法。</p><h3 id="方法一：使用定位伪元素遮盖末尾文字"><a href="#方法一：使用定位伪元素遮盖末尾文字" class="headerlink" title="方法一：使用定位伪元素遮盖末尾文字"></a>方法一：使用定位伪元素遮盖末尾文字</h3><p><strong>给父元素设置:</strong></p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;<span class="hljs-comment">/* 溢出隐藏 */</span><span class="hljs-attribute">line-height</span>: <span class="hljs-number">20px</span>;<span class="hljs-comment">/* 设置行高与容器高度成倍数关系，这样避免文本溢出时，文字显示一半 */</span><span class="hljs-attribute">text-align</span>: justify;<span class="hljs-comment">/* 设置文本对齐方式为两端对齐，这样在伪元素内容遮盖末尾文字时才能对齐*/</span><span class="hljs-attribute">position</span>: relative;<span class="hljs-comment">/* 子绝父相，这里是为了给伪元素设置定位*/</span>   作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dg4wsi/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><p><strong>给父元素设置伪元素 ::after ，并为其设置属性：</strong></p><div class="code-wrapper"><pre><code class="hljs css">     <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;...&quot;</span>;<span class="hljs-comment">/* 省略号是放在文本最后面的 */</span>     <span class="hljs-attribute">width</span>: <span class="hljs-number">1em</span>;<span class="hljs-comment">/* 设置伪元素的宽度为1em，是为了遮盖的时候正好遮盖中原来的一个字的大小*/</span>     <span class="hljs-attribute">background-color</span>: pink;<span class="hljs-comment">/* 设置与父元素相同的背景颜色，同理，也是为了和原来的内容样式保持一致*/</span>     <span class="hljs-attribute">position</span>: absolute;<span class="hljs-comment">/*设置定位，其位置就是文本的右下角 */</span>     <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dg4wsi/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h3 id="方法二：-利用旧版弹性盒"><a href="#方法二：-利用旧版弹性盒" class="headerlink" title="方法二： 利用旧版弹性盒"></a>方法二： 利用旧版弹性盒</h3><p>步骤：</p><p>给容器元素类型转换为 display:-webkit-box ;</p><p>设置弹性盒子垂直排列 -webkit-box-orient:vertical ;</p><p>控制要显示的行数 -webkit-line-clamp:数值 ；</p><p>溢出隐藏 overflow:hidden ;</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dg12ze/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dg12ze/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-comment">/* 多行文本溢出隐藏显示省略号方法二：</span></span><span class="hljs-comment"><span class="language-css">          兼容性写法,因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端</span></span><span class="hljs-comment"><span class="language-css">        */</span></span><span class="language-css">        <span class="hljs-selector-class">.box</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">            <span class="hljs-comment">/* height: 100px; 如果设置了高度，且高度超过文本显示行数，在第三行会正常出现省略号，但是三行之后的仍然正常显示*/</span></span><span class="language-css">            <span class="hljs-attribute">background-color</span>: pink;</span><span class="language-css">            <span class="hljs-comment">/* 设置高度是行高的倍数，防止文本露出一半 */</span></span><span class="language-css">            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">20px</span>;</span><span class="language-css">            <span class="hljs-comment">/* 旧版弹性盒 */</span></span><span class="language-css">            <span class="hljs-attribute">display</span>: -webkit-box;</span><span class="language-css">            <span class="hljs-comment">/* 弹性盒子元素垂直排列 */</span></span><span class="language-css">            -webkit-box-orient: vertical;</span><span class="language-css">            <span class="hljs-comment">/* 控制要显示的行数 */</span></span><span class="language-css">            -webkit-line-clamp: <span class="hljs-number">3</span>;</span><span class="language-css">            <span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">        &#125;</span><span class="language-css">        </span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>        我是文本我是文本我是文本我是文我是文我是文我是文我是文我是文我是文我是是文本我是文本我是文本我是文本我是文本我是文本我是文本我是文本我是文本    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dg12ze/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h2 id="第八章：用-CSS-实现三角符号"><a href="#第八章：用-CSS-实现三角符号" class="headerlink" title="第八章：用 CSS 实现三角符号"></a>第八章：用 CSS 实现三角符号</h2><p>本章讲用 CSS 实现三角符号问题的 8 种类型。</p><ol><li>类型一：上三角</li><li>类型二：下三角</li><li>类型三：左三角</li><li>类型四：右三角</li><li>类型五：左下三角</li><li>类型六：右下三角</li><li>类型七：右上三角</li><li>类型八：左上三角</li></ol><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/d3b2kh/">https://leetcode.cn/leetbook/read/interview-coding-frontend/d3b2kh/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="第九章：实现九宫格布局"><a href="#第九章：实现九宫格布局" class="headerlink" title="第九章：实现九宫格布局"></a>第九章：实现九宫格布局</h2><p>本章讲实现九宫格布局的 4 种方法。</p><p><a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dz5ud3/"></a><a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dz97wm/">方法一：flex</a><a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dzewn1/">方法二：float</a><a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dzo227/">方法三：grid</a>[方法四：table</p><h2 id="第十章：单行多行文字隐藏显示省略号"><a href="#第十章：单行多行文字隐藏显示省略号" class="headerlink" title="第十章：单行多行文字隐藏显示省略号"></a>第十章：单行多行文字隐藏显示省略号</h2><p>本章讲解实现单行多行文字隐藏显示省略号的不同方法。</p><h3 id="单行文字实现"><a href="#单行文字实现" class="headerlink" title="单行文字实现"></a>单行文字实现</h3><p>文字单行隐藏：给它设定一个宽和高，对于文字超出部分进行隐藏，多余的部分用省略号来表示。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">text-overflow</span>: ellipsis;<span class="hljs-attribute">overflow</span>: hidden ;<span class="hljs-attribute">white-space</span>: nowrap;</code></pre></div><h3 id="多行文字实现"><a href="#多行文字实现" class="headerlink" title="多行文字实现"></a>多行文字实现</h3><p>多行隐藏：多行隐藏的 div 的高度不能设置，让其自动 3 行隐藏即可。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span> : hidden;-webkit-line-clamp: <span class="hljs-number">3</span>;-webkit-box-orient: vertical;<span class="hljs-attribute">display</span>: -webkit-box;</code></pre></div><h2 id="第十一章-函数柯里化"><a href="#第十一章-函数柯里化" class="headerlink" title="第十一章 函数柯里化"></a>第十一章 函数柯里化</h2><p>本章讲解实现函数柯里化的不同方法。</p><h3 id="什么是函数柯里化"><a href="#什么是函数柯里化" class="headerlink" title="什么是函数柯里化"></a>什么是函数柯里化</h3><p>函数柯里化是指将使用多个参数的函数转化成一系列使用一个参数的函数的技术, 它返回一个新的函数, 这个新函数去处理剩余的参数</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ex:</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;    <span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><span class="hljs-comment">// 柯里化const addCurry = curry(add);addCurry(1)(2) // 3</span></code></pre></div><h3 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h3><p>实现思路: 通过函数的 length 属性获取函数的形参个数, 形参的个数就是所需参数的个数</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn</span>) &#123;  <span class="hljs-keyword">return</span> _curry.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, fn, fn.<span class="hljs-property">length</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">_curry</span>(<span class="hljs-params">fn, len, ...args</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...params</span>) &#123;    <span class="hljs-keyword">const</span> _args = args.<span class="hljs-title function_">concat</span>(params);    <span class="hljs-keyword">if</span> (_args.<span class="hljs-property">length</span> &gt;= len) &#123;      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, _args);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> _curry.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, fn, len, ..._args);    &#125;  &#125;&#125;<span class="hljs-comment">// test</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span> (a, b, c, d) &#123;  <span class="hljs-keyword">return</span> a + b + c + d;&#125;<span class="hljs-keyword">const</span> addCurry = <span class="hljs-title function_">curry</span>(add);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addCurry</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)) <span class="hljs-comment">// 10</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addCurry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)) <span class="hljs-comment">// 10</span></code></pre></div><h3 id="函数柯里化的作用"><a href="#函数柯里化的作用" class="headerlink" title="函数柯里化的作用"></a>函数柯里化的作用</h3><p>1、参数复用: 本质上来说就是降低通用性, 提高适用性</p><p>假如一个函数需要两个参数, 其中一个参数可能多次调用并不会发生更改, 比如商品打折的力度, 此时可以根据折扣进行封装</p><p>2、提前返回</p><p>经典实例: 元素绑定事件监听器, 区分 IE 浏览器的 attachEvent 方法</p><p>3、延迟计算: 柯里化函数不会立即执行计算，第一次只是返回一个函数，后面的调用才会进行计算</p><h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 实现一个add方法，使计算结果能够满足如下预期：</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)) <span class="hljs-comment">// 6;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)) <span class="hljs-comment">// 10;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)) <span class="hljs-comment">// 15;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>];  <span class="hljs-keyword">function</span> <span class="hljs-title function_">_add</span>(<span class="hljs-params"></span>) &#123;    args = args.<span class="hljs-title function_">concat</span>([...<span class="hljs-variable language_">arguments</span>]);    <span class="hljs-keyword">return</span> _add;  &#125;  _add.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> pre + cur;    &#125;)  &#125;  <span class="hljs-keyword">return</span> _add;&#125;</code></pre></div><h2 id="第十二章-图片懒加载"><a href="#第十二章-图片懒加载" class="headerlink" title="第十二章 图片懒加载"></a>第十二章 图片懒加载</h2><p>本章讲实现图片懒加载问题的 3 种方法。</p><h3 id="方法一：滚动监听-scrollTop-offsetTop-innerHeight"><a href="#方法一：滚动监听-scrollTop-offsetTop-innerHeight" class="headerlink" title="方法一：滚动监听 + scrollTop + offsetTop + innerHeight"></a>方法一：滚动监听 + scrollTop + offsetTop + innerHeight</h3><ul><li><p>scrollTop：指网页元素被滚动条卷去的部分。</p></li><li><p>offsetTop：元素相对父元素的位置</p></li><li><p>innerHeight：当前浏览器窗口的大小。需要注意兼容性问题。</p></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">img</span> &#123;</span><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;./img/loading.gif&#x27;</span>) no-repeat center;</span><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;</span><span class="language-css">            <span class="hljs-attribute">display</span>: block;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/1.jpeg&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/2.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/3.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/4.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/5.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/6.webp&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-keyword">let</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;img&#x27;</span>)</span><span class="language-javascript">        <span class="hljs-comment">// 1. 一上来立即执行一次</span></span><span class="language-javascript">        <span class="hljs-title function_">fn</span>()</span><span class="language-javascript">        <span class="hljs-comment">// 2. 监听滚动事件</span></span><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-title function_">lazyload</span>(fn, <span class="hljs-literal">true</span>)</span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-comment">// 获取视口高度和内容的偏移量</span></span><span class="language-javascript">            <span class="hljs-keyword">let</span> clietH = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientHeight</span>;</span><span class="language-javascript">            <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageYOffset</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span>;</span><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clietH, scrollTop);</span><span class="language-javascript">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; imgs.<span class="hljs-property">length</span>; i++) &#123;</span><span class="language-javascript">                <span class="hljs-keyword">let</span> x = scrollTop + clietH - imgs[i].<span class="hljs-property">offsetTop</span> <span class="hljs-comment">//当内容的偏移量+视口高度&gt;图片距离内容顶部的偏移量时，说明图片在视口内</span></span><span class="language-javascript">                <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">                    imgs[i].<span class="hljs-property">src</span> = imgs[i].<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-url&#x27;</span>); <span class="hljs-comment">//从dataurl中取出真实的图片地址赋值给url</span></span><span class="language-javascript">                &#125;</span><span class="language-javascript">            &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript">          <span class="hljs-comment">// 函数节流</span></span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyload</span>(<span class="hljs-params">fn, immediate</span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span></span><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">                <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;</span><span class="language-javascript">                <span class="hljs-keyword">if</span> (!timer) &#123;</span><span class="language-javascript">                    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">                        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>)</span><span class="language-javascript">                        timer = <span class="hljs-literal">null</span></span><span class="language-javascript">                    &#125;, <span class="hljs-number">200</span>)</span><span class="language-javascript">                &#125;</span><span class="language-javascript">            &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dzv8fv/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h3 id="方法二：滚动监听-getBoundingClientRect"><a href="#方法二：滚动监听-getBoundingClientRect" class="headerlink" title="方法二：滚动监听 + getBoundingClientRect()"></a>方法二：滚动监听 + getBoundingClientRect()</h3><ul><li><p>rectObject.top：元素上边到视窗上边的距离;</p></li><li><p>rectObject.right：元素右边到视窗左边的距离;</p></li><li><p>rectObject.bottom：元素下边到视窗上边的距离;</p></li><li><p>rectObject.left：元素左边到视窗左边的距离;</p></li><li><p>rectObject.width：元素自身的宽度;</p></li><li><p>rectObject.height：元素自身的高度;</p></li></ul><div class="code-wrapper"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        * &#123;</span><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><span class="language-css">        &#125;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">img</span> &#123;</span><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;./img/loading.gif&#x27;</span>) no-repeat center;</span><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;</span><span class="language-css">            <span class="hljs-attribute">display</span>: block;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/1.jpeg&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/2.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/3.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/4.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/5.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/6.webp&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-keyword">let</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;img&#x27;</span>)</span><span class="language-javascript">        <span class="hljs-comment">// 1. 一上来立即执行一次</span></span><span class="language-javascript">        <span class="hljs-title function_">fn</span>()</span><span class="language-javascript">        <span class="hljs-comment">// 2. 监听滚动事件</span></span><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-title function_">lazyload</span>(fn, <span class="hljs-literal">true</span>)</span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-comment">// 获取视口高度和内容的偏移量</span></span><span class="language-javascript">            <span class="hljs-keyword">let</span> offsetHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span></span><span class="language-javascript">            <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(imgs).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;</span><span class="language-javascript">                <span class="hljs-keyword">let</span> oBounding = item.<span class="hljs-title function_">getBoundingClientRect</span>() <span class="hljs-comment">//返回一个矩形对象，包含上下左右的偏移值</span></span><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index, oBounding.<span class="hljs-property">top</span>, offsetHeight);</span><span class="language-javascript">                <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt;= oBounding.<span class="hljs-property">top</span> &amp;&amp; oBounding.<span class="hljs-property">top</span> &lt;= offsetHeight) &#123;</span><span class="language-javascript">                    item.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>, item.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-url&#x27;</span>))</span><span class="language-javascript">                &#125;</span><span class="language-javascript">            &#125;)</span><span class="language-javascript">        &#125;</span><span class="language-javascript">        <span class="hljs-comment">// 函数节流</span></span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyload</span>(<span class="hljs-params">fn, immediate</span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span></span><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">                <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;</span><span class="language-javascript">                <span class="hljs-keyword">if</span> (!timer) &#123;</span><span class="language-javascript">                    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">                        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>)</span><span class="language-javascript">                        timer = <span class="hljs-literal">null</span></span><span class="language-javascript">                    &#125;, <span class="hljs-number">200</span>)</span><span class="language-javascript">                &#125;</span><span class="language-javascript">            &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dzwibj/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h3 id="方法三-intersectionObserve"><a href="#方法三-intersectionObserve" class="headerlink" title="方法三: intersectionObserve()"></a>方法三: intersectionObserve()</h3><ul><li><p>IntersectionObserver : 浏览器原生提供的构造函数，接收两个参数</p></li><li><p>IntersectionObserver API 是异步的，不会与目标元素的滚动同步触发</p></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">img</span> &#123;</span><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;./img/loading.gif&#x27;</span>) no-repeat center;</span><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;</span><span class="language-css">            <span class="hljs-attribute">display</span>: block;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/1.jpeg&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/2.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/3.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/4.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/5.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/6.webp&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-keyword">let</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;img&#x27;</span>)</span><span class="language-javascript">        <span class="hljs-comment">// 1. 一上来立即执行一次</span></span><span class="language-javascript">        <span class="hljs-keyword">let</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">entires</span>) &#123;</span><span class="language-javascript">            <span class="hljs-comment">//图片进入视口时就执行回调</span></span><span class="language-javascript">            entires.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;</span><span class="language-javascript">                <span class="hljs-comment">// 获取目标元素</span></span><span class="language-javascript">                <span class="hljs-keyword">let</span> oImg = item.<span class="hljs-property">target</span></span><span class="language-javascript">                <span class="hljs-comment">// console.log(item);</span></span><span class="language-javascript">                <span class="hljs-comment">// 当图片进入视口的时候，就赋值图片的真实地址</span></span><span class="language-javascript">                <span class="hljs-keyword">if</span> (item.<span class="hljs-property">intersectionRatio</span> &gt; <span class="hljs-number">0</span> &amp;&amp; item.<span class="hljs-property">intersectionRatio</span> &lt;= <span class="hljs-number">1</span>) &#123;</span><span class="language-javascript">                    oImg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>, oImg.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-url&#x27;</span>))</span><span class="language-javascript">                &#125;</span><span class="language-javascript">            &#125;)</span><span class="language-javascript">        &#125;)</span><span class="language-javascript">        <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(imgs).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;</span><span class="language-javascript">            io.<span class="hljs-title function_">observe</span>(element)  <span class="hljs-comment">//给每一个图片设置监听</span></span><span class="language-javascript">        &#125;);</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="第十三章：bind、apply、call-的用法"><a href="#第十三章：bind、apply、call-的用法" class="headerlink" title="第十三章：bind、apply、call 的用法"></a>第十三章：bind、apply、call 的用法</h2><p>本章讲解 call、apply、bind 的相同点和不同点以及手撕代码。</p><h3 id="相同点和不同点"><a href="#相同点和不同点" class="headerlink" title="相同点和不同点"></a>相同点和不同点</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol><li><p>三个都是用于改变 this 指向；</p></li><li><p>接收的第一个参数都是 this 要指向的对象；</p></li><li><p>都可以利用后续参数传参。</p></li></ol><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol><li><p>call 和 bind 传参相同，多个参数依次传入的；</p></li><li><p>apply 只有两个参数，第二个参数为数组；</p></li><li><p>call 和 apply 都是对函数进行直接调用，而 bind 方法不会立即调用函数，而是返回一个修改 this 后的函数。</p></li></ol><h3 id="call的用法"><a href="#call的用法" class="headerlink" title="call的用法"></a>call的用法</h3><div class="code-wrapper"><pre><code class="hljs JavaScript">fn.<span class="hljs-title function_">call</span>(thisArg, arg1, arg2, arg3, ...)</code></pre></div><p>调用 fn.call 时会将 fn 中的 this 指向修改为传入的第一个参数 thisArg；将后面的参数传入给 fn,并立即执行函数 fn。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaoming&quot;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>,        <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">job, hobby</span>) &#123;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我叫<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>,今年<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁。我的工作是: <span class="hljs-subst">$&#123;job&#125;</span>，我的爱好是: <span class="hljs-subst">$&#123;hobby&#125;</span>。`</span>);        &#125;    &#125;    obj.<span class="hljs-title function_">sayHello</span>(<span class="hljs-string">&#x27;程序员&#x27;</span>, <span class="hljs-string">&#x27;看美女&#x27;</span>); <span class="hljs-comment">// 我叫xiaoming,今年24岁。我的工作是: 程序员，我的爱好是: 看美女。</span>    <span class="hljs-keyword">let</span> obj1 = &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lihua&quot;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>    &#125;    <span class="hljs-comment">// obj1.sayHello(); // Uncaught TypeError: obj1.sayHello is not a function</span>    obj.<span class="hljs-property">sayHello</span>.<span class="hljs-title function_">call</span>(obj1, <span class="hljs-string">&#x27;设计师&#x27;</span>, <span class="hljs-string">&#x27;画画&#x27;</span>); <span class="hljs-comment">// 我叫lihua,今年30岁。我的工作是: 设计师，我的爱好是: 画画。</span></code></pre></div><p>手撕call的写法：</p><ul><li><p>第一参数接收 this 对象</p></li><li><p>改变 this 指向：将函数作为传入 this 对象的方法</p></li><li><p>展开语法，支持传入和调用参数列表</p></li><li><p>调用并删除方法，返回结果</p></li></ul><div class="code-wrapper"><pre><code class="hljs actionscript">Function.prototype.myCall = <span class="hljs-keyword">function</span><span class="hljs-params">(_this, <span class="hljs-rest_arg">...args</span>)</span> &#123;        <span class="hljs-keyword">if</span> (!_this) _this = Object.create(<span class="hljs-literal">null</span>)        _this.fn = <span class="hljs-keyword">this</span>        <span class="hljs-keyword">const</span> res = _this.fn(...args)        <span class="hljs-keyword">delete</span> _this.fn        <span class="hljs-keyword">return</span> res&#125;<span class="hljs-comment">// 使用</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> <span class="hljs-params">(a, b)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.v + a + b&#125;sum.myCall(&#123;v: <span class="hljs-number">1</span>&#125;, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 6</span></code></pre></div><h3 id="apply的用法"><a href="#apply的用法" class="headerlink" title="apply的用法"></a>apply的用法</h3><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-title function_">apply</span>(thisArg, [argsArr])</code></pre></div><p>fn.apply 的作用和 call 相同：修改 this 指向，并立即执行 fn。区别在于传参形式不同， apply 接受两个参数，第一个参数是要指向的 this 对象，第二个参数是一个数组，数组里面的元素会被展开传入 fn , 作为 fn 的参数。</p><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaoming&quot;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>,        <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">job, hobby</span>) &#123;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我叫<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>,今年<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁。我的工作是: <span class="hljs-subst">$&#123;job&#125;</span>，我的爱好是: <span class="hljs-subst">$&#123;hobby&#125;</span>。`</span>);        &#125;    &#125;    obj.<span class="hljs-title function_">sayHello</span>(<span class="hljs-string">&#x27;程序员&#x27;</span>, <span class="hljs-string">&#x27;看美女&#x27;</span>); <span class="hljs-comment">// 我叫xiaoming,今年24岁。我的工作是: 程序员，我的爱好是: 看美女。</span>    <span class="hljs-keyword">let</span> obj1 = &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lihua&quot;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>    &#125;    obj.<span class="hljs-property">sayHello</span>.<span class="hljs-title function_">apply</span>(obj1, [<span class="hljs-string">&#x27;设计师&#x27;</span>, <span class="hljs-string">&#x27;画画&#x27;</span>]); <span class="hljs-comment">// 我叫lihua,今年30岁。我的工作是: 设计师，我的爱好是: 画画。</span></code></pre></div><p>手撕 apply 的写法：</p><ul><li><p>第一参数接收 this 对象</p></li><li><p>改变 this 指向：将函数作为传入 this 对象的方法</p></li><li><p>第二个参数默认数组</p></li><li><p>展开语法，支持调用参数列表</p></li><li><p>调用并删除方法，返回结果</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">_this, args = []</span>) &#123;        <span class="hljs-keyword">if</span> (!_this) _this = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)        _this.<span class="hljs-property">fn</span> =<span class="hljs-variable language_">this</span>        <span class="hljs-keyword">const</span> res = _this.<span class="hljs-title function_">fn</span>(...args)        <span class="hljs-keyword">delete</span> _this.<span class="hljs-property">fn</span>        <span class="hljs-keyword">return</span> res&#125;<span class="hljs-comment">// 使用</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (a, b) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">v</span> + a + b&#125;sum.<span class="hljs-title function_">myApply</span>(&#123;<span class="hljs-attr">v</span>: <span class="hljs-number">1</span>&#125;, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// 6</span></code></pre></div><h3 id="bind-的用法"><a href="#bind-的用法" class="headerlink" title="bind 的用法"></a>bind 的用法</h3><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-title function_">bind</span>(thisArg, arg1, arg2, arg3, ...)</code></pre></div><p>fn.bind 的作用是只修改 this 指向，但不会立即执行 fn ；会返回一个修改了 this 指向后的 fn 。需要调用才会执行: bind(thisArg, arg1, arg2, arg3, …)()。bind 的传参和 call 相同。</p><p>手撕bind的写法：</p><ul><li><p>第一个参数接收 this 对象</p></li><li><p>返回函数，根据使用方式</p></li></ul><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dzi9zh/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dzi9zh/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">_this, ...args</span>) &#123;        <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">this</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params">...args2</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> F ? <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>(...args, ...args2)                : fn.<span class="hljs-title function_">apply</span>(_this, args.<span class="hljs-title function_">concat</span>(args2))        &#125;&#125;<span class="hljs-comment">//使用</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Sum</span> (a, b) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">v</span>= (<span class="hljs-variable language_">this</span>.<span class="hljs-property">v</span> || <span class="hljs-number">0</span>)+ a + b        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>&#125;<span class="hljs-keyword">const</span> <span class="hljs-title class_">NewSum</span> = <span class="hljs-title class_">Sum</span>.<span class="hljs-title function_">myBind</span>(&#123;<span class="hljs-attr">v</span>: <span class="hljs-number">1</span>&#125;, <span class="hljs-number">2</span>)<span class="hljs-title class_">NewSum</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 调用：&#123;v: 6&#125;</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">NewSum</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 构造函数：&#123;v: 5&#125; 忽略 myBind 绑定this</span></code></pre></div><h2 id="第十四章：手写-new"><a href="#第十四章：手写-new" class="headerlink" title="第十四章：手写 new"></a>第十四章：手写 new</h2><ul><li>第一参数作为构造函数，其余参数作为构造函数参数</li><li>继承构造函数原型创建新对象</li><li>执行构造函数</li><li>结果为对象，返回结果，反之，返回新对象</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">...args</span>) &#123;        <span class="hljs-keyword">const</span> <span class="hljs-title class_">Constructor</span> = args[<span class="hljs-number">0</span>]        <span class="hljs-keyword">const</span> o = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)        <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(o, args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>))        <span class="hljs-keyword">return</span> res <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? res : o&#125;<span class="hljs-comment">// 使用</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">P</span>(<span class="hljs-params">v</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">v</span> = v&#125;<span class="hljs-keyword">const</span> p = <span class="hljs-title function_">myNew</span>(P, <span class="hljs-number">1</span>) <span class="hljs-comment">// P &#123;v: 1&#125;</span></code></pre></div><h2 id="第十五章：promise-的用法"><a href="#第十五章：promise-的用法" class="headerlink" title="第十五章：promise 的用法"></a>第十五章：promise 的用法</h2><p>本章讲解 promise 的用法及对应函数的手撕代码。</p><h3 id="promise-相关概念"><a href="#promise-相关概念" class="headerlink" title="promise 相关概念"></a>promise 相关概念</h3><p>回调方法：就是将一个方法 func2 作为参数传入另一个方法 func1 中，当 func1 执行到某一步或者满足某种条件的时候才执行传入的参数 func2</p><p>Promise 是 ES6 引入的异步编程的新解决方案。</p><p>Promise 对象三种状态：初始化、成功、失败 pending-进行中、resolved-已完成、rejected-已失败</p><p>就好像，你跟你女朋友求婚，她跟你说她要考虑一下，明天才能给你答案，这就是承诺（promise）。同时，这也是一个等待的过程（pending），然后你就等，等到明天你女朋友给你答复，同意（resolved）或者拒绝（rejected），如果同意就准备结婚了，如果不同意就等下次再求婚，哈哈哈。</p><p>promise 是用来解决两个问题的：</p><ul><li><p>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</p></li><li><p>promise 可以支持多个并发的请求，获取并发请求中的数据</p></li><li><p>这个 promise 可以解决异步的问题，本身不能说 promise 是异步的</p></li></ul><h3 id="promise-基本用法"><a href="#promise-基本用法" class="headerlink" title="promise 基本用法"></a>promise 基本用法</h3><p>这样构造 promise 实例，然后调用 .then.then.then 的编写代码方式，就是 promise。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">//    调用了Promise构造函数</span>  <span class="hljs-comment">// 做一些事情</span>  <span class="hljs-comment">// 然后在某些条件下resolve，或者reject</span>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 条件随便写^_^ */</span>) &#123;    <span class="hljs-title function_">resolve</span>()  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-title function_">reject</span>()  &#125;&#125;)p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;                                 <span class="hljs-comment">//    调用了promise实例的.then方法</span>    <span class="hljs-comment">// 如果p的状态被resolve了，就进入这里</span>&#125;, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 如果p的状态被reject</span>&#125;)</code></pre></div><h3 id="声明一个-Promise-对象"><a href="#声明一个-Promise-对象" class="headerlink" title="声明一个 Promise 对象"></a>声明一个 Promise 对象</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;     <span class="hljs-comment">// 这两个方法主要是用来修改状态的</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;开始求婚。&quot;</span>)    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;。。。。。&quot;</span>)    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;考虑一下。&quot;</span>)    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (isHandsome || isRich) &#123; <span class="hljs-comment">// 当我们调用 resolve 函数的时候，Promise 的状态就变成 resolved</span>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;我同意！&#x27;</span>)        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 当我们调用 reject 函数的时候，Promise 的状态就变成 reject</span>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;拒绝：我们八字不合&quot;</span>)        &#125;    &#125;, <span class="hljs-number">2000</span>)&#125;)<span class="hljs-comment">// 如果一个 promise 已经被兑现（resolved）或被拒绝（rejected），那么我们也可以说它处于已敲定（settled）状态。</span></code></pre></div><h3 id="Promise-prototype-then-方法"><a href="#Promise-prototype-then-方法" class="headerlink" title="Promise.prototype.then 方法"></a>Promise.prototype.then 方法</h3><p>已成功 <strong>resolved 的回调和已失败 rejected 的回调</strong></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 调用 Promise 对象的then方法，两个参数为函数</span>p.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123; <span class="hljs-comment">// 成功</span>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">season</span>)&#123; <span class="hljs-comment">// 失败</span>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(season);&#125;);</code></pre></div><p>getNumber()</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">getNumber</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);&#125;);</code></pre></div><h3 id="Promise-prototype-catch-方法"><a href="#Promise-prototype-catch-方法" class="headerlink" title="Promise.prototype.catch 方法"></a>Promise.prototype.catch 方法</h3><p>catch() 的作用是捕获 Promise 的错误</p><p>其实它和 then 的第二个参数一样，用来指定 reject 的回调，用法是这样：</p><p>在执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死 js，而是会进到这个 catch 方法中。请看下面的代码：</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dz36t5/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dz36t5/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div class="code-wrapper"><pre><code class="hljs javascript">promise.<span class="hljs-title function_">then</span>(    <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this is success callback&#x27;</span>) &#125;).<span class="hljs-title function_">catch</span>(    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err) &#125;)</code></pre></div><p>效果和写在 then 的第二个参数里面一样。不过它还有另外一个作用：在执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死 js ，而是会进到这个 catch 方法中。请看下面的代码：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">getNumber</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(somedata);  <span class="hljs-comment">//此处的somedata未定义</span>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);&#125;);</code></pre></div><h3 id="Promise-all-方法"><a href="#Promise-all-方法" class="headerlink" title="Promise.all() 方法"></a>Promise.all() 方法</h3><p>有了 all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。</p><p>「谁跑的慢，以谁为准执行回调」</p><p>Promise 的 all 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">runAsync1</span>(), <span class="hljs-title function_">runAsync2</span>(), <span class="hljs-title function_">runAsync3</span>()]).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">results</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results);&#125;);</code></pre></div><p>Promise.all 手撕代码题:</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">myPromiseAll</span> =(<span class="hljs-params">arr</span>)=&gt;&#123;     <span class="hljs-keyword">let</span> result = [];     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Peomise</span> (<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;             arr[i].<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;                 result[i] = data;                 <span class="hljs-keyword">if</span>(result.<span class="hljs-property">length</span> === arr.<span class="hljs-property">length</span>)<span class="hljs-comment">//所有的都成功才执行成功的回调</span>                 &#123;                     <span class="hljs-title function_">resolve</span>(result)                   &#125;<span class="hljs-comment">//这里可以用计数器更好点</span>             &#125;,reject)<span class="hljs-comment">//有一个失败则执行失败的回调</span>         &#125;     &#125;)&#125;</code></pre></div><h3 id="Promise-race-方法"><a href="#Promise-race-方法" class="headerlink" title="Promise.race() 方法"></a>Promise.race() 方法</h3><ul><li><p>「谁跑的快，以谁为准执行回调」</p></li><li><p>1 秒后 runAsync1 已经执行完了，此时then里面的就执行了</p></li><li><p>在 then 里面的回调开始执行时，runAsync2() 和 runAsync3() 并没有停止，仍旧再执行。</p></li><li><p>于是再过 1 秒后，输出了他们结束的标志。</p></li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript">  <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)&#123;        <span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();        img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;            <span class="hljs-title function_">resolve</span>(img);        &#125;        img.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;xxxxxx&#x27;</span>;    &#125;);    <span class="hljs-keyword">return</span> p;&#125;<span class="hljs-comment">//延时函数，用于给请求计时</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)&#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;图片请求超时&#x27;</span>);        &#125;, <span class="hljs-number">5000</span>);    &#125;);    <span class="hljs-keyword">return</span> p;&#125;<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-title function_">requestImg</span>(), <span class="hljs-title function_">timeout</span>()]).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">results</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results);&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);&#125;);</code></pre></div><p>Promise.race()手撕代码用法：</p><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseRace</span>(<span class="hljs-params">promises</span>) &#123;     <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(promises)) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;promises must be an array&quot;</span>)     &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;         promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span>             <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;                 <span class="hljs-title function_">resolve</span>(data)                 &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                 <span class="hljs-title function_">reject</span>(err)             &#125;)         )     &#125;) &#125;</code></pre></div><h3 id="Promise-prototype-finally-方法"><a href="#Promise-prototype-finally-方法" class="headerlink" title="Promise.prototype.finally() 方法"></a>Promise.prototype.finally() 方法</h3><p>finally 方法用于指定无论 Promise 对象的最终状态如何，都将执行 finally。Finally 不接受参数。Finally 独立于先前的执行状态，不依赖于先前的运行结果。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x + <span class="hljs-number">1</span>);&#125;);promise4  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好&quot;</span>);&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);&#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;finally&quot;</span>);&#125;);<span class="hljs-comment">// finally</span></code></pre></div><h2 id="第十六章：解析-URL"><a href="#第十六章：解析-URL" class="headerlink" title="第十六章：解析 URL"></a>第十六章：解析 URL</h2><h3 id="什么是解析URL？"><a href="#什么是解析URL？" class="headerlink" title="什么是解析URL？"></a>什么是解析URL？</h3><p>js解析url，就是将如下url： <code>const url = https://www.baidu.com/m?f=8&amp;ie=utf-8&amp;rsv_bp=1&amp;tn=monline_3_dg&amp;wd=session</code> 解析为：</p><div class="code-wrapper"><pre><code class="hljs css">&#123;f:<span class="hljs-string">&#x27;8&#x27;</span>,ie:<span class="hljs-string">&#x27;utf-8&#x27;</span>rsv_bp:<span class="hljs-string">&#x27;1&#x27;</span>,tn:<span class="hljs-string">&#x27;monline_3_dg&#x27;</span>,wd:<span class="hljs-string">&#x27;session&#x27;</span>&#125;</code></pre></div><h3 id="方法一：利用-splice-分割-循环依次取出"><a href="#方法一：利用-splice-分割-循环依次取出" class="headerlink" title="方法一：利用 splice 分割 + 循环依次取出"></a>方法一：利用 splice 分割 + 循环依次取出</h3><ul><li>解析 url 并将其存储在新对象中，因此初始化一个空对象，让 obj &#x3D; {}</li><li>首先判断 url 后面是否有 ？传参, 如果没有 ? 传参，直接返回空对象</li></ul><p>if (url.indexOf(‘?’) &lt; 0) return obj</p><ul><li>用 <code>？</code> 进行参数分割 let arr &#x3D; url.split(‘?’)</li></ul><p>此时的效果是将 ? 前后，一分为二</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">queryURLparams</span>(<span class="hljs-params">url</span>) &#123;    <span class="hljs-keyword">let</span> obj = &#123;&#125;    <span class="hljs-keyword">if</span> (url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;?&#x27;</span>) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> obj    <span class="hljs-keyword">let</span> arr = url.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;?&#x27;</span>)    url = arr[<span class="hljs-number">1</span>]    <span class="hljs-keyword">let</span> array = url.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>)    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;        <span class="hljs-keyword">let</span> arr2 = array[i]        <span class="hljs-keyword">let</span> arr3 = arr2.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;=&#x27;</span>)        obj[arr3[<span class="hljs-number">0</span>]] = arr3[<span class="hljs-number">1</span>]    &#125;    <span class="hljs-keyword">return</span> obj&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">queryURLparams</span>(url)); <span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;https://www.baidu.com/m?f=8&amp;ie=utf-8&amp;rsv_bp=1&amp;tn=monline_3_dg&amp;wd=session&quot;</span>;   <span class="hljs-keyword">function</span> <span class="hljs-title function_">getURL</span>(<span class="hljs-params">url</span>)&#123;      <span class="hljs-keyword">let</span> str = url.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;?&quot;</span>)[<span class="hljs-number">1</span>];      <span class="hljs-keyword">let</span> str1 = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);      <span class="hljs-keyword">let</span> obj = &#123;&#125;;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt;str1.<span class="hljs-property">length</span>; i++)&#123;          <span class="hljs-keyword">let</span> str2 = str1[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>);          <span class="hljs-keyword">let</span> key = str2[<span class="hljs-number">0</span>];          <span class="hljs-keyword">let</span> value = str2[<span class="hljs-number">1</span>];          obj[key] = value;      &#125;      <span class="hljs-keyword">return</span> obj;  &#125;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getURL</span>(url))</code></pre></div><h3 id="方法二-正则-arguments"><a href="#方法二-正则-arguments" class="headerlink" title="方法二: 正则 + arguments"></a>方法二: 正则 + arguments</h3><ul><li>正则匹配规则 <code>/([^?=&amp;]+)=([^?=&amp;]+)/g</code></li><li>利用 replace 替换</li><li>用伪数组进行键值对拼接</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">queryURLparamsRegEs5</span>(<span class="hljs-params">url</span>) &#123;    <span class="hljs-keyword">let</span> obj = &#123;&#125;    <span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/([^?=&amp;]+)=([^?=&amp;]+)/g</span>    url.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;        obj[<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]] = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">2</span>]    &#125;)    <span class="hljs-keyword">return</span> obj&#125;</code></pre></div><h3 id="方法三-正则-arg"><a href="#方法三-正则-arg" class="headerlink" title="方法三: 正则 + ..arg"></a>方法三: 正则 + ..arg</h3><ul><li>就是用 ES6 的 …arg</li><li>其实和 arguments 差不多 ，就是 arguments 是伪数组，…arg 是真数组</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">queryURLparamsRegEs6</span>(<span class="hljs-params">url</span>) &#123;    <span class="hljs-keyword">let</span> obj = &#123;&#125;    <span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/([^?=&amp;]+)=([^?=&amp;]+)/g</span>    url.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-function">(<span class="hljs-params">...arg</span>) =&gt;</span> &#123;        obj[arg[<span class="hljs-number">1</span>]] = arg[<span class="hljs-number">2</span>]    &#125;)    <span class="hljs-keyword">return</span> obj&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>理解Nginx</title>
    <link href="/2023/01/28/%E7%90%86%E8%A7%A3Nginx/"/>
    <url>/2023/01/28/%E7%90%86%E8%A7%A3Nginx/</url>
    
    <content type="html"><![CDATA[<h2 id="Nginx是什么？"><a href="#Nginx是什么？" class="headerlink" title="Nginx是什么？"></a>Nginx是什么？</h2><p><code>Nginx</code> (engine x) 是一个<strong>轻量级、高性能的HTTP</strong>和<strong>反向代理服务器</strong>,同时也是一个<strong>通用代理服务器</strong>(TCP&#x2F;UDP&#x2F;IMAP&#x2F;POP3&#x2F;SMTP),最初由俄罗斯人Igor Sysoev编写。</p><p>简单的说：</p><ul><li><code>Nginx</code>是一个拥有高性能HTTP和反向代理服务器，其特点是<code>占用内存少</code>，<code>并发能力强</code>，并且在现实中，nginx的并发能力要比在同类型的网页服务器中表现要好</li><li><code>Nginx</code>专为<code>性能优化</code>而开发，最重要的要求便是<code>性能</code>，且十分注重效率，有报告nginx能支持高达50000个并发连接数</li></ul><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><p>Nginx 是一个反向代理服务器，那么反向代理是什么呢？我们先看看什么叫做正向代理</p><p><strong>正向代理</strong>：局域网中的电脑用户想要直接访问网络是不可行的，只能通过代理服务器（Server）来访问，这种代理服务就被称为正向代理。</p><p>就好比我们俩在一块，直接对话即可，但如果我和你分隔两地，我们要想对话，必须借助一个通讯设备（如：电话）来沟通，那么这个通讯设备就是”代理服务器”，这种行为称为“正向代理”</p><p>那么反向代理是什么呢？</p><p><strong>反向代理</strong>：客户端无法感知代理，因为客户端访问网络不需要配置，只要把请求发送到反向代理服务器，由<strong>反向代理服务器去选择目标服务器</strong>获取数据，然后再返回到客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p><p>在正向代理中，我向你打电话，你能看到向你打电话的电话号码，由电话号码知道是我给你打的，那么此时我用<code>虚拟电话</code>给你打过去，你看到的不再是我的手机号，而是<code>虚拟号码</code>,你便不知道是我给你打的，这种行为变叫做”反向代理”。</p><p>在以上述的例子简单的说下：</p><ul><li>正向代理：我通过我的手机（proxy Server）去给你打电话，相当于<strong>我和我的手机</strong>是一个整体，与你的手机（Server）是分开的</li><li>反向代理：我通过我的手机（proxy Server）通过软件转化为虚拟号码去给你打电话，此时相当于<strong>我的手机和你的手机</strong>是一个整体，和我是分开的</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><strong>负载均衡</strong>：是高可用网络基础架构的关键组件，通常用于将工作<strong>负载分布到多个服务器</strong>来提高网站、应用、数据库或其他服务的性能和可靠性。</p><p>如果没有负载均衡，客户端与服务端的操作通常是：<strong>客户端请求服务端，然后服务端去数据库查询数据，将返回的数据带给客户端</strong>：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b03812eb40b047be8052ee9288f6798e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>但随着客户端越来越多，数据，访问量飞速增长，这种情况显然无法满足，我们从上图发现，客户端的请求和相应都是通过服务端的，那么我们加大服务端的量，让多个服务端分担，是不是就能解决这个问题了呢？</p><p>但此时对于客户端而言，他去访问这个地址就是固定的，才不会去管那个服务端有时间，你只要给我返回出数据就OK了，所以我们就需要一个“管理者“，将这些服务端找个老大过来，客户端直接找老大，再由老大分配谁处理谁的数据，从而减轻服务端的压力，而这个”老大“就是<strong>反向代理服务器</strong>，而端口号就是这些服务端的工号。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6c634ec69f54d5ab76644d8dd78b0c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>像这样，当有15个请求时，反向代理服务器会平均分配给服务端，也就是各处理5个，这个过程就称之为：<strong>负载均衡</strong></p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>当客户端发起请求时，正常的情况是这样的：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f9e589ff2224234ad1413e4c4c58cce~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>就好比你去找客服，一般先是先说一大堆官方的话，你问什么，他都会这么说，那么这个就叫<strong>静态资源（可以理解为是html，css）</strong></p><p>而回答具体的问题时，每个回答都是不同的，而这些不同的就叫做<strong>动态资源（会改变，可以理解为是变量）</strong></p><p>在未分离的时候，可以理解为每个客服都要先说出官方的话，在打出具体的回答，这无异加大了客服的工作量，所以为了更好的有效利用客服的时间，我们把这些官方的话分离出来，找个机器人，让他代替客服去说，这样就减轻了客服的工作量。</p><p>也就是说，我们将动态资源和静态资源分离出来，交给不同的服务器去解析，这样就加快了解析的速度，从而降低由单个服务器的压力</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a91e7a373df14e90891e6f4f62a629d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h2><p>关于 nginx 如何安装，这里就不做过多的介绍了，感兴趣的小伙伴看看这篇文章：<a href="https://link.juejin.cn/?target=https://blog.csdn.net/yujing1314/article/details/97267369" title="https://blog.csdn.net/yujing1314/article/details/97267369">【Linux】中如何安装nginx</a></p><p>这里让我们看看一些常用的命令：</p><ul><li>查看版本：<code>./nginx -v</code></li><li>启动：<code>./nginx</code></li><li>关闭：<code>./nginx -s stop</code>(推荐) 或 <code>./nginx -s quit</code></li><li>重新加载nginx配置：<code>./nginx -s reload</code></li></ul><h2 id="Nginx-的配置文件"><a href="#Nginx-的配置文件" class="headerlink" title="Nginx 的配置文件"></a>Nginx 的配置文件</h2><p>配置文件分为三个模块：</p><ul><li>全局块：从配置文件开始到events块之间，主要是设置一些<strong>影响nginx服务器整体运行的配置指令</strong>。（按道理说：并发处理服务的配置时，值越大，可支持的并发处理量越多，但此时会受到硬件、软件等设备等的制约）</li><li>events块：影响<strong>nginx服务器与用户的网络连接</strong>，常用的设置包括是否开启对多workprocess下的网络连接进行序列化，是否允许同时接收多个网络连接等等</li><li>http块：如反向代理和负载均衡都在此配置</li></ul><h2 id="location-的匹配规则"><a href="#location-的匹配规则" class="headerlink" title="location 的匹配规则"></a>location 的匹配规则</h2><p>共有四种方式：</p><div class="code-wrapper"><pre><code class="hljs gherkin">    location[ = |<span class="hljs-string"> ~ </span>|<span class="hljs-string"> ~* </span>|<span class="hljs-string"> ^~ ] url &#123;</span><span class="hljs-string">    </span><span class="hljs-string">    &#125;</span><span class="hljs-string">复制代码</span></code></pre></div><ul><li><code>=</code> ：<code>精确匹配</code>，用于<strong>不含正则表达式</strong>的url前，要求字符串与url<strong>严格匹配</strong>，完全相等时，才能停止向下搜索并处理请求</li><li><code>^~</code>：用于<strong>不含正则表达式</strong>的url前，要求ngin服务器找到表示<strong>url和字符串匹配度最高</strong>的location后，立即使用此location处理请求，而不再匹配</li><li><code>~</code> ：<code>最佳匹配</code>，用于表示url<strong>包含正则表达式</strong>，并且<strong>区分</strong>大小写。</li><li><code>~*</code>：与<code>~</code>一样，只是<strong>不区分</strong>大小写</li></ul><p>注意：</p><ul><li>如果 <code>url</code> 包含正则表达式，则不需要 <code>~</code> 作为开头表示</li><li>nginx的匹配具有<code>优先顺序</code>，一旦匹配上就会立马退出，不再进行向下匹配</li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>关于具体的配置可以参考：<a href="https://juejin.cn/post/7052952117425733663" title="https://juejin.cn/post/7052952117425733663">写给前端的nginx教程</a></p><h3 id="其他好文"><a href="#其他好文" class="headerlink" title="其他好文"></a>其他好文</h3><ul><li><a href="https://juejin.cn/post/7088304364078497800" title="https://juejin.cn/post/7088304364078497800">一篇让你完全够用TS的指南</a></li><li><a href="https://juejin.cn/post/7068935394191998990" title="https://juejin.cn/post/7068935394191998990">🔥花一个小时，迅速了解ES6~ES12的全部特性</a></li><li><a href="https://juejin.cn/post/7063657010885034020" title="https://juejin.cn/post/7063657010885034020">10分钟，打造一个专属于你的cli</a></li><li><a href="https://juejin.cn/post/7077805900055969823" title="https://juejin.cn/post/7077805900055969823">通过开水果店，帮你全面了解package.json文件的作用</a></li><li><a href="https://juejin.cn/post/7052204193968291870" title="https://juejin.cn/post/7052204193968291870">打造开箱即用的 react 移动端框架</a></li></ul><p>致此，有关Nginx相关的知识就已经完成了，相信对于前端而言已经足够了，喜欢的点个赞👍🏻支持下吧(●￣(ｴ)￣●)</p><p>文章被收录于专栏：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d8225778b6543f697208f3a32484dec~tplv-k3u1fbpfcp-no-mark:160:160:160:120.awebp" alt="cover"></p><p>前端八股文</p><p>八股文包含： node、 cli、webpack、git、网络、浏览器、性能优化、等一些实用的插件等</p><p>相关小册</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c802eb3fdc3a41a29229d496ebd0ef67~tplv-k3u1fbpfcp-no-mark:420:420:300:420.awebp" alt="「从前端到全栈」封面"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/288aed1ab1f044f08f541cfd12b5c221~tplv-k3u1fbpfcp-no-mark:420:420:300:420.awebp" alt="「NestJS 项目实战」封面"></p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/c794682f2184652c07e62d648e048460.svg"> 1k+</p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/3d482c7a948bac826e155953b2a28a9e.svg"> 收藏</p>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域方式实现原理</title>
    <link href="/2023/01/27/%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2023/01/27/%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="九种跨域方式实现原理"><a href="#九种跨域方式实现原理" class="headerlink" title="九种跨域方式实现原理"></a>九种跨域方式实现原理</h1><p>前后端数据交互经常会碰到请求跨域，什么是跨域，以及有哪几种跨域方式，这是本文要探讨的内容。</p><p><strong>本文完整的源代码请猛戳<a href="https://link.juejin.cn/?target=https://github.com/ljianshu/Blog">github博客</a>，纸上得来终觉浅，建议大家动手敲敲代码。</strong></p><h2 id="一、什么是跨域？"><a href="#一、什么是跨域？" class="headerlink" title="一、什么是跨域？"></a>一、什么是跨域？</h2><h3 id="1-什么是同源策略及其限制内容？"><a href="#1-什么是同源策略及其限制内容？" class="headerlink" title="1.什么是同源策略及其限制内容？"></a>1.什么是同源策略及其限制内容？</h3><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p><img src="/../imgs/%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1638b3579d9eeb32tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="url的组成"></p><p><strong>同源策略限制内容有：</strong></p><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容</li><li>DOM 节点</li><li>AJAX 请求发送后，结果被浏览器拦截了</li></ul><p>但是有三个标签是允许跨域加载资源：</p><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><h3 id="2-常见跨域场景"><a href="#2-常见跨域场景" class="headerlink" title="2.常见跨域场景"></a>2.常见跨域场景</h3><p><strong>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</strong>。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：</p><p><img src="/../imgs/%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1638b3579dde630etplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>特别说明两点：</p><p><strong>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</strong></p><p><strong>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”</strong>。</p><p>这里你或许有个疑问：<strong>请求跨域了，那么请求到底发出去没有？</strong></p><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p><h2 id="二、跨域解决方案"><a href="#二、跨域解决方案" class="headerlink" title="二、跨域解决方案"></a>二、跨域解决方案</h2><h3 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1.jsonp"></a>1.jsonp</h3><h4 id="1-JSONP原理"><a href="#1-JSONP原理" class="headerlink" title="1) JSONP原理"></a>1) JSONP原理</h4><p><strong>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</strong></p><h4 id="2-JSONP和AJAX对比"><a href="#2-JSONP和AJAX对比" class="headerlink" title="2) JSONP和AJAX对比"></a>2) JSONP和AJAX对比</h4><p>JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）</p><h4 id="3-JSONP优缺点"><a href="#3-JSONP优缺点" class="headerlink" title="3) JSONP优缺点"></a>3) JSONP优缺点</h4><p>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。<strong>缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</strong></p><h4 id="4-JSONP的实现流程"><a href="#4-JSONP的实现流程" class="headerlink" title="4) JSONP的实现流程"></a>4) JSONP的实现流程</h4><ul><li>声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</li><li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback&#x3D;show）。</li><li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是<code>show(&#39;我不爱你&#39;)</code>。</li><li>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</li></ul><p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// index.html</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">&#123; url, params, callback &#125;</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)    <span class="hljs-variable language_">window</span>[callback] = <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;      <span class="hljs-title function_">resolve</span>(data)      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(script)    &#125;    params = &#123; ...params, callback &#125; <span class="hljs-comment">// wd=b&amp;callback=show</span>    <span class="hljs-keyword">let</span> arrs = []    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) &#123;      arrs.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>`</span>)    &#125;    script.<span class="hljs-property">src</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;arrs.join(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;</span>`</span>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script)  &#125;)&#125;<span class="hljs-title function_">jsonp</span>(&#123;  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000/say&#x27;</span>,  <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">wd</span>: <span class="hljs-string">&#x27;Iloveyou&#x27;</span> &#125;,  <span class="hljs-attr">callback</span>: <span class="hljs-string">&#x27;show&#x27;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)&#125;)复制代码</code></pre></div><p>上面这段代码相当于向<code>http://localhost:3000/say?wd=Iloveyou&amp;callback=show</code>这个地址请求数据，然后后台返回<code>show(&#39;我不爱你&#39;)</code>，最后会运行show()这个函数，打印出’我不爱你’</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// server.js</span><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-keyword">let</span> app = <span class="hljs-title function_">express</span>()app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/say&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;  <span class="hljs-keyword">let</span> &#123; wd, callback &#125; = req.<span class="hljs-property">query</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wd) <span class="hljs-comment">// Iloveyou</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(callback) <span class="hljs-comment">// show</span>  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;callback&#125;</span>(&#x27;我不爱你&#x27;)`</span>)&#125;)app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)复制代码</code></pre></div><h4 id="5-jQuery的jsonp形式"><a href="#5-jQuery的jsonp形式" class="headerlink" title="5) jQuery的jsonp形式"></a>5) jQuery的jsonp形式</h4><p><strong>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。</strong></p><div class="code-wrapper"><pre><code class="hljs javascript">$.<span class="hljs-title function_">ajax</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&quot;http://crossdomain.com/jsonServerResponse&quot;</span>,<span class="hljs-attr">dataType</span>:<span class="hljs-string">&quot;jsonp&quot;</span>,<span class="hljs-attr">type</span>:<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-comment">//可以省略</span><span class="hljs-attr">jsonpCallback</span>:<span class="hljs-string">&quot;show&quot;</span>,<span class="hljs-comment">//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span><span class="hljs-attr">jsonp</span>:<span class="hljs-string">&quot;callback&quot;</span>,<span class="hljs-comment">//-&gt;把传递函数名的那个形参callback，可省略</span><span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;&#125;);复制代码</code></pre></div><h3 id="2-cors"><a href="#2-cors" class="headerlink" title="2.cors"></a>2.cors</h3><p><strong>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现</strong>。</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><h4 id="1-简单请求"><a href="#1-简单请求" class="headerlink" title="1) 简单请求"></a>1) 简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求</p><p>条件1：使用下列方法之一：</p><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><p>条件2：Content-Type 的值仅限于下列三者之一：</p><ul><li>text&#x2F;plain</li><li>multipart&#x2F;form-data</li><li>application&#x2F;x-www-form-urlencoded</li></ul><p>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p><h4 id="2-复杂请求"><a href="#2-复杂请求" class="headerlink" title="2) 复杂请求"></a>2) 复杂请求</h4><p>不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p><p>我们用<code>PUT</code>向后台请求时，属于复杂请求，后台需做如下配置：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 允许哪个方法访问我</span>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;PUT&#x27;</span>)<span class="hljs-comment">// 预检的存活时间</span>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="hljs-number">6</span>)<span class="hljs-comment">// OPTIONS请求不做任何处理</span><span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;  res.<span class="hljs-title function_">end</span>() &#125;<span class="hljs-comment">// 定义后台返回的内容</span>app.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">headers</span>)  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;我不爱你&#x27;</span>)&#125;)复制代码</code></pre></div><p>接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// index.html</span><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&#x27;name=xiamen&#x27;</span> <span class="hljs-comment">// cookie不能跨域</span>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">// 前端设置是否带cookie</span>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;PUT&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:4000/getData&#x27;</span>, <span class="hljs-literal">true</span>)xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;xiamen&#x27;</span>)xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;    <span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> === <span class="hljs-number">304</span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">response</span>)      <span class="hljs-comment">//得到响应头，后台需设置Access-Control-Expose-Headers</span>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-title function_">getResponseHeader</span>(<span class="hljs-string">&#x27;name&#x27;</span>))    &#125;  &#125;&#125;xhr.<span class="hljs-title function_">send</span>()复制代码<span class="hljs-comment">//server1.js</span><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">let</span> app = <span class="hljs-title function_">express</span>();app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(__dirname));app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);复制代码<span class="hljs-comment">//server2.js</span><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-keyword">let</span> app = <span class="hljs-title function_">express</span>()<span class="hljs-keyword">let</span> whitList = [<span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>] <span class="hljs-comment">//设置白名单</span>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;  <span class="hljs-keyword">let</span> origin = req.<span class="hljs-property">headers</span>.<span class="hljs-property">origin</span>  <span class="hljs-keyword">if</span> (whitList.<span class="hljs-title function_">includes</span>(origin)) &#123;    <span class="hljs-comment">// 设置哪个源可以访问我</span>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, origin)    <span class="hljs-comment">// 允许携带哪个头访问我</span>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>)    <span class="hljs-comment">// 允许哪个方法访问我</span>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;PUT&#x27;</span>)    <span class="hljs-comment">// 允许携带cookie</span>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="hljs-literal">true</span>)    <span class="hljs-comment">// 预检的存活时间</span>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="hljs-number">6</span>)    <span class="hljs-comment">// 允许返回的头</span>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Expose-Headers&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>)    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;      res.<span class="hljs-title function_">end</span>() <span class="hljs-comment">// OPTIONS请求不做任何处理</span>    &#125;  &#125;  <span class="hljs-title function_">next</span>()&#125;)app.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">headers</span>)  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;jw&#x27;</span>) <span class="hljs-comment">//返回一个响应头，后台需设置</span>  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;我不爱你&#x27;</span>)&#125;)app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">headers</span>)  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;我不爱你&#x27;</span>)&#125;)app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(__dirname))app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">4000</span>)复制代码</code></pre></div><p>上述代码由<code>http://localhost:3000/index.html</code>向<code>http://localhost:4000/</code>跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。</p><h3 id="3-postMessage"><a href="#3-postMessage" class="headerlink" title="3.postMessage"></a>3.postMessage</h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</strong>。</p><blockquote><p>otherWindow.postMessage(message, targetOrigin, [transfer]);</p></blockquote><ul><li>message: 将要发送到其他 window的数据。</li><li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li><li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><p>接下来我们看个例子： <code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递“我爱你”,然后后者传回”我不爱你”。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// a.html</span>  &lt;iframe src=<span class="hljs-string">&quot;http://localhost:4000/b.html&quot;</span> frameborder=<span class="hljs-string">&quot;0&quot;</span> id=<span class="hljs-string">&quot;frame&quot;</span> onload=<span class="hljs-string">&quot;load()&quot;</span>&gt;&lt;<span class="hljs-regexp">/iframe&gt; /</span><span class="hljs-regexp">/等它加载完触发一个事件</span><span class="hljs-regexp">  /</span><span class="hljs-regexp">/内嵌在http:/</span><span class="hljs-regexp">/localhost:3000/</span>a.<span class="hljs-property">html</span>    &lt;script&gt;      <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">let</span> frame = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;frame&#x27;</span>)        frame.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;我爱你&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:4000&#x27;</span>) <span class="hljs-comment">//发送数据</span>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123; <span class="hljs-comment">//接受返回数据</span>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>) <span class="hljs-comment">//我不爱你</span>        &#125;      &#125;    &lt;/script&gt;复制代码<span class="hljs-comment">// b.html</span>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>) <span class="hljs-comment">//我爱你</span>    e.<span class="hljs-property">source</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;我不爱你&#x27;</span>, e.<span class="hljs-property">origin</span>) &#125;复制代码</code></pre></div><h3 id="4-websocket"><a href="#4-websocket" class="headerlink" title="4.websocket"></a>4.websocket</h3><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p><p>原生WebSocket API使用起来不太方便，我们使用<code>Socket.io</code>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>我们先来看个例子：本地文件socket.html向<code>localhost:3000</code>发生数据和接受数据</p><div class="code-wrapper"><pre><code class="hljs xml">// socket.html<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">let</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:3000&#x27;</span>);</span><span class="language-javascript">    socket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;我爱你&#x27;</span>);<span class="hljs-comment">//向服务器发送数据</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript">    socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>);<span class="hljs-comment">//接收服务器返回的数据</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码// server.jslet express = require(&#x27;express&#x27;);let app = express();let WebSocket = require(&#x27;ws&#x27;);//记得安装wslet wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on(&#x27;connection&#x27;,function(ws) &#123;  ws.on(&#x27;message&#x27;, function (data) &#123;    console.log(data);    ws.send(&#x27;我不爱你&#x27;)  &#125;);&#125;)复制代码</code></pre></div><h3 id="5-Node中间件代理-两次跨域"><a href="#5-Node中间件代理-两次跨域" class="headerlink" title="5. Node中间件代理(两次跨域)"></a>5. Node中间件代理(两次跨域)</h3><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong> 代理服务器，需要做以下几个步骤：</p><ul><li><p>接受客户端请求 。</p></li><li><p>将请求 转发给服务器。</p></li><li><p>拿到服务器 响应 数据。</p></li><li><p>将 响应 转发给客户端。</p><p><img src="/../imgs/%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1685c5bed77e7788tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p></li></ul><p>我们先来看个例子：本地文件index.html文件，通过代理服务器<code>http://localhost:3000</code>向目标服务器<code>http://localhost:4000</code>请求数据。</p><div class="code-wrapper"><pre><code class="hljs xml">// index.html(http://127.0.0.1:5500) <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      $.<span class="hljs-title function_">ajax</span>(&#123;</span><span class="language-javascript">        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>,</span><span class="language-javascript">        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;post&#x27;</span>,</span><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiamen&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span> &#125;,</span><span class="language-javascript">        <span class="hljs-attr">contentType</span>: <span class="hljs-string">&#x27;application/json;charset=utf-8&#x27;</span>,</span><span class="language-javascript">        <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// &#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span></span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)</span><span class="language-javascript">        &#125;</span><span class="language-javascript">      &#125;)</span><span class="language-javascript">     </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码// server1.js 代理服务器(http://localhost:3000)const http = require(&#x27;http&#x27;)// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; &#123;  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段  response.writeHead(200, &#123;    &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;,    &#x27;Access-Control-Allow-Methods&#x27;: &#x27;*&#x27;,    &#x27;Access-Control-Allow-Headers&#x27;: &#x27;Content-Type&#x27;  &#125;)  // 第二步：将请求转发给服务器  const proxyRequest = http    .request(      &#123;        host: &#x27;127.0.0.1&#x27;,        port: 4000,        url: &#x27;/&#x27;,        method: request.method,        headers: request.headers      &#125;,      serverResponse =&gt; &#123;        // 第三步：收到服务器的响应        var body = &#x27;&#x27;        serverResponse.on(&#x27;data&#x27;, chunk =&gt; &#123;          body += chunk        &#125;)        serverResponse.on(&#x27;end&#x27;, () =&gt; &#123;          console.log(&#x27;The data is &#x27; + body)          // 第四步：将响应结果转发给浏览器          response.end(body)        &#125;)      &#125;    )    .end()&#125;)server.listen(3000, () =&gt; &#123;  console.log(&#x27;The proxyServer is running at http://localhost:3000&#x27;)&#125;)复制代码// server2.js(http://localhost:4000)const http = require(&#x27;http&#x27;)const data = &#123; title: &#x27;fontend&#x27;, password: &#x27;123456&#x27; &#125;const server = http.createServer((request, response) =&gt; &#123;  if (request.url === &#x27;/&#x27;) &#123;    response.end(JSON.stringify(data))  &#125;&#125;)server.listen(4000, () =&gt; &#123;  console.log(&#x27;The server is running at http://localhost:4000&#x27;)&#125;)复制代码</code></pre></div><p>上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出<code>&#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</code></p><h3 id="6-nginx反向代理"><a href="#6-nginx反向代理" class="headerlink" title="6.nginx反向代理"></a>6.nginx反向代理</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>先下载<a href="https://link.juejin.cn/?target=http://nginx.org/en/download.html">nginx</a>，然后将nginx目录下的nginx.conf修改如下:</p><div class="code-wrapper"><pre><code class="hljs ini">// proxy服务器server &#123;    listen       81<span class="hljs-comment">;</span>    server_name  www.domain1.com<span class="hljs-comment">;</span>    location / &#123;        proxy_pass   http://www.domain2.com:8080<span class="hljs-comment">;  #反向代理</span>        proxy_cookie_domain www.domain2.com www.domain1.com<span class="hljs-comment">; #修改cookie里域名</span>        index  index.html index.htm<span class="hljs-comment">;</span>        <span class="hljs-comment"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span>        add_header Access-Control-Allow-Origin http://www.domain1.com<span class="hljs-comment">;  #当前端只跨域不带cookie时，可为*</span>        add_header Access-Control-Allow-Credentials true<span class="hljs-comment">;</span>    &#125;&#125;复制代码</code></pre></div><p>最后通过命令行<code>nginx -s reload</code>启动nginx</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// index.html</span><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<span class="hljs-comment">// 前端开关：浏览器是否读写cookie</span>xhr.withCredentials = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 访问nginx中的代理服务器</span>xhr.open(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;http://www.domain1.com:81/?user=admin&#x27;</span>, <span class="hljs-literal">true</span>);xhr.send();复制代码<span class="hljs-comment">// server.js</span><span class="hljs-keyword">var</span> http = require(<span class="hljs-string">&#x27;http&#x27;</span>);<span class="hljs-keyword">var</span> server = http.createServer();<span class="hljs-keyword">var</span> qs = require(<span class="hljs-string">&#x27;querystring&#x27;</span>);server.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, function(req, res) &#123;    <span class="hljs-keyword">var</span> <span class="hljs-keyword">params</span> = qs.parse(req.url.substring(<span class="hljs-number">2</span>));    <span class="hljs-comment">// 向前台写cookie</span>    res.writeHead(<span class="hljs-number">200</span>, &#123;        <span class="hljs-string">&#x27;Set-Cookie&#x27;</span>: <span class="hljs-string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>   <span class="hljs-comment">// HttpOnly:脚本无法读取</span>    &#125;);    res.write(JSON.stringify(<span class="hljs-keyword">params</span>));    res.end();&#125;);server.listen(<span class="hljs-string">&#x27;8080&#x27;</span>);console.log(<span class="hljs-string">&#x27;Server is running at port 8080...&#x27;</span>);复制代码</code></pre></div><h3 id="7-window-name-iframe"><a href="#7-window-name-iframe" class="headerlink" title="7.window.name + iframe"></a>7.window.name + iframe</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>其中a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p><div class="code-wrapper"><pre><code class="hljs ini"> // a.html(http://localhost:3000/b.html)  &lt;iframe <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:4000/c.html&quot;</span> frameborder=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-literal">on</span>load=<span class="hljs-string">&quot;load()&quot;</span> id=<span class="hljs-string">&quot;iframe&quot;</span>&gt;&lt;/iframe&gt;  &lt;script&gt;    let <span class="hljs-attr">first</span> = <span class="hljs-literal">true</span>    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name    function load() &#123;      if(first)&#123;      // 第1次onload(跨域页)成功后，切换到同域代理页面        let <span class="hljs-attr">iframe</span> = document.getElementById(<span class="hljs-string">&#x27;iframe&#x27;</span>)<span class="hljs-comment">;</span>        <span class="hljs-attr">iframe.src</span> = <span class="hljs-string">&#x27;http://localhost:3000/b.html&#x27;</span><span class="hljs-comment">;</span>        <span class="hljs-attr">first</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>      &#125;else&#123;      // 第2次onload(同域b.html页)成功后，读取同域window.name中数据        console.log(iframe.contentWindow.name)<span class="hljs-comment">;</span>      &#125;    &#125;  &lt;/script&gt;复制代码</code></pre></div><p>b.html为中间代理页，与a.html同域，内容为空。</p><div class="code-wrapper"><pre><code class="hljs xml"> // c.html(http://localhost:4000/c.html)  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;我不爱你&#x27;</span>  </span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码</code></pre></div><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="8-location-hash-iframe"><a href="#8-location-hash-iframe" class="headerlink" title="8.location.hash + iframe"></a>8.location.hash + iframe</h3><p>实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p><div class="code-wrapper"><pre><code class="hljs xml"> // a.html  <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:4000/c.html#iloveyou&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//检测hash的变化</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hash</span>);</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码 // b.html  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span> = location.<span class="hljs-property">hash</span> </span><span class="language-javascript">    <span class="hljs-comment">//b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span></span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码 // c.html console.log(location.hash);  let iframe = document.createElement(&#x27;iframe&#x27;);  iframe.src = &#x27;http://localhost:3000/b.html#idontloveyou&#x27;;  document.body.appendChild(iframe);复制代码</code></pre></div><h3 id="9-document-domain-iframe"><a href="#9-document-domain-iframe" class="headerlink" title="9.document.domain + iframe"></a>9.document.domain + iframe</h3><p><strong>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式</strong>。 只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>我们看个例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中a的值</p><div class="code-wrapper"><pre><code class="hljs xml">// a.html<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> helloa  <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://b.zf1.cn:3000/b.html&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;load()&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;frame&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;zf1.cn&#x27;</span></span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(frame.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">a</span>);</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>复制代码// b.html<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>   hellob   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">     <span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;zf1.cn&#x27;</span></span><span class="language-javascript">     <span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span>;</span><span class="language-javascript">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>复制代码</code></pre></div><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul><li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li><li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li><li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li><li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://link.juejin.cn/?target=http://www.zhufengpeixun.cn/main/course/index.html">珠峰架构课(强烈推荐)</a></li><li><a href="https://link.juejin.cn/?target=http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a></li><li><a href="https://juejin.cn/book/6844733763675488269/section/6844733763771957261">前端面试之道</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage">window.postMessage</a></li><li><a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000011145364">前端常见跨域解决方案（全）</a></li><li><a href="https://juejin.cn/post/6844903607297376263">深入跨域问题(4) - 利用代理解决跨域</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2023/01/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/01/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机操作系统知识点总结"><a href="#计算机操作系统知识点总结" class="headerlink" title="计算机操作系统知识点总结"></a>计算机操作系统知识点总结</h1><h2 id="一、操作系统概述"><a href="#一、操作系统概述" class="headerlink" title="一、操作系统概述"></a>一、操作系统概述</h2><h3 id="1-1-操作系统的定义与目标"><a href="#1-1-操作系统的定义与目标" class="headerlink" title="1.1 操作系统的定义与目标"></a>1.1 操作系统的定义与目标</h3><p>定义：操作系统是控制管理计算机系统的硬软件，分配调度资源的系统软件。</p><p>目标：方便性，有效性（提高系统资源的利用率、提高系统的吞吐量），可扩充性，开放性。</p><h3 id="1-2-操作系统的基本功能"><a href="#1-2-操作系统的基本功能" class="headerlink" title="1.2 操作系统的基本功能"></a>1.2 操作系统的基本功能</h3><p>统一管理计算机资源：处理器资源，IO设备资源，存储器资源，文件资源;<br>实现了对计算机资源的抽象：IO设备管理软件提供读写接口，文件管理软件提供操作文件接;<br>提供了用户与计算机之间的接口：GUI（图形用户界面），命令形式，系统调用形式。</p><h3 id="1-3-操作系统的特征"><a href="#1-3-操作系统的特征" class="headerlink" title="1.3 操作系统的特征"></a>1.3 操作系统的特征</h3><p>最基本的特征，互为存在条件：并发，共享；</p><p>（1）并行：指两个或多个事件可以在同一个时刻发生，多核CPU可以实现并行，一个cpu同一时刻只有一个程序在运行；</p><p>（2）并发：指两个或多个事件可以在同一个时间间隔发生，用户看起来是每个程序都在运行，实际上是每个程序都交替执行。</p><p>image-20210830104953215</p><p>（3）共享性：操作系统的中资源可供多个并发的程序共同使用，这种形式称之为资源共享。</p><p>互斥共享：当资源被程序占用时，其它想使用的程序只能等待。<br>同时访问：某种资源并发的被多个程序访问。<br>虚拟和异步特性前提是具有并发性。</p><p>（4）虚拟性：表现为把一个物理实体转变为若干个逻辑实体。</p><p>时分复用技术：资源在时间上进行复用，不同程序并发使用，多道程序分时使用计算机的硬件资源，提高资源的利用率。<br>空分复用技术：用来实现虚拟磁盘（物理磁盘虚拟为逻辑磁盘，电脑上的C盘、D盘等）、虚拟内存（在逻辑上扩大程序的存储容量）等，提高资源的利用率，提高编程效率。<br>（5）异步性：在多道程序环境下，允许多个进程并发执行，但由于资源等因素的限制，使进程的执行以“停停走走”的方式运行，而且每个进程执行的情况（运行、暂停、速度、完成）也是未知的。</p><h3 id="1-4-操作系统的中断处理"><a href="#1-4-操作系统的中断处理" class="headerlink" title="1.4 操作系统的中断处理"></a>1.4 操作系统的中断处理</h3><p>中断机制的作用：为了在多道批处理系统中让用户进行交互；</p><p>中断产生：</p><p>发生中断时，CPU立马切换到管态，开展管理工作；（管态又叫特权态，系统态或核心态，是操作系统管理的程序执行时，机器所处的状态。）<br>发生中断后，当前运行的进程回暂停运行，由操作系统内核对中断进行处理；<br>对于不同的中断信号，会进行不同的处理。<br>中断的分类：</p><p>内中断（也叫“异常”、“例外”、“陷入”）——- 信号来源：CPU内部，与当前执行指令有关；<br>外中断（中断）———-信号来源：CPU外部，与当前执行指令无关。<br>外中断的处理过程：</p><p>每执行完一个指令后，CPU都需要检查当前是否有外部中断 信号；<br>如果检查到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW，程序计数器PC、各种通用寄存器）把他们存储在PCB（进程控制块中）；<br>根据中断信号类型转入相应的中断处理程序；<br>恢复原进程的CPU环境并退出中断，返回原进程继续执行。</p><h2 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h2><h3 id="2-1-进程管理之进程实体"><a href="#2-1-进程管理之进程实体" class="headerlink" title="2.1 进程管理之进程实体"></a>2.1 进程管理之进程实体</h3><p>为什么需要进程：</p><p>进程是系统进行资源分配和调度的基本单位；<br>进程作为程序独立运行的载体保障程序正常执行；<br>进程的存在使得操作系统资源的利用率大幅提升。+<br>进程控制块（PCB）：用于描述和控制进程运行的通用数据结构,记录进程当前状态和控制进程运行的全部信息，是进程存在的唯一标识。</p><p>进程（Process）与线程（Thread）：</p><p>线程：操作系统进行<strong>运行调度的最小单位</strong>。<br>进程：系统进行<strong>资源分配和调度的基本单位</strong>。<br>区别与联系：</p><p>一个进程可以有一个或多个线程；<br>线程包含在进程之中，是进程中实际运行工作的单位；<br>进程的线程共享进程资源；<br>一个进程可以并发多个线程，每个线程执行不同的任务。<br>image-20210826153718544</p><h3 id="2-2-进程管理之五状态模型"><a href="#2-2-进程管理之五状态模型" class="headerlink" title="2.2 进程管理之五状态模型"></a>2.2 进程管理之五状态模型</h3><p>就绪状态：其它资源（进程控制块、内存、栈空间、堆空间等）都准备好、只差CPU的状态。<br>  执行状态：进程获得CPU，其程序正在执行。<br>  阻塞状态：进程因某种原因放弃CPU的状态，阻塞进程以队列的形式放置。<br>  创建状态：创建进程时拥有PCB但其它资源尚未就绪。<br>  终止状态：进程结束由系统清理或者归还PCB的状态。</p><p>image-20210830134139425</p><h3 id="2-3-进程管理之进程同步"><a href="#2-3-进程管理之进程同步" class="headerlink" title="2.3 进程管理之进程同步"></a>2.3 进程管理之进程同步</h3><p>生产者-消费者问题：有一群生产者进程在生产产品，并将这些产品提供给消费者进程进行消费，生产者进程和消费者进程可以并发执行，在两者之间设置了一个具有n个缓冲区的缓冲池，生产者进程需要将所生产的产品放到缓冲区中（+1操作），消费者进程可以从缓冲区取走产品消费（-1操作）。</p><p>image-20210826155239580</p><p>image-20210826155306444</p><p>产生问题：当两者并发执行时可能出差错，导致预期的结果与真实的结果不相符：当执行生产者+1和消费者-1操作之后，缓冲区的值从10变为了11。</p><p>哲学家进餐问题：有5个哲学家，他们的生活方式是交替的思考和进餐，哲学家们共同使用一张圆桌，分别坐在5张椅子上，圆桌上有5只碗和5只筷子。平时哲学家们只进行思考，饥饿时则试图取靠近他们的左右两只筷子，只有两只筷子都被拿到的时候才能进餐，否则等待，进餐完毕后，放下左右筷子进行思考。</p><p>这会导致以下的问题，筷子就相当于临界资源：</p><p>临界资源指的是一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源。</p><p>进程同步的作用：对竞争资源在多进程间进行使用次序的协调，使得并发执行的多个进程之间可以有效使用资源和相互合作。</p><p>进程间同步的四原则：</p><p>空闲让进：资源无占用，允许使用；<br>忙则等待：资源被占用，请求进程等待；<br>有限等待：保证有限等待时间能够使用资源；<br>让权等待：等待时，进程需要让出CPU。</p><h4 id="2-3-1进程同步的方法（重要）"><a href="#2-3-1进程同步的方法（重要）" class="headerlink" title="2.3.1进程同步的方法（重要）"></a>2.3.1进程同步的方法（重要）</h4><p>1.使用fork系统调用创建进程：使用fork系统调用无参数，fork会返回两次，分别返回子进程id和0，返回子进程id的是父进程，返回0的是子进程。</p><p>fork系统调用是用于创建进程的；<br>fork创建的进程初始化状态与父进程一样；<br>系统会为fork的进程分配新的资源<br>2.共享内存：在某种程度上，多进程是共同使用物理内存的，但是由于操作系统的进程管理，进程间的内存空间是独立的，因此进程默认是不能访问进程空间之外的内存空间的。</p><p>共享存储允许不相关的进程访问同一片物理内存；<br>共享内存是两个进程之间共享和传递数据最快的方式；<br>共享内存未提供同步机制，需要借助其他机制管理访问；<br>image-20210826223244411</p><p>3.Unix域套接字</p><p>域套接字是一种高级的进程间通信的方法，可以用于同一机器进程间通信。</p><p>套接字（socket）：为网络通信中使用的术语。</p><p>Unix系统提供的域套接字提供了网络套接字类似的功能，如Nfinx、uWSGI等。</p><p>服务端和客户端分别使用Unix域套接字的过程：</p><p>image-20210826223709480</p><h4 id="2-3-2-线程同步的方法（重要）"><a href="#2-3-2-线程同步的方法（重要）" class="headerlink" title="2.3.2 线程同步的方法（重要）"></a>2.3.2 线程同步的方法（重要）</h4><p>线程同步的方法：</p><p>互斥锁：互斥锁是最简单的线程同步的方法，也称为互斥量，处于两态之一的变量：解锁和加锁，两个状态可以保证资源访问的串行。 原子性：指一系列操作不可被中断的特性，要么全部执行完成，要么全部没有执行。</p><p>image-20210826220013572</p><p>自旋锁：自旋锁是一种多线程同步的变量，使用自旋锁的线程会反复检查锁变量是否可用，自旋锁不会让出CPU，是一种忙等待状态，即死循环等待锁被释放，自旋锁的效率远高于互斥锁。特点：避免了进程或者线程上下文切换的开销，但是不适合在单核CPU使用。</p><p>读写锁：是一种特殊的自旋锁，允许多个读操作同时访问资源以提高读性能，但是对写操作是互斥的，即<strong>对多读少写的操作效率提升</strong>很显著。</p><p>条件变量：是一种相对比较复杂的线程同步方法，条件变量允许线程睡眠，直到满足某种条件，当<strong>满足条件时，可以给该线程信号通知唤醒</strong>。</p><p>2.3.3 线程同步方法对比（重要）<br>image-20210826222325975</p><p>image-20210826222346498</p><p>image-20210826222400048</p><p>2.4 Linux的进程管理<br>进程的类型：</p><p>前台进程：具有终端，可以和用户交互；<br>后台进程：没有占用终端，基本不和用户交互，优先级比前台进程低（将需要执行的命令以“&amp;”符号结束）；<br>守护进程：特殊的后台进程，在系统引导时启动，一直运行直到系统关闭（进程名字以“d”结尾的一般都是守护进程），如crond、sshd、httpd、mysqld…<br>进程的标记：</p><p>进程ID：非负整数，进程的唯一标记，每个进程拥有不同的ID；<br>进程的状态标记：R表示进程处于运行状态，S表示进程处于睡眠状态…</p><p>操作Linux进程的相关命令：</p><p>ps命令：列出当前的进程，结合-aux可以打印进程的详细信息（ps -aux）；<br>top命令：查看所有进程的状态；<br>kill命令：给进程发送信号。</p><h2 id="三、作业管理"><a href="#三、作业管理" class="headerlink" title="三、作业管理"></a>三、作业管理</h2><p>3.1 作业管理之进程调度<br>定义：指计算机通过决策决定哪个就绪进程可以获得CPU使用权。</p><p>什么时候需要进程调度？</p><p>主动放弃：进程正常终止；运行过程中发生异常而终止；主动阻塞（如等待I&#x2F;O）；<br>被动放弃：分给进程的时间片用完；有更高优先级的进程进入就绪队列；有更紧急的事情需要处理（如I&#x2F;O中断）；<br>进程调度方式：</p><p>非抢占式调度：只能由当前运行的进程主动放弃CPU；</p><p>处理器一旦分配给某个进程，就让该进程一直使用下去；<br>调度程序不以任何原因抢占正在被使用的处理器；<br>调度程序不以任何原因抢占正在被使用的处理器；<br>抢占式调度：可由操作系统剥夺当前进程的CPU使用权。</p><p>允许调度程序以一定的策略暂停当前运行的进程；<br>保存好旧进程的上下文信息，分配处理器给新进程；<br>image-20210826162907842</p><p>进程调度的三大机制：</p><p>就绪队列的排队机制：为了提高进程调度的效率，将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程。</p><p>image-20210830141937877</p><p>选择运行进程的委派机制：调度程序以一定的策略，选择就绪进程，将CPU资源分配给它。</p><p>新老进程的上下文切换机制：保存当前进程的上下文信息，装入被委派执行进程的运行上下文。<br>image-20210830141949702</p><p>进程调度算法：</p><p>先来先服务算法：按照在就绪队列中的先后顺序执行。<br>短进程优先调度算法：优先选择就绪队列中估计运行时间最短的进程，不利于长作业进程的执行。<br>高优先权优先调度算法：进程附带优先权，优先选择权重高的进程，可以使得紧迫的任务优先处理。<br>时间片轮转调度算法：按照FIFO的原则排列就绪进程，每次从队列头部取出待执行进程，分配一个时间片执行，是相对公平的调度算法，但是不能保证就是响应用户。<br>3.2 作业管理之死锁<br>3.2.1 进程死锁、饥饿、死循环的区别：<br>死锁：两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。永远在互相等待的进程称为死锁进程。</p><p>饥饿：由于长期得不到资源导致进程无法推进；</p><p>死循环：代码逻辑BUG。</p><p>死锁的产生：竞争资源（共享资源数量不满足各进程需求）、进程调度顺序不当，当调度顺序为A-&gt;B-&gt;C-&gt;D时会产生死锁，但改为A-&gt;D-&gt;B-&gt;C则不会产生。</p><p>image-20210826163418015</p><p>死锁的四个必要条件：</p><p>互斥条件：必须互斥使用资源才会产生死锁；<br>请求保持条件：进程至少保持一个资源，又提出新的资源请求，新资源被占用，请求被阻塞，被阻塞的进程不释放自己保持的资源；<br>不可剥夺条件：进程获得的资源在未完成使用前不能被剥夺（包括OS），只能由进程自身释放；<br>环路等待条件：发生死锁时，必然存在进程-资源环形链,环路等待不一定造成死锁，但是死锁一定有循环等待。<br>死锁的处理策略：</p><p>一.预防死锁的方法：破坏四个必要条件的中一个或多个。</p><p>破坏互斥条件：将临界资源改造成共享资源（Spooling池化技术）；（可行性不高，很多时候无法破坏互斥条件）<br>破坏请求保持条件：系统规定进程运行之前，一次性申请所有需要的资源；（资源利用率低，可能导致别的线程饥饿）<br>破坏不可剥夺条件：当一个进程请求新的资源得不到满足时，必须释放占有的资源；（实现复杂，剥夺资源可能导致部分工作失效，反复申请和释放造成额外的系统开销）<br>破坏环路等待条件：可用资源线性排序，申请必须按照需要递增申请；（进程实际使用资源顺序和编号顺序不同，会导致资源浪费）<br>二.银行家算法：检查当前资源剩余是否可以满足某个进程的最大需求；如果可以，就把该进程加入安全序列，等待进程允许完成，回收所有资源；重复1，2，直到当前没有线程等待资源；</p><p>三.死锁的检测和解除：死锁检测算法，资源剥夺法，撤销进程法（终止进程法），进程回退法；</p><h2 id="四、存储管理"><a href="#四、存储管理" class="headerlink" title="四、存储管理"></a>四、存储管理</h2><p>存储管理为了确保计算机有足够的内存处理数据；确保程序可以从可用内存中获取一部分内存使用；确保程序可以归还使用后的内存以供其他程序使用。</p><p>4.1 存储管理之内存分配与回收<br>内存分配的过程：单一连续分配（已经过时）、固定分区分配、动态分区分配（根据实际需要，动态的分配内存）。<br>  动态分区分配算法：</p><p>首次适应算法：分配内存时，从开始顺序查找适合内存区，若无合适内存区，则分配失败，每次从头部开始，使得头部地址空间不断被划分；<br>最佳适应算法：要求空闲区链表按照容量大小排序，遍历以找到最佳适合的空闲区（会留下越来越多的内部碎片）。<br>快速适应算法：要求有多个空闲区链表，每个空闲区链表存储一种容量的空闲区。<br>内存回收的过程：</p><p>回收区在空闲区下方：不需要新建空闲链表节点；只需要把空闲区1的容量增大即可；<br>回收区在空闲区上方：将回收区与空闲区合并；新的空闲区使用回收区的地址；<br>回收区在空闲区中间方：将空闲区1、空闲区2和回收区合并；新的空闲区使用空闲区1的地址；<br>仅仅剩余回收区：为回收区创建新的空闲节点；插入到相应的空闲区链表中去；<br>4.2 存储管理之段页式存储管理<br>页式存储管理：将进程逻辑空间等分成若干大小的页面，相应的把物理内存空间分成与页面大小的物理块，以页面为单位把进程空间装进物理内存中分散的物理块。</p><p>页面大小应该适中，过大难以分配，过小内存碎片过多；页面大小通常是512B~8K；</p><p>现代计算机系统中，可以支持非常大的逻辑地址空间(232~264)，具有32位逻辑地址空间的分页系统，规定页面大小为4KB，则在每个进程页表中的页表项可达1M(2个20)个，如果每个页表项占用1Byte，故每个进程仅仅页表就要占用1MB的内存空间。</p><p>image-20210830150815294</p><p>段式存储管理：将进程逻辑空间分成若干段（不等分），段的长度由连续逻辑的长度决定。</p><p>页式和者段式存储管理相比：</p><p>段式存储和页式存储都离散地管理了进程的逻辑空间；<br>页是物理单位，段是逻辑单位；<br>分页是为了合理利用空间，分段是满足用户要求页大小由硬件固定，段长度可动态变化；<br>页表信息是一维的，段表信息是二维的；<br>段页式存储管理：现将逻辑空间按照段式管理分成若干段，再将内存空间按照页式管理分成若干页，分页可以有效提高内存利用率，分段可以更好的满足用户需求。</p><p>image-20210826165620416</p><p>4.3 存储管理之虚拟内存<br>虚拟内存概述：是操作系统内存管理的关键技术，使得多道程序运行和大程序运行成为现实，把程序使用内存划分，将部分暂时不使用的内存放置在辅存，实际是对物理内存的扩充。<br>  局部性原理：指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。<br>  虚拟内存的置换算法：先进先出（FIFO）、最不经常使用（LFU）、最近最少使用（LRU）</p><p>虚拟内存的特征：</p><p>多次性：无需再作业运行时一次性全部装入内存，而是允许被分成多次调入内存；<br>对换性：无需在作业运行时一直常驻内存，而是允许在作业运行过程中，将作业换入、换出；<br>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存用来，远大于实际的容量；<br>4.4 Linux的存储管理<br>Buddy内存管理算法：经典的内存管理算法，为解决内存外碎片的问题，算法基于计算机处理二进制的优势具有极高的效率。<br>  Linux交换空间：交换空间（Swap）是磁盘的一个分区，Linux内存满时，会把一些内存交换至Swap空间，Swap空间是初始化系统时配置的。<br>  Swap空间与虚拟内存的对比：</p><p>image-20210830151958862</p><p>五、文件管理<br>5.1 操作系统的文件管理<br>文件的逻辑结构：</p><p>逻辑结构的文件类型：有结构文件（文本文件，文档，媒体文件）、无结构文件（二进制文件、链接库）。<br>顺序文件：按顺序放在存储介质中的文件，在逻辑文件当中存储效率最高，但不适合存储可变长文件。<br>索引文件：为解决可变长文件存储而发明，需要配合索引表存储。<br>辅存的存储空间分配：</p><p>辅存的分配方式：连续分配（读取文件容易，速度快）、链接分配（隐式链接和显式链接）、索引分配<br>辅存的存储空间管理：空闲表、空闲链表、位示图。<br>目录树：使得任何文件或目录都有唯一的路径。</p><p>image-20210830152736217</p><p>Linux文件的基本操作：参考链接</p><p>image-20210826213430203</p><p>img</p><p>image-20210826214028660</p><p>Linux的文件系统：FAT、NTFS（对FAT进行改进）、EXT2&#x2F;3&#x2F;4（扩展文件系统，Linux的文件系统）</p><p>六、设备管理<br>I&#x2F;O设备的基本概念：将数据输入输出计算机的外部设备；</p><p>广义的IO设备：</p><p>按照使用特性分类：存储设备（内存、磁盘、U盘）和交互IO设备（键盘、显示器、鼠标）；<br>按照信息交换分类：块设备（磁盘、SD卡）和字符设备（打印机、shell终端）；<br>按照设备共享属性分类：独占设备，共享设备，虚拟设备；<br>按照传输速率分类：低速设备，高速设备；<br>IO设备的缓冲区：减少CPU处理IO请求的频率，提高CPU与IO设备之间的并行性。</p><p>SPOOLing技术：虚拟设备技术，把同步调用低速设备改为异步调用，在输入、输出之间增加了排队转储环节(输入井、输出井)，SPoOLing负责输入（出）井与低速设备之间的调度，逻辑上，进程直接与高速设备交互，减少了进程的等待时间。</p><p>七、实现支持异步任务的线程池<br>线程池：线程池是存放多个线程的容器，CPU调度线程执行后不会销毁线程，将线程放回线程池重新利用。</p><p>使用线程池的原因：</p><p>线程是稀缺资源 ，不应该频繁创建和销毁；<br>架构解耦，业务创建和业务处理解耦，更加优雅；<br>线程池是使用线程的最佳实践。<br>实现线程安全的队列Queue</p><p>队列：用于存放多个元素，是存放各种元素的“池”。<br>实现的基本功能：获取当前队列元素数量，往队列放入元素，往队列取出元素。<br>注意：队列可能有多个线程同时操作，因此需要保证线程安全，如下两种情况：<br>image-20210830160845040</p><p>实现基本任务对象Task<br>实现的基本功能：任务参数，任务唯一标记（UUID），任务具体的执行逻辑</p><p>实现任务处理线程ProcessThread：任务处理线程需要不断地从任务队列里取任务执行，任务处理线程需要有一个标记，标记线程什么时候应该停止。<br>实现的基本功能：基本属性（任务队列、标记），线程执行的逻辑（run），线程停止（stop）。</p><p>实现任务处理线程池Pool：存放多个任务处理线程，负责多个线程的启停，管理向线程池的提交任务，下发给线程去执行。<br>实现的基本过程：基本属性，提交任务（put，batch_put），线程启停（start，join），线程池大小（size）。</p><p>实现异步任务处理AsyncTask：给任务添加一个标记，任务完成后，则标记为完成；任务完成时可直接获取任务运行结果；任务未完成时，获取任务结果，会阻塞获取线程。<br>主要实现的两个函数：设置运行结果（set_result），获取运行结果（get_result)</p><p>文章知识点与官方知识档案匹配，可进一步学习相关知识<br>CS入门技能树Linux入门初识Linux17162 人正在系统学习中</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript数组常用方法总结</title>
    <link href="/2023/01/27/JavaScript%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2023/01/27/JavaScript%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript常用的数组方法的总结"><a href="#JavaScript常用的数组方法的总结" class="headerlink" title="JavaScript常用的数组方法的总结"></a>JavaScript常用的数组方法的总结</h1><p>此篇属于前端算法入门系列的第一篇，主要介绍常用的<code>数组方法</code>、<code>字符串方法</code>、<code>遍历方法</code>、<code>高阶函数</code>、<code>正则表达式</code>以及相关<code>数学知识</code>。</p><blockquote><p><strong>文章主要包含以下内容：</strong></p><ul><li>数组常用方法</li><li>字符串常用方法</li><li>常用遍历方法&amp;高阶函数</li><li>常用正则表达式</li><li>数学知识</li></ul></blockquote><h2 id="一、数组常用方法"><a href="#一、数组常用方法" class="headerlink" title="一、数组常用方法"></a>一、数组常用方法</h2><h3 id="1-push"><a href="#1-push" class="headerlink" title="1.push()"></a>1.push()</h3><p>在尾部追加，类似于压栈，原数组会改变。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">8</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3, 8]</span></code></pre></div><h3 id="2-pop"><a href="#2-pop" class="headerlink" title="2.pop()"></a>2.pop()</h3><p>在尾部弹出，类似于出栈，原数组会变。数组的 <code>push</code> &amp; <code>pop</code> 可以模拟常见数据结构之一：栈。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-keyword">const</span> popVal = arr.<span class="hljs-title function_">pop</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(popVal) <span class="hljs-comment">// 3</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2]</span><span class="hljs-comment">// 数组模拟常见数据结构之一：栈</span><span class="hljs-keyword">const</span> stack = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 压栈</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack) <span class="hljs-comment">// [0, 1, 2]</span><span class="hljs-keyword">const</span> popValue = stack.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">// 出栈</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(popValue) <span class="hljs-comment">// 2</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack) <span class="hljs-comment">// [0, 1]</span></code></pre></div><h3 id="3-unshift"><a href="#3-unshift" class="headerlink" title="3.unshift()"></a>3.unshift()</h3><p>在头部压入数据，类似于入队，原数组会变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">0</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [0, 1, 2, 3]</span></code></pre></div><h3 id="4-shift"><a href="#4-shift" class="headerlink" title="4.shift()"></a>4.shift()</h3><p>在头部弹出数据，原数组会变。数组的 <code>push</code>（入队） &amp; <code>shift</code>（出队） 可以模拟常见数据结构之一：队列。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-keyword">const</span> shiftVal = arr.<span class="hljs-title function_">shift</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(shiftVal) <span class="hljs-comment">// 1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [2, 3]</span><span class="hljs-comment">// 数组模拟常见数据结构之一：队列</span><span class="hljs-keyword">const</span> queue = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]queue.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 入队</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue) <span class="hljs-comment">// [0, 1, 2]</span><span class="hljs-keyword">const</span> shiftValue = queue.<span class="hljs-title function_">shift</span>() <span class="hljs-comment">// 出队</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(shiftValue) <span class="hljs-comment">// 0</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue) <span class="hljs-comment">// [1, 2]</span></code></pre></div><h3 id="5-concat"><a href="#5-concat" class="headerlink" title="5.concat()"></a>5.concat()</h3><p><code>concat</code>会在当前数组尾部拼接传入的数组，然后返回一个新数组，原数组不变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-keyword">const</span> arr2 = arr.<span class="hljs-title function_">concat</span>([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2) <span class="hljs-comment">// [1, 2, 3, 7, 8, 9]</span></code></pre></div><h3 id="6-indexOf"><a href="#6-indexOf" class="headerlink" title="6.indexOf()"></a>6.indexOf()</h3><p>在数组中寻找该值，找到则返回其下标，找不到则返回<code>-1</code>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">0</span>)) <span class="hljs-comment">// -1</span></code></pre></div><h3 id="7-includes"><a href="#7-includes" class="headerlink" title="7.includes()"></a>7.includes()</h3><p>在数组中寻找该值，找到则返回<code>true</code>，找不到则返回<code>false</code>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>)) <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">4</span>)) <span class="hljs-comment">// false</span></code></pre></div><h3 id="8-join"><a href="#8-join" class="headerlink" title="8.join()"></a>8.join()</h3><p>将数组转化成字符串，并返回该字符串，不传值则默认逗号隔开，原数组不变。</p><div class="code-wrapper"><pre><code class="hljs arcade">const arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.join()) <span class="hljs-comment">// ‘1, 2, 3’</span><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr) <span class="hljs-comment">// [1, 2, 3]</span></code></pre></div><h3 id="9-reverse"><a href="#9-reverse" class="headerlink" title="9.reverse()"></a>9.reverse()</h3><p>翻转原数组，并返回已完成翻转的数组，原数组改变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">reverse</span>()) <span class="hljs-comment">// [3, 2, 1]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [3, 2, 1]</span></code></pre></div><h3 id="10-slice-start，end"><a href="#10-slice-start，end" class="headerlink" title="10.slice(start，end)"></a>10.slice(start，end)</h3><p>从<code>start</code> 开始截取到<code>end</code>，但是不包括<code>end</code></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)) <span class="hljs-comment">// [2, 3, 4]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3, 4, 5]</span></code></pre></div><h3 id="11-splice-start-deleteCount-item1-item2……"><a href="#11-splice-start-deleteCount-item1-item2……" class="headerlink" title="11.splice(start, deleteCount, item1, item2……)"></a>11.splice(start, deleteCount, item1, item2……)</h3><ul><li><code>start</code>参数 开始的位置</li><li><code>deleteCount</code>要截取的个数</li><li>后面的<code>items</code>为要添加的元素</li><li>如果<code>deleteCount</code>为<code>0</code>，则表示不删除元素，从<code>start</code>位置开始添加后面的几个元素到原始的数组里面。</li><li>返回值为由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</li><li>这个方法会改变原始数组，数组的长度会发生变化</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr3 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-string">&quot;f1&quot;</span>, <span class="hljs-string">&quot;f2&quot;</span>];<span class="hljs-keyword">const</span> arr4 = arr3.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 删除第三个元素以后的三个数组元素(包含第三个元素)</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr4); <span class="hljs-comment">// [3, 4, 5];</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr3); <span class="hljs-comment">// [1, 2, 6, 7, &quot;f1&quot;, &quot;f2&quot;]; 原始数组被改变</span><span class="hljs-keyword">const</span> arr5 = arr3.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;wu&quot;</span>, <span class="hljs-string">&quot;leon&quot;</span>); <span class="hljs-comment">// 从第2位开始删除0个元素，插入&quot;wu&quot;,&quot;leon&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr5); <span class="hljs-comment">// [] 返回空数组</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr3); <span class="hljs-comment">// [1, 2, &quot;wu&quot;, &quot;leon&quot;, 6, 7, &quot;f1&quot;, &quot;f2&quot;]; 原始数组被改变</span><span class="hljs-keyword">const</span> arr6 = arr3.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;xiao&quot;</span>, <span class="hljs-string">&quot;long&quot;</span>);<span class="hljs-comment">// 从第 2 位开始删除 3 个元素，插入&quot;xiao&quot;, &quot;long&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr6); <span class="hljs-comment">// [&quot;wu&quot;, &quot;leon&quot;, 6]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr3); <span class="hljs-comment">//[ 1, 2, &quot;xiao&quot;, &quot;long&quot;, 7, &quot;f1&quot;, &quot;f2&quot;]</span><span class="hljs-keyword">const</span> arr7 = arr3.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 从第三个元素开始删除所有的元素</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr7);<span class="hljs-comment">// [&quot;xiao&quot;, &quot;long&quot;, 7, &quot;f1&quot;, &quot;f2&quot;]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr3); <span class="hljs-comment">// [1, 2]</span></code></pre></div><h3 id="12-sort"><a href="#12-sort" class="headerlink" title="12.sort()"></a>12.sort()</h3><ul><li>对数组的元素进行排序，并返回数组。</li><li>默认排序顺序是在将元素转换为字符串，然后比较它们的<code>UTF-16</code>代码单元值序列时构建的。</li><li>由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。</li></ul><p>可参考 <strong>MDN：Sort</strong>[5]</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [3, 2, 1]</span></code></pre></div><h3 id="13-toString"><a href="#13-toString" class="headerlink" title="13.toString()"></a>13.toString()</h3><p>将数组转化成字符串，并返回该字符串，逗号隔开，原数组不变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">// ‘1, 2, 3, 4, 5’</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3, 4, 5]</span></code></pre></div><h2 id="二、字符串常用方法"><a href="#二、字符串常用方法" class="headerlink" title="二、字符串常用方法"></a>二、字符串常用方法</h2><h3 id="1-charAt"><a href="#1-charAt" class="headerlink" title="1.charAt()"></a>1.charAt()</h3><p>返回指定索引位置处的字符。类似于数组用中括号获取相应下标位置的数据。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abcdefg&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 输出 &#x27;c&#x27; </span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str[<span class="hljs-number">2</span>]) <span class="hljs-comment">// 输出 &#x27;c&#x27;</span></code></pre></div><h3 id="2-concat"><a href="#2-concat" class="headerlink" title="2.concat()"></a>2.concat()</h3><p>类似数组的concat()，用来返回一个合并拼接两个或两个以上字符串。原字符串不变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str1 = <span class="hljs-string">&#x27;abcdefg&#x27;</span><span class="hljs-keyword">const</span> str2 = <span class="hljs-string">&#x27;1234567&#x27;</span><span class="hljs-keyword">const</span> str3 = str1.<span class="hljs-title function_">concat</span>(str2)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str3) <span class="hljs-comment">// 输出 &#x27;abcdefg1234567&#x27;</span></code></pre></div><h3 id="3-indexOf-、lastIndexOf"><a href="#3-indexOf-、lastIndexOf" class="headerlink" title="3.indexOf()、lastIndexOf()"></a>3.indexOf()、lastIndexOf()</h3><p><code>indexOf</code>,返回一个字符在字符串中首次出现的位置,<code>lastIndexOf</code>返回一个字符在字符串中最后一次出现的位置。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdcefcg&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;c&#x27;</span>)) <span class="hljs-comment">// 输出 &#x27;2&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&#x27;c&#x27;</span>)) <span class="hljs-comment">// 输出 &#x27;7&#x27;</span></code></pre></div><h3 id="4-slice"><a href="#4-slice" class="headerlink" title="4.slice()"></a>4.slice()</h3><p>提取字符串的片断，并把提取的字符串作为新的字符串返回出来。原字符串不变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdefg&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">slice</span>()) <span class="hljs-comment">// 输出 &#x27;abcdefg&#x27;, 不传递参数默认复制整个字符串</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 输出 &#x27;bcdefg&#x27;,传递一个，则为提取的起点，然后到字符串结尾</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>, str.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>)) <span class="hljs-comment">// 输出&#x27;cdef&#x27;,传递两个，为提取的起始点和结束点</span></code></pre></div><h3 id="5-split"><a href="#5-split" class="headerlink" title="5.split()"></a>5.split()</h3><p>使用指定的分隔符将一个字符串拆分为多个子字符串数组并返回，原字符串不变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;A*B*C*D*E*F*G&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;*&#x27;</span>)) <span class="hljs-comment">// 输出 [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;]</span></code></pre></div><h3 id="6-substr-substring"><a href="#6-substr-substring" class="headerlink" title="6.substr(), substring()"></a>6.substr(), substring()</h3><ul><li>这两个方法的功能都是截取一个字符串的片段，并返回截取的字符串。</li><li><code>substr</code>和<code>substring</code>这两个方法不同的地方就在于参数二，<code>substr</code>的参数二是截取返回出来的这个字符串指定的长度，<code>substring</code>的参数二是截取返回这个字符串的结束点，并且不包含这个结束点。而它们的参数一，都是一样的功能，截取的起始位置。</li><li><strong>注意事项</strong>：<code>substr</code>的参数二如果为<code>0</code>或者负数，则返回一个空字符串，如果未填入，则会截取到字符串的结尾去。<code>substring</code>的参数一和参数二为<code>NAN</code>或者负数，那么它将被替换为<code>0</code>。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;ABCDEFGHIJKLMN&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>))  <span class="hljs-comment">// 输出 &#x27;CDEFGHIJKLMN&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 输出 &#x27;CDEFGHIJKLMN&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>))  <span class="hljs-comment">// 输出 &#x27;CDEFGHIJK&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>))  <span class="hljs-comment">// 输出 &#x27;CDEFGHI&#x27;</span></code></pre></div><h3 id="7-match"><a href="#7-match" class="headerlink" title="7.match()"></a>7.match()</h3><p><code>match()</code>方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配，并返回一个包含该搜索结果的数组。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;2018年结束了，2019年开始了，2020年就也不远了&#x27;</span><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\d+/g</span>  <span class="hljs-comment">// 这里是定义匹配规则，匹配字符串里的1到多个数字</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg))  <span class="hljs-comment">// 输出符合匹配规则的内容，以数组形式返回 [&#x27;2018&#x27;, &#x27;2019&#x27;, &#x27;2020&#x27;]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(<span class="hljs-string">&#x27;20&#x27;</span>))  <span class="hljs-comment">// 不使用正则 [&quot;20&quot;, index: 0, input: &quot;2018年结束了，2019年开始了&quot;]</span></code></pre></div><p><strong>注意事项</strong>:如果<code>match</code>方法没有找到匹配，将返回<code>null</code>。如果找到匹配，则 <code>match</code>方法会把匹配到以数组形式返回，如果正则规则未设置全局修饰符<code>g</code>，则 <code>match</code>方法返回的数组有两个特性：<code>input</code>和<code>index</code>。<code>input</code>属性包含整个被搜索的字符串。<code>index</code>属性包含了在整个被搜索字符串中匹配的子字符串的位置。</p><h3 id="8-replace"><a href="#8-replace" class="headerlink" title="8.replace()"></a>8.replace()</h3><p><code>replace</code>接收两个参数，参数一是需要替换掉的字符或者一个正则的匹配规则，参数二，需要替换进去的字符，仔实际的原理当中，参数二，你可以换成一个回调函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;2018年结束了，2019年开始了，2020年就也不远了&#x27;</span><span class="hljs-keyword">const</span> rex = <span class="hljs-regexp">/\d+/g</span>  <span class="hljs-comment">// 这里是定义匹配规则，匹配字符串里的1到多个数字</span><span class="hljs-keyword">const</span> str1 = str.<span class="hljs-title function_">replace</span>(rex, <span class="hljs-string">&#x27;****&#x27;</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str1) <span class="hljs-comment">// 输出：&quot;****年结束了，****年开始了,****年也不远了&quot;</span><span class="hljs-keyword">const</span> str2 = str.<span class="hljs-title function_">replace</span>(rex, <span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)  <span class="hljs-comment">// 看下面的图片</span>    <span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;零&#x27;</span>, <span class="hljs-string">&#x27;壹&#x27;</span>, <span class="hljs-string">&#x27;贰&#x27;</span>, <span class="hljs-string">&#x27;叁&#x27;</span>, <span class="hljs-string">&#x27;肆&#x27;</span>, <span class="hljs-string">&#x27;伍&#x27;</span>, <span class="hljs-string">&#x27;陆&#x27;</span>, <span class="hljs-string">&#x27;柒&#x27;</span>, <span class="hljs-string">&#x27;捌&#x27;</span>, <span class="hljs-string">&#x27;玖&#x27;</span>]    <span class="hljs-keyword">let</span> newStr = <span class="hljs-string">&#x27;&#x27;</span>    item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)&#123;            newStr += arr[i]    &#125;)         <span class="hljs-keyword">return</span> newStr       &#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2) <span class="hljs-comment">// 输出：贰零壹捌年结束了，贰零壹玖年开始了,贰零贰零年也不远了</span></code></pre></div><h3 id="9-search"><a href="#9-search" class="headerlink" title="9.search()"></a>9.search()</h3><p>在目标字符串中搜索与正则规则相匹配的字符，搜索到，则返回第一个匹配项在目标字符串当中的位置，没有搜索到则返回一个<code>-1</code>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;2018年结束了，2019年开始了，2020年就也不远了&#x27;</span><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\d+/i</span>  <span class="hljs-comment">// 这里是定义匹配规则,匹配字符串里的1到多个数字</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">search</span>(reg)) <span class="hljs-comment">// 输出 0  这里搜索到的第一项是从位置0开始的</span></code></pre></div><h3 id="10-toLowerCase-toUpperCase"><a href="#10-toLowerCase-toUpperCase" class="headerlink" title="10.toLowerCase(),toUpperCase()"></a>10.toLowerCase(),toUpperCase()</h3><p><code>toLowerCase</code>把字母转换成小写，<code>toUpperCase()</code>则是把字母转换成大写。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str1 = <span class="hljs-string">&#x27;abcdefg&#x27;</span><span class="hljs-keyword">const</span> str2 = <span class="hljs-string">&#x27;ABCDEFG&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2.<span class="hljs-title function_">toLowerCase</span>())  <span class="hljs-comment">// 输出：&#x27;abcdefg&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str1.<span class="hljs-title function_">toUpperCase</span>())  <span class="hljs-comment">// 输出：&#x27;ABCDEFG&#x27;</span></code></pre></div><h3 id="11-includes-startsWith-endsWith"><a href="#11-includes-startsWith-endsWith" class="headerlink" title="11.includes(), startsWith(), endsWith()"></a>11.includes(), startsWith(), endsWith()</h3><p><code>includes</code>、<code>startsWith</code>、<code>endsWith</code>，<code>es6</code>的新增方法，<code>includes</code> 用来检测目标字符串对象是否包含某个字符，返回一个布尔值，<code>startsWith</code>用来检测当前字符是否是目标字符串的起始部分，相对的<code>endwith</code>是用来检测是否是目标字符串的结尾部分。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;Excuse me, how do I get to park road?&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;how&#x27;</span>)) <span class="hljs-comment">// 输出：true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;Excuse&#x27;</span>)) <span class="hljs-comment">// 输出： true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;?&#x27;</span>)) <span class="hljs-comment">// 输出： true</span></code></pre></div><h3 id="12-repeat"><a href="#12-repeat" class="headerlink" title="12.repeat()"></a>12.repeat()</h3><p>返回一个新的字符串对象，新字符串等于重复了指定次数的原始字符串。接收一个参数，就是指定重复的次数。原字符串不变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;http&#x27;</span><span class="hljs-keyword">const</span> str2 = str.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str) <span class="hljs-comment">// 输出：&#x27;http&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2) <span class="hljs-comment">// 输出：&#x27;httphttphttp&#x27;</span></code></pre></div><h2 id="三、常用遍历方法-amp-高阶函数"><a href="#三、常用遍历方法-amp-高阶函数" class="headerlink" title="三、常用遍历方法&amp;高阶函数"></a>三、常用遍历方法&amp;高阶函数</h2><h3 id="1-for"><a href="#1-for" class="headerlink" title="1.for()"></a>1.for()</h3><p>最常用的<code>for</code>循环，经常用的数组遍历，也可以遍历字符串。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc&#x27;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i])    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str[i])&#125;</code></pre></div><h3 id="2-while-x2F-do-while"><a href="#2-while-x2F-do-while" class="headerlink" title="2.while() &#x2F; do while()"></a>2.while() &#x2F; do while()</h3><p><code>while</code>、<code>do while</code>主要的功能是，当满足<code>while</code>后边所跟的条件时，来执行相关业务。这两个的区别是，<code>while</code>会先判断是否满足条件，然后再去执行花括号里面的任务，而<code>do while</code>则是先执行一次花括号中的任务，再去执行<code>while</code>条件，判断下次还是否再去执行<code>do</code>里面的操作。也就是说 <strong><code>do while</code>至少会执行一次操作</strong>.</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span>(条件)&#123;     执行...&#125;------------<span class="hljs-keyword">do</span>&#123;    执行...&#125;<span class="hljs-keyword">while</span>(条件)</code></pre></div><h3 id="3-forEach"><a href="#3-forEach" class="headerlink" title="3.forEach()"></a>3.forEach()</h3><p>拷贝一份遍历原数组。</p><ul><li><code>return</code>无法终止循环。不过可以起到<code>continue</code>效果。</li><li>本身是不支持的<code>continue</code>与<code>break</code>语句的我们可以通过<code>some</code>和 <code>every</code>来实现。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>]arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (item &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`索引：<span class="hljs-subst">$&#123;index&#125;</span>，数值：<span class="hljs-subst">$&#123;item&#125;</span>`</span>)    arr[<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<span class="hljs-comment">// 打印结果：</span><span class="hljs-comment">// 索引：0，数值：5</span><span class="hljs-comment">// 索引：2，数值：3</span><span class="hljs-comment">// 索引：3，数值：7</span><span class="hljs-comment">// 索引：4，数值：4</span><span class="hljs-comment">// [5, 1, 3, 7, 4, 0]</span></code></pre></div><h3 id="4-for…in"><a href="#4-for…in" class="headerlink" title="4.for…in"></a>4.for…in</h3><ul><li><code>for...in</code> 是 ES5 标准， 此方法遍历数组效率低，主要是用来循环遍历对象的属性。</li><li>遍历数组的缺点：数组的下标<code>index</code>值是数字，<code>for-in</code>遍历的<code>index</code>值<code>&quot;0&quot;,&quot;1&quot;,&quot;2&quot;</code>等是字符串。</li><li><code>Object.defineProperty</code>，建立的属性，默认不可枚举。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(foo, <span class="hljs-string">&quot;age&quot;</span>, &#123; value : <span class="hljs-number">18</span> &#125;)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> foo)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`可枚举属性：<span class="hljs-subst">$&#123;key&#125;</span>`</span>)&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`age属性：<span class="hljs-subst">$&#123;foo.age&#125;</span>`</span>)<span class="hljs-comment">// 打印结果：</span><span class="hljs-comment">// 可枚举属性：name</span><span class="hljs-comment">// 可枚举属性：sex</span><span class="hljs-comment">// age属性：18</span></code></pre></div><h3 id="5-for…of"><a href="#5-for…of" class="headerlink" title="5.for…of"></a>5.for…of</h3><p><code>for…of</code>是<code>ES6</code>新增的方法，但是<code>for…of</code>不能去遍历普通的对象，**<code>for…of</code>的好处是可以使用<code>break</code>跳出循环。**</p><ul><li><code>for-of</code>这个方法避开了<code>for-in</code>循环的所有缺陷</li><li>与<code>forEach()</code>不同的是，它可以正确响应<code>break</code>、<code>continue</code>和<code>return</code>语句</li><li><code>for-of</code>循环不仅支持数组，还支持大多数类数组对象，例如<code>DOM</code> <strong>NodeList对象</strong>[6]。</li><li><code>for-of</code>循环也支持字符串遍历</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// for of 循环直接得到的就是值</span><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> arr) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)&#125;</code></pre></div><p><strong>面试官：说一下 <code>for...in</code> 和 <code>for...of</code> 区别？</strong></p><div class="code-wrapper"><pre><code class="hljs javascript">（<span class="hljs-number">1</span>）<span class="hljs-keyword">for</span>…<span class="hljs-keyword">in</span> 用于可枚举数据，如对象、数组、字符串（<span class="hljs-number">2</span>）<span class="hljs-keyword">for</span>…<span class="hljs-keyword">of</span> 用于可迭代数据，如数组、字符串、<span class="hljs-title class_">Map</span>、<span class="hljs-title class_">Set</span></code></pre></div><h3 id="6-every-x2F-some"><a href="#6-every-x2F-some" class="headerlink" title="6.every &#x2F; some"></a>6.every &#x2F; some</h3><p><strong>返回一个布尔值</strong>。当我们需要判定数组中的元素是否满足某些条件时，可以使用<code>every</code> &#x2F; <code>some</code>。这两个的区别是，<code>every</code>会去判断判断数组中的每一项，而 <code>some</code>则是当某一项满足条件时返回。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// every</span><span class="hljs-keyword">const</span> foo = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>].<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`索引：<span class="hljs-subst">$&#123;index&#125;</span>，数值：<span class="hljs-subst">$&#123;item&#125;</span>`</span>)    <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">2</span>&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<span class="hljs-comment">// every 打印：</span><span class="hljs-comment">// 索引：0，数值：5</span><span class="hljs-comment">// 索引：1，数值：1</span><span class="hljs-comment">// false</span><span class="hljs-comment">// some</span><span class="hljs-keyword">const</span> foo = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>].<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`索引：<span class="hljs-subst">$&#123;index&#125;</span>，数值：<span class="hljs-subst">$&#123;item&#125;</span>`</span>)    <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">2</span>&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<span class="hljs-comment">// some 打印：</span><span class="hljs-comment">// 索引：0，数值：5</span><span class="hljs-comment">// true</span></code></pre></div><h3 id="7-filter"><a href="#7-filter" class="headerlink" title="7.filter()"></a>7.filter()</h3><ul><li><code>filter</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</li><li>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为<code>true</code>的成员组成一个新数组返回。</li><li>该方法不会改变原数组。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript">javascriptjavascriptconst foo = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item,index</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`索引：<span class="hljs-subst">$&#123;index&#125;</span>，数值：<span class="hljs-subst">$&#123;item&#125;</span>`</span>)    <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">2</span>&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<span class="hljs-comment">// 打印结果：</span><span class="hljs-comment">// 索引：0，数值：5</span><span class="hljs-comment">// 索引：1，数值：1</span><span class="hljs-comment">// 索引：2，数值：3</span><span class="hljs-comment">// 索引：3，数值：7</span><span class="hljs-comment">// 索引：4，数值：4</span><span class="hljs-comment">// [5, 3, 7, 4]</span></code></pre></div><h3 id="8-map"><a href="#8-map" class="headerlink" title="8.map()"></a>8.map()</h3><ul><li><code>map</code>即是 “映射”的意思 ，原数组被“映射”成对应新数组。</li><li><code>map：</code>支持<code>return</code>，相当与原数组克隆了一份，把克隆的每项改变了，也不影响原数组。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript">javascriptjavascriptjavascriptconst foo = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item,index</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`索引：<span class="hljs-subst">$&#123;index&#125;</span>，数值：<span class="hljs-subst">$&#123;item&#125;</span>`</span>)    <span class="hljs-keyword">return</span> item + <span class="hljs-number">2</span>&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<span class="hljs-comment">// 打印结果：</span><span class="hljs-comment">// 索引：0，数值：5</span><span class="hljs-comment">// 索引：1，数值：1</span><span class="hljs-comment">// 索引：2，数值：3</span><span class="hljs-comment">// 索引：3，数值：7</span><span class="hljs-comment">// 索引：4，数值：4</span><span class="hljs-comment">// [7, 3, 5, 9, 6]</span></code></pre></div><h3 id="9-reduce-x2F-reduceRight"><a href="#9-reduce-x2F-reduceRight" class="headerlink" title="9. reduce() &#x2F; reduceRight()"></a>9. reduce() &#x2F; reduceRight()</h3><p><code>reduce</code> 从左到右将数组元素做“叠加”处理，返回一个值。<code>reduceRight</code> 从右到左。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, cur</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`叠加：<span class="hljs-subst">$&#123;total&#125;</span>，当前：<span class="hljs-subst">$&#123;cur&#125;</span>`</span>)    <span class="hljs-keyword">return</span> total + cur&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<span class="hljs-comment">// 打印结果：</span><span class="hljs-comment">// 叠加：5，当前：1</span><span class="hljs-comment">// 叠加：6，当前：3</span><span class="hljs-comment">// 叠加：9，当前：7</span><span class="hljs-comment">// 叠加：16，当前：4</span><span class="hljs-comment">// 20</span></code></pre></div><h3 id="10-Object-keys遍历对象的属性"><a href="#10-Object-keys遍历对象的属性" class="headerlink" title="10.Object,keys遍历对象的属性"></a>10.Object,keys遍历对象的属性</h3><p><code>Object.keys</code>方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名，且只返回可枚举的属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">p1</span>: <span class="hljs-number">123</span>,  <span class="hljs-attr">p2</span>: <span class="hljs-number">456</span>&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj) <span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;]</span></code></pre></div><h3 id="11-Object-getOwnPropertyNames-遍历对象的属性"><a href="#11-Object-getOwnPropertyNames-遍历对象的属性" class="headerlink" title="11.Object.getOwnPropertyNames() 遍历对象的属性"></a>11.Object.getOwnPropertyNames() 遍历对象的属性</h3><p><code>Object.getOwnPropertyNames</code>方法与<code>Object.keys</code>类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。但它能返回不可枚举的属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;World&#x27;</span>];<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(arr) <span class="hljs-comment">// [&quot;0&quot;, &quot;1&quot;]</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(arr) <span class="hljs-comment">// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span></code></pre></div><h3 id="以上遍历方法的区别："><a href="#以上遍历方法的区别：" class="headerlink" title="以上遍历方法的区别："></a>以上遍历方法的区别：</h3><div class="code-wrapper"><pre><code class="hljs javascript">一：<span class="hljs-title function_">map</span>()，<span class="hljs-title function_">forEach</span>()，<span class="hljs-title function_">filter</span>()循环的共同之处：  <span class="hljs-number">1.</span>forEach，map，filter循环中途是无法停止的，总是会将所有成员遍历完。  <span class="hljs-number">2.</span>他们都可以接受第二个参数，用来绑定回调函数内部的 <span class="hljs-variable language_">this</span> 变量，将回调函数内部的 <span class="hljs-variable language_">this</span> 对象，指向第二个参数，间接操作这个参数（一般是数组）。二：<span class="hljs-title function_">map</span>()、<span class="hljs-title function_">filter</span>()循环和<span class="hljs-title function_">forEach</span>()循环的不同：   forEach 循环没有返回值；map，filter 循环有返回值。三：<span class="hljs-title function_">map</span>()和<span class="hljs-title function_">filter</span>()都会跳过空位，<span class="hljs-keyword">for</span> 和 <span class="hljs-keyword">while</span> 不会四：<span class="hljs-title function_">some</span>()和<span class="hljs-title function_">every</span>():   <span class="hljs-title function_">some</span>()只要有一个是<span class="hljs-literal">true</span>，便返回<span class="hljs-literal">true</span>；而<span class="hljs-title function_">every</span>()只要有一个是<span class="hljs-literal">false</span>，便返回<span class="hljs-literal">false</span>.五：<span class="hljs-title function_">reduce</span>()，<span class="hljs-title function_">reduceRight</span>()：   reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员）。六：<span class="hljs-title class_">Object</span>对象的两个遍历 <span class="hljs-title class_">Object</span>.<span class="hljs-property">keys</span> 与 <span class="hljs-title class_">Object</span>.<span class="hljs-property">getOwnPropertyNames</span>：   他们都是遍历对象的属性，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。但<span class="hljs-title class_">Object</span>.<span class="hljs-property">keys</span>不能返回不可枚举的属性；<span class="hljs-title class_">Object</span>.<span class="hljs-property">getOwnPropertyNames</span>能返回不可枚举的属性。</code></pre></div><h2 id="四、常用正则表达式"><a href="#四、常用正则表达式" class="headerlink" title="四、常用正则表达式"></a>四、常用正则表达式</h2><p>这里罗列一些我在刷算法题中遇到的正则表达式，如果有时间可认真学一下<strong>正则表达式不要背</strong>[7]。</p><h3 id="1-判断字符"><a href="#1-判断字符" class="headerlink" title="1.判断字符"></a>1.判断字符</h3><div class="code-wrapper"><pre><code class="hljs javascript">由<span class="hljs-number">26</span>个英文字母组成的字符串：^[A-<span class="hljs-title class_">Za</span>-z]+$由<span class="hljs-number">26</span>个大写英文字母组成的字符串：^[A-Z]+$由<span class="hljs-number">26</span>个小写英文字母组成的字符串：^[a-z]+$由数字和<span class="hljs-number">26</span>个英文字母组成的字符串：^[A-<span class="hljs-title class_">Za</span>-z0-<span class="hljs-number">9</span>]+$</code></pre></div><h3 id="2-判断数字"><a href="#2-判断数字" class="headerlink" title="2.判断数字"></a>2.判断数字</h3><div class="code-wrapper"><pre><code class="hljs javascript">数字：^[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*$</code></pre></div><p>持续更新，敬请期待……</p><h2 id="五、数学知识"><a href="#五、数学知识" class="headerlink" title="五、数学知识"></a>五、数学知识</h2><h3 id="1-质数"><a href="#1-质数" class="headerlink" title="1.质数"></a>1.质数</h3><p>若一个正整数无法被除了<code>1</code> 和它自身之外的任何自然数整除，则称该数为质数（或素数），否则称该正整数为合数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">judgePrime</span>(<span class="hljs-params">n</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++) &#123;        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></div><h3 id="2-斐波那契数列"><a href="#2-斐波那契数列" class="headerlink" title="2.斐波那契数列"></a>2.斐波那契数列</h3><div class="code-wrapper"><pre><code class="hljs c">function <span class="hljs-title function_">Fibonacci</span><span class="hljs-params">(n)</span> &#123;    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n      <span class="hljs-keyword">return</span> Fibonacci(n - <span class="hljs-number">1</span>) + Fibonacci(n - <span class="hljs-number">2</span>)&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript面试题总结</title>
    <link href="/2023/01/23/TypeScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2023/01/23/TypeScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScrip—面试题"><a href="#TypeScrip—面试题" class="headerlink" title="TypeScrip—面试题"></a>TypeScrip—面试题</h1><p>类型 支持ES6新特性 添加ES6不具备的新特性 丰富的配置选项</p><h2 id="安装typescript"><a href="#安装typescript" class="headerlink" title="安装typescript"></a>安装typescript</h2><div class="code-wrapper"><pre><code class="hljs bash">npm install -g typescript    //全局安装</code></pre></div><h2 id="查看安装的typescript版本"><a href="#查看安装的typescript版本" class="headerlink" title="查看安装的typescript版本"></a>查看安装的typescript版本</h2><div class="code-wrapper"><pre><code class="hljs bash">tsc -v</code></pre></div><h2 id="什么是-Typescript？"><a href="#什么是-Typescript？" class="headerlink" title="什么是 Typescript？"></a><strong>什么是 Typescript？</strong></h2><p>Typescript 是 Javascript 的超集</p><h2 id="1、-TypeScript-的主要特点是什么？"><a href="#1、-TypeScript-的主要特点是什么？" class="headerlink" title="1、 TypeScript 的主要特点是什么？"></a><strong>1、 TypeScript 的主要特点是什么？</strong></h2><p><strong>跨平台</strong>：TypeScript 编译器可以安装在任何操作系统上，包括 Windows、macOS 和 Linux。</p><p><strong>ES6 特性</strong>：TypeScript 包含计划中的 ECMAScript 2015 (ES6) 的大部分特性，例如箭头函数。</p><p><strong>面向对象的语言</strong>：TypeScript 提供所有标准的 OOP 功能，如类、接口和模块。</p><p><strong>静态类型检查</strong>：TypeScript 使用静态类型并帮助在编译时进行类型检查。因此，你可以在编写代码时发现编译时错误，而无需运行脚本。</p><p><strong>可选的静态类型</strong>：如果你习惯了 JavaScript 的动态类型，TypeScript 还允许可选的静态类型。</p><p><strong>DOM 操作</strong>：您可以使用 TypeScript 来操作 DOM 以添加或删除客户端网页元素。</p><h2 id="2、使用-TypeScript-有什么好处？"><a href="#2、使用-TypeScript-有什么好处？" class="headerlink" title="2、使用 TypeScript 有什么好处？"></a><strong>2、使用 TypeScript 有什么好处？</strong></h2><p>TypeScript 更具表现力，这意味着它的语法混乱更少。</p><p>由于高级调试器专注于在编译时之前捕获逻辑错误，因此调试很容易。</p><p>静态类型使 TypeScript 比 JavaScript 的动态类型更易于阅读和结构化。</p><p>由于通用的转译，它可以跨平台使用，在客户端和服务器端项目中。</p><h2 id="3、TypeScript-的内置数据类型有哪些？"><a href="#3、TypeScript-的内置数据类型有哪些？" class="headerlink" title="3、TypeScript 的内置数据类型有哪些？"></a><strong>3、TypeScript 的内置数据类型有哪些？</strong></h2><p><strong>数字类型</strong>：用于表示数字类型的值。TypeScript 中的所有数字都存储为浮点值。</p><p>let identifier: number &#x3D; value;</p><p><strong>布尔类型</strong>：一个逻辑二进制开关，包含true或false</p><p>let identifier: string &#x3D; “ “;</p><p><strong>Null 类型</strong>：Null 表示值未定义的变量。</p><p>let identifier: bool &#x3D; Boolean value;</p><p><strong>未定义类型</strong>：一个未定义的字面量，它是所有变量的起点。</p><p>let num: number &#x3D; null;、、、、、、、</p><p><strong>void 类型</strong>：分配给没有返回值的方法的类型。</p><p>let unusable: void &#x3D; undefined;</p><h2 id="4、TypeScript-目前的稳定版本是什么？"><a href="#4、TypeScript-目前的稳定版本是什么？" class="headerlink" title="4、TypeScript 目前的稳定版本是什么？"></a><strong>4、TypeScript 目前的稳定版本是什么？</strong></h2><p>当前的稳定版本是 4.2.3。</p><h2 id="5、TypeScript-中的接口是什么？"><a href="#5、TypeScript-中的接口是什么？" class="headerlink" title="5、TypeScript 中的接口是什么？"></a><strong>5、TypeScript 中的接口是什么？</strong></h2><p>接口为使用该接口的对象定义契约或结构。</p><p>接口是用关键字定义的interface，它可以包含使用函数或箭头函数的属性和方法声明。</p><p>interface IEmployee { empCode: number; empName: string; getSalary: (number) &#x3D;&gt; number; &#x2F;&#x2F; arrow function getManagerName(number): string; }</p><h2 id="6、TypeScript-中的模块是什么？"><a href="#6、TypeScript-中的模块是什么？" class="headerlink" title="6、TypeScript 中的模块是什么？"></a><strong>6、TypeScript 中的模块是什么？</strong></h2><p>TypeScript 中的模块是相关变量、函数、类和接口的集合。</p><p>你可以将模块视为包含执行任务所需的一切的容器。可以导入模块以轻松地在项目之间共享代码。</p><p>module module_name{class xyz{export sum(x, y){return x+y;}}</p><h2 id="7、后端如何使用TypeScript？"><a href="#7、后端如何使用TypeScript？" class="headerlink" title="7、后端如何使用TypeScript？"></a><strong>7、后端如何使用TypeScript？</strong></h2><p>你可以将 Node.js 与 TypeScript 结合使用，将 TypeScript 的优势带入后端工作。</p><p>只需输入以下命令，即可将 TypeScript 编译器安装到你的 Node.js 中：</p><p>npm i -g typescript  &#x2F;&#x2F;全局安装</p><h2 id="8、TypeScript-中的类型断言是什么？"><a href="#8、TypeScript-中的类型断言是什么？" class="headerlink" title="8、TypeScript 中的类型断言是什么？"></a><strong>8、TypeScript 中的类型断言是什么？</strong></h2><p>TypeScript 中的类型断言的工作方式类似于其他语言中的类型转换，但没有 C# 和 Java 等语言中可能的类型检查或数据重组。类型断言对运行时没有影响，仅由编译器使用。</p><p>类型断言本质上是类型转换的软版本，它建议编译器将变量视为某种类型，但如果它处于不同的形式，则不会强制它进入该模型。</p><h2 id="9、如何在-TypeScript-中创建变量？"><a href="#9、如何在-TypeScript-中创建变量？" class="headerlink" title="9、如何在 TypeScript 中创建变量？"></a><strong>9、如何在 TypeScript 中创建变量？</strong></h2><p>你可以通过三种方式创建变量：var，let，和const。</p><p>var是严格范围变量的旧风格。你应该尽可能避免使用，var因为它会在较大的项目中导致问题。</p><p>var num:number &#x3D; 1;</p><p>let是在 TypeScript 中声明变量的默认方式。与var相比，let减少了编译时错误的数量并提高了代码的可读性。</p><p>let num:number &#x3D; 1;</p><p>const创建一个其值不能改变的常量变量。它使用相同的范围规则，let并有助于降低整体程序的复杂性。</p><p>const num:number &#x3D; 100;</p><h2 id="10、在TypeScript中如何从子类调用基类构造函数？"><a href="#10、在TypeScript中如何从子类调用基类构造函数？" class="headerlink" title="10、在TypeScript中如何从子类调用基类构造函数？"></a><strong>10、在TypeScript中如何从子类调用基类构造函数？</strong></h2><p>你可以使用该super()函数来调用基类的构造函数。</p><p>class Animal { name: string; constructor(theName: string) { this.name &#x3D; theName; } move(distanceInMeters: number &#x3D; 0) { console.log(<code>$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.</code>); }}class Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters &#x3D; 5) { console.log(“Slithering…”); super.move(distanceInMeters); }}</p><h2 id="11、解释如何使用-TypeScript-mixin。"><a href="#11、解释如何使用-TypeScript-mixin。" class="headerlink" title="11、解释如何使用 TypeScript mixin。"></a><strong>11、解释如何使用 TypeScript mixin。</strong></h2><p>Mixin 本质上是在相反方向上工作的继承。Mixins 允许你通过组合以前类中更简单的部分类设置来构建新类。</p><p>相反，类A继承类B来获得它的功能，类B从类A需要返回一个新类的附加功能。</p><h2 id="12、TypeScript-中如何检查-null-和-undefined？"><a href="#12、TypeScript-中如何检查-null-和-undefined？" class="headerlink" title="12、TypeScript 中如何检查 null 和 undefined？"></a><strong>12、TypeScript 中如何检查 null 和 undefined？</strong></h2><p>你可以使用 juggle-check，它检查 null 和 undefined，或者使用 strict-check，它返回true设置为null的值，并且不会评估true未定义的变量。</p><p>&#x2F;&#x2F;juggleif (x &#x3D;&#x3D; null) { }</p><p>var a: number; var b: number &#x3D; null; function check(x, name) { if (x &#x3D;&#x3D; null) { console.log(name + ‘ &#x3D;&#x3D; null’); } if (x &#x3D;&#x3D;&#x3D; null) { console.log(name + ‘ &#x3D;&#x3D;&#x3D; null’); } if (typeof x &#x3D;&#x3D;&#x3D; ‘undefined’) { console.log(name + ‘ is undefined’); } } check(a, ‘a’); check(b, ‘b’);</p><h2 id="13、TypeScript-中的-getter-x2F-setter-是什么？你如何使用它们？"><a href="#13、TypeScript-中的-getter-x2F-setter-是什么？你如何使用它们？" class="headerlink" title="13、TypeScript 中的 getter&#x2F;setter 是什么？你如何使用它们？"></a><strong>13、TypeScript 中的 getter&#x2F;setter 是什么？你如何使用它们？</strong></h2><p>Getter 和 setter 是特殊类型的方法，可帮助你根据程序的需要委派对私有变量的不同级别的访问。</p><p>Getters 允许你引用一个值但不能编辑它。Setter 允许你更改变量的值，但不能查看其当前值。这些对于实现封装是必不可少的。</p><p>例如，新雇主可能能够了解get公司的员工人数，但无权set了解员工人数。</p><p>const fullNameMaxLength &#x3D; 10;class Employee { private _fullName: string &#x3D; “”; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (newName &amp;&amp; newName.length &gt; fullNameMaxLength) { throw new Error(“fullName has a max length of “ + fullNameMaxLength); } this._fullName &#x3D; newName; }}let employee &#x3D; new Employee();employee.fullName &#x3D; “Bob Smith”;if (employee.fullName) { console.log(employee.fullName);}</p><h2 id="14、-如何允许模块外定义的类可以访问？"><a href="#14、-如何允许模块外定义的类可以访问？" class="headerlink" title="14、 如何允许模块外定义的类可以访问？"></a><strong>14、 如何允许模块外定义的类可以访问？</strong></h2><p>你可以使用export关键字打开模块以供在模块外使用。</p><p>module Admin { &#x2F;&#x2F; use the export keyword in TypeScript to access the class outside export class Employee { constructor(name: string, email: string) { } } let alex &#x3D; new Employee(‘alex’, ‘<a href="mailto:&#x61;&#108;&#x65;&#120;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;">&#x61;&#108;&#x65;&#120;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;</a>‘);}&#x2F;&#x2F; The Admin variable will allow you to access the Employee class outside the module with the help of the export keyword in TypeScriptlet nick &#x3D; new Admin.Employee(‘nick’, ‘<a href="mailto:&#110;&#105;&#99;&#x6b;&#64;&#x79;&#x61;&#104;&#111;&#111;&#x2e;&#99;&#x6f;&#109;">&#110;&#105;&#99;&#x6b;&#64;&#x79;&#x61;&#104;&#111;&#111;&#x2e;&#99;&#x6f;&#109;</a>‘);</p><h2 id="15、如何使用-Typescript-将字符串转换为数字？"><a href="#15、如何使用-Typescript-将字符串转换为数字？" class="headerlink" title="15、如何使用 Typescript 将字符串转换为数字？"></a><strong>15、如何使用 Typescript 将字符串转换为数字？</strong></h2><p>与 JavaScript 类似，你可以使用parseInt或parseFloat函数分别将字符串转换为整数或浮点数。你还可以使用一元运算符+将字符串转换为最合适的数字类型，“3”成为整数，3而“3.14”成为浮点数3.14。</p><p>var x &#x3D; “32”;var y: number &#x3D; +x;</p><h2 id="16、什么是-map-文件，为什么-x2F-如何使用它？"><a href="#16、什么是-map-文件，为什么-x2F-如何使用它？" class="headerlink" title="16、什么是 .map 文件，为什么&#x2F;如何使用它？"></a><strong>16、什么是 .map 文件，为什么&#x2F;如何使用它？</strong></h2><p>甲.map文件是源地图，显示原始打字稿代码是如何解释成可用的JavaScript代码。它们有助于简化调试，因为你可以捕获任何奇怪的编译器行为。</p><p>调试工具还可以使用这些文件来允许你编辑底层的 TypeScript 而不是发出的 JavaScript 文件。</p><h2 id="17、TypeScript-中的类是什么？你如何定义它们？"><a href="#17、TypeScript-中的类是什么？你如何定义它们？" class="headerlink" title="17、TypeScript 中的类是什么？你如何定义它们？"></a><strong>17、TypeScript 中的类是什么？你如何定义它们？</strong></h2><p>类表示一组相关对象的共享行为和属性。</p><p>例如，我们的类可能是Student，其所有对象都具有该attendClass方法。另一方面，John是一个单独的 type 实例，Student可能有额外的独特行为，比如attendExtracurricular.</p><p>你使用关键字声明类class：</p><p>class Student { studCode: number; studName: string; constructor(code: number, name: string) { this.studName &#x3D; name; this.studCode &#x3D; code; }</p><h2 id="18、TypeScript-与-JavaScript-有什么关系？"><a href="#18、TypeScript-与-JavaScript-有什么关系？" class="headerlink" title="18、TypeScript 与 JavaScript 有什么关系？"></a><strong>18、TypeScript 与 JavaScript 有什么关系？</strong></h2><p>TypeScript 是 JavaScript 的开源语法超集，可编译为 JavaScript。所有原始 JavaScript 库和语法仍然有效，但 TypeScript 增加了 JavaScript 中没有的额外语法选项和编译器功能。</p><p>TypeScript 还可以与大多数与 JavaScript 相同的技术接口，例如 Angular 和 jQuery。</p><h2 id="19、TypeScript-中的-JSX-是什么？"><a href="#19、TypeScript-中的-JSX-是什么？" class="headerlink" title="19、TypeScript 中的 JSX 是什么？"></a><strong>19、TypeScript 中的 JSX 是什么？</strong></h2><p>JSX 是一种可嵌入的类似于 XML 的语法，允许你创建 HTML。TypeScript 支持嵌入、类型检查和将 JSX 直接编译为 JavaScript。</p><h2 id="20、TypeScript-支持哪些-JSX-模式？"><a href="#20、TypeScript-支持哪些-JSX-模式？" class="headerlink" title="20、TypeScript 支持哪些 JSX 模式？"></a><strong>20、TypeScript 支持哪些 JSX 模式？</strong></h2><p>TypeScript有内置的支持preserve，react和react-native。</p><p>preserve 保持 JSX 完整以用于后续转换。</p><p>react不经过 JSX 转换，而是react.createElement作为.js文件扩展名发出和输出。</p><p>react-native结合起来preserve，react因为它维护所有 JSX 和输出作为.js扩展。</p><h2 id="21、如何编译-TypeScript-文件？"><a href="#21、如何编译-TypeScript-文件？" class="headerlink" title="21、如何编译 TypeScript 文件？"></a><strong>21、如何编译 TypeScript 文件？</strong></h2><p>你需要调用 TypeScript 编译器tsc来编译文件。你需要安装 TypeScript 编译器，你可以使用npm.</p><p>npm install -g typescripttsc <TypeScript File Name></p><h2 id="22、-TypeScript-中有哪些范围可用？这与JS相比如何？"><a href="#22、-TypeScript-中有哪些范围可用？这与JS相比如何？" class="headerlink" title="22、 TypeScript 中有哪些范围可用？这与JS相比如何？"></a><strong>22、 TypeScript 中有哪些范围可用？这与JS相比如何？</strong></h2><p>全局作用域：在任何类之外定义，可以在程序中的任何地方使用。</p><p>函数&#x2F;类范围：在函数或类中定义的变量可以在该范围内的任何地方使用。</p><p>局部作用域&#x2F;代码块：在局部作用域中定义的变量可以在该块中的任何地方使用。</p><h2 id="23、TypeScript-中的箭头-x2F-lambda-函数是什么？"><a href="#23、TypeScript-中的箭头-x2F-lambda-函数是什么？" class="headerlink" title="23、TypeScript 中的箭头&#x2F;lambda 函数是什么？"></a><strong>23、TypeScript 中的箭头&#x2F;lambda 函数是什么？</strong></h2><p>胖箭头函数是用于定义匿名函数的函数表达式的速记语法。它类似于其他语言中的 lambda 函数。箭头函数可让你跳过function关键字并编写更简洁的代码。</p><h2 id="24、解释rest参数和声明rest参数的规则。"><a href="#24、解释rest参数和声明rest参数的规则。" class="headerlink" title="24、解释rest参数和声明rest参数的规则。"></a><strong>24、解释rest参数和声明rest参数的规则。</strong></h2><p>其余参数允许你将不同数量的参数（零个或多个）传递给函数。当你不确定函数将接收多少参数时，这很有用。其余符号之后的所有参数…都将存储在一个数组中。</p><p>例如：</p><p>function Greet(greeting: string, …names: string[]) { return greeting + “ “ + names.join(“, “) + “!”;}Greet(“Hello”, “Steve”, “Bill”); &#x2F;&#x2F; returns “Hello Steve, Bill!”Greet(“Hello”);&#x2F;&#x2F; returns “Hello !”</p><p>rest 参数必须是参数定义的最后一个，并且每个函数只能有一个 rest 参数。</p><h2 id="25、什么是三斜线指令？有哪些三斜杠指令？"><a href="#25、什么是三斜线指令？有哪些三斜杠指令？" class="headerlink" title="25、什么是三斜线指令？有哪些三斜杠指令？"></a><strong>25、什么是三斜线指令？有哪些三斜杠指令？</strong></h2><p>三斜线指令是单行注释，包含用作编译器指令的 XML 标记。每个指令都表示在编译过程中要加载的内容。三斜杠指令仅在其文件的顶部工作，并且将被视为文件中其他任何地方的普通注释。</p><p>&#x2F;&#x2F;&#x2F; <reference path="..." /> 是最常见的指令，定义文件之间的依赖关系。</p><p>&#x2F;&#x2F;&#x2F; <reference types="..." />类似于path但定义了包的依赖项。</p><p>&#x2F;&#x2F;&#x2F; <reference lib="..." />允许您显式包含内置lib文件。</p><h2 id="26、Omit类型有什么作用？"><a href="#26、Omit类型有什么作用？" class="headerlink" title="26、Omit类型有什么作用？"></a><strong>26、Omit类型有什么作用？</strong></h2><p>Omit是实用程序类型的一种形式，它促进了常见的类型转换。Omit允许你通过传递电流Type并选择Keys在新类型中省略来构造类型。</p><p>Omit&lt;Type, Keys&gt;</p><p>例如：</p><p>interface Todo { title: string; description: string; completed: boolean; createdAt: number;}type TodoPreview &#x3D; Omit&lt;Todo, “description”&gt;;</p><h2 id="27、TypeScript中如何实现函数重载？"><a href="#27、TypeScript中如何实现函数重载？" class="headerlink" title="27、TypeScript中如何实现函数重载？"></a><strong>27、TypeScript中如何实现函数重载？</strong></h2><p>要在 TypeScript 中重载函数，只需创建两个名称相同但参数&#x2F;返回类型不同的函数。两个函数必须接受相同数量的参数。这是 TypeScript 中多态性的重要组成部分。</p><p>例如，你可以创建一个add函数，如果它们是数字，则将两个参数相加，如果它们是字符串，则将它们连接起来。</p><p>function add(a:string, b:string):string;function add(a:number, b:number): number;function add(a: any, b:any): any { return a + b;}add(“Hello “, “Steve”); &#x2F;&#x2F; returns “Hello Steve” add(10, 20); &#x2F;&#x2F; returns 30</p><h2 id="28、如何让接口的所有属性都可选？"><a href="#28、如何让接口的所有属性都可选？" class="headerlink" title="28、如何让接口的所有属性都可选？"></a><strong>28、如何让接口的所有属性都可选？</strong></h2><p>你可以使用partial映射类型轻松地将所有属性设为可选。</p><h2 id="29、什么时候应该使用关键字unknown？"><a href="#29、什么时候应该使用关键字unknown？" class="headerlink" title="29、什么时候应该使用关键字unknown？"></a><strong>29、什么时候应该使用关键字unknown？</strong></h2><p>unknown，如果你不知道预先期望哪种类型，但想稍后分配它，则应该使用该any关键字，并且该关键字将不起作用。</p><h2 id="30、什么是装饰器，它们可以应用于什么？"><a href="#30、什么是装饰器，它们可以应用于什么？" class="headerlink" title="30、什么是装饰器，它们可以应用于什么？"></a><strong>30、什么是装饰器，它们可以应用于什么？</strong></h2><p>装饰器是一种特殊的声明，它允许你通过使用@<name>注释标记来一次性修改类或类成员。每个装饰器都必须引用一个将在运行时评估的函数。</p><p>例如，装饰器@sealed将对应于sealed函数。任何标有 的@sealed都将用于评估sealed函数。</p><p>function sealed(target) { &#x2F;&#x2F; do something with ‘target’ …}</p><p>它们可以附加到：</p><p>类声明</p><p>方法</p><p>配件</p><p>特性</p><p>参数</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解ES6</title>
    <link href="/2023/01/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/"/>
    <url>/2023/01/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/</url>
    
    <content type="html"><![CDATA[<h3 id="ECMAScript简介"><a href="#ECMAScript简介" class="headerlink" title="ECMAScript简介"></a>ECMAScript简介</h3><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><p>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和ActionScript），日常场合，这两个词是可以互换的。</p><h3 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>ES6 新增了<code>let</code>和<code>const</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>和<code>const</code>命令所在的代码块内有效。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> j=<span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> k=<span class="hljs-number">1</span>;</code></pre></div><p>var：存在变量提升，可以在声明前使用，值为<code>undefined</code>。</p><p>let：存在块级作用域，声明的变量一定要在声明过后使用，不然会报错，不可重复声明。</p><p>const：常量的值不能改变。，不可重复声明</p><p>ES5 只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6 除了添加<code>let</code>和<code>const</code>命令，还有另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6 一共有 6 种声明变量的方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3的组合式API详解</title>
    <link href="/2023/01/23/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/01/23/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h1><div class="code-wrapper"><pre><code class="hljs bash">npm install</code></pre></div><p>文档地址：<a href="https://cn.vuejs.org/api/">API 参考 | Vue.js (vuejs.org)</a></p><p>Vue3 组合式 API（Composition API） 主要用于在大型组件中提高代码逻辑的可复用性。</p><p>传统的组件随着业务复杂度越来越高，代码量会不断的加大，整个代码逻辑都不易阅读和理解。</p><p>Vue3 使用组合式 API 的代码地方为 setup。</p><p>在 setup 中，我们可以按逻辑关注点对部分代码进行分组，然后提取逻辑片段并与其他组件共享代码。因此，组合式 API（Composition API）允许我们编写更有条理的代码。</p><p>vue3 API主要包含以下六个部分：</p><ol><li>全局API —— 全局会用到的API</li><li>组合式API —— vue3所拥有的组合式API</li><li>选项式API —— vue2所拥有的选项式API</li><li>内置内容 —— 指令、组件、特殊元素和特殊属性</li><li>单文件组件 —— 语法定义</li><li>进阶API —— 渲染函数、服务端渲染、TS工具类型和自定义渲染</li></ol><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/1.png"></p><h1 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h1><p>Vue3的全局API包含两个部分：应用实例和通用API。</p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/3.jpg"></p><h2 id="通用API"><a href="#通用API" class="headerlink" title="通用API"></a>通用API</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/4.png"></p><h1 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h1><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/5.png"></p><h2 id="响应式：核心"><a href="#响应式：核心" class="headerlink" title="响应式：核心"></a>响应式：核心</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/5.png"></p><h2 id="响应式：工具函数"><a href="#响应式：工具函数" class="headerlink" title="响应式：工具函数"></a>响应式：工具函数</h2><p>![]222222</p><h2 id="响应式：进阶"><a href="#响应式：进阶" class="headerlink" title="响应式：进阶"></a>响应式：进阶</h2><p>![22222</p><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><p>![22222</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/5.png"></p><h1 id="选项式API"><a href="#选项式API" class="headerlink" title="选项式API"></a>选项式API</h1><h2 id="状态选项"><a href="#状态选项" class="headerlink" title="状态选项"></a>状态选项</h2><p>111</p><h2 id="渲染选项"><a href="#渲染选项" class="headerlink" title="渲染选项"></a>渲染选项</h2><p>1111</p><h2 id="生命周期选项"><a href="#生命周期选项" class="headerlink" title="生命周期选项"></a>生命周期选项</h2><p>11111</p><h2 id="组合选项"><a href="#组合选项" class="headerlink" title="组合选项"></a>组合选项</h2><p>!1111</p><h2 id="其他杂项"><a href="#其他杂项" class="headerlink" title="其他杂项"></a>其他杂项</h2><p>111</p><h2 id="组件实例"><a href="#组件实例" class="headerlink" title="组件实例"></a>组件实例</h2><p>!11111</p><h1 id="内置内容"><a href="#内置内容" class="headerlink" title="内置内容"></a>内置内容</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>!11111</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>!1111</p><h2 id="特殊元素"><a href="#特殊元素" class="headerlink" title="特殊元素"></a>特殊元素</h2><p>!11111</p><h2 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h2><p>![](111111</p><h1 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h1><h2 id="SFC语法定义"><a href="#SFC语法定义" class="headerlink" title="SFC语法定义"></a>SFC语法定义</h2><p>![]1111</p><h2 id="单文件组件script-setup"><a href="#单文件组件script-setup" class="headerlink" title="单文件组件script setup"></a>单文件组件script setup</h2><p>![111111</p><h2 id="css功能"><a href="#css功能" class="headerlink" title="css功能"></a>css功能</h2><p>1111</p><h1 id="进阶API"><a href="#进阶API" class="headerlink" title="进阶API"></a>进阶API</h1><h2 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h2><p>1111</p><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>1111</p><h2 id="TypeScript工具类型"><a href="#TypeScript工具类型" class="headerlink" title="TypeScript工具类型"></a>TypeScript工具类型</h2><p>1111</p><h2 id="自定义渲染"><a href="#自定义渲染" class="headerlink" title="自定义渲染"></a>自定义渲染</h2><p>1111</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对包依赖管理工具的了解</title>
    <link href="/2023/01/23/%E5%AF%B9%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
    <url>/2023/01/23/%E5%AF%B9%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>npm</tag>
      
      <tag>yarn</tag>
      
      <tag>pnpm</tag>
      
      <tag>cnpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS面试记录</title>
    <link href="/2023/01/22/CSS%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/22/CSS%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="如何实现一个元素的水平垂直居中？"><a href="#如何实现一个元素的水平垂直居中？" class="headerlink" title="如何实现一个元素的水平垂直居中？"></a>如何实现一个元素的水平垂直居中？</h2><p>要求对行内元素、块状元素及不定宽高的块状元素均可适用：</p><h2 id="css3-有哪些新特性？"><a href="#css3-有哪些新特性？" class="headerlink" title="css3 有哪些新特性？"></a>css3 有哪些新特性？</h2><ul><li>rgba 和 透明度</li><li>background-image、background-origin、background-size、background-repeat</li><li>word-wrap: break-word（对长的不可分割的单词换行）</li><li>文字阴影 text-shadow</li><li>font-face属性，定义自己的字体</li><li>border-radius</li><li>边框图片 border-image</li><li>盒阴影 box-shadow</li><li>媒体查询：定义多套 css，当浏览器尺寸发生变化时采用不同的属性</li></ul><h2 id="style-标签写在-body-后与-body-前有什么区别？"><a href="#style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="style 标签写在 body 后与 body 前有什么区别？"></a>style 标签写在 body 后与 body 前有什么区别？</h2><ol><li>写在 body 标签前有利于浏览器逐步渲染： resources downloading –&gt; cssDOM + DOM –&gt; Render Tree –&gt; layout –&gt; paint</li><li>写在 body 标签后： 由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载且解析样式完成后重新渲染；在 windows 的 IE 下可能出现样式失效导致的页面闪烁问题。</li></ol><h2 id="CSS选择器及优先级"><a href="#CSS选择器及优先级" class="headerlink" title="CSS选择器及优先级"></a>CSS选择器及优先级</h2><ol><li>选择器<ul><li>id选择器(#myid)</li><li>类选择器(.myclass)</li><li>属性选择器(a[rel&#x3D;”external”])</li><li>伪类选择器(a:hover, li:nth-child)</li><li>标签选择器(div, h1, p)</li><li>伪元素选择器(p::first-line)</li><li>相邻选择器（h1 + p）</li><li>子选择器(ul &gt; li)</li><li>后代选择器(li a)</li><li>通配符选择器(*)</li></ul></li><li>优先级<ul><li><code>!important</code></li><li>内联样式（1000）</li><li>ID选择器（0100）</li><li>类选择器 &#x2F; 属性选择器 &#x2F; 伪类选择器（0010）</li><li>标签选择器 &#x2F; 伪元素选择器（0001）</li><li>关系选择器 &#x2F; 通配符选择器（0000）</li></ul></li></ol><p>带 !important 标记的样式属性优先级最高；样式表的来源相同时：<code>!important &gt; 行内样式&gt; ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</code></p><h2 id="rgba-和-opacity-设置透明度的区别是什么？"><a href="#rgba-和-opacity-设置透明度的区别是什么？" class="headerlink" title="rgba() 和 opacity 设置透明度的区别是什么？"></a>rgba() 和 opacity 设置透明度的区别是什么？</h2><p>rgba() 和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度；而 rgba() 只作用于元素的颜色或其背景色，设置 rgba() 透明的元素的子元素不会继承透明效果。</p><h2 id="浏览器是如何解析-css-选择器等？"><a href="#浏览器是如何解析-css-选择器等？" class="headerlink" title="浏览器是如何解析 css 选择器等？"></a>浏览器是如何解析 css 选择器等？</h2><p><code>从右向左解析的。</code>若从左向右匹配，发现不符合规则，需要回溯，会损失很多性能。若从右向左匹配，先找到所有的最后节点，对于每一个节点，向上寻找其父节点直到查找至根元素或满足条件的匹配规则，则结束这个分支的遍历。</p><p>在 css 解析完毕后，需将解析结果 css 规则树和 DOM Tree 一起进行分析建立一颗 Render Tree，最终用来进行绘图。</p><h2 id="display-none-和-visibility-hidden-两者的区别"><a href="#display-none-和-visibility-hidden-两者的区别" class="headerlink" title="display: none 和 visibility: hidden 两者的区别"></a>display: none 和 visibility: hidden 两者的区别</h2><ol><li>display: none 隐藏后不占用文档流；而 visibility: hidden 会占用文档流。</li><li>visibility 具有继承性，给父元素设置 “visibility: hidden”，子元素也会继承该属性，但如果重新给子元素设置 “visibility: visible”，则子元素又会显示出来。</li><li>visibility: hidden 不会影响计数器的计数，虽然隐藏了，但计数器依然运行着。</li><li>在 css3 中 transition 支持 visibility 属性，但不支持 display。因为 transition 可以延迟执行，因此配合 visibility 使用纯 css 延时显示效果可以提高用户体验。</li><li>display: none 会引起回流（重排）和重绘；visibility: hidden 会引起重绘。</li></ol><h2 id="简述-transform，transition，animation-的作用"><a href="#简述-transform，transition，animation-的作用" class="headerlink" title="简述 transform，transition，animation 的作用"></a>简述 transform，transition，animation 的作用</h2><ol><li><code>transform</code>：描述了元素的静态样式，本身不会呈现动画效果，可以对元素进行旋转 rotate、扭曲 skew、缩放 scale 和移动 translate 以及矩阵变形 matrix。<code>transition</code> 和 <code>animation</code> 两者都能实现动画效果。<code>transform</code> 常配合<code>transition</code> 和 <code>animation</code> 使用。</li><li><code>transition</code>：样式过渡，从一种效果逐渐改变为另一种效果，它是一个合写属性。transition: transition-property transition-duration transition-timing-function transition-delay 从左到右，依次是：过渡效果的css属性名称、过渡效果花费时间、速度曲线、过渡开始的延迟时间 <code>transition</code> 通常和 hover 等事件配合使用，需要由事件来触发过渡。</li><li><code>animation</code>：动画，有 <code>@keyframes</code> 来描述每一帧的样式。</li></ol><p>区别：</p><ul><li><code>transform</code> 仅描述元素的静态样式，常配合<code>transition</code> 和 <code>animation</code> 使用。</li><li><code>transition</code> 通常和 hover 等事件配合使用；<code>animation</code> 是自发的，立即播放。</li><li><code>animation</code> 可以设置循环次数。</li><li><code>animation</code> 可以设置每一帧的样式和时间，<code>transition</code> 只能设置头尾。</li><li><code>transition</code> 可以与 js 配合使用， js 设定要变化的样式，<code>transition</code> 负责动画效果。</li></ul><h2 id="line-height-如何继承？"><a href="#line-height-如何继承？" class="headerlink" title="line-height 如何继承？"></a>line-height 如何继承？</h2><ul><li>父元素的 <code>line-height</code> 是具体数值，则子元素 <code>line-height</code> 继承该值。</li><li>父元素的 <code>line-height</code> 是比例值，如’2’，则子元素 <code>line-height</code> 继承该比例。</li><li>父元素的 <code>line-height</code> 是百分比，则子元素 <code>line-height</code> 继承的是父元素的 font-size * 百分比 计算出来的值。</li></ul><h2 id="如何让-chrome-支持-10px-的文字？"><a href="#如何让-chrome-支持-10px-的文字？" class="headerlink" title="如何让 chrome 支持 10px 的文字？"></a>如何让 chrome 支持 10px 的文字？</h2><ol><li>font-size: 12px; -webkit-transform: scale(0.84);</li><li>font-size: 20px; -webkit-transform: scale(0.5);</li></ol><h2 id="position-属性的值有哪些？"><a href="#position-属性的值有哪些？" class="headerlink" title="position 属性的值有哪些？"></a>position 属性的值有哪些？</h2><ol><li><code>static</code>：默认定位。元素出现在正常的文档流中（忽略top，bottom，left，right 或 z-index声明）</li><li><code>relative</code>：相对定位。如果对一个元素进行相对定位，将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，使其“相对于”它的起点进行移动。使用相对定位时，无论是否移动，元素仍然占据原来的空间；移动元素会导致其覆盖其他元素。</li><li><code>absolute</code>：绝对定位。元素的位置相对于最近的已定位的父元素，如果元素没有已定位的父元素，则相对于根元素（即 html 元素）定位。绝对定位的元素会脱离文档流，不占据空间，会与其他元素重叠。</li><li><code>fixed</code>：固定定位。元素的位置相对于浏览器窗口是固定位置，即使窗口滚动它也不会移动。固定定位的元素会脱离文档流，不占据空间，会与其他元素重叠。</li><li><code>sticky</code>：粘性定位。粘性定位可以被认为是相对定位和固定定位的混合，元素在跨越特定阈值前为相对定位，之后为固定定位。top，right，buttom，left，必须指定这四个阈值中的一个，才可以使粘性定位生效，否则行为与其相对定位相同。</li><li><code>inherit</code>：规定应该从父元素继承 position 属性的值。</li></ol><h2 id="css-盒模型？"><a href="#css-盒模型？" class="headerlink" title="css 盒模型？"></a>css 盒模型？</h2><ul><li><code>标准盒模型</code>，width 指 content 部分的宽度，总宽度 &#x3D; width + border(左右) + padding（左右）+ margin（左右）；高度同理。</li><li><code>怪异盒模型（IE盒模型）</code>，width 指 content + border（左右） + padding（左右）三部分的宽度，因此，总宽度 &#x3D; width + margin（左右）；高度同理。</li></ul><h2 id="box-sizing-属性"><a href="#box-sizing-属性" class="headerlink" title="box-sizing 属性"></a>box-sizing 属性</h2><ol><li><code>content-box</code>，对应标准盒模型。</li><li><code>border-box</code>，IE盒模型。</li><li><code>inherit</code>，继承父元素的 box-sizing 值。</li></ol><h2 id="BFC（块级格式上下文）"><a href="#BFC（块级格式上下文）" class="headerlink" title="BFC（块级格式上下文）"></a>BFC（块级格式上下文）</h2><ol><li>概念： BFC（Block Formatting Context），块级格式上下文。BFC 是 css 布局的一个概念，是一个独立的渲染区域，规定了内部 box 如何布局，且这个区域内的子元素不会影响到外面的元素。</li><li>布局规则：</li></ol><ul><li>内部的 box 会在垂直方向一个接一个的放置</li><li>box 垂直方向的距离由 margin 决定，同一个 BFC 相邻的 box 的 margin 会发生重叠</li><li>每个 box 的 margin 左边，与包含块的左 border 相接触（对于从左往右的格式化，否则相反）</li><li>BFC 的区域不会与 float box 重叠</li><li>BFC 是一个独立容器，容器内的子元素不会影响到外面的元素</li><li>计算 BFC 高度时，浮动元素也参与计算高度</li></ul><ol start="3"><li>如何创建 BFC ？</li></ol><ul><li>根元素，即 html 元素</li><li>float 值不为 none</li><li>position 值为 absolute 或 fixed</li><li>display 的值为 inline-block、tabl-cell、table-caption</li><li>overflow 的值不为 visible</li></ul><ol start="4"><li>BFC 的使用场景</li></ol><ul><li>去除边距重叠问题</li><li>清除浮动（让父元素的高度包含子浮动元素）</li><li>阻止元素被浮动元素覆盖</li></ul><h2 id="让一个元素水平-x2F-垂直居中"><a href="#让一个元素水平-x2F-垂直居中" class="headerlink" title="让一个元素水平&#x2F;垂直居中"></a>让一个元素水平&#x2F;垂直居中</h2><ol><li>水平居中</li></ol><ul><li>行内元素：<code>text-align: center;</code></li><li>对于确定宽度的块级元素<ul><li>width 和 margin 实现： <code>mragin: 0 auto;</code></li><li>绝对定位和 margin-left 实现： <code>margin-left: (父width - 子 width)/2；</code>(前提是父元素相对定位)</li></ul></li><li>对于宽度未知的块级元素<ul><li>table 标签配合 margin 左右 auto 实现</li><li>inline-block 实现：<code>display: inline-block; text-align: center;</code></li><li>绝对定位和 transform 实现， translateX 可以移动本身元素的50%</li><li>flex 布局 <code>justify-content: center</code></li></ul></li></ul><ol start="2"><li>垂直居中</li></ol><ul><li>纯文字类，设置 line-height 等于 height</li><li>子绝父相，子元素通过 margin 实现自适应居中</li><li>子绝父相，通过位移 transform 实现</li><li>flex 布局，<code>align-items: center;</code></li><li>table 布局，父级通过转换为表格形式，子级设置 vertical-align 实现</li></ul><h2 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h2><p>flex 布局，是一种弹性盒布局模型，给子元素提供了空间分布和对齐能力，由<code>container</code>（容器）及<code>item</code>（项目）组成。该布局模型提供了一种更加高效的方式来对容器中的项目进行布局、对齐和分配空间。适用于在不同尺寸的屏幕中创建可自动扩展和收缩布局，通常可用于<code>水平/垂直居中</code>，<code>两栏</code>、<code>三栏布局</code>等的场景里。</p><p>其中<code>flex</code>属性是<code>flex-grow</code>，<code>flex-shrink</code>和<code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。<strong>该属性有两个快捷值：<code>auto (1 1 auto)</code> 和 <code>none (0 0 auto)</code>。</strong></p><ul><li><p><code>flex-grow</code>：定义项目的放大比例，默认值为 0，即如果存在剩余空间，也不放大。如果所有项目的<code>flex-grow</code>属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p></li><li><p><code>flex-shrink</code>：项目的缩小比例，默认为 1，即如果空间不足，项目将缩小。如果所有项目的<code>flex-shrink</code>属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</p></li><li><p><code>flex-basis</code>：定义了在分配多余空间之前，项目占据的主轴空间。浏览器会根据该属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。当设置为 0 的是，会根据内容撑开。也可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如 350px），则项目将占据固定空间。</p></li></ul><p><code>flex</code>常用的属性值：</p><ul><li>flex: 1 –&gt; flex: 1 1 0%</li><li>flex: 2 –&gt; flex: 2 1 0%</li><li>flex: auto –&gt; flex: 1 1 auto</li><li>flex: none –&gt; flex: 0 0 auto【常用于固定尺寸不伸缩】</li></ul><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><ol><li>直接把 <code>&lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;</code>作为最后一个子标签<ul><li>优点：通俗易懂，容易掌握；</li><li>缺点：会添加较多无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦</li></ul></li><li>.clearfix { overflow: hidden; zoom: 1; }<ul><li>优点：不存在结构和语义化问题，代码量极少</li><li>缺点：内容增多时容易造成不自动换行，导致内容被隐藏掉，无法显示需要溢出的元素</li></ul></li><li>建立伪类选择器</li></ol><p><img src="/../imgs/CSS%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/98e2353e3275475095bd26ecedfa32e9tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="image.png"></p><h2 id="css-中优雅降级和渐进增强有什么区别？"><a href="#css-中优雅降级和渐进增强有什么区别？" class="headerlink" title="css 中优雅降级和渐进增强有什么区别？"></a>css 中优雅降级和渐进增强有什么区别？</h2><p>优雅降级和渐进增强是随着 css3 流出来的一个概念。由于低级浏览器不支持 css3， 但 css3 的效果又很优秀不忍放弃，所以在高级浏览器中使用 css3 ，而在低级浏览器只保证最基本的功能。二者最关键的区别是它们所侧重的内容，以及这种不同所造成的工作流程的差异。</p><ul><li><code>优雅降级</code>：一开始就构建完整的功能，然后针对浏览器测试和修复。</li><li><code>渐进增强</code>：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能以达到更好的体验。</li></ul><h2 id="img-的-alt-和-title-的异同？实现图片懒加载的原理？"><a href="#img-的-alt-和-title-的异同？实现图片懒加载的原理？" class="headerlink" title="img 的 alt 和 title 的异同？实现图片懒加载的原理？"></a>img 的 alt 和 title 的异同？实现图片懒加载的原理？</h2><ul><li><code>alt</code>是图片加载失败时显示在网页上的替代文字；<code>title</code>是鼠标放在图片上面时显示的文字，是对图片的进一步描述和说明。</li><li><code>alt</code>是 img 的必要属性；<code>title</code>不是。</li><li>对于网站 SEO 优先来说，搜索引擎对图片意思的判断，主要是靠<code>alt</code>属性，所以在图片<code>alt</code>属性中以简要文字说明，同时包含关键字，也是页面优化的一部分。</li></ul><p><code>懒加载原理</code>：先设置图片的 <code>data-set</code> 属性值（也可以是其他任意的，只要不发生 http 请求就可以，作用是为了存取值）为图片路径，由于不是 <code>src</code> 属性，故不会发生 http 请求。然后计算出页面的 scrollTop 的高度和浏览器的高度之和，如果图片距页面顶端距离小于前两者之和，说明图片要显示出来了，这时将 <code>data-set</code> 属性替换为 <code>src</code> 属性即可。</p><h2 id="css-sprites-（雪碧图-x2F-精灵图）"><a href="#css-sprites-（雪碧图-x2F-精灵图）" class="headerlink" title="css sprites （雪碧图&#x2F;精灵图）"></a>css sprites （雪碧图&#x2F;精灵图）</h2><p>css sprites 就是把网页中一些小图片整合到一张图片文件中，再利用 css 的 background-image、background-repeat、background-position 的组合进行背景定位。</p><p>优点： 减少图片体积；减少 http 请求次数</p><p>缺点：维护比较麻烦；不能随便改变大小，会失真模糊</p><h2 id="什么是字体图标？"><a href="#什么是字体图标？" class="headerlink" title="什么是字体图标？"></a>什么是字体图标？</h2><p>字体图标简单的说，就是一种特殊的字体，通过这种字体，显示给用户的就像一个个图片一样。字体图标最大的好处，在于它不会变形和加载速度快。字体图标可以像文字一样，随意通过 css 来控制它的大小和颜色，非常方便。</p><h2 id="主流浏览器内核私有属性-css-前缀？"><a href="#主流浏览器内核私有属性-css-前缀？" class="headerlink" title="主流浏览器内核私有属性 css 前缀？"></a>主流浏览器内核私有属性 css 前缀？</h2><ul><li>mozilla(firefox、flock等): -moz</li><li>webkit 内核(safari、chrome等): -webkit</li><li>opera 内核(opera浏览器): -o</li><li>trident 内核(ie 浏览器): -ms</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML面试记录</title>
    <link href="/2023/01/22/HTML%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/22/HTML%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><ol><li>语义化，指对文本内容的结构化（内容语义化），选择合乎语义的标签（代码语义化）。</li><li>语义化标签：<code>header</code>、<code>nav</code>、<code>main</code>、<code>article</code>、<code>section</code>、<code>aside</code>、<code>footer</code>等。</li><li>优点：<ul><li>代码结构清晰，易于阅读，有利于维护</li><li>方便其他设备解析（如：屏幕阅读器）</li><li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li></ul></li></ol><p>建议阅读文章：<a href="https://link.juejin.cn/?target=https://rainylog.com/post/ife-note-1/" title="https://rainylog.com/post/ife-note-1/">百度ife的h5语义化文章</a></p><p><a href="https://zhuanlan.zhihu.com/p/32570423">初探 · HTML5语义化</a></p><h2 id="script-标签中属性-async-和-defer-的区别？"><a href="#script-标签中属性-async-和-defer-的区别？" class="headerlink" title="script 标签中属性 async 和 defer 的区别？"></a>script 标签中属性 async 和 defer 的区别？</h2><ul><li><code>script</code> 会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML</li><li><code>async script</code>：解析 HTML 的过程中会进行脚本的异步下载，下载成功后立马执行，因此有可能会阻断 HTML 的解析。多个脚本的执行顺序无法保证。</li><li><code>defer script</code>：也是异步下载脚步，加载完成后，如果此时 HTML 还没有解析完，浏览器不会暂停解析去执行 JS 代码，而是等待 HTML 解析完毕再执行 JS 代码，如果存在多个 <code>defer script</code> 标签，浏览器（IE9及以下除外）会保证它们按照在 HTML 中出现的顺序执行，不会破坏 JS 脚本之间的依赖关系。</li></ul><p>建议阅读文章：<a href="https://juejin.cn/post/6894629999215640583" title="https://juejin.cn/post/6894629999215640583">图解 script 标签中的 async 和 defer 属性</a></p><h2 id="DOCTYPE-的作用是什么？"><a href="#DOCTYPE-的作用是什么？" class="headerlink" title="DOCTYPE 的作用是什么？"></a>DOCTYPE 的作用是什么？</h2><p><code>&lt;!DOCTYE&gt;</code> 声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以“标准模式”进行文档解析，否则就以“兼容模式”进行解析。</p><ul><li>在<code>标准模式</code>下，浏览器的解析规则都是按照最新的标准进行解析的。</li><li>而在<code>兼容模式</code>下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站能正常访问。</li></ul><h2 id="SGML、HTML、XML-和-XHTML的区别"><a href="#SGML、HTML、XML-和-XHTML的区别" class="headerlink" title="SGML、HTML、XML 和 XHTML的区别"></a>SGML、HTML、XML 和 XHTML的区别</h2><ul><li><code>SGML</code> 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。</li><li><code>HTML</code> 是超文本标记语言，主要是用于规定怎样显示网页。</li><li><code>XML</code> 是可扩展标记语言，是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。</li><li><code>XHTML</code> 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</li></ul><h2 id="HTML5-有哪些新特性、移除了哪些元素？"><a href="#HTML5-有哪些新特性、移除了哪些元素？" class="headerlink" title="HTML5 有哪些新特性、移除了哪些元素？"></a>HTML5 有哪些新特性、移除了哪些元素？</h2><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像、位置、存储、多任务等功能的增加。</p><p>新增的：</p><ul><li>绘图 <code>canvas</code></li><li>用于媒介回放的 <code>video</code> 和 <code>audio</code> 元素</li><li>本地离线存储 <code>localStorage</code> 、<code>sessionStorage</code></li><li>语义化更好的内容元素，如：<code>header</code>、<code>article</code>、<code>nav</code>、<code>section</code>、<code>footer</code>等</li><li>表单控件 <code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code> 等</li><li>新的技术 <code>webworker</code>、<code>websocket</code></li><li>新的文档属性 <code>document.visibilityState</code></li></ul><p>移除的：</p><ul><li>纯表现的元素：<code>basefont</code>、<code>big</code>、<code>center</code>、<code>s</code>、<code>tt</code>、<code>u</code></li><li>对可用性产生负面影响的元素：<code>frame</code>、<code>frameset</code>、<code>noframes</code></li></ul><h2 id="对浏览器内核的理解"><a href="#对浏览器内核的理解" class="headerlink" title="对浏览器内核的理解"></a>对浏览器内核的理解</h2><p>主要分为两部分：渲染引擎和JS引擎。</p><ul><li><code>渲染引擎</code>：其职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 HTML、 XML 文档及图片，它也可以借助一些浏览器扩展插件显示其他类型数据，如：使用PDF阅读器插件可以显示 PDF 格式。</li><li><code>JS引擎</code>：解析和执行 JavaScript 来实现网页的动态效果。</li></ul><p>最开始渲染引擎和JS引擎并没有区分的很明显，后来JS引擎越来越独立，内核就倾向于只指渲染引擎了。</p><h2 id="什么是文档的预解析？"><a href="#什么是文档的预解析？" class="headerlink" title="什么是文档的预解析？"></a>什么是文档的预解析？</h2><p>当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载，从而使整体速度更快。</p><p>需要注意的是，预解析并不改变DOM树，它将这个工作交给主解析过程，自己只解析外部资源的引用，比如：外部脚本、样式及图片。</p><h2 id="浏览器的渲染原理"><a href="#浏览器的渲染原理" class="headerlink" title="浏览器的渲染原理"></a>浏览器的渲染原理</h2><p>简记： 生成DOM树 –&gt; 生成CSS规则树 –&gt; 构建渲染树 –&gt; 布局 –&gt; 绘制</p><ol><li>首先解析收到的文档，根据文档定义构建一颗 <code>DOM 树</code>，DOM 树是由 DOM 元素及属性节点组成的。</li><li>然后对 CSS 进行解析，生成一颗 <code>CSS 规则树</code>。</li><li>根据 DOM 树和 CSS 规则树构建<code>渲染树</code>。渲染树的节点被称为渲染对象，它是一个包含有颜色等属性的矩形。渲染对象和 DOM 元素相对应，但这种关系不是一对一的，不可见的 DOM 元素不会插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行<code>布局</code>（也可以叫做回流）。这一阶段浏览器要做的是计算出各个节点在页面中确切位置和大小。通常这一行为也被称为自动重排。</li><li>布局阶段结束后是<code>绘制</code>阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示到屏幕上。值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎会尽早的将内容呈现到屏幕上，并不会等到所有 HMTL 内容都解析完之后再去构建和布局渲染树，它是解析完一部分内容就显示一部分内容，同时，可能还通过网络下载其余内容。</li></ol><h2 id="什么是回流和重绘？"><a href="#什么是回流和重绘？" class="headerlink" title="什么是回流和重绘？"></a>什么是回流和重绘？</h2><p>1.概念：</p><ul><li><code>回流</code>：当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做回流（也可以叫做重排）。表现为重新生成布局，重新排列元素。</li><li><code>重绘</code>：当一个元素的外观发生改变，重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。</li></ul><p>2.常见引起回流和重绘的属性和方法：</p><p>任何会改变元素几何信息（元素的位置和尺寸大小）的操作都会触发回流。</p><ul><li>添加或删除可见的 DOM 元素</li><li>元素尺寸改变–边距、填充、宽度、高度</li><li>浏览器尺寸改变– resize 事件发生时</li><li>计算 offsetWidth 和 offsetHeight 属性</li><li>设置 style 属性的值</li><li>修改网页默认字体</li></ul><p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong></p><p><strong>回流所需的成本比重绘高得多</strong></p><p>建议阅读文章：<a href="https://juejin.cn/post/6844903779700047885" title="https://juejin.cn/post/6844903779700047885">你真的了解回流和重绘吗</a></p><h2 id="如何减少回流？"><a href="#如何减少回流？" class="headerlink" title="如何减少回流？"></a>如何减少回流？</h2><ul><li>使用 transform 代替 top</li><li>不要把节点的属性值放在一个循环里，当成循环里的变量</li><li>不要使用 table 布局，可能很小的一个改动会造成整个 table 的重新布局</li><li>把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM</li><li>不要一条一条的修改样式，可以预先定义好 class，然后修改 DOM 的 className</li><li>使用 absolute 或 fixed 使元素脱离文档流</li></ul><h2 id="sessionStorage，localStorage-和-cookie-的区别"><a href="#sessionStorage，localStorage-和-cookie-的区别" class="headerlink" title="sessionStorage，localStorage 和 cookie 的区别"></a>sessionStorage，localStorage 和 cookie 的区别</h2><ol><li>共同点：都是保存在浏览器端，且同源的</li><li>区别:</li></ol><ul><li>cookie 始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器之间来回传递；而 sessionStorage 和 localStorage 不会自动把数据发送到服务器，仅在本地保存。cookie 还有路径（path）的概念，可以限制 cookie 只属于某个路径下。</li><li>存储大小限制不同。cookie 不能超过 4K，因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如：会话标识。sessionStorage 和 localStorage 虽然也有存储大小限制，但比 cookie 大得多，可以达到 5M 或更大。</li><li>数据有效期不同。sessionStorage 仅在当前浏览器窗口关闭之前有效；localStorage 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前有效。</li><li>作用域不同。sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和 cookie 在所有同源窗口中都是共享的。</li></ul><h2 id="iframe-有哪些优缺点？"><a href="#iframe-有哪些优缺点？" class="headerlink" title="iframe 有哪些优缺点？"></a>iframe 有哪些优缺点？</h2><p>优点：</p><ol><li>iframe 能原封不动的把嵌入的网页展现出来。</li><li>如果有多个网页引用 iframe，只需修改 iframe 的内容，就可以实现调用每一个页面的更改，方便快捷。</li></ol><p>缺点：</p><ol><li>iframe 会阻塞主页面的 onload 事件。</li><li>iframe 和主页面共享链接池，而浏览器对相同域的链接有限制，所以会影响页面的并行加载。</li><li>不利于 SEO，代码复杂，无法一下被搜索引擎索引到。</li><li>iframe 框架页面会增加服务器的 http 请求，对于大型网站不可取。</li><li>很多移动设备无法完全显示框架，设备兼容性差。</li></ol><p>注意：通过动态给 iframe 添加 src 属性值，可解决前两个问题。</p><h2 id="什么是-canvas，基本用法是什么？"><a href="#什么是-canvas，基本用法是什么？" class="headerlink" title="什么是 canvas，基本用法是什么？"></a>什么是 canvas，基本用法是什么？</h2><p>canvas 元素是 HTML5 的一部分，允许脚步语言动态渲染位图像。canvas 由一个可控制区域 HTML 代码中的属性定义决定高度和宽度。JavaScript 代码可以访问该区域，通过一套完整的绘图功能类似于其他通用二维的 API，从而生成动态的图形。</p><ol><li>创建 canvas 标签</li></ol><div class="code-wrapper"><pre><code class="hljs routeros">&lt;canvas <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;150&quot;</span> <span class="hljs-attribute">height</span>=<span class="hljs-string">&quot;150&quot;</span>&gt;该浏览器不支持canvas&lt;/canvas&gt;复制代码</code></pre></div><ol start="2"><li>渲染上下文</li></ol><div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);复制代码</code></pre></div><p>代码第一行通过使用 <code>document.getElementById()</code> 方法获取 <code>&lt;canvas&gt;</code> 元素对应的 DOM 对象，然后可以通过使用它的 <code>getContext()</code> 方法来绘制上下文。 创建 canvas 标签时可以在标签内写上不支持的提示信息；也可以通过 <code>getContext()</code> 方法判读是否支持编程。</p><div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);<span class="hljs-keyword">if</span> (canvas.getContext) &#123;  <span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);  <span class="hljs-comment">// other code</span>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 不支持 canvas 的其他代码</span>&#125;复制代码</code></pre></div><p>用途：</p><p>canvas 可用于游戏和图表（echarts.js、heightchart.js 都是基于 canvas 来绘图）制作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo创建博客</title>
    <link href="/2023/01/22/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/01/22/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo部署博客的命令"><a href="#hexo部署博客的命令" class="headerlink" title="hexo部署博客的命令"></a>hexo部署博客的命令</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>- </p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue面试题总结</title>
    <link href="/2023/01/19/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2023/01/19/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-vue2-0组件通信⽅式有哪些？"><a href="#1-vue2-0组件通信⽅式有哪些？" class="headerlink" title="1. vue2.0组件通信⽅式有哪些？"></a>1. vue2.0组件通信⽅式有哪些？</h2><ul><li><p>⽗⼦组件通信： <code>props</code> 和 <code>event</code>、<code>v-model</code>、 <code>.sync</code>、 <code>ref</code>、 <code>$parent</code> 和 <code>$children</code></p></li><li><p>非⽗⼦组件通信： <code>$attr</code> 和 <code>$listeners</code>、 <code>provide</code> 和 <code>inject</code>、<code>eventbus</code>、通过根实例<code>$root</code>访问、 <code>vuex</code>、<code>dispatch</code> 和 <code>brodcast</code></p></li></ul><h2 id="2-v-model是如何实现双向绑定的？"><a href="#2-v-model是如何实现双向绑定的？" class="headerlink" title="2. v-model是如何实现双向绑定的？"></a>2. v-model是如何实现双向绑定的？</h2><ul><li><p>vue 2.0 <code>v-model</code> 是⽤来在表单控件或者组件上创建双向绑定的，他的本质是 <code>v-bind</code> 和 <code>v-on</code> 的语法糖，在 ⼀个组件上使⽤ <code>v-model</code> ，默认会为组件绑定名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件。</p></li><li><p>Vue3.0 在 3.x 中，⾃定义组件上的 <code>v-model</code> 相当于传递了 <code>modelValue prop</code> 并接收抛出的 <code>update:modelValue</code> 事件</p></li></ul><h2 id="3-Vuex和单纯的全局对象有什么区别？"><a href="#3-Vuex和单纯的全局对象有什么区别？" class="headerlink" title="3. Vuex和单纯的全局对象有什么区别？"></a>3. Vuex和单纯的全局对象有什么区别？</h2><p><strong>Vuex和全局对象主要有两⼤区别：</strong></p><ol><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发⽣变 化，那么相应的组件也会相应地得到⾼效更新。</li><li>不能直接改变 store 中的状态。改变 store 中的状态的唯⼀途径就是显式地提交 (commit)mutation。这样使得我们可以⽅便地跟踪每⼀个状态的变化，从⽽让我们能够实现⼀些⼯具帮助我们更好地了解我们的应⽤。</li></ol><h2 id="4-Vue-的⽗组件和⼦组件⽣命周期钩⼦执⾏顺序是什么？"><a href="#4-Vue-的⽗组件和⼦组件⽣命周期钩⼦执⾏顺序是什么？" class="headerlink" title="4. Vue 的⽗组件和⼦组件⽣命周期钩⼦执⾏顺序是什么？"></a>4. Vue 的⽗组件和⼦组件⽣命周期钩⼦执⾏顺序是什么？</h2><p><strong>渲染过程：</strong> ⽗组件挂载完成⼀定是等⼦组件都挂载完成后，才算是⽗组件挂载完，所以⽗组件的mounted在⼦组件mouted之后</p><p>⽗beforeCreate -&gt; ⽗created -&gt; ⽗beforeMount -&gt; ⼦beforeCreate -&gt; ⼦created -&gt; ⼦beforeMount -&gt; ⼦mounted -&gt; ⽗mounted</p><p><strong>⼦组件更新过程：</strong></p><ol><li>影响到⽗组件： ⽗beforeUpdate -&gt; ⼦beforeUpdate-&gt;⼦updated -&gt; ⽗updted</li><li>不影响⽗组件： ⼦beforeUpdate -&gt; ⼦updated</li></ol><p><strong>⽗组件更新过程：</strong></p><ol><li>影响到⼦组件： ⽗beforeUpdate -&gt; ⼦beforeUpdate-&gt;⼦updated -&gt; ⽗updted</li><li>不影响⼦组件： ⽗beforeUpdate -&gt; ⽗updated</li></ol><p><strong>销毁过程：</strong> ⽗beforeDestroy -&gt; ⼦beforeDestroy -&gt; ⼦destroyed -&gt; ⽗destroyed</p><p>看起来很多好像很难记忆，其实只要理解了，不管是哪种情况，都⼀定是⽗组件等待⼦组件完成后，才会执⾏⾃⼰对应完成的钩⼦，就可以很容易记住</p><h2 id="5-v-show-和-v-if-有哪些区别？"><a href="#5-v-show-和-v-if-有哪些区别？" class="headerlink" title="5. v-show 和 v-if 有哪些区别？"></a>5. v-show 和 v-if 有哪些区别？</h2><ul><li><p><code>v-if</code> 会在切换过程中对条件块的事件监听器和⼦组件进⾏<strong>销毁和重建</strong>，如果初始条件是false，则什么都不做，直到条件第⼀次为true时才开始渲染模块。</p></li><li><p><code>v-show</code> 只是<strong>基于css进⾏切换</strong>，不管初始条件是什么，都会渲染。</p></li></ul><p>所以， <code>v-if</code> 切换的开销更⼤，⽽ <code>v-show</code> 初始化渲染开销更⼤，<strong>在需要频繁切换，或者切换的部分dom很复杂时，使⽤ <code>v-show</code> 更合适。渲染后很少切换的则使⽤ <code>v-if</code> 更合适。</strong></p><h2 id="6-Vue-中-v-html-会导致什么问题"><a href="#6-Vue-中-v-html-会导致什么问题" class="headerlink" title="6. Vue 中 v-html 会导致什么问题"></a>6. Vue 中 v-html 会导致什么问题</h2><p>在⽹站上动态渲染任意 HTML，<strong>很容易导致 XSS 攻击</strong>。所以只能在可信内容上使⽤ v-html，且永远不能⽤于⽤户提交的内容上。</p><h2 id="7-v-for-中-key-的作⽤是什么？"><a href="#7-v-for-中-key-的作⽤是什么？" class="headerlink" title="7. v-for 中 key 的作⽤是什么？"></a>7. v-for 中 key 的作⽤是什么？</h2><p><code>key</code> 是给每个 <code>vnode</code> 指定的唯⼀ <code>id</code> ，在同级的 <code>vnode</code> diff 过程中，可以根据 <code>key</code> 快速的对⽐，来判断是否为相同节点，并且利⽤ <code>key</code> 的唯⼀性可以⽣成 <code>map</code> 来更快的获取相应的节点。</p><p>另外指定 <code>key</code> 后，就不再采⽤“就地复⽤”策略了，可以保证渲染的准确性。</p><h2 id="8-为什么-v-for-和-v-if-不建议⽤在⼀起"><a href="#8-为什么-v-for-和-v-if-不建议⽤在⼀起" class="headerlink" title="8. 为什么 v-for 和 v-if 不建议⽤在⼀起"></a>8. 为什么 v-for 和 v-if 不建议⽤在⼀起</h2><ul><li>当 <code>v-for</code> 和 <code>v-if</code> 处于同⼀个节点时， <code>v-for</code> 的优先级⽐ <code>v-if</code> 更⾼，这意味着 <code>v-if</code> 将分别重复运⾏于每个 <code>v-for</code> 循环中。如果要遍历的数组很⼤，⽽真正要展示的数据很少时，这将造成很⼤的性能浪费。</li><li>这种场景建议使⽤ <code>computed</code> ，先对数据进⾏过滤。</li></ul><h2 id="9-vue-router-hash-模式和-history-模式有什么区别？"><a href="#9-vue-router-hash-模式和-history-模式有什么区别？" class="headerlink" title="9. vue-router hash 模式和 history 模式有什么区别？"></a>9. vue-router hash 模式和 history 模式有什么区别？</h2><p>区别：</p><ol><li>url 展示上，hash 模式有 “#”，history 模式没有</li><li>刷新⻚⾯时，hash 模式可以正常加载到 hash 值对应的⻚⾯，⽽ history 没有处理的话，会返回404，⼀般需要后端将所有⻚⾯都配置重定向到⾸⻚路由。</li><li>兼容性。hash 可以⽀持低版本浏览器和 IE</li></ol><h2 id="10-vue-router-hash-模式和-history-模式是如何实现的？"><a href="#10-vue-router-hash-模式和-history-模式是如何实现的？" class="headerlink" title="10. vue-router hash 模式和 history 模式是如何实现的？"></a>10. vue-router hash 模式和 history 模式是如何实现的？</h2><ul><li>hash 模式：</li></ul><p><code>#</code> 后⾯ hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新⻚⾯。同时通过监听 hashchange 事件可以知道 hash 发⽣了哪些变化，然后根据 hash 变化来实现更新⻚⾯部分内容的操作。</p><ul><li>history 模式：</li></ul><p>history 模式的实现，主要是 HTML5 标准发布的两个 API， <code>pushState</code> 和 <code>replaceState</code> ，这两个 API 可以在改变 url，但是不会发送请求。这样就可以监听 url 变化来实现更新⻚⾯部分内容的操作。</p><h2 id="11-vue3-0-相对于-vue2-x-有哪些变化？"><a href="#11-vue3-0-相对于-vue2-x-有哪些变化？" class="headerlink" title="11. vue3.0 相对于 vue2.x 有哪些变化？"></a>11. vue3.0 相对于 vue2.x 有哪些变化？</h2><ul><li>监测机制的改变（Object.defineProperty —&gt; Proxy）</li><li>模板</li><li>对象式的组件声明⽅式 （class）</li><li>使⽤ts</li><li>其它⽅⾯的更改：⽀持⾃定义渲染器、 ⽀持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件、基于 treeshaking 优化，提供了更多的内置功能</li></ul><h2 id="12-那你能讲⼀讲MVVM吗？"><a href="#12-那你能讲⼀讲MVVM吗？" class="headerlink" title="12. 那你能讲⼀讲MVVM吗？"></a>12. 那你能讲⼀讲MVVM吗？</h2><ul><li>MVVM是 <code>Model-View-ViewModel</code> 缩写，也就是把 <code>MVC</code> 中的 <code>Controller</code> 演变成 <code>ViewModel</code> 。</li><li>Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，<strong>数据会绑定到viewModel层并⾃动将数据渲染到⻚⾯中，视图变化的时候会通知viewModel层更新数据</strong>。</li></ul><h2 id="13-vue-中组件-data-为什么是-return-⼀个对象的函数，⽽不是直接是个对象？"><a href="#13-vue-中组件-data-为什么是-return-⼀个对象的函数，⽽不是直接是个对象？" class="headerlink" title="13. vue 中组件 data 为什么是 return ⼀个对象的函数，⽽不是直接是个对象？"></a>13. vue 中组件 data 为什么是 return ⼀个对象的函数，⽽不是直接是个对象？</h2><ul><li>如果将data定义为对象，这就表示<strong>所有的组件实例共⽤了⼀份data数据</strong>，因此，⽆论在哪个组件实例中修改了data,都会影响到所有的组件实例。</li><li>组件中的data写成⼀个函数，<strong>数据以函数返回值形式定义</strong>，这样每复⽤⼀次组件，就会返回⼀份新的data，类似于给每个组件实例创建⼀个<strong>私有的数据空间</strong>，让各个组件实例维护各⾃的数据。⽽单纯的写成对象形式，就使得所有组件实例共⽤了⼀份data，就会造成⼀个变了全都会变的结果。</li></ul><h2 id="14-Vue-中的-computed-是如何实现的"><a href="#14-Vue-中的-computed-是如何实现的" class="headerlink" title="14. Vue 中的 computed 是如何实现的"></a>14. Vue 中的 computed 是如何实现的</h2><p><strong>流程总结如下：</strong></p><ol><li><p>当组件初始化的时候， <code>computed</code> 和 <code>data</code> 会分别建⽴各⾃的响应系统， <code>Observer</code> 遍历 <code>data</code>中每个属性设置 <code>get/set</code> 数据拦截</p></li><li><p>初始化 <code>computed</code> 会调⽤ <code>initComputed</code> 函数</p></li></ol><ul><li><p>注册⼀个 <code>watcher</code> 实例，并在内实例化⼀个 <code>Dep</code> 消息订阅器⽤作后续收集依赖（⽐如渲染函数的 <code>watcher</code> 或者其他观察该计算属性变化的 <code>watcher</code> ）</p></li><li><p>调⽤计算属性时会触发其 <code>Object.defineProperty</code> 的 <code>get</code> 访问器函数</p></li><li><p>调⽤ <code>watcher.depend()</code> ⽅法向⾃身的消息订阅器 <code>dep</code> 的 <code>subs</code> 中添加其他属性的 <code>watcher</code></p></li><li><p>调⽤ <code>watcher</code> 的 <code>evaluate</code> ⽅法（进⽽调⽤ <code>watcher</code> 的 <code>get</code> ⽅法）让⾃身成为其他 <code>watcher</code> 的消息订阅器的订阅者，⾸先将 <code>watcher</code> 赋给 <code>Dep.target</code> ，然后执⾏ <code>getter</code> 求值函数，当访问求值函数⾥⾯的属性（⽐如来⾃ <code>data</code> 、 <code>props</code> 或其他 <code>computed</code> ）时， 会同样触发它们的 <code>get</code> 访问器函数从⽽将该计算属性的 <code>watcher</code> 添加到求值函数中属性的 <code>watcher</code> 的消息订阅器 <code>dep</code> 中，当这些操作完成，最后关闭 <code>Dep.target</code> 赋为 <code>null</code> 并 返回求值函数结果。</p></li></ul><ol start="3"><li>当某个属性发⽣变化，触发 <code>set</code> 拦截函数，然后调⽤⾃身消息订阅器 <code>dep</code> 的 <code>notify</code> ⽅法，遍 历当前 dep 中保存着所有订阅者 <code>wathcer</code> 的 <code>subs</code> 数组，并逐个调⽤ <code>watcher</code> 的 <code>update</code> ⽅ 法，完成响应更新。</li></ol><h2 id="15-Vue-的响应式原理"><a href="#15-Vue-的响应式原理" class="headerlink" title="15. Vue 的响应式原理"></a>15. Vue 的响应式原理</h2><p>如果⾯试被问到这个问题，⼜描述不清楚，可以直接画出 Vue 官⽅⽂档的这个图，对着图来解释效果会更好。</p><p><img src="/../imgs/VUE%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/32499420ebf84b55b3eef52751eb21cctplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="image.png"></p><ul><li>Vue 的响应式是通过 <code>Object.defineProperty</code> 对数据进⾏<strong>劫持</strong>，并结合<strong>观察者模式</strong>实现。</li><li>Vue 利⽤<code>Object.defineProperty</code> 创建⼀个 <code>observe</code> 来劫持监听所有的属性，把这些属性全部转为 <code>getter</code>和 <code>setter</code> 。</li><li>Vue 中每个组件实例都会对应⼀个 <code>watcher</code> 实例，它会在组件渲染的过程中把使⽤过的 数据属性通过 <code>getter</code> 收集为依赖。之后当依赖项的 <code>setter</code> 触发时，会通知 <code>watcher</code> ，从⽽使它关联的组件重新渲染。</li></ul><h2 id="16-Object-defineProperty有哪些缺点？"><a href="#16-Object-defineProperty有哪些缺点？" class="headerlink" title="16. Object.defineProperty有哪些缺点？"></a>16. Object.defineProperty有哪些缺点？</h2><ol><li><code>Object.defineProperty</code> 只能劫持<strong>对象的属性</strong>，⽽ <code>Proxy</code> 是直接<strong>代理对象</strong>由于 <code>Object.defineProperty</code> 只能对属性进⾏劫持，需要遍历对象的每个属性。⽽ Proxy 可以直接代理对象。</li><li><code>Object.defineProperty</code> 对新增属性需要⼿动进⾏ <code>Observe</code> ， 由于 <code>Object.defineProperty</code> 劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新 增属性再使⽤ <code>Object.defineProperty</code> 进⾏劫持。 也正是因为这个原因，使⽤ Vue 给 <code>data</code>中的数组或对象新增属性时，需要使⽤ <code>vm.$set</code>才能保证新增的属性也是响应式的。</li><li><code>Proxy</code> ⽀持<strong>13种拦截</strong>操作，这是 <code>defineProperty</code> 所不具有的。</li><li>新标准性能红利Proxy 作为新标准，⻓远来看，JS引擎会继续优化 <code>Proxy</code> ，但 <code>getter</code> 和 <code>setter</code> 基本不会再有针对性优化。</li><li><code>Proxy</code> 兼容性差 ⽬前并没有⼀个完整⽀持 <code>Proxy</code> 所有拦截⽅法的Polyfill⽅案</li></ol><h2 id="17-Vue2-0中如何检测数组变化？"><a href="#17-Vue2-0中如何检测数组变化？" class="headerlink" title="17. Vue2.0中如何检测数组变化？"></a>17. Vue2.0中如何检测数组变化？</h2><p>Vue 的 <code>Observer</code> 对数组做了单独的处理，对数组的⽅法进⾏编译，并赋值给数组属性的 <code>__proto__</code>属性上，因为<strong>原型链</strong>的机制，找到对应的⽅法就不会继续往上找了。编译⽅法中会对⼀些会增加索引的⽅法（ <code>push</code> ， <code>unshift</code> ， <code>splice</code> ）进⾏⼿动 observe。</p><h2 id="18-nextTick是做什么⽤的，其原理是什么"><a href="#18-nextTick是做什么⽤的，其原理是什么" class="headerlink" title="18. nextTick是做什么⽤的，其原理是什么?"></a>18. nextTick是做什么⽤的，其原理是什么?</h2><p>能回答清楚这道问题的前提，是清楚 EventLoop 过程。</p><ul><li>在下次 DOM 更新循环结束后执⾏延迟回调，在修改数据之后⽴即使⽤ nextTick 来获取更新后的DOM。</li><li><code>nextTick</code> 对于 micro task 的实现，会先检测是否⽀持 <code>Promise</code> ，不⽀持的话，直接指向 macrotask，⽽ macro task 的实现，优先检测是否⽀持 <code>setImmediate</code> （⾼版本IE和Etage⽀持），不⽀持的再去检测是否⽀持 MessageChannel，如果仍不⽀持，最终降级为 <code>setTimeout</code> 0；</li><li>默认的情况，会先以 micro task ⽅式执⾏，因为 micro task 可以在⼀次 tick 中全部执⾏完毕，在⼀些有重绘和动画的场景有更好的性能。</li><li>但是由于 micro task 优先级较⾼，在某些情况下，可能会在事件冒泡过程中触发，导致⼀些问题，所以有些地⽅会强制使⽤ macro task （如 <code>v-on</code> ）。</li></ul><p><strong>注意</strong>：之所以将 <code>nextTick</code> 的回调函数放⼊到数组中⼀次性执⾏，⽽不是直接在 <code>nextTick</code> 中执⾏回调函数，是为了保证在同⼀个tick内多次执⾏了 <code>nextTcik</code> ，不会开启多个异步任务，⽽是把这些异步任务都压成⼀个同步任务，在下⼀个tick内执⾏完毕。</p><h2 id="19-Vue-的模板编译原理"><a href="#19-Vue-的模板编译原理" class="headerlink" title="19. Vue 的模板编译原理"></a>19. Vue 的模板编译原理</h2><p>vue模板的编译过程分为3个阶段：</p><ul><li>第⼀步：解析</li></ul><p>将模板字符串解析⽣成 AST，⽣成的AST 元素节点总共有 3 种类型，1 为普通元素， 2 为表达式，3为纯⽂本。</p><ul><li>第⼆步：优化语法树</li></ul><p>Vue 模板中并不是所有数据都是响应式的，有很多数据是⾸次渲染后就永远不会变化的，那么这部分数据⽣成的 DOM 也不会变化，我们可以在 patch 的过程跳过对他们的⽐对。</p><p>此阶段会深度遍历⽣成的 AST 树，检测它的每⼀颗⼦树是不是静态节点，如果是静态节点则它们⽣成DOM 永远不需要改变，这对运⾏时对模板的更新起到极⼤的优化作⽤。</p><ol><li>⽣成代码</li></ol><div class="code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">const</span> code = <span class="hljs-keyword">generate</span>(ast, options)复制代码</code></pre></div><p>通过 generate ⽅法，将ast⽣成 render 函数。</p><h2 id="20-你知道Vue3-x响应式数据原理吗？"><a href="#20-你知道Vue3-x响应式数据原理吗？" class="headerlink" title="20. 你知道Vue3.x响应式数据原理吗？"></a>20. 你知道Vue3.x响应式数据原理吗？</h2><p>Vue3.x改⽤ <code>Proxy</code> 替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截⽅法。并且作为新标准将受到浏览器⼚商重点持续的性能优化。</p><blockquote><p>Proxy只会代理对象的第⼀层，那么Vue3⼜是怎样处理这个问题的呢？</p></blockquote><p>判断当前Reflect.get的返回值是否为Object，如果是则再通过 reactive ⽅法做代理， 这样就实现了深度观测。</p><blockquote><p>监测数组的时候可能触发多次get&#x2F;set，那么如何防⽌触发多次呢？</p></blockquote><p>我们可以判断key是否为当前被代理对象target⾃身属性，也可以判断旧值与新值是否相等，只有满⾜以上两个条件之⼀时，才有可能执⾏trigger。</p><h2 id="21-你都做过哪些Vue的性能优化？"><a href="#21-你都做过哪些Vue的性能优化？" class="headerlink" title="21. 你都做过哪些Vue的性能优化？"></a>21. 你都做过哪些Vue的性能优化？</h2><p><strong>编码阶段</strong></p><ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li><li>v-if和v-for不能连⽤</li><li>如果需要使⽤v-for给每项元素绑定事件时使⽤事件代理</li><li>SPA ⻚⾯采⽤keep-alive缓存组件</li><li>在更多的情况下，使⽤v-if替代v-show</li><li>key保证唯⼀</li><li>使⽤路由懒加载、异步组件</li><li>防抖、节流</li><li>第三⽅模块按需导⼊</li><li>⻓列表滚动到可视区域动态加载</li><li>图⽚懒加载</li></ul><p><strong>SEO优化</strong></p><ul><li>预渲染</li><li>服务端渲染SSR</li></ul><p><strong>打包优化</strong></p><ul><li>压缩代码</li><li>Tree Shaking&#x2F;Scope Hoisting</li><li>使⽤cdn加载第三⽅模块</li><li>多线程打包happypack</li><li>splitChunks抽离公共⽂件</li><li>sourceMap优化</li></ul><p><strong>⽤户体验</strong></p><ul><li>骨架屏</li><li>PWA</li></ul><p>还可以使⽤缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</p><h2 id="💐-🌸-🌹-🌻-🌺-🍁"><a href="#💐-🌸-🌹-🌻-🌺-🍁" class="headerlink" title="💐 🌸 🌹 🌻 🌺 🍁"></a>💐 🌸 🌹 🌻 🌺 🍁</h2><p>本次的分享就到这里，如果本章内容对你有所帮助的话可以<strong>点赞+收藏</strong>，希望大家都能够有所收获。有任何疑问都可以在评论区留言，大家一起探讨、进步！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
