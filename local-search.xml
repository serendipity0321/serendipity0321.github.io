<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TypeScript面试题总结</title>
    <link href="/2023/01/23/TypeScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2023/01/23/TypeScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScrip—面试题"><a href="#TypeScrip—面试题" class="headerlink" title="TypeScrip—面试题"></a>TypeScrip—面试题</h1><p>类型 支持ES6新特性 添加ES6不具备的新特性 丰富的配置选项</p><h2 id="什么是-Typescript？"><a href="#什么是-Typescript？" class="headerlink" title="什么是 Typescript？"></a><strong>什么是 Typescript？</strong></h2><p>Typescript 是 Javascript 的超集</p><h2 id="1、-TypeScript-的主要特点是什么？"><a href="#1、-TypeScript-的主要特点是什么？" class="headerlink" title="1、 TypeScript 的主要特点是什么？"></a><strong>1、 TypeScript 的主要特点是什么？</strong></h2><p><strong>跨平台</strong>：TypeScript 编译器可以安装在任何操作系统上，包括 Windows、macOS 和 Linux。</p><p><strong>ES6 特性</strong>：TypeScript 包含计划中的 ECMAScript 2015 (ES6) 的大部分特性，例如箭头函数。</p><p><strong>面向对象的语言</strong>：TypeScript 提供所有标准的 OOP 功能，如类、接口和模块。</p><p><strong>静态类型检查</strong>：TypeScript 使用静态类型并帮助在编译时进行类型检查。因此，你可以在编写代码时发现编译时错误，而无需运行脚本。</p><p><strong>可选的静态类型</strong>：如果你习惯了 JavaScript 的动态类型，TypeScript 还允许可选的静态类型。</p><p><strong>DOM 操作</strong>：您可以使用 TypeScript 来操作 DOM 以添加或删除客户端网页元素。</p><h2 id="2、使用-TypeScript-有什么好处？"><a href="#2、使用-TypeScript-有什么好处？" class="headerlink" title="2、使用 TypeScript 有什么好处？"></a><strong>2、使用 TypeScript 有什么好处？</strong></h2><p>TypeScript 更具表现力，这意味着它的语法混乱更少。</p><p>由于高级调试器专注于在编译时之前捕获逻辑错误，因此调试很容易。</p><p>静态类型使 TypeScript 比 JavaScript 的动态类型更易于阅读和结构化。</p><p>由于通用的转译，它可以跨平台使用，在客户端和服务器端项目中。</p><h2 id="3、TypeScript-的内置数据类型有哪些？"><a href="#3、TypeScript-的内置数据类型有哪些？" class="headerlink" title="3、TypeScript 的内置数据类型有哪些？"></a><strong>3、TypeScript 的内置数据类型有哪些？</strong></h2><p><strong>数字类型</strong>：用于表示数字类型的值。TypeScript 中的所有数字都存储为浮点值。</p><p>let identifier: number &#x3D; value;</p><p><strong>布尔类型</strong>：一个逻辑二进制开关，包含true或false</p><p>let identifier: string &#x3D; “ “;</p><p><strong>Null 类型</strong>：Null 表示值未定义的变量。</p><p>let identifier: bool &#x3D; Boolean value;</p><p><strong>未定义类型</strong>：一个未定义的字面量，它是所有变量的起点。</p><p>let num: number &#x3D; null;、、、、、、、</p><p><strong>void 类型</strong>：分配给没有返回值的方法的类型。</p><p>let unusable: void &#x3D; undefined;</p><h2 id="4、TypeScript-目前的稳定版本是什么？"><a href="#4、TypeScript-目前的稳定版本是什么？" class="headerlink" title="4、TypeScript 目前的稳定版本是什么？"></a><strong>4、TypeScript 目前的稳定版本是什么？</strong></h2><p>当前的稳定版本是 4.2.3。</p><h2 id="5、TypeScript-中的接口是什么？"><a href="#5、TypeScript-中的接口是什么？" class="headerlink" title="5、TypeScript 中的接口是什么？"></a><strong>5、TypeScript 中的接口是什么？</strong></h2><p>接口为使用该接口的对象定义契约或结构。</p><p>接口是用关键字定义的interface，它可以包含使用函数或箭头函数的属性和方法声明。</p><p>interface IEmployee { empCode: number; empName: string; getSalary: (number) &#x3D;&gt; number; &#x2F;&#x2F; arrow function getManagerName(number): string; }</p><h2 id="6、TypeScript-中的模块是什么？"><a href="#6、TypeScript-中的模块是什么？" class="headerlink" title="6、TypeScript 中的模块是什么？"></a><strong>6、TypeScript 中的模块是什么？</strong></h2><p>TypeScript 中的模块是相关变量、函数、类和接口的集合。</p><p>你可以将模块视为包含执行任务所需的一切的容器。可以导入模块以轻松地在项目之间共享代码。</p><p>module module_name{class xyz{export sum(x, y){return x+y;}}</p><h2 id="7、后端如何使用TypeScript？"><a href="#7、后端如何使用TypeScript？" class="headerlink" title="7、后端如何使用TypeScript？"></a><strong>7、后端如何使用TypeScript？</strong></h2><p>你可以将 Node.js 与 TypeScript 结合使用，将 TypeScript 的优势带入后端工作。</p><p>只需输入以下命令，即可将 TypeScript 编译器安装到你的 Node.js 中：</p><p>npm i -g typescript  &#x2F;&#x2F;全局安装</p><h2 id="8、TypeScript-中的类型断言是什么？"><a href="#8、TypeScript-中的类型断言是什么？" class="headerlink" title="8、TypeScript 中的类型断言是什么？"></a><strong>8、TypeScript 中的类型断言是什么？</strong></h2><p>TypeScript 中的类型断言的工作方式类似于其他语言中的类型转换，但没有 C# 和 Java 等语言中可能的类型检查或数据重组。类型断言对运行时没有影响，仅由编译器使用。</p><p>类型断言本质上是类型转换的软版本，它建议编译器将变量视为某种类型，但如果它处于不同的形式，则不会强制它进入该模型。</p><h2 id="9、如何在-TypeScript-中创建变量？"><a href="#9、如何在-TypeScript-中创建变量？" class="headerlink" title="9、如何在 TypeScript 中创建变量？"></a><strong>9、如何在 TypeScript 中创建变量？</strong></h2><p>你可以通过三种方式创建变量：var，let，和const。</p><p>var是严格范围变量的旧风格。你应该尽可能避免使用，var因为它会在较大的项目中导致问题。</p><p>var num:number &#x3D; 1;</p><p>let是在 TypeScript 中声明变量的默认方式。与var相比，let减少了编译时错误的数量并提高了代码的可读性。</p><p>let num:number &#x3D; 1;</p><p>const创建一个其值不能改变的常量变量。它使用相同的范围规则，let并有助于降低整体程序的复杂性。</p><p>const num:number &#x3D; 100;</p><h2 id="10、在TypeScript中如何从子类调用基类构造函数？"><a href="#10、在TypeScript中如何从子类调用基类构造函数？" class="headerlink" title="10、在TypeScript中如何从子类调用基类构造函数？"></a><strong>10、在TypeScript中如何从子类调用基类构造函数？</strong></h2><p>你可以使用该super()函数来调用基类的构造函数。</p><p>class Animal { name: string; constructor(theName: string) { this.name &#x3D; theName; } move(distanceInMeters: number &#x3D; 0) { console.log(<code>$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.</code>); }}class Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters &#x3D; 5) { console.log(“Slithering…”); super.move(distanceInMeters); }}</p><h2 id="11、解释如何使用-TypeScript-mixin。"><a href="#11、解释如何使用-TypeScript-mixin。" class="headerlink" title="11、解释如何使用 TypeScript mixin。"></a><strong>11、解释如何使用 TypeScript mixin。</strong></h2><p>Mixin 本质上是在相反方向上工作的继承。Mixins 允许你通过组合以前类中更简单的部分类设置来构建新类。</p><p>相反，类A继承类B来获得它的功能，类B从类A需要返回一个新类的附加功能。</p><h2 id="12、TypeScript-中如何检查-null-和-undefined？"><a href="#12、TypeScript-中如何检查-null-和-undefined？" class="headerlink" title="12、TypeScript 中如何检查 null 和 undefined？"></a><strong>12、TypeScript 中如何检查 null 和 undefined？</strong></h2><p>你可以使用 juggle-check，它检查 null 和 undefined，或者使用 strict-check，它返回true设置为null的值，并且不会评估true未定义的变量。</p><p>&#x2F;&#x2F;juggleif (x &#x3D;&#x3D; null) { }</p><p>var a: number; var b: number &#x3D; null; function check(x, name) { if (x &#x3D;&#x3D; null) { console.log(name + ‘ &#x3D;&#x3D; null’); } if (x &#x3D;&#x3D;&#x3D; null) { console.log(name + ‘ &#x3D;&#x3D;&#x3D; null’); } if (typeof x &#x3D;&#x3D;&#x3D; ‘undefined’) { console.log(name + ‘ is undefined’); } } check(a, ‘a’); check(b, ‘b’);</p><h2 id="13、TypeScript-中的-getter-x2F-setter-是什么？你如何使用它们？"><a href="#13、TypeScript-中的-getter-x2F-setter-是什么？你如何使用它们？" class="headerlink" title="13、TypeScript 中的 getter&#x2F;setter 是什么？你如何使用它们？"></a><strong>13、TypeScript 中的 getter&#x2F;setter 是什么？你如何使用它们？</strong></h2><p>Getter 和 setter 是特殊类型的方法，可帮助你根据程序的需要委派对私有变量的不同级别的访问。</p><p>Getters 允许你引用一个值但不能编辑它。Setter 允许你更改变量的值，但不能查看其当前值。这些对于实现封装是必不可少的。</p><p>例如，新雇主可能能够了解get公司的员工人数，但无权set了解员工人数。</p><p>const fullNameMaxLength &#x3D; 10;class Employee { private _fullName: string &#x3D; “”; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (newName &amp;&amp; newName.length &gt; fullNameMaxLength) { throw new Error(“fullName has a max length of “ + fullNameMaxLength); } this._fullName &#x3D; newName; }}let employee &#x3D; new Employee();employee.fullName &#x3D; “Bob Smith”;if (employee.fullName) { console.log(employee.fullName);}</p><h2 id="14、-如何允许模块外定义的类可以访问？"><a href="#14、-如何允许模块外定义的类可以访问？" class="headerlink" title="14、 如何允许模块外定义的类可以访问？"></a><strong>14、 如何允许模块外定义的类可以访问？</strong></h2><p>你可以使用export关键字打开模块以供在模块外使用。</p><p>module Admin { &#x2F;&#x2F; use the export keyword in TypeScript to access the class outside export class Employee { constructor(name: string, email: string) { } } let alex &#x3D; new Employee(‘alex’, ‘<a href="mailto:&#x61;&#108;&#x65;&#120;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;">&#x61;&#108;&#x65;&#120;&#64;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;</a>‘);}&#x2F;&#x2F; The Admin variable will allow you to access the Employee class outside the module with the help of the export keyword in TypeScriptlet nick &#x3D; new Admin.Employee(‘nick’, ‘<a href="mailto:&#110;&#x69;&#99;&#107;&#x40;&#121;&#x61;&#x68;&#111;&#111;&#x2e;&#99;&#111;&#x6d;">&#110;&#x69;&#99;&#107;&#x40;&#121;&#x61;&#x68;&#111;&#111;&#x2e;&#99;&#111;&#x6d;</a>‘);</p><h2 id="15、如何使用-Typescript-将字符串转换为数字？"><a href="#15、如何使用-Typescript-将字符串转换为数字？" class="headerlink" title="15、如何使用 Typescript 将字符串转换为数字？"></a><strong>15、如何使用 Typescript 将字符串转换为数字？</strong></h2><p>与 JavaScript 类似，你可以使用parseInt或parseFloat函数分别将字符串转换为整数或浮点数。你还可以使用一元运算符+将字符串转换为最合适的数字类型，“3”成为整数，3而“3.14”成为浮点数3.14。</p><p>var x &#x3D; “32”;var y: number &#x3D; +x;</p><h2 id="16、什么是-map-文件，为什么-x2F-如何使用它？"><a href="#16、什么是-map-文件，为什么-x2F-如何使用它？" class="headerlink" title="16、什么是 .map 文件，为什么&#x2F;如何使用它？"></a><strong>16、什么是 .map 文件，为什么&#x2F;如何使用它？</strong></h2><p>甲.map文件是源地图，显示原始打字稿代码是如何解释成可用的JavaScript代码。它们有助于简化调试，因为你可以捕获任何奇怪的编译器行为。</p><p>调试工具还可以使用这些文件来允许你编辑底层的 TypeScript 而不是发出的 JavaScript 文件。</p><h2 id="17、TypeScript-中的类是什么？你如何定义它们？"><a href="#17、TypeScript-中的类是什么？你如何定义它们？" class="headerlink" title="17、TypeScript 中的类是什么？你如何定义它们？"></a><strong>17、TypeScript 中的类是什么？你如何定义它们？</strong></h2><p>类表示一组相关对象的共享行为和属性。</p><p>例如，我们的类可能是Student，其所有对象都具有该attendClass方法。另一方面，John是一个单独的 type 实例，Student可能有额外的独特行为，比如attendExtracurricular.</p><p>你使用关键字声明类class：</p><p>class Student { studCode: number; studName: string; constructor(code: number, name: string) { this.studName &#x3D; name; this.studCode &#x3D; code; }</p><h2 id="18、TypeScript-与-JavaScript-有什么关系？"><a href="#18、TypeScript-与-JavaScript-有什么关系？" class="headerlink" title="18、TypeScript 与 JavaScript 有什么关系？"></a><strong>18、TypeScript 与 JavaScript 有什么关系？</strong></h2><p>TypeScript 是 JavaScript 的开源语法超集，可编译为 JavaScript。所有原始 JavaScript 库和语法仍然有效，但 TypeScript 增加了 JavaScript 中没有的额外语法选项和编译器功能。</p><p>TypeScript 还可以与大多数与 JavaScript 相同的技术接口，例如 Angular 和 jQuery。</p><h2 id="19、TypeScript-中的-JSX-是什么？"><a href="#19、TypeScript-中的-JSX-是什么？" class="headerlink" title="19、TypeScript 中的 JSX 是什么？"></a><strong>19、TypeScript 中的 JSX 是什么？</strong></h2><p>JSX 是一种可嵌入的类似于 XML 的语法，允许你创建 HTML。TypeScript 支持嵌入、类型检查和将 JSX 直接编译为 JavaScript。</p><h2 id="20、TypeScript-支持哪些-JSX-模式？"><a href="#20、TypeScript-支持哪些-JSX-模式？" class="headerlink" title="20、TypeScript 支持哪些 JSX 模式？"></a><strong>20、TypeScript 支持哪些 JSX 模式？</strong></h2><p>TypeScript有内置的支持preserve，react和react-native。</p><p>preserve 保持 JSX 完整以用于后续转换。</p><p>react不经过 JSX 转换，而是react.createElement作为.js文件扩展名发出和输出。</p><p>react-native结合起来preserve，react因为它维护所有 JSX 和输出作为.js扩展。</p><h2 id="21、如何编译-TypeScript-文件？"><a href="#21、如何编译-TypeScript-文件？" class="headerlink" title="21、如何编译 TypeScript 文件？"></a><strong>21、如何编译 TypeScript 文件？</strong></h2><p>你需要调用 TypeScript 编译器tsc来编译文件。你需要安装 TypeScript 编译器，你可以使用npm.</p><p>npm install -g typescripttsc <TypeScript File Name></p><h2 id="22、-TypeScript-中有哪些范围可用？这与JS相比如何？"><a href="#22、-TypeScript-中有哪些范围可用？这与JS相比如何？" class="headerlink" title="22、 TypeScript 中有哪些范围可用？这与JS相比如何？"></a><strong>22、 TypeScript 中有哪些范围可用？这与JS相比如何？</strong></h2><p>全局作用域：在任何类之外定义，可以在程序中的任何地方使用。</p><p>函数&#x2F;类范围：在函数或类中定义的变量可以在该范围内的任何地方使用。</p><p>局部作用域&#x2F;代码块：在局部作用域中定义的变量可以在该块中的任何地方使用。</p><h2 id="23、TypeScript-中的箭头-x2F-lambda-函数是什么？"><a href="#23、TypeScript-中的箭头-x2F-lambda-函数是什么？" class="headerlink" title="23、TypeScript 中的箭头&#x2F;lambda 函数是什么？"></a><strong>23、TypeScript 中的箭头&#x2F;lambda 函数是什么？</strong></h2><p>胖箭头函数是用于定义匿名函数的函数表达式的速记语法。它类似于其他语言中的 lambda 函数。箭头函数可让你跳过function关键字并编写更简洁的代码。</p><h2 id="24、解释rest参数和声明rest参数的规则。"><a href="#24、解释rest参数和声明rest参数的规则。" class="headerlink" title="24、解释rest参数和声明rest参数的规则。"></a><strong>24、解释rest参数和声明rest参数的规则。</strong></h2><p>其余参数允许你将不同数量的参数（零个或多个）传递给函数。当你不确定函数将接收多少参数时，这很有用。其余符号之后的所有参数…都将存储在一个数组中。</p><p>例如：</p><p>function Greet(greeting: string, …names: string[]) { return greeting + “ “ + names.join(“, “) + “!”;}Greet(“Hello”, “Steve”, “Bill”); &#x2F;&#x2F; returns “Hello Steve, Bill!”Greet(“Hello”);&#x2F;&#x2F; returns “Hello !”</p><p>rest 参数必须是参数定义的最后一个，并且每个函数只能有一个 rest 参数。</p><h2 id="25、什么是三斜线指令？有哪些三斜杠指令？"><a href="#25、什么是三斜线指令？有哪些三斜杠指令？" class="headerlink" title="25、什么是三斜线指令？有哪些三斜杠指令？"></a><strong>25、什么是三斜线指令？有哪些三斜杠指令？</strong></h2><p>三斜线指令是单行注释，包含用作编译器指令的 XML 标记。每个指令都表示在编译过程中要加载的内容。三斜杠指令仅在其文件的顶部工作，并且将被视为文件中其他任何地方的普通注释。</p><p>&#x2F;&#x2F;&#x2F; <reference path="..." /> 是最常见的指令，定义文件之间的依赖关系。</p><p>&#x2F;&#x2F;&#x2F; <reference types="..." />类似于path但定义了包的依赖项。</p><p>&#x2F;&#x2F;&#x2F; <reference lib="..." />允许您显式包含内置lib文件。</p><h2 id="26、Omit类型有什么作用？"><a href="#26、Omit类型有什么作用？" class="headerlink" title="26、Omit类型有什么作用？"></a><strong>26、Omit类型有什么作用？</strong></h2><p>Omit是实用程序类型的一种形式，它促进了常见的类型转换。Omit允许你通过传递电流Type并选择Keys在新类型中省略来构造类型。</p><p>Omit&lt;Type, Keys&gt;</p><p>例如：</p><p>interface Todo { title: string; description: string; completed: boolean; createdAt: number;}type TodoPreview &#x3D; Omit&lt;Todo, “description”&gt;;</p><h2 id="27、TypeScript中如何实现函数重载？"><a href="#27、TypeScript中如何实现函数重载？" class="headerlink" title="27、TypeScript中如何实现函数重载？"></a><strong>27、TypeScript中如何实现函数重载？</strong></h2><p>要在 TypeScript 中重载函数，只需创建两个名称相同但参数&#x2F;返回类型不同的函数。两个函数必须接受相同数量的参数。这是 TypeScript 中多态性的重要组成部分。</p><p>例如，你可以创建一个add函数，如果它们是数字，则将两个参数相加，如果它们是字符串，则将它们连接起来。</p><p>function add(a:string, b:string):string;function add(a:number, b:number): number;function add(a: any, b:any): any { return a + b;}add(“Hello “, “Steve”); &#x2F;&#x2F; returns “Hello Steve” add(10, 20); &#x2F;&#x2F; returns 30</p><h2 id="28、如何让接口的所有属性都可选？"><a href="#28、如何让接口的所有属性都可选？" class="headerlink" title="28、如何让接口的所有属性都可选？"></a><strong>28、如何让接口的所有属性都可选？</strong></h2><p>你可以使用partial映射类型轻松地将所有属性设为可选。</p><h2 id="29、什么时候应该使用关键字unknown？"><a href="#29、什么时候应该使用关键字unknown？" class="headerlink" title="29、什么时候应该使用关键字unknown？"></a><strong>29、什么时候应该使用关键字unknown？</strong></h2><p>unknown，如果你不知道预先期望哪种类型，但想稍后分配它，则应该使用该any关键字，并且该关键字将不起作用。</p><h2 id="30、什么是装饰器，它们可以应用于什么？"><a href="#30、什么是装饰器，它们可以应用于什么？" class="headerlink" title="30、什么是装饰器，它们可以应用于什么？"></a><strong>30、什么是装饰器，它们可以应用于什么？</strong></h2><p>装饰器是一种特殊的声明，它允许你通过使用@<name>注释标记来一次性修改类或类成员。每个装饰器都必须引用一个将在运行时评估的函数。</p><p>例如，装饰器@sealed将对应于sealed函数。任何标有 的@sealed都将用于评估sealed函数。</p><p>function sealed(target) { &#x2F;&#x2F; do something with ‘target’ …}</p><p>它们可以附加到：</p><p>类声明</p><p>方法</p><p>配件</p><p>特性</p><p>参数</p>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解ES6</title>
    <link href="/2023/01/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/"/>
    <url>/2023/01/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/</url>
    
    <content type="html"><![CDATA[<h3 id="ECMAScript简介"><a href="#ECMAScript简介" class="headerlink" title="ECMAScript简介"></a>ECMAScript简介</h3><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><p>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和ActionScript），日常场合，这两个词是可以互换的。</p><h3 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>ES6 新增了<code>let</code>和<code>const</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>和<code>const</code>命令所在的代码块内有效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> j=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> k=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>var：存在变量提升，可以在声明前使用，值为<code>undefined</code>。</p><p>let：存在块级作用域，声明的变量一定要在声明过后使用，不然会报错，不可重复声明。</p><p>const：常量的值不能改变。，不可重复声明</p><p>ES5 只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6 除了添加<code>let</code>和<code>const</code>命令，还有另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6 一共有 6 种声明变量的方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3的组合式API详解</title>
    <link href="/2023/01/23/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/01/23/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install <br></code></pre></td></tr></table></figure><p>文档地址：<a href="https://cn.vuejs.org/api/">API 参考 | Vue.js (vuejs.org)</a></p><p>Vue3 组合式 API（Composition API） 主要用于在大型组件中提高代码逻辑的可复用性。</p><p>传统的组件随着业务复杂度越来越高，代码量会不断的加大，整个代码逻辑都不易阅读和理解。</p><p>Vue3 使用组合式 API 的代码地方为 setup。</p><p>在 setup 中，我们可以按逻辑关注点对部分代码进行分组，然后提取逻辑片段并与其他组件共享代码。因此，组合式 API（Composition API）允许我们编写更有条理的代码。</p><p>vue3 API主要包含以下六个部分：</p><ol><li>全局API —— 全局会用到的API</li><li>组合式API —— vue3所拥有的组合式API</li><li>选项式API —— vue2所拥有的选项式API</li><li>内置内容 —— 指令、组件、特殊元素和特殊属性</li><li>单文件组件 —— 语法定义</li><li>进阶API —— 渲染函数、服务端渲染、TS工具类型和自定义渲染</li></ol><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/1.png"></p><h1 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h1><p>Vue3的全局API包含两个部分：应用实例和通用API。</p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/3.jpg"></p><h2 id="通用API"><a href="#通用API" class="headerlink" title="通用API"></a>通用API</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/4.png"></p><h1 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h1><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/5.png"></p><h2 id="响应式：核心"><a href="#响应式：核心" class="headerlink" title="响应式：核心"></a>响应式：核心</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/5.png"></p><h2 id="响应式：工具函数"><a href="#响应式：工具函数" class="headerlink" title="响应式：工具函数"></a>响应式：工具函数</h2><p>![]222222</p><h2 id="响应式：进阶"><a href="#响应式：进阶" class="headerlink" title="响应式：进阶"></a>响应式：进阶</h2><p>![22222</p><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><p>![22222</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/5.png"></p><h1 id="选项式API"><a href="#选项式API" class="headerlink" title="选项式API"></a>选项式API</h1><h2 id="状态选项"><a href="#状态选项" class="headerlink" title="状态选项"></a>状态选项</h2><p>111</p><h2 id="渲染选项"><a href="#渲染选项" class="headerlink" title="渲染选项"></a>渲染选项</h2><p>1111</p><h2 id="生命周期选项"><a href="#生命周期选项" class="headerlink" title="生命周期选项"></a>生命周期选项</h2><p>11111</p><h2 id="组合选项"><a href="#组合选项" class="headerlink" title="组合选项"></a>组合选项</h2><p>!1111</p><h2 id="其他杂项"><a href="#其他杂项" class="headerlink" title="其他杂项"></a>其他杂项</h2><p>111</p><h2 id="组件实例"><a href="#组件实例" class="headerlink" title="组件实例"></a>组件实例</h2><p>!11111</p><h1 id="内置内容"><a href="#内置内容" class="headerlink" title="内置内容"></a>内置内容</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>!11111</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>!1111</p><h2 id="特殊元素"><a href="#特殊元素" class="headerlink" title="特殊元素"></a>特殊元素</h2><p>!11111</p><h2 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h2><p>![](111111</p><h1 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h1><h2 id="SFC语法定义"><a href="#SFC语法定义" class="headerlink" title="SFC语法定义"></a>SFC语法定义</h2><p>![]1111</p><h2 id="单文件组件script-setup"><a href="#单文件组件script-setup" class="headerlink" title="单文件组件script setup"></a>单文件组件script setup</h2><p>![111111</p><h2 id="css功能"><a href="#css功能" class="headerlink" title="css功能"></a>css功能</h2><p>1111</p><h1 id="进阶API"><a href="#进阶API" class="headerlink" title="进阶API"></a>进阶API</h1><h2 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h2><p>1111</p><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>1111</p><h2 id="TypeScript工具类型"><a href="#TypeScript工具类型" class="headerlink" title="TypeScript工具类型"></a>TypeScript工具类型</h2><p>1111</p><h2 id="自定义渲染"><a href="#自定义渲染" class="headerlink" title="自定义渲染"></a>自定义渲染</h2><p>1111</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对包依赖管理工具的了解</title>
    <link href="/2023/01/23/%E5%AF%B9%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
    <url>/2023/01/23/%E5%AF%B9%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>npm</tag>
      
      <tag>yarn</tag>
      
      <tag>pnpm</tag>
      
      <tag>cnpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS面试记录</title>
    <link href="/2023/01/22/CSS%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/22/CSS%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML面试记录</title>
    <link href="/2023/01/22/HTML%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/22/HTML%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo创建博客</title>
    <link href="/2023/01/22/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/01/22/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo部署博客的命令"><a href="#hexo部署博客的命令" class="headerlink" title="hexo部署博客的命令"></a>hexo部署博客的命令</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
