<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>巩固基础CSS知识点</title>
    <link href="/2023/01/29/%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80CSS%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2023/01/29/%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80CSS%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>文中篇概念性的内容也蛮多，小编一如既往的做了分割线，记忆力好的童鞋请自行忽略。</p><hr><h3 id="1-🤨标准的CSS盒子模型及其和低版本的IE盒子模型的区别？"><a href="#1-🤨标准的CSS盒子模型及其和低版本的IE盒子模型的区别？" class="headerlink" title="1.🤨标准的CSS盒子模型及其和低版本的IE盒子模型的区别？"></a>1.🤨标准的CSS盒子模型及其和低版本的IE盒子模型的区别？</h3><p>标准（W3C）盒子模型：<code>width</code> &#x3D; 内容宽度<code>（content） + border + padding + margin</code></p><p>低版本IE盒子模型： <code>width</code> &#x3D; 内容宽度<code>（content + border + padding）+ margin</code></p><p>图片展示:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/30/172633c783abc1eb~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/30/17263443113eb879~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><p>区别： 标准盒子模型盒子的<code>height</code>和<code>width</code>是<code>content</code>（内容）的宽高，而IE盒子模型盒子的宽高则包括<code>content+padding+border</code>部分。</p><h3 id="2-几种解决IE6存在的bug的方法"><a href="#2-几种解决IE6存在的bug的方法" class="headerlink" title="2.几种解决IE6存在的bug的方法"></a>2.几种解决IE6存在的bug的方法</h3><ul><li>由<code>float</code>引起的双边距的问题，使用<code>display</code>解决；</li><li>由<code>float</code>引起的3像素问题，使用<code>display: inline -3px</code>;</li><li>使用正确的书写顺序<code>link visited hover active</code>，解决超链接<code>hover</code>点击失效问题；</li><li>对于<code>IE</code> 的<code>z-index</code>问题，通过给父元素增加<code>position: relative</code>解决；</li><li>使用<code>!important</code>解决<code>Min-height</code>最小高度问题；</li><li>使用<code>iframe</code>解决<code>select</code>在<code>IE6</code>下的覆盖问题；</li><li>使用<code>over: hidden</code>, <code>zoom: 0.08</code>, <code>line-height: 1px</code>解决定义1px左右的容器宽度问题；</li></ul><p>🍀<strong>注意</strong>：有关<code>IE6</code>支不支持<code>!important</code>的问题，对于单个类是支持的。例如：</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-class">.content</span> &#123; <span class="hljs-attribute">color</span>: pink !importent &#125;;<span class="hljs-selector-class">.content</span> &#123; <span class="hljs-attribute">color</span>: orange &#125;;<span class="hljs-comment">// 这里IE6及以上，FF，google等都将显示粉红色</span>复制代码</code></pre></div><p>但是，当一个样式内部有多个相同属性的时候。例如：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.content</span> &#123; <span class="hljs-attribute">color</span>: pink !importent; <span class="hljs-attribute">color</span>: orange &#125;;// IE7及以上，FF, google显示粉红色，而IE6将显示橙色（原因是一个样式内重复设置了属性，后面的就会覆盖掉之前的）复制代码</code></pre></div><h3 id="3-CSS选择符有哪些？哪些属性可以继承？"><a href="#3-CSS选择符有哪些？哪些属性可以继承？" class="headerlink" title="3.CSS选择符有哪些？哪些属性可以继承？"></a>3.CSS选择符有哪些？哪些属性可以继承？</h3><p>常见的选择符有一下：</p><p><code>id</code>选择器（<code>#content</code>），类选择器（<code>.content</code>）, 标签选择器（<code>div</code>, <code>p</code>, <code>span</code>等）, 相邻选择器（<code>h1+p</code>）, 子选择器（<code>ul&gt;li</code>）, 后代选择器（<code>li a</code>）， 通配符选择器（<code>*</code>）, 属性选择器（<code>a[rel = &quot;external&quot;]</code>）， 伪类选择器（<code>a:hover</code>, <code>li:nth-child</code>）</p><p>可继承的样式属性： <code>font-size</code>, <code>font-family</code>, <code>color</code>, <code>ul</code>, <code>li</code>, <code>dl</code>, <code>dd</code>, <code>dt</code>;</p><p>不可继承的样式属性： <code>border</code>, <code>padding</code>, <code>margin</code>, <code>width</code>, <code>height</code>；</p><h3 id="4-CSS优先级算法如何计算？"><a href="#4-CSS优先级算法如何计算？" class="headerlink" title="4.CSS优先级算法如何计算？"></a>4.CSS优先级算法如何计算？</h3><ul><li>考虑到就近原则，同权重情况下样式定义以最近者为准</li><li>载入的样式按照最后的定位为准</li></ul><p>优先级排序：</p><p>同权重情况下： 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）</p><p><code>!important &gt; # &gt; . &gt; tag</code></p><p>🍀<strong>注意</strong>： <code>!important</code> 比 内联优先级高</p><h3 id="5-CSS3新增伪类有那些？"><a href="#5-CSS3新增伪类有那些？" class="headerlink" title="5.CSS3新增伪类有那些？"></a>5.CSS3新增伪类有那些？</h3><ul><li><p><code>:root</code> 选择文档的根元素，等同于<code>html</code>元素</p></li><li><p><code>:empty</code> 选择没有子元素的元素</p></li><li><p><code>:target</code> 选取当前活动的目标元素</p></li><li><p><code>:not(selector)</code> 选择除 <code>selector</code> 元素意外的元素</p></li><li><p><code>:enabled</code> 选择可用的表单元素</p></li><li><p><code>:disabled</code> 选择禁用的表单元素</p></li><li><p><code>:checked</code> 选择被选中的表单元素</p></li><li><p><code>:nth-child(n)</code> 匹配父元素下指定子元素，在所有子元素中排序第<code>n</code></p></li><li><p><code>nth-last-child(n)</code> 匹配父元素下指定子元素，在所有子元素中排序第<code>n</code>，从后向前数</p></li><li><p><code>:nth-child(odd)</code></p></li><li><p><code>:nth-child(even)</code></p></li><li><p><code>:nth-child(3n+1)</code></p></li><li><p><code>:first-child</code></p></li><li><p><code>:last-child</code></p></li><li><p><code>:only-child</code></p></li><li><p><code>:nth-of-type(n)</code> 匹配父元素下指定子元素，在同类子元素中排序第<code>n</code></p></li><li><p><code>:nth-last-of-type(n)</code> 匹配父元素下指定子元素，在同类子元素中排序第<code>n</code>，从后向前数</p></li><li><p><code>:nth-of-type(odd)</code></p></li><li><p><code>:nth-of-type(even)</code></p></li><li><p><code>:nth-of-type(3n+1)</code></p></li><li><p><code>:first-of-type</code></p></li><li><p><code>:last-of-type</code></p></li><li><p><code>:only-of-type</code></p></li><li><p><code>::selection</code> 选择被用户选取的元素部分（伪元素）</p></li><li><p><code>:first-line</code> 选择元素中的第一行（伪元素）</p></li><li><p><code>:first-letter</code> 选择元素中的第一个字符（伪元素）</p></li><li><p><code>:after</code> 在元素在该元素之后添加内容（伪元素）</p></li><li><p><code>:before</code> 在元素在该元素之前添加内容（伪元素）</p></li></ul><h3 id="6-如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"><a href="#6-如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？" class="headerlink" title="6.如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"></a>6.如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</h3><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><div class="code-wrapper"><pre><code class="hljs css">// 方式<span class="hljs-number">1</span>： 使用<span class="hljs-attribute">margin</span>： <span class="hljs-number">0</span> auto居中css:     * &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">background</span>: pink;    &#125;// 方式<span class="hljs-number">2</span>： 使用 定位 + <span class="hljs-attribute">left</span> 居中css:     * &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;    <span class="hljs-selector-class">.content</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">background</span>: pink;        <span class="hljs-attribute">position</span>: absolute;        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);    &#125;    <span class="hljs-selector-tag">html</span>:   &lt;div class=<span class="hljs-string">&quot;content&quot;</span>&gt;&lt;/div&gt;复制代码</code></pre></div><h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><div class="code-wrapper"><pre><code class="hljs css">    <span class="hljs-number">1</span>.已知父元素高度情况下方法<span class="hljs-number">1</span>：css:     * &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;    <span class="hljs-selector-class">.content</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">600px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;    &#125;    <span class="hljs-selector-class">.content-one</span> &#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">background</span>: pink;        <span class="hljs-attribute">position</span>: relative;    // 父元素无定位，子元素直接用相对定位        <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">50%</span>);    &#125;<span class="hljs-selector-tag">html</span>:     &lt;div class=<span class="hljs-string">&quot;content&quot;</span>&gt;       &lt;div class=<span class="hljs-string">&quot;content-one&quot;</span>&gt;&lt;/div&gt;    &lt;/div&gt;方法<span class="hljs-number">2</span>：css: * &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.content</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">600px</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;    <span class="hljs-attribute">position</span>: relative;     // 给父元素定位，子绝父相&#125;<span class="hljs-selector-class">.content-one</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;    <span class="hljs-attribute">background</span>: pink;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">50%</span>);&#125;<span class="hljs-selector-tag">html</span>:     &lt;div class=<span class="hljs-string">&quot;content&quot;</span>&gt;       &lt;div class=<span class="hljs-string">&quot;content-one&quot;</span>&gt;&lt;/div&gt;    &lt;/div&gt;复制代码</code></pre></div><h4 id="如何让绝对定位的div居中"><a href="#如何让绝对定位的div居中" class="headerlink" title="如何让绝对定位的div居中"></a>如何让绝对定位的div居中</h4><div class="code-wrapper"><pre><code class="hljs css">css:     * &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;        <span class="hljs-attribute">position</span>: absolute;        <span class="hljs-attribute">width</span>: <span class="hljs-number">1500px</span>;        <span class="hljs-attribute">background</span>: pink;        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;    &#125;<span class="hljs-selector-tag">html</span>:     &lt;div class=<span class="hljs-string">&quot;content&quot;</span>&gt;&lt;/div&gt;复制代码</code></pre></div><h3 id="7-display有哪些值？他们的作用是什么？"><a href="#7-display有哪些值？他们的作用是什么？" class="headerlink" title="7.display有哪些值？他们的作用是什么？"></a>7.display有哪些值？他们的作用是什么？</h3><table><thead><tr><th>值</th><th>作用</th></tr></thead><tbody><tr><td>none</td><td>使用后元素将不会显示</td></tr><tr><td>grid</td><td>定义一个容器属性为网格布局</td></tr><tr><td>flex</td><td>定义一个弹性布局</td></tr><tr><td>block</td><td>使用后元素将变为块级元素显示，元素前后带有换行符</td></tr><tr><td>inline</td><td>display默认值。使用后原色变为行内元素显示，前后无换行符</td></tr><tr><td>list-item</td><td>使用后元素作为列表显示</td></tr><tr><td>run-in</td><td>使用后元素会根据上下文作为块级元素或行内元素显示</td></tr><tr><td>table</td><td>使用后将作为块级表格来显示（类似<code>&lt;table&gt;</code>），前后带有换行符</td></tr><tr><td>inline-table</td><td>使用后元素将作为内联表格显示（类似<code>&lt;table&gt;</code>），前后没有换行符</td></tr><tr><td>table-row-group</td><td>元素将作为一个或多个行的分组来显示（类似<code>&lt;tbody&gt;</code>）</td></tr><tr><td>table-hewder-group</td><td>元素将作为一个或多个行的分组来表示（类似<code>&lt;thead&gt;</code>）</td></tr><tr><td>table-footer-group</td><td>元素将作为一个或多个行分组显示（类似<code>&lt;tfoot&gt;</code>）</td></tr><tr><td>table-row</td><td>元素将作为一个表格行显示（类似<code>&lt;tr&gt;</code>）</td></tr><tr><td>table-column-group</td><td>元素将作为一个或多个列的分组显示（类似<code>&lt;colgroup&gt;</code>）</td></tr><tr><td>table-column</td><td>元素将作为一个单元格列显示（类似<code>&lt;col&gt;</code>）</td></tr><tr><td>table-cell</td><td>元素将作为一个表格单元格显示（类似<code>&lt;td&gt;和&lt;th&gt;</code>）</td></tr><tr><td>table-caption</td><td>元素将作为一个表格标题显示（类似<code>&lt;caption&gt;</code>）</td></tr><tr><td>inherit</td><td>规定应该从父元素集成display属性的值</td></tr></tbody></table><p>其中，常用的有：<code>block</code>， <code>inline-block</code>， <code>none</code>， <code>table</code>， <code>line</code>。</p><h3 id="8-position的值relative和absolute定位原点？"><a href="#8-position的值relative和absolute定位原点？" class="headerlink" title="8.position的值relative和absolute定位原点？"></a>8.position的值relative和absolute定位原点？</h3><p>首先，使用<code>position</code>的时候，应该记住一个规律是‘<strong>子绝父相</strong>’。</p><p><code>relative</code>（相对定位）： 生成相对定位的元素，定位原点是元素本身所在的位置；</p><p><code>absolute</code>（绝对定位）：生成绝对定位的元素，定位原点是离自己这一级元素最近的一级<code>position</code>设置为<code>absolute</code>或者<code>relative</code>的父元素的左上角为原点的。</p><p><code>fixed</code> （老IE不支持）：生成绝对定位的元素，相对于浏览器窗口进行定位。</p><p><code>static</code>：默认值。没有定位，元素出现在正常的流中（忽略 <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>、<code>z-index</code> 声明）。</p><p><code>inherit</code>：规定从父元素继承 <code>position</code> 属性的值。</p><p><strong>更新一个属性</strong></p><p><code>sticky</code>: (新增元素，目前兼容性可能不是那么的好)，可以设置 position:sticky 同时给一个 (top,bottom,right,left) 之一即可。</p><p><strong>注意</strong>：</p><ul><li>使用<code>sticky</code>时，必须指定top、bottom、left、right4个值之一，不然只会处于相对定位；</li><li><code>sticky</code>只在其父元素内其效果，且保证父元素的高度要高于<code>sticky</code>的高度；</li><li>父元素不能<code>overflow:hidden</code>或者<code>overflow:auto</code>等属性。</li></ul><h3 id="9-CSS3有哪些新特性？"><a href="#9-CSS3有哪些新特性？" class="headerlink" title="9.CSS3有哪些新特性？"></a>9.CSS3有哪些新特性？</h3><p>关于<code>CSS</code>新增的特性，有以下：</p><ul><li>选择器;</li><li>圆角<code>（border-raduis）</code>;</li><li>多列布局<code>（multi-column layout）</code>;</li><li>阴影<code>（shadow）</code>和反射<code>（reflect）</code>;</li><li>文字特效<code>（text-shadow）</code>;</li><li>文字渲染<code>（text-decoration</code>）;</li><li>线性渐变<code>（gradient）</code>;</li><li>旋转<code>（rotate</code>）&#x2F;缩放<code>（scale）</code>&#x2F;倾斜<code>（skew）</code>&#x2F;移动<code>（translate）</code>;</li><li>媒体查询<code>（@media）</code>;</li><li><code>RGBA</code>和透明度 ;</li><li><code>@font-face</code>属性;</li><li>多背景图 ;</li><li>盒子大小;</li><li>语音;</li></ul><p>大致想到这么多，有遗漏的可以留言指出，小编看到会加上。</p><h3 id="10-用纯CSS创建一个三角形的原理是什么？"><a href="#10-用纯CSS创建一个三角形的原理是什么？" class="headerlink" title="10.用纯CSS创建一个三角形的原理是什么？"></a>10.用纯CSS创建一个三角形的原理是什么？</h3><h4 id="方法一：隐藏上，左，右三条边，颜色设定为（transparent）"><a href="#方法一：隐藏上，左，右三条边，颜色设定为（transparent）" class="headerlink" title="方法一：隐藏上，左，右三条边，颜色设定为（transparent）"></a>方法一：隐藏上，左，右三条边，颜色设定为（transparent）</h4><div class="code-wrapper"><pre><code class="hljs css">css:     * &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;        <span class="hljs-attribute">border-width</span>: <span class="hljs-number">20px</span>;        <span class="hljs-attribute">border-style</span>: solid;        <span class="hljs-attribute">border-color</span>: transparent transparent pink transparent;  // 对应上右下左，此处为 下 粉色    &#125;<span class="hljs-selector-tag">html</span>:     &lt;div class=<span class="hljs-string">&quot;content&quot;</span>&gt;&lt;/div&gt;复制代码</code></pre></div><h4 id="方法二：-采用的是均分原理"><a href="#方法二：-采用的是均分原理" class="headerlink" title="方法二： 采用的是均分原理"></a>方法二： 采用的是均分原理</h4><p>实现步骤： 1.首先保证元素是块级元素；2.设置元素的边框；3.不需要显示的边框使用透明色。</p><div class="code-wrapper"><pre><code class="hljs css">css:     * &#123;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;    <span class="hljs-selector-class">.content</span> &#123;        <span class="hljs-attribute">width</span>:<span class="hljs-number">0</span>;        <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;        <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> auto;        <span class="hljs-attribute">border</span>:<span class="hljs-number">50px</span> solid transparent;        <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid pink;    &#125;<span class="hljs-selector-tag">html</span>:     &lt;div class=<span class="hljs-string">&quot;content&quot;</span>&gt;&lt;/div&gt;复制代码</code></pre></div><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/172820401d58cdf8~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="11-🤨什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"><a href="#11-🤨什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？" class="headerlink" title="11.🤨什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"></a>11.🤨什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h3><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。</p><p>关于兼容： 页面头部必须有mate声明的<code>viewport</code>。</p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;’viewport’&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;”width=device-width,&quot;</span> <span class="hljs-attribute">initial-scale</span>=<span class="hljs-string">&quot;1.&quot;</span> <span class="hljs-attribute">maximum-scale</span>=<span class="hljs-string">&quot;1,user-scalable=no”&quot;</span>/&gt;复制代码</code></pre></div><h3 id="12-为什么要初始化CSS样式？"><a href="#12-为什么要初始化CSS样式？" class="headerlink" title="12.为什么要初始化CSS样式？"></a>12.为什么要初始化CSS样式？</h3><p>因为浏览器的兼容问题，不同浏览器对标签的默认值是不同的，如果没有对浏览器的<code>CSS</code>初始化，会造成相同页面在不同浏览器的显示存在差异。</p><h3 id="13-浮动原理以及为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"><a href="#13-浮动原理以及为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？" class="headerlink" title="13.浮动原理以及为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？"></a>13.浮动原理以及为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</h3><p>非IE浏览器下，容器不设定高度且子元素浮动时，容器高度不能被内容撑开。此时，内容会溢出到容器外面而影响布局。此类现象被称为浮动（溢出）。</p><p>原理：</p><ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）；</li><li>浮动元素碰到包含它的边框或其他浮动元素的边框停留。</li></ul><p>浮动元素碰到包含他的边框或者浮动元素的边框停留。由于浮动元素不在文档流之中，文档流的块级框会表现的就像浮动框不存在一样。浮动元素会漂浮在文档流的块级框之上。</p><p>浮动会带来的问题：</p><ul><li>父级元素的高度将会无法被撑开，会影响与父级元素同级的元素</li><li>与浮动元素同级的非浮动元素（内联元素）会跟随其后</li><li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li></ul><p>清除方式：</p><ul><li>父级盒子定义高度<code>（height）</code>;</li><li>最后一个浮动元素后面加一个<code>div</code>空标签，并且添加样式<code>clear: both</code>;</li><li>包含浮动元素的父级标签添加样式<code>overflow</code>为<code>hidden/both</code>;</li><li>父级<code>div</code>定义<code>zoom</code>;</li></ul><h3 id="14-CSS优化、提高性能的方法有哪些？"><a href="#14-CSS优化、提高性能的方法有哪些？" class="headerlink" title="14.CSS优化、提高性能的方法有哪些？"></a>14.CSS优化、提高性能的方法有哪些？</h3><ul><li>多个<code>css</code>可合并，并尽量减少<code>http</code>请求</li><li>属性值为0时，不加单位</li><li>将<code>css</code>文件放在页面最上面</li><li>避免后代选择符，过度约束和链式选择符</li><li>使用紧凑的语法</li><li>避免不必要的重复</li><li>使用语义化命名，便于维护</li><li>尽量少的使用<code>!impotrant</code>，可以选择其他选择器</li><li>精简规则，尽可能合并不同类的重复规则</li><li>遵守盒子模型规则</li></ul><h3 id="15-CSS预处理器-x2F-后处理器是什么？为什么要使用它们？"><a href="#15-CSS预处理器-x2F-后处理器是什么？为什么要使用它们？" class="headerlink" title="15.CSS预处理器&#x2F;后处理器是什么？为什么要使用它们？"></a>15.CSS预处理器&#x2F;后处理器是什么？为什么要使用它们？</h3><p>预处理器，如：<code>less</code>，<code>sass</code>，<code>stylus</code>,用来预编译<code>sass</code>或者<code>less</code>，增加了<code>css</code>代码的复用性，还有层级，<code>mixin</code>， 变量，循环， 函数等，对编写以及开发UI组件都极为方便。</p><p>后处理器， 如： <code>postCss</code>,通常被视为在完成的样式表中根据<code>css</code>规范处理<code>css</code>，让其更加有效。目前最常做的是给<code>css</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><p><code>css</code>预处理器为<code>css</code>增加一些编程特性，无需考虑浏览器的兼容问题，我们可以在<code>CSS</code>中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让我们的<code>css</code>更加的简洁，增加适应性以及可读性，可维护性等。</p><p>其它<code>css</code>预处理器语言：<code>Sass（Scss</code>）, <code>Less</code>, <code>Stylus</code>, <code>Turbine</code>, <code>Swithch css</code>, <code>CSS Cacheer</code>, <code>DT Css</code>。</p><p>使用原因：</p><ul><li>结构清晰， 便于扩展</li><li>可以很方便的屏蔽浏览器私有语法的差异</li><li>可以轻松实现多重继承</li><li>完美的兼容了<code>CSS</code>代码，可以应用到老项目中</li></ul><h3 id="16-before-和-after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用"><a href="#16-before-和-after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用" class="headerlink" title="16.::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用"></a>16.::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用</h3><p>（1）、冒号(<code>:</code>)用于<code>CSS3</code>伪类，双冒号(<code>::</code>)用于<code>CSS3</code>伪元素。</p><p>（2）、<code>::before</code>就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于<code>dom</code>之中，只存在在页面之中。</p><p>🍀<strong>注意：</strong> <code>:before</code> 和 <code>:after</code> 这两个伪元素，是在<code>CSS2.1</code>里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着<code>Web</code>的进化，在<code>CSS3</code>的规范里，伪元素的语法被修改成使用双冒号，成为<code>::before ::after</code>。</p><h3 id="17-让页面里的字体变清晰，变细用CSS怎么做？"><a href="#17-让页面里的字体变清晰，变细用CSS怎么做？" class="headerlink" title="17.让页面里的字体变清晰，变细用CSS怎么做？"></a>17.让页面里的字体变清晰，变细用CSS怎么做？</h3><p><code>-webkit-font-smoothing</code> 在 <code>window</code> 系统下没有起作用，但是在 <code>IOS</code> 设备上起作用 <code>-webkit-font-smoothing：antialiased</code> 是最佳的，灰度平滑。</p><h3 id="18-如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><a href="#18-如果需要手动写动画，你认为最小时间间隔是多久，为什么？" class="headerlink" title="18. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>18. 如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h3><p>多数显示器默认频率是<code>60Hz</code>，即1秒刷新60次，所以理论上最小间隔为<code>1/60＊1000ms ＝ 16.7ms</code>。</p><h3 id="19-rgba-和-opacity-的透明效果有什么不同？"><a href="#19-rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="19. rgba() 和 opacity 的透明效果有什么不同？"></a>19. rgba() 和 opacity 的透明效果有什么不同？</h3><p><code>opacity</code> 作用于元素以及元素内的所有内容（包括文字）的透明度；</p><p><code>rgba()</code> 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果；</p><h3 id="20-css-属性-content-有什么作用？"><a href="#20-css-属性-content-有什么作用？" class="headerlink" title="20.css 属性 content 有什么作用？"></a>20.css 属性 content 有什么作用？</h3><p><code>content</code> 属性专门应用在 <code>before/after</code> 伪元素上，用于插入额外内容或样式。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/17282046671bd2f1~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="21-🧐请解释一下-CSS3-的-Flexbox（弹性盒布局模型）以及适用场景？"><a href="#21-🧐请解释一下-CSS3-的-Flexbox（弹性盒布局模型）以及适用场景？" class="headerlink" title="21.🧐请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？"></a>21.🧐请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？</h3><blockquote><p>概念： <code>Flex</code>是<code>Flexible Box</code>的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。采用<code>Flex</code>布局的元素，称为<code>Flex</code>容器<code>（flex container）</code>，简称”容器”。它的所有子元素自动成为容器成员，称为<code>Flex</code>项目<code>（flex item）</code>，简称”项目”。</p></blockquote><p>适用场景： 任何一个容器都可以指定为<code>Flex</code>布局。<code>Flexbox</code> 用于不同尺寸屏幕中创建可自动扩展和收缩布局。</p><h3 id="22-display-inline-block-什么时候会显示间隙？"><a href="#22-display-inline-block-什么时候会显示间隙？" class="headerlink" title="22.display:inline-block 什么时候会显示间隙？"></a>22.display:inline-block 什么时候会显示间隙？</h3><ul><li>有空格时候会有间隙， 可以删除空格解决；</li><li><code>margin</code>正值的时候， 可以让<code>margin</code>使用负值解决；</li><li>使用<code>font-size</code>时候，可通过设置<code>font-size:0</code>、<code>letter-spacing</code>、<code>word-spacing</code>解决；</li></ul><h3 id="23-png、jpg、-jpeg、-bmp、gif-这些图片格式解释一下，分别什么时候用。有没有了解过webp？"><a href="#23-png、jpg、-jpeg、-bmp、gif-这些图片格式解释一下，分别什么时候用。有没有了解过webp？" class="headerlink" title="23. png、jpg、 jpeg、 bmp、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？"></a>23. png、jpg、 jpeg、 bmp、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</h3><p>（1）、<code>png</code>-便携式网络图片<code>（Portable Network Graphics）</code>,是一种无损数据压缩位图文件格式。优点是：压缩比高，色彩好。 大多数地方都可以用。</p><p>（2）、<code>jpg</code>是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在<code>www</code>上，被用来储存和传输照片的格式。</p><p>（3）、<code>gif</code>是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果。</p><p>（4）、<code>bmp</code>的优点： 高质量图片；缺点： 体积太大； 适用场景： <code>windows</code>桌面壁纸；</p><p>（4）、<code>webp</code>格式是谷歌在2010年推出的图片格式，压缩率只有<code>jpg</code>的2&#x2F;3，大小比<code>png</code>小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和<code>opera</code>支持。</p><h3 id="24-在CSS样式中常使用-px、em-在表现上有什么区别？"><a href="#24-在CSS样式中常使用-px、em-在表现上有什么区别？" class="headerlink" title="24. 在CSS样式中常使用 px、em 在表现上有什么区别？"></a>24. 在CSS样式中常使用 px、em 在表现上有什么区别？</h3><p><code>px</code>相对于显示器屏幕分辨率，无法用浏览器字体放大功能。</p><p><code>em</code>值不是固定的，会继承父级的字体大小： <code>em = 像素值 / 父级font-size</code>。</p><h3 id="25-一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度问题怎么解决？"><a href="#25-一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度问题怎么解决？" class="headerlink" title="25.一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度问题怎么解决？"></a>25.一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度问题怎么解决？</h3><p>方案一： <code>.content &#123; height: calc(100%-100px); &#125;</code></p><p>方案二：<code>.container &#123; position:relative; &#125; .content &#123; position: absolute; top: 100px; bottom: 0; &#125;</code></p><p>方案三：<code>.container &#123; display:flex; flex-direction:column; &#125; .content &#123; flex:1; &#125;</code></p><h3 id="26-overflow-scroll-时不能平滑滚动的问题怎么处理？"><a href="#26-overflow-scroll-时不能平滑滚动的问题怎么处理？" class="headerlink" title="26.overflow: scroll 时不能平滑滚动的问题怎么处理？"></a>26.overflow: scroll 时不能平滑滚动的问题怎么处理？</h3><p>监听滚轮事件，然后滚动到一定距离时用 <code>jquery</code> 的 <code>animate</code> 实现平滑效果。</p><h3 id="27-transform、animation和animation-duration的区别？"><a href="#27-transform、animation和animation-duration的区别？" class="headerlink" title="27.transform、animation和animation-duration的区别？"></a>27.transform、animation和animation-duration的区别？</h3><ul><li><code>Transform</code>: 它和<code>width</code>、<code>left</code>一样，定义了元素很多静态样式实现变形、旋转、缩放、移位及透视等功能，通过一系列功能的组合我们可以实现很炫酷的静态效果（非动画)。</li><li><code>Animation</code>: 作用于元素本身而不是样式属性,属于关键帧动画的范畴，它本身被用来替代一些纯粹表现的<code>javascript</code>代码而实现动画,可以通过<code>keyframe</code>显式控制当前帧的属性值。</li><li><code>animation-duration</code>：规定完成动画所花费的时间，以秒或毫秒计。</li></ul><h3 id="28-对-line-height-是如何理解的？"><a href="#28-对-line-height-是如何理解的？" class="headerlink" title="28.对 line-height 是如何理解的？"></a>28.对 line-height 是如何理解的？</h3><p><code>line-height</code>指的是一行字的高度，包含了字间距，实际上是下一行基线到上一行基线的距离。如果一个标签没有定义<code>height</code>属性，那么其最终表现的高度是由<code>line-height</code>决定的。一个容器没有设置高度，那么撑开容器的高度的是<code>line-height</code>,而不是容器内部的文字内容。把<code>line-height</code>值设置为<code>height</code>一样大小的值可以实现单行文字的垂直居中。<code>line-height</code>和<code>height</code>都能撑开一个高度，<code>height</code>会触发<code>haslayout</code>，而<code>line-height</code>不会。</p><h3 id="29-抽离样式模块怎么写？述其思路。"><a href="#29-抽离样式模块怎么写？述其思路。" class="headerlink" title="29.抽离样式模块怎么写？述其思路。"></a>29.抽离样式模块怎么写？述其思路。</h3><p>可将<code>css</code>拆分成两部分： 公共<code>CSS</code>和业务<code>CSS</code>。</p><p>网站的配色，字体，交互提取出为公共的<code>CSS</code>。这部分的<code>CSS</code>命名不应涉及具体的业务。对于业务<code>CSS</code>，需要有统一的命名，使用公共的前缀。</p><h3 id="30-在网页中的应该使用奇数还是偶数的字体？"><a href="#30-在网页中的应该使用奇数还是偶数的字体？" class="headerlink" title="30.在网页中的应该使用奇数还是偶数的字体？"></a>30.在网页中的应该使用奇数还是偶数的字体？</h3><p>在网页中的应该使用“偶数”字体：</p><p>偶数字号相对更容易和 <code>web</code> 设计的其他部分构成比例关系，使用奇数号字体时文本段落无法对齐，宋体的中文网页排布中使用最多的就是 <code>12</code> 和 <code>14</code>。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/1728204b7a73d69c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="31-🤥什么是外边距重叠？-重叠的结果是什么？"><a href="#31-🤥什么是外边距重叠？-重叠的结果是什么？" class="headerlink" title="31. 🤥什么是外边距重叠？ 重叠的结果是什么？"></a>31. 🤥什么是外边距重叠？ 重叠的结果是什么？</h3><p>首先，外边距重叠就是 <code>margin-collapse</code>。相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。 这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距。</p><p>折叠结果遵循下列计算原则：</p><ul><li>两个相邻的外面边距是正数时，折叠结果就是他们之中的较大值；</li><li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值；</li><li>两个外边距一正一负时，折叠结果是两者的相加的和；</li></ul><h3 id="32-display-none-与-visibility-hidden-有什么区别？"><a href="#32-display-none-与-visibility-hidden-有什么区别？" class="headerlink" title="32.display: none; 与 visibility: hidden; 有什么区别？"></a>32.display: none; 与 visibility: hidden; 有什么区别？</h3><p>联系： 这两个属性的值都可以让元素变得不可见；</p><p>区别：</p><ul><li><strong>从占据空间角度看</strong>：<code>display: none;</code>会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden;</code>不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见；</li><li><strong>从继承方面角度看</strong>：<code>display: none;</code>是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；<code>visibility:hidden;</code>是继承属性，子孙节点消失由于继承了<code>hidden</code>，通过设置<code>visibility: visible;</code>可以让子孙节点显式；</li><li><strong>从重绘和重排角度看</strong>：修改常规流中元素的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘 读屏器不会读取<code>display: none;</code>元素内容；会读取<code>visibility: hidden</code>元素内容；</li></ul><h3 id="33-css-hack原理及常用hack有哪些？"><a href="#33-css-hack原理及常用hack有哪些？" class="headerlink" title="33.css hack原理及常用hack有哪些？"></a>33.css hack原理及常用hack有哪些？</h3><p>原理： 利用不同浏览器对<code>CSS</code>的支持和解析结果不一样编写针对特定浏览器的样式。</p><p>常见的<code>hack</code>有： <strong>属性hack</strong>、<strong>选择器hack</strong>、<strong>IE条件注释</strong>。</p><h3 id="34-link-与-import-的区别？"><a href="#34-link-与-import-的区别？" class="headerlink" title="34.link 与 @import 的区别？"></a>34.link 与 @import 的区别？</h3><ul><li><code>link</code> 是<code>HTML</code>方式， <code>@import</code> 是<code>CSS</code>方式；</li><li><code>link</code>最大限度支持并行下载，<code>@import</code> 过多嵌套导致串行下载，出现<code>FOUC</code>；</li><li><code>link</code> 可以通过 <code>rel=&quot;alternate stylesheet&quot;</code> 指定候选样式；</li><li>浏览器对 <code>link</code> 支持早于<code>@import</code> ，可以使用 <code>@import</code>对老浏览器隐藏样式；</li><li><code>@import</code>必须在样式规则之前，可以在css文件中引用其他文件；</li></ul><p>总的来说： <code>link</code>优于<code>@import</code>。</p><h3 id="35-什么是-FOUC-Flash-of-Unstyled-Content-？-如何来避免-FOUC？"><a href="#35-什么是-FOUC-Flash-of-Unstyled-Content-？-如何来避免-FOUC？" class="headerlink" title="35.什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？"></a>35.什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？</h3><p>当使用<code>@import</code>导入<code>CSS</code>时，会导致某些页面在<code>IE</code>出现奇怪的现象： 没有样式的页面内容显示瞬间闪烁，这种现象被称为“文档样式暂时失效”，简称<code>FOUC</code>。</p><p>产生原因： 当样式表晚于结构性html加载时，加载到此样式表时，页面将会停止之前的渲染。等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。</p><p>解决办法： 只要在<code>&lt;head&gt;</code>之间加入一个<code>&lt;link&gt;</code>或者<code>&lt;script&gt;``&lt;/script&gt;</code>元素即可。</p><h3 id="36-display-float-position有什么关系？"><a href="#36-display-float-position有什么关系？" class="headerlink" title="36.display,float,position有什么关系？"></a>36.display,float,position有什么关系？</h3><ul><li>如果 <code>display</code> 为<code>none</code>，那么<code>position</code>和<code>float</code>都不起作用，元素不显示；</li><li>如果<code>position</code>值为<code>absolute</code>或者<code>fixed</code>，元素绝对定位，<code>float</code>的计算值为<code>none</code>，<code>display</code>根据下面的表格进行调整；</li><li>如果<code>float</code>不是<code>none</code>，框是浮动的，<code>display</code>根据下表进行调整；</li><li>其他情况下<code>display</code>的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整 <code>display</code>；</li></ul><h3 id="37-外边距折叠-collapsing-margins"><a href="#37-外边距折叠-collapsing-margins" class="headerlink" title="37.外边距折叠(collapsing margins)"></a>37.外边距折叠(collapsing margins)</h3><p>毗邻的两个或多个<code>margin</code>会合并成一个<code>margin</code>，叫做外边距折叠。规则如下：</p><ul><li>两个或多个毗邻的普通流中的块元素垂直方向上的<code>margin</code>会折叠；</li><li>浮动元素或<code>inline-block</code>元素或绝对定位元素的<code>margin</code>不会和垂直方向上的其他元素的<code>margin</code>折叠；</li><li>创建了块级格式化上下文的元素，不会和它的子元素发生<code>margin</code>折叠；</li><li>元素自身的<code>margin-bottom</code>和<code>margin-top</code>相邻时也会折叠；</li></ul><h3 id="38-有哪几种隐藏元素的方法？"><a href="#38-有哪几种隐藏元素的方法？" class="headerlink" title="38.有哪几种隐藏元素的方法？"></a>38.有哪几种隐藏元素的方法？</h3><ul><li><code>visibility: hidden;</code> 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在；</li><li><code>opacity: 0;``CSS3</code>属性，设置0可以使一个元素完全透明；</li><li><code>position: absolute;</code> 设置一个很大的 left 负值定位，使元素定位在可见区域之外；</li><li><code>display: none;</code> 元素会变得不可见，并且不会再占用文档的空间；</li><li><code>transform: scale(0);</code> 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留；</li><li><code>&lt;div hidden=&quot;hidden&quot;&gt;</code> <code>HTML5</code>属性,效果和<code>display:none;</code>相同，但这个属性用于记录一个元素的状态；</li><li><code>height: 0;</code> 将元素高度设为 0 ，并消除边框；</li><li><code>filter: blur(0);</code> <code>CSS3</code>属性，括号内的数值越大，图像高斯模糊的程度越大，到达一定程度可使图像消失<code>（此处感谢小伙伴支持）</code>；</li></ul><h3 id="39-li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#39-li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="39.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>39.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3><p><code>li</code>排列受到中间空白(回车&#x2F;空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔。解决办法：</p><ul><li>在<code>ul</code>中用<code>font-size：0</code>（谷歌不支持）；可以使用<code>letter-space：-3px;</code></li><li>设置<code>float：left；</code></li></ul><h3 id="40-浏览器是怎样解析CSS选择器的？"><a href="#40-浏览器是怎样解析CSS选择器的？" class="headerlink" title="40.浏览器是怎样解析CSS选择器的？"></a>40.浏览器是怎样解析CSS选择器的？</h3><p>浏览器解析<code>CSS</code>是从上到下，从右到左解析的，这样会提高查找选择器所对应的元素的效率（至于原因，有兴趣的童鞋可以自行去了解）。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/1728204cd6ce8aa0~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="41-🤭全屏滚动的原理是什么？用到了CSS的哪些属性？"><a href="#41-🤭全屏滚动的原理是什么？用到了CSS的哪些属性？" class="headerlink" title="41.🤭全屏滚动的原理是什么？用到了CSS的哪些属性？"></a>41.🤭全屏滚动的原理是什么？用到了CSS的哪些属性？</h3><p>全屏滚动有点类似于轮播，整体的元素一直排列下去，假设有<code>5</code>个需要展示的全屏页面，那么高度是<code>500%</code>，只是展示<code>100%</code>。也可以理解为超出隐藏部分，滚动时显示。</p><p>可能用到的<code>CSS</code>属： <code>overflow:hidden; transform:translate(100%, 100%); display:none;</code></p><p>❤️<strong>拓展</strong> ： 也可以利用全屏视觉滚动差，使用<code>background-attachment: fixed;</code> 来实现全屏效果。（这里是细心的小伙伴提出的另一个idea🤨）</p><h3 id="42-对浏览器内核的理解？"><a href="#42-对浏览器内核的理解？" class="headerlink" title="42.对浏览器内核的理解？"></a>42.对浏览器内核的理解？</h3><p>浏览器内核主要分为两个部分： 渲染引擎和js引擎；</p><ul><li>渲染引擎： 负责取得页面的内容（<code>html</code>，<code>xml</code>， 图像等）、整理讯息（加入<code>css</code>等）、以及计算网页的显示方式，然后对输出至显示器或者打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同。所有网页浏览器、电子邮件客户以及其他所需要编辑、显示网络的应用程序都需要内核。</li><li><code>JS</code>引擎： 解析和执行<code>Javascript</code>来实现网页的动态效果。</li></ul><p>最开始渲染引擎和<code>js</code>引擎没有明确的区分，后来<code>js</code>引擎越来越独立，内核就倾向于只渲染引擎。</p><h3 id="43-对WEB标准以及W3C的理解与认识"><a href="#43-对WEB标准以及W3C的理解与认识" class="headerlink" title="43.对WEB标准以及W3C的理解与认识"></a>43.对WEB标准以及W3C的理解与认识</h3><p>对于结构的要求：（规范的标签可以提高搜索引擎对页面的抓取效率，对<code>SEO</code>很有帮助）</p><ul><li>标签要闭合</li><li>标签字母小写</li><li>标签不允许随意嵌套</li></ul><p>对于<code>CSS</code>和<code>JS</code>来说：</p><ul><li>尽量使用外链<code>CSS</code>样式表和<code>JS</code>脚本。同时结构，表现和行为分为三块，符合规范。此外，还得提高页面渲染速度，提高用户体验。</li><li>尽量少用行内样式，保证结构和表现分离。标签的<code>id</code>和<code>class</code>等的属性命名要做到见文知意，标签越少，加载越快，用户体验就会越高。同时代码方面也会更易于维护，便于改版。</li><li>不需要变动内容，便可一同打印版本而不需要复制内容，提高网站易用性。</li></ul><h3 id="44-制作一个访问量很大的网站，如何管理所有的css文件，js和图片？"><a href="#44-制作一个访问量很大的网站，如何管理所有的css文件，js和图片？" class="headerlink" title="44.制作一个访问量很大的网站，如何管理所有的css文件，js和图片？"></a>44.制作一个访问量很大的网站，如何管理所有的css文件，js和图片？</h3><p>从人手，分工和同步方面回答：</p><ul><li>前期团队必须确认好全局样式，编码模式；</li><li>代码风格，编写习惯保持一致；</li><li>标注样式编写人，各模块都要及时标注（标注关键样式调用的地方）；</li><li>对自己负责的页面进行标注；</li><li><code>CSS</code>和<code>JS</code>分文件夹存并行存放，命名都要统一；</li><li><code>JS</code>分文件夹存放，明明以该<code>JS</code>功能为准的英文翻译；</li><li>图片采用整合的<code>.png</code>格式存放，尽量整合在一起，方便将来管理；</li></ul><h3 id="45-视差滚动效果以及如何实现？"><a href="#45-视差滚动效果以及如何实现？" class="headerlink" title="45.视差滚动效果以及如何实现？"></a>45.视差滚动效果以及如何实现？</h3><p>视差滚动<code>（Parallax Scrolling）</code>指网页滚动过程中，多层次的元素进行不同程度的移动，视觉上形成立体运动效果的网页展示技术（3D效果）。</p><p>实现方式：</p><ul><li><code>CSS3</code>实现： 优点是开发时间相对较短，性能和开发效率比较好。缺点是不能兼容到低版本的浏览器；</li><li><code>JQuery</code>实现：（通过控制不同层滚动速度，计算每一层的时间）优点是能兼容到各个版本，效果可控性好，缺点是开发起来对制作者的要求较高；</li><li>插件实现方式： 例如使用<code>parallax-scrolling</code>,兼容性十分好；</li></ul><h3 id="46-对BFC规范-块级格式化上下文：block-formatting-context-的理解"><a href="#46-对BFC规范-块级格式化上下文：block-formatting-context-的理解" class="headerlink" title="46.对BFC规范(块级格式化上下文：block formatting context)的理解"></a>46.对BFC规范(块级格式化上下文：block formatting context)的理解</h3><p><code>BFC</code>规定了内部的<code>Block Box</code>如何布局。一个页面是由很多个<code>Box</code>组成的，元素的类型和<code>display</code>属性，决定了这个<code>Box</code>的类型。不同类型的<code>box</code>，会参与不同的<code>Formatting Context</code>（决定如何渲染文档的容器），因此<code>Box</code>内的元素会以不用的方式渲染，也是就是说<code>BFC</code>内部的元素和外部的元素不会相互影响。</p><p>定位方案：</p><ul><li>内部的<code>box</code>会在垂直方向上一个接一个的放置；</li><li><code>box</code>垂直方向的距离由<code>margin</code>决定，属于同一个<code>BFC</code>的两个相邻<code>Box</code>的<code>margin</code>会发生重叠；</li><li>每个元素<code>margin box</code>的左边，与包含块<code>border box</code>的左边相接触；</li><li><code>BFC</code>的区域不会与float box重叠；</li><li><code>BFC</code>是页面上的一个隔离的独立容器，容器里面的元素不会影响到外面的元素；</li><li>计算<code>BFC</code>的高度时，浮动元素也会参与计算。</li></ul><p>满足下列条件之一就可以出发BFC：</p><ul><li>根元素变化，即<code>html</code>；</li><li><code>float</code>的值不为<code>none</code>（默认）；</li><li><code>overflow</code>的值不为<code>visible</code>（默认）；</li><li><code>display</code>的值为<code>inline-block</code>, <code>tabke-cell</code>，<code>table-caption</code>；</li><li><code>position</code>的值为<code>absolute</code>或<code>fixed</code>;</li></ul><h3 id="47-元素竖向的百分比设定是相对于容器的高度吗？"><a href="#47-元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="47.元素竖向的百分比设定是相对于容器的高度吗？"></a>47.元素竖向的百分比设定是相对于容器的高度吗？</h3><p>一般来说，子元素的百分比单位都是以父元素为依据。但是<code>margin</code>和<code>padding</code>例外。元素的<code>height</code>是相对于容器的高度，但是元素的<code>margin</code>和<code>padding</code>是相对于容器的宽度。</p><h3 id="48-一个满屏’品字’布局如何设计"><a href="#48-一个满屏’品字’布局如何设计" class="headerlink" title="48.一个满屏’品字’布局如何设计?"></a>48.一个满屏’品字’布局如何设计?</h3><p>方法有挺多种，但是比较简单的方式就是： 上面的<code>div</code>宽度设置为100%，底下两个<code>div</code>设置成<code>50%</code>，并使用<code>float</code>或者<code>inline</code>使其保持在同一行即可（具体的样式可以自己微调）。如下：</p><div class="code-wrapper"><pre><code class="hljs css">css: .content &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;&#125;<span class="hljs-selector-class">.top</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">40%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">background-color</span>: pink;    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">30%</span>;&#125;<span class="hljs-selector-class">.left</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">45%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">background-color</span>: pink;    <span class="hljs-attribute">float</span>: left;&#125;<span class="hljs-selector-class">.right</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">45%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;    <span class="hljs-attribute">background-color</span>: pink;    <span class="hljs-attribute">float</span>: right;&#125;<span class="hljs-selector-tag">html</span>: &lt;div class=<span class="hljs-string">&quot;content&quot;</span>&gt;    &lt;div class=<span class="hljs-string">&quot;top&quot;</span>&gt;&lt;/div&gt;    &lt;div class=<span class="hljs-string">&quot;left&quot;</span>&gt;&lt;/div&gt;    &lt;div class=<span class="hljs-string">&quot;right&quot;</span>&gt;&lt;/div&gt;&lt;/div&gt;&gt;复制代码</code></pre></div><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/1/1726ed981ba3eb0a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><h3 id="49-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？"><a href="#49-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？" class="headerlink" title="49.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？"></a>49.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</h3><p>（1）、问题：<code>png24</code>位的图片在<code>ie</code>浏览器上出现背景。解决： 做成<code>png8</code>；</p><p>（2）、问题：浏览器默认的<code>margin</code>和<code>padding</code>不同。 解决： 添加一个全局的<code>*&#123; margin： 0; padding： 0;&#125;</code>；</p><p>（3）、问题：<code>IE</code>下,可以使用获取常规属性的方法来获取自定义属性,也可以使用<code>getAttribute()</code>获取自定义属性，而<code>Firefox</code>下,只能使用<code>getAttribute()</code>获取自定义属性。 解决： 统一通过<code>getAttribute()</code>获取自定义属性；</p><p>（4）、问题： <code>IE</code>下,<code>event</code>对象有<code>x</code>,<code>y</code>属性,但是没有<code>pageX</code>,<code>pageY</code>属性，而<code>Firefox</code>下,<code>event</code>对象有<code>pageX</code>,<code>pageY</code>属性,但是没有<code>x</code>,<code>y</code>属性。 解决： 使用<code>mX(mX = event.x ? event.x : event.pageX;)</code>来代替<code>IE</code>下的<code>event.x</code>或者<code>Firefox</code>下的<code>event.pageX</code>。</p><h3 id="50-box-sizing-常用的属性有哪些？分别有什么作用？"><a href="#50-box-sizing-常用的属性有哪些？分别有什么作用？" class="headerlink" title="50.box-sizing 常用的属性有哪些？分别有什么作用？"></a>50.box-sizing 常用的属性有哪些？分别有什么作用？</h3><ul><li><code>box-sizing: content-box;</code> &#x2F;&#x2F; 默认的标准<code>(W3C)</code>盒模型元素效果；</li><li><code>box-sizing: border-box;</code> &#x2F;&#x2F; 触发怪异<code>(IE)</code>盒模型元素的效果；</li><li><code>box-sizing: inherit;</code> &#x2F;&#x2F; 继承父元素 <code>box-sizing</code> 属性的值；</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/1728204f634255b2~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="51-🤤在网页中的应该使用奇数还是偶数的字体？"><a href="#51-🤤在网页中的应该使用奇数还是偶数的字体？" class="headerlink" title="51. 🤤在网页中的应该使用奇数还是偶数的字体？"></a>51. 🤤在网页中的应该使用奇数还是偶数的字体？</h3><p>一般情况下，在网页中，应该使用 <strong>偶数</strong> 字体。原因：</p><ul><li>偶数字号相对更容易和<code>web</code>设计的其他部分构成比例关系；</li><li>使用基数字号时文本段落无法对齐；</li><li>宋体的中文网页排布中使用最多的是12号和14号。</li></ul><h3 id="52-margin和padding分别适合什么场景使用？"><a href="#52-margin和padding分别适合什么场景使用？" class="headerlink" title="52. margin和padding分别适合什么场景使用？"></a>52. margin和padding分别适合什么场景使用？</h3><p>（1）、需要在<code>border</code>外侧添加空白且空白处不需要背景（色），或上下相连的两个盒子之间的空白需要相互抵消时，可以使用<code>margin</code>；</p><p>（2）、需要在<code>border</code>内侧添加空白且空白处需要背景（色），或上下相连的两个盒子之间的空白，希望等于两者之和时，可以使用<code>padding</code>。</p><h3 id="53-伪元素和伪类的区别和作用？"><a href="#53-伪元素和伪类的区别和作用？" class="headerlink" title="53. 伪元素和伪类的区别和作用？"></a>53. 伪元素和伪类的区别和作用？</h3><p>首先，伪类的效果可以通过添加实际的类来实现，而伪元素的效果可以通过添加实际的元素来实现。所以它们的<strong>本质区别就是是否抽象创造了新元素</strong>。</p><p>伪元素&#x2F;伪对象： 不存在在DOM文档中，是虚拟的元素，是创建新元素。代表某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>::first-child &#123;<span class="hljs-attribute">color</span>: red&#125;复制代码</code></pre></div><p>伪类：存在<code>DOM</code>文档中，逻辑上存在但在文档树中却无须标识的“幽灵”分类。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-number">#FF00FF</span>&#125;<span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<span class="hljs-attribute">color</span>: red&#125;复制代码</code></pre></div><p>🍀<strong>注意</strong>：</p><ul><li>伪类只能使用“：”；</li><li>而伪元素既可以使用“:”，也可以使用“::”；</li><li>因为伪类是类似于添加类所以可以是多个，而伪元素在一个选择器中只能出现一次，并且只能出现在末尾。</li></ul><h3 id="54-before-和-after-中双冒号和单冒号有什么区别？"><a href="#54-before-和-after-中双冒号和单冒号有什么区别？" class="headerlink" title="54. ::before 和 :after 中双冒号和单冒号有什么区别？"></a>54. ::before 和 :after 中双冒号和单冒号有什么区别？</h3><ul><li>在 <code>CSS</code> 中伪类一直用 : 表示，如 <code>:hover</code>, <code>:active</code> 等；</li><li>伪元素在<code>CSS1</code>中已存在，当时语法是用 : 表示，如 <code>:before</code> 和<code>:after</code>；</li><li>后来在<code>CSS3</code>中修订，伪元素用 <code>::</code> 表示，如 <code>::before</code> 和 <code>::after</code>，以此区分伪元素和伪类；</li><li>由于低版本<code>IE</code>对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 <code>:after</code> 这种老语法表示伪元素；</li></ul><p>综上所述：<code>::before</code> 是<code>CSS3</code>中写伪元素的新语法； <code>:after</code>是 <code>CSS1</code> 中存在的、兼容<code>IE</code>的老语法。</p><h3 id="55-怎么让Chrome支持小于12px-的文字？"><a href="#55-怎么让Chrome支持小于12px-的文字？" class="headerlink" title="55. 怎么让Chrome支持小于12px 的文字？"></a>55. 怎么让Chrome支持小于12px 的文字？</h3><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.shrink</span> &#123;    -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.8</span>);    -o-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);    <span class="hljs-attribute">display</span>: inilne-block;&#125;复制代码</code></pre></div><h3 id="56-将多个元素设置为同一行-清除浮动有几种方式"><a href="#56-将多个元素设置为同一行-清除浮动有几种方式" class="headerlink" title="56. 将多个元素设置为同一行?清除浮动有几种方式?"></a>56. 将多个元素设置为同一行?清除浮动有几种方式?</h3><p>将多个元素设置为同一行的方法： 使用<code>float</code>或<code>inline-block</code>；</p><p>清除浮动的方式：</p><ul><li>添加新的元素，应用<code>clear： both</code>；</li><li>父级<code>div</code>定义<code>overflow：hidden</code>;</li><li>利用<code>：after</code>和<code>：before</code>来在元素内部插入两个元素块，从而达到清除浮动的效果。</li></ul><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.clear</span> &#123; zoom:<span class="hljs-number">1</span>; &#125;<span class="hljs-selector-class">.clear</span><span class="hljs-selector-pseudo">:after</span> &#123;   <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot; &quot;</span>;   <span class="hljs-attribute">clear</span>:both;  <span class="hljs-attribute">display</span>:block;  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">overflow</span>:hidden;  <span class="hljs-attribute">visibility</span>:hidden;&#125;复制代码</code></pre></div><h3 id="57-css-hack概念以及简述几个css-hack"><a href="#57-css-hack概念以及简述几个css-hack" class="headerlink" title="57. css hack概念以及简述几个css hack?"></a>57. css hack概念以及简述几个css hack?</h3><blockquote><p><strong>概念</strong>： <code>CSS hack</code>是通过在<code>CSS</code>样式中加入一些特殊的符号，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号是有标准的，<code>CSS hack</code>就是让你记住这个标准），以达到应用不同的<code>CSS</code>样式的目的。</p></blockquote><p>（1）、图片间隙</p><p>在<code>div</code>中插入图片，图片会将<code>div</code>下方撑大<code>3px</code>：</p><ul><li><code>hack1</code>： 将<code>&lt;div&gt;</code>与<code>&lt;img&gt;</code>写在同一行；</li><li><code>hack2</code>： 给<code>&lt;img&gt;</code>添加<code>display：block</code>；</li></ul><p><code>dt</code> <code>li</code> 中的图片间隙：</p><ul><li><code>hack1:</code> 给<code>&lt;img&gt;</code>添加<code>display：block</code>；</li></ul><p>（2）、默认高度，<code>IE6</code>以下版本中，部分块元素，拥有默认高度（低于18px）：</p><ul><li><code>hack1</code>： 给元素添加： <code>font-size： 0</code>；</li><li><code>hack2</code>： 声明： <code>overflow： hidden</code>；</li></ul><p>表单行高不一致：</p><ul><li><code>hack1</code>： 给表单添加声明： <code>float： left; height: ; border: 0</code>;</li></ul><p>鼠标指针：</p><ul><li><code>hack</code>： 若统一某一元素鼠标指针为手型：<code>cursor： pointer;</code>,当li内的a转化为块元素时，给<code>a</code>设置<code>float</code>，<code>IE</code>里面会出现阶梯状；</li><li><code>hack1</code>： 给<code>a</code>添加<code>display： inline-block</code>;</li><li><code>hack2</code>： 给<code>li</code>添加<code>float: left</code>;</li></ul><h3 id="58-css2-0-和css3-0对比有什么不同？"><a href="#58-css2-0-和css3-0对比有什么不同？" class="headerlink" title="58. css2.0 和css3.0对比有什么不同？"></a>58. css2.0 和css3.0对比有什么不同？</h3><p><code>CSS3</code>加强了<code>CSS2</code>的功能，增加了新的属性和新的标签，并且删除了一些冗余的标签，在布局方面减少了代码量。以前比较复杂的布局，现在使用一个属性就能解决（例如<code>columns</code>等）。在展示型效果方面还加入了更多的效果（如动画，阴影，圆角等），在盒子模型和列表模块都有了改进。但是<code>CSS3</code>就兼容性而言，还是有些不足之处是，只能支持一些高版本的浏览器。</p><h3 id="59-块级元素、行内元素和空元素定义？"><a href="#59-块级元素、行内元素和空元素定义？" class="headerlink" title="59. 块级元素、行内元素和空元素定义？"></a>59. 块级元素、行内元素和空元素定义？</h3><ul><li><strong>行内元素</strong>：和有他元素都在一行上，高度、行高及外边距和内边距都不可改变，文字图片的宽度不可改变，只能容纳文本或者其他行内元素；</li><li><strong>块级元素</strong>：总是在新行上开始，高度、行高及外边距和内边距都可控制，可以容纳内敛元素和其他元素；</li><li><strong>空元素</strong>：在<code>HTML</code>元素中，没有内容的 <code>HTML</code> 元素被称为空元素。空元素是在开始标签中关闭的。<code>&lt;br&gt;</code> 就是没有关闭标签的空元素。</li></ul><h3 id="60-如何解决特定浏览器的样式问题？"><a href="#60-如何解决特定浏览器的样式问题？" class="headerlink" title="60. 如何解决特定浏览器的样式问题？"></a>60. 如何解决特定浏览器的样式问题？</h3><p>建议方案： 主张向前兼容，不考虑向后兼容。根据产品的用户群中各大浏览器，来考虑需要兼容的浏览器。</p><p>可以把浏览器分为两类： 一类是历史遗留浏览器，一类是现代浏览器。根据这个分类开发两个版本的网站，然后自己来定义哪些浏览器是历史遗留版本。</p><p>在用户使用历史遗留版本的时候，通过通告栏告知用户使用现代浏览器，获取更多的功能，拥有更好的用户体验等（升级）。当用户的浏览器不能兼容时，提示用户只是使用什么版本的浏览器才能使用网站（下载可以兼容的浏览器）。</p><p>🍀<strong>注意</strong>：项目开始前就需要确认兼容支持的最低版本是多少，以此设计一个对应的兼容方案。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/1728205163289fcb~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="61-🥴浏览器如何判断元素是否匹配某个CSS选择器？"><a href="#61-🥴浏览器如何判断元素是否匹配某个CSS选择器？" class="headerlink" title="61. 🥴浏览器如何判断元素是否匹配某个CSS选择器？"></a>61. 🥴浏览器如何判断元素是否匹配某个CSS选择器？</h3><p>浏览器先产生一个集合，这个集合往往由最后一个部分的索引产生（如果没有索引就是所有元素的集合）。然后向上匹配，如果不符合上一个部分，就把元素从集合中删除，直到这个选择器都匹配完，还在集合中的元素就匹配这个选择器了。</p><h3 id="62-描述css-reset的作用和用途？"><a href="#62-描述css-reset的作用和用途？" class="headerlink" title="62. 描述css reset的作用和用途？"></a>62. 描述css reset的作用和用途？</h3><p><code>Reset</code>重置浏览器的<code>CSS</code>默认属性，浏览器的品种不同，样式不同时，将他们重置，让他们统一。</p><h3 id="63-css-sprites是什么？如何使用？"><a href="#63-css-sprites是什么？如何使用？" class="headerlink" title="63. css sprites是什么？如何使用？"></a>63. css sprites是什么？如何使用？</h3><p><code>css</code>精灵图，把一堆小的图片整合到一张大的图片（png）上，利用<code>CSS</code>的<code>“background-image”</code>，<code>“background- repeat”``，“background-position”</code>的组合进行背景定位<code>background-position</code>可以用数字能精确的定位出背景图片的位置，减轻服务器对图片的请求数量。</p><h3 id="64-css-sprites的优缺点？"><a href="#64-css-sprites的优缺点？" class="headerlink" title="64. css sprites的优缺点？"></a>64. css sprites的优缺点？</h3><p><strong>优点：</strong></p><ul><li>利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而大大提高了页面的性能，这也是<code>CSS Sprites</code>最大的优点；</li><li><code>CSS Sprites</code>能减少图片的字节，曾经多次比较过，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li></ul><p><strong>缺点：</strong></p><ul><li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li><li><code>CSSSprites</code>在开发的时候相对来说有点麻烦，需要借助<code>photoshop</code>或其他工具来对每个背景单元测量其准确的位置。</li><li>维护方面：<code>CSS Sprites</code>在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的<code>CSS</code>，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动<code>CSS</code>。</li></ul><p><strong>拓展：</strong> 目前网站开发所用的精灵图（如字体库）一般都是直接用云端，而不是采用这种本地的了，如阿里图标库等。</p><h3 id="65-绝对定位和浮动的区别和应用？"><a href="#65-绝对定位和浮动的区别和应用？" class="headerlink" title="65. 绝对定位和浮动的区别和应用？"></a>65. 绝对定位和浮动的区别和应用？</h3><p><strong>绝对定位</strong>： 绝对定位脱离标准文档流，它的参考点是文档的左上角或者是右上角。如果有任何父元素有定位属性，此时就可以参考“<strong>子绝父相</strong>”定律来设置自己的定位参考元素。在网页制作过程中很灵活。制作覆盖效果的时候，会大量使用绝对定位。</p><p><strong>浮动</strong>： 浮动脱离标准文档流，通常用于制作并排显示的元素，通常用于大的布局，或者无序列表比如图片的并排。可以使用<code>clear:both</code>属性让标准流中的其他元素在此之后依次排列。</p><h3 id="66-当float和margin同时使用时，如何解决IE6的双倍边距？"><a href="#66-当float和margin同时使用时，如何解决IE6的双倍边距？" class="headerlink" title="66. 当float和margin同时使用时，如何解决IE6的双倍边距？"></a>66. 当float和margin同时使用时，如何解决IE6的双倍边距？</h3><p>当浮动的方向和<code>margin</code>是同方向的时候，此时IE6会在这个方向的第一个元素身上产生双倍<code>margin</code>。</p><p>解决办法：</p><p>（1）、改变<code>margin</code>的方向，<code>float:left; margin-right:20px;</code> 浮动向左，<code>margin</code>向右； （2）、给第一个元素单独写一个类叫做<code>.content</code>, 此时<code>.content&#123;_margin-left:一半的margin;&#125;</code>； （3）、用<code>display:inline;</code>不用浮动了（哈哈哈哈）。</p><h3 id="67-简述什么是内容与表现分离？"><a href="#67-简述什么是内容与表现分离？" class="headerlink" title="67. 简述什么是内容与表现分离？"></a>67. 简述什么是内容与表现分离？</h3><p>首先对于<code>html</code>，<code>css</code>以及<code>javascript</code>，可以这样理解：</p><p>把网站理解成一个人，<code>html</code>就是构成人体的‘骨架’，<code>css</code>就是人体的‘装饰’，比如衣服，饰品等；而<code>javascript</code>就相当于人做出的‘动作’，这样就通俗易懂了。</p><p>对于内容和表现分离，小编的理解是：尽量不要再<code>html</code>中插入行内样式，尽量将css抽成一个独立的模块，实现<code>html</code>‘骨架’和样式的分离，利于搜索引擎的同时，也便于后期维护。</p><h3 id="68-CSS怎样判断不同分辨率显示不同宽度布局，从而实现自适应宽度？"><a href="#68-CSS怎样判断不同分辨率显示不同宽度布局，从而实现自适应宽度？" class="headerlink" title="68. CSS怎样判断不同分辨率显示不同宽度布局，从而实现自适应宽度？"></a>68. CSS怎样判断不同分辨率显示不同宽度布局，从而实现自适应宽度？</h3><ul><li>使用百分比布局，用百分比来写宽度、<code>marign</code>、<code>padding</code>；</li><li>使用<code>rem</code>做单位，适当的写<code>js``让html</code>根元素的字号随着浏览器宽度的变化而等比例变化；</li><li>使用媒体查询让不同宽度的浏览器使用不同的样式表。</li></ul><h3 id="69-rem为什么可以缩放，以什么为基准？其优缺点有哪些？"><a href="#69-rem为什么可以缩放，以什么为基准？其优缺点有哪些？" class="headerlink" title="69.rem为什么可以缩放，以什么为基准？其优缺点有哪些？"></a>69.rem为什么可以缩放，以什么为基准？其优缺点有哪些？</h3><p><code>rem``以html</code>的字号为基准，比如<code>2rem</code>，而<code>html</code>的字号时<code>16px</code>，此时<code>rem</code>就是<code>32px</code>。可以写一段<code>js</code>让<code>html</code>根元素的字号随着浏览器宽度的变化而等比例变化，此时造成页面等比例缩放的现象。</p><p><strong>优点</strong>：</p><p>相对于<code>em</code>的好处来说，不会发生逐渐增大或者减小字体尺寸的情况，因为始终集成根元素的字体大小；<code>rem</code>单位不仅仅是可应用于字体大小，还可以用于设定高度等其它大小，使页面可以适配不同屏幕尺寸。</p><p>🍀<strong>注意</strong>： <code>rem</code> 一般只用于移动端。</p><h3 id="70-5条常见的Firefox和IE的脚本兼容的问题。"><a href="#70-5条常见的Firefox和IE的脚本兼容的问题。" class="headerlink" title="70. 5条常见的Firefox和IE的脚本兼容的问题。"></a>70. 5条常见的Firefox和IE的脚本兼容的问题。</h3><ul><li><strong>绑定监听</strong>： <code>IE</code>是<code>attatchEvent()</code> 、 <code>firefox</code>是<code>addEventListener()</code>;</li><li><strong>计算样式</strong>：<code>IE</code>是<code>currentStyle</code>、 <code>firefox</code>是<code>getComputedSyle</code>;</li><li><strong>滚动事件</strong>：<code>IE</code>是<code>MouseWheel</code>、 <code>firefox</code>是<code>onmousewheel</code>；</li><li><strong>表单元素</strong>：<code>IE</code>是 <code>document.forms(”formname”)</code> ， <code>firefox</code>是<code>document.forms[&quot;formname&quot;]</code>；</li><li><strong>事件对象</strong>： <code>IE</code>是<code>window.event</code>属性， <code>firefox</code>必须给事件处理函数注入实参<code>event</code>；</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/17282053da3df444~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="71-🥳css的优先级如何计算？"><a href="#71-🥳css的优先级如何计算？" class="headerlink" title="71. 🥳css的优先级如何计算？"></a>71. 🥳css的优先级如何计算？</h3><p>巩固一下：</p><table><thead><tr><th>分类</th><th>优先级</th></tr></thead><tbody><tr><td>元素选择符</td><td>1</td></tr><tr><td>class选择器</td><td>10</td></tr><tr><td>id选择器</td><td>100</td></tr><tr><td>元素标签</td><td>1000</td></tr></tbody></table><p>（1）、<code>!important</code>声明的样式优先级最高，若有冲突会再进行计算；</p><p>（2）、优先级相同时，以最后出现的样式为准；</p><p>（3）、继承得到的样式的优先级是最低的。</p><h3 id="72-回顾position的值及其作用？"><a href="#72-回顾position的值及其作用？" class="headerlink" title="72. 回顾position的值及其作用？"></a>72. 回顾position的值及其作用？</h3><ul><li><code>static</code>（默认）：按照正常文档流进行排列；</li><li><code>relative</code>（相对定位）： 不脱离文档流，参考自身静态位置通过<code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>定位；</li><li><code>absolute</code>（绝对定位）： 参考距离最近一个不为<code>static</code>的父级元素通过<code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>定位；</li><li><code>fixed</code>（固定定位）： 所固定的参照对象是可视窗口。</li></ul><h3 id="73-有哪几种高等布局？"><a href="#73-有哪几种高等布局？" class="headerlink" title="73.有哪几种高等布局？"></a>73.有哪几种高等布局？</h3><ul><li>假等高列：使用背景图片，在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假象；</li><li>给容器的<code>div</code>使用单独的背景色（固定布局）（流体布局）：用元素中的最大高度撑起其他容器的高度；</li><li>创建带边框的两列等高布局： 用<code>border-left</code>来做，之鞥呢使用两列；</li><li>使用正<code>padding</code>和负<code>margin</code>对冲实现多列布局方法： 在所有列中使用的上，下<code>padding</code>和负的上，下<code>margin</code>，并在所有列外面加上一个容器，设置<code>overflow： hidden</code>，把溢出的背景切掉。</li><li>使用边框和定位模拟列等高： 但不能使用在多列；</li><li>模仿表格布局等高列效果： 兼容性不好，在<code>ie6-7</code>中无法正常运行；</li></ul><h3 id="74-link、-visited、-hover、-active的执行顺序是怎么样的？"><a href="#74-link、-visited、-hover、-active的执行顺序是怎么样的？" class="headerlink" title="74. :link、:visited、:hover、:active的执行顺序是怎么样的？"></a>74. :link、:visited、:hover、:active的执行顺序是怎么样的？</h3><p><code>L-V-H-A</code>，<code>l(link)ov(visited)e h(hover)a(active)te</code>，即用喜欢和讨厌两个词来概括。</p><h3 id="75-经常遇到的浏览器兼容性有哪些？如何解决？"><a href="#75-经常遇到的浏览器兼容性有哪些？如何解决？" class="headerlink" title="75. 经常遇到的浏览器兼容性有哪些？如何解决？"></a>75. 经常遇到的浏览器兼容性有哪些？如何解决？</h3><ul><li>浏览器默认的<code>margin</code>和<code>padding</code>不同；</li><li><code>IE6</code>双边距<code>bug</code>；</li><li>在<code>IE6-7</code>中元素高度超出自己设置的高度。原因是IE8以前的浏览器中会给元素设置偶人的行高的高度所导致的；</li><li><code>min-height</code>在<code>IE6</code>下不起作用；</li><li>透明性<code>IE</code>用<code>filter：Alpha（Opacity=60）</code>,而其它主流浏览器用<code>opacity： 0.6</code>；</li><li><code>input</code>边框问题，去掉<code>input</code>边框一般用<code>border：none；</code>就可以但是由于<code>IE6</code>在解析<code>input</code>样式时<code>bug</code>（优先级问题），在<code>IE6</code>下无效；</li></ul><h3 id="76-为什么要语义化以及对于标签语义化的理解？"><a href="#76-为什么要语义化以及对于标签语义化的理解？" class="headerlink" title="76. 为什么要语义化以及对于标签语义化的理解？"></a>76. 为什么要语义化以及对于标签语义化的理解？</h3><p>原因： <strong>为了在没有css的情况下，页面也能呈现出很好的内筒结构和代码架构（可以理解为为了裸奔时好看哈哈哈）</strong>。</p><p>理解：</p><ul><li>去掉或者丢失样式的时候能够让页面呈现清晰的结构；</li><li>有利于<code>SEO</code>，可以和搜索引擎建立良好的沟通，有助于爬虫抓取更多的有效信息（爬虫依赖于标签来确定上下文和各个关键字的权重）；</li><li>方便其他设备解析（如屏幕阅读器，盲人阅读器，移动设备等），以意义的方式来渲染网页；</li><li>便于团队的开发和维护，语义化更具有可读性，遵循<code>W3C</code>标准的团队都遵循这个标准，可以减少代码差异化；</li></ul><h3 id="77-常见的CSS布局有几种？"><a href="#77-常见的CSS布局有几种？" class="headerlink" title="77. 常见的CSS布局有几种？"></a>77. 常见的CSS布局有几种？</h3><p>常见的<code>CSS</code>布局有： <strong>固定布局</strong>、<strong>流式布局</strong>、<strong>弹性布局</strong>、<strong>浮动布局</strong>、<strong>定位布局</strong>、<strong>margin和padding</strong>。</p><h3 id="78-position的absolute与fixed共同点与不同点？"><a href="#78-position的absolute与fixed共同点与不同点？" class="headerlink" title="78. position的absolute与fixed共同点与不同点？"></a>78. position的absolute与fixed共同点与不同点？</h3><p>相同点：</p><ul><li>改变行内元素的呈现方式，<code>display</code>被设置为<code>block</code>；</li><li>让元素脱离普通流，不占据空间；</li><li>默认会覆盖到非定位元素上；</li></ul><p>不同点：</p><ul><li><code>absolute</code>的“根元素”是可以设置的，而<code>fixed</code>的“根元素”固定为浏览器窗口；</li><li>当滚动网页时，<code>fixed</code>元素与浏览器窗口之间的距离是不变的。</li></ul><h3 id="79-CSS哪些属性可以继承？哪些属性不可以继承？"><a href="#79-CSS哪些属性可以继承？哪些属性不可以继承？" class="headerlink" title="79. CSS哪些属性可以继承？哪些属性不可以继承？"></a>79. CSS哪些属性可以继承？哪些属性不可以继承？</h3><ul><li>可以继承的样式属性： <code>font-size</code>、<code>font-family</code>、<code>color</code>、<code>list-style</code>、<code>cursor</code>、<code>ul</code>, <code>li</code>, <code>dl</code>, <code>dd</code>, <code>dt</code>;</li><li>不可继承的样式属性： <code>width</code>、<code>height</code>、 <code>border</code>、 <code>padding</code>、 <code>margin</code>、 <code>background</code>；</li></ul><p>🍀<strong>注意</strong>： 为了便于理解，小编觉得可以大致理解为<strong>字体相关的样式可以继承，与尺寸相关的样式不可继承</strong>。</p><h3 id="80-使用过的-CSS-预处理器？"><a href="#80-使用过的-CSS-预处理器？" class="headerlink" title="80.使用过的 CSS 预处理器？"></a>80.使用过的 CSS 预处理器？</h3><p><code>CSS</code>预处理器的基本思想： 为<code>CSS</code>增加了一些变量的特性（变量，判断逻辑和函数等）。</p><p>开发者使用这种语言进行web页面上样式设计，再编译成正常的<code>css</code>文件使用。使用CSS预处理器，可以使<code>CSS</code>更加简洁，适应性更强，可读性更佳，无需考虑兼容性。最常用的<code>CSS</code>预处理器语言包括： <code>Sass(Scss)</code>和<code>Less</code>。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/17282056ed97998b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="81-🤧设置元素浮动后，该元素的-display-值会如何变化？"><a href="#81-🤧设置元素浮动后，该元素的-display-值会如何变化？" class="headerlink" title="81. 🤧设置元素浮动后，该元素的 display 值会如何变化？"></a>81. 🤧设置元素浮动后，该元素的 display 值会如何变化？</h3><p>设置元素浮动后，该元素的<code>display</code>值自动变成<code>block</code>。</p><h3 id="82-行内元素有哪些-块级元素有哪些-空-void-元素有那些"><a href="#82-行内元素有哪些-块级元素有哪些-空-void-元素有那些" class="headerlink" title="82. 行内元素有哪些?块级元素有哪些? 空(void)元素有那些?"></a>82. 行内元素有哪些?块级元素有哪些? 空(void)元素有那些?</h3><ul><li>行内元素： <code>a</code>、<code>b</code>、 <code>span</code>、<code>img</code>、 <code>input</code>、 <code>strong</code>、 <code>select</code>、 <code>label</code>、 <code>em</code>、 <code>button</code>、 <code>textarea</code>；</li><li>块级元素： <code>div</code>、 <code>ul</code>、 <code>li</code>、 <code>dl</code>、 <code>dt</code>、 <code>dd</code>、 <code>p</code>、 <code>h1-h6</code>、 <code>blockquote</code>；</li><li>空元素： 即没有实际内容内容的<code>html</code>元素，如：<code>br</code>、 <code>meta</code>、 <code>hr</code>、 <code>link</code>、 <code>input</code>、 <code>img</code>；</li></ul><h3 id="83-box-sizing属性？"><a href="#83-box-sizing属性？" class="headerlink" title="83. box-sizing属性？"></a>83. box-sizing属性？</h3><p>用来控制元素的盒子模型的解析模式，默认为<code>content-box</code>。</p><ul><li><code>content-box: W3C</code>的标准盒子模型，设置元素的<code>height/width</code>属性指的是<code>content</code>部分的宽&#x2F;高；</li><li><code>border-box</code>：IE传统盒子模型。设置元素的<code>height/width</code>属性指的是<code>border + padding + content</code>部分的高&#x2F;宽；</li></ul><h3 id="84-CSS3动画比基于脚本的动画有哪些优势？"><a href="#84-CSS3动画比基于脚本的动画有哪些优势？" class="headerlink" title="84. CSS3动画比基于脚本的动画有哪些优势？"></a>84. CSS3动画比基于脚本的动画有哪些优势？</h3><p>跟脚本动画相比，使用<code>CSS3</code>动画具有以下优势：</p><ul><li>易于使用，任何人都可以在不了解<code>javascript</code>的情况下创建它们；</li><li>即使在合理的系统负载下也能很好的执行。</li><li>由于简单的动画在<code>javascript</code>中的效果比较差，因此渲染引擎使用跳帧技术来使动画流畅进行；</li><li>允许浏览器控制动画序列，通过建撒谎哦在当前不可见的选项卡中执行的动画的更新频率来优化性能和效率；</li></ul><h3 id="85-如何优化网页的打印样式？"><a href="#85-如何优化网页的打印样式？" class="headerlink" title="85. 如何优化网页的打印样式？"></a>85. 如何优化网页的打印样式？</h3><p><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen(或者print、tv等) href=&quot;aaa.css&quot;&gt;</code></p><p>🍀<strong>注意</strong>，在打印样式表也应该注意以下几点：</p><ul><li>打印样式表中最好不要用背景图片，因为打印机不能打印CSS中的背景图。如果坚持要显示图片，可以使用<code>html</code>插入到页面中；</li><li>最好不要使用像素作为单位，因为打印样式表要打印出来的是实物，建议使用<code>pt/cm</code>;</li><li>隐藏掉不必要的内容。（如<code>@print content&#123;display: none&#125;</code>）;</li><li>打印样式表中不建议使用浮动属性（建议少用），因为它们会消失。</li></ul><h3 id="86-React-Native中的样式与css的区别？"><a href="#86-React-Native中的样式与css的区别？" class="headerlink" title="86. React Native中的样式与css的区别？"></a>86. React Native中的样式与css的区别？</h3><ul><li><code>React Native</code> 的样式基本上是实现了 <code>CSS</code> 的一个子集，并且属性名不完全一致，所以当你开始在考虑兼容 <code>React Native</code> 端之前，可以先简要了解一下 <code>React Native</code> 的样式。</li><li>这些样式名基本上是遵循了 <code>web</code> 上的 <code>CSS</code> 的命名，只是按照 <code>JS</code> 的语法要求使用了驼峰命名法。</li><li><code>RN</code>使用 <code>JavaScript</code> 来写样式，所有核心组件都接受名为<code>style</code>的属性，相当于<code>css</code>的行内样式。</li><li>在 <code>React Native</code> 中使用 Flexbox 规则来指定某个组件的子元素的布局。<code>Flexbox</code> 可以在不同屏幕尺寸上提供一致的布局结构。因此，如果你要考虑 <code>React Native</code> 端，那你的样式布局就得采用 <code>Flex</code> 布局。</li></ul><h3 id="87-style标签写在body后与body前有什么区别？"><a href="#87-style标签写在body后与body前有什么区别？" class="headerlink" title="87. style标签写在body后与body前有什么区别？"></a>87. style标签写在body后与body前有什么区别？</h3><p>一般情况下，页面加载时自上而下的。将<code>style</code>标签至于<code>body</code>之前，为的是先加载样式。</p><p>若是写在<code>body</code>标签之后，由于浏览器以逐行方式对html文档进行解析，当解析到写在写在文档尾部的样式表时，会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后会重新渲染，在<code>windows</code>的<code>IE</code>下可能会出现<code>FOUC</code>现象（页面闪烁）。</p><h3 id="88-CSS属性overflow属性定义溢出元素内容区的内容会如何处理"><a href="#88-CSS属性overflow属性定义溢出元素内容区的内容会如何处理" class="headerlink" title="88. CSS属性overflow属性定义溢出元素内容区的内容会如何处理?"></a>88. CSS属性overflow属性定义溢出元素内容区的内容会如何处理?</h3><ul><li>参数是<code>scroll</code>的时候，一定会出滚动条；</li><li>参数是<code>auto</code>的时候，子元素内容大于父元素时出现滚动条；</li><li>参数是<code>visible</code>的时候，溢出的内容出现在父元素之外；</li><li>参数是<code>hidden</code>的时候，溢出隐藏；</li></ul><h3 id="89-BFC、IFC、GFC、FFC是什么？"><a href="#89-BFC、IFC、GFC、FFC是什么？" class="headerlink" title="89. BFC、IFC、GFC、FFC是什么？"></a>89. BFC、IFC、GFC、FFC是什么？</h3><ul><li><code>Block formatting context(BFC)</code>--块级格式化上下文；</li><li><code>Inline formatting context(IFC)</code>--内联格式化上下文；</li><li><code>Grid formatting context(GFC)</code>--网格布局格式化上下文；</li><li><code>Flex formatting context(FFC)</code>--自适应格式化上下文；</li></ul><h3 id="90-对于使用图片，需要注意什么？"><a href="#90-对于使用图片，需要注意什么？" class="headerlink" title="90. 对于使用图片，需要注意什么？"></a>90. 对于使用图片，需要注意什么？</h3><ul><li>优化图片；</li><li>尽量避免在<code>html</code>中使用压缩图片；</li><li>使用恰当的图片格式；</li><li>使用<code>css sprites</code>技巧对图片优化；</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/5/172820593043a22d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h3 id="91-😯如何优化图像以及图像格式有什么区别？"><a href="#91-😯如何优化图像以及图像格式有什么区别？" class="headerlink" title="91.😯如何优化图像以及图像格式有什么区别？"></a>91.😯如何优化图像以及图像格式有什么区别？</h3><p><strong>优化图像</strong>：</p><ul><li>不用图片，尽量使用<code>CSS3</code>代替。对于一些要实现的修饰效果，例如阴影，圆角，半透明等，可以用<code>CSS3</code>完成；</li><li>尽可能使用矢量图<code>SVG</code>代替位图。对于绝大多数图案和图标等，矢量图更小，而且可以缩放而无需生成多套图。现代的主流浏览器大多数都能稳定的支持<code>SVG</code>。</li></ul><p><strong>图像格式区别</strong>：</p><ul><li>矢量图： 图标字体，如<code>font-awesome</code>、<code>svg</code>；</li><li>位图： <code>GIF</code>、<code>jpg（JPEG）</code>、<code>png</code>；</li></ul><p>矢量图和位图的区别：</p><ul><li><code>PNG</code>：它可以细分为三种格式： <code>PNG8</code>，<code>PNG24</code>，<code>PNG32</code>。后面的数字代表这种<code>PNG</code>格式最多可以索引和存储的颜色值；</li><li><code>JPG</code>: 一种大小与质量相对平衡的压缩图片格式。适用于允许轻微失真的色彩丰富的照片，不适用于色彩简单（色调少）的图片，比如图标啊，<code>logo</code>等；</li><li><code>GIF</code>： 一种无损的，8位图片格式。具有支持动画，索引透明，压缩等特性。使用色彩简单的图片。</li></ul><p><strong>优点</strong>： 能保证在最不失真的情况下尽可能压缩图像文件的大小；</p><p><strong>缺点</strong>： 对于需要高保真的较为复杂的图像，<code>PNG</code>虽然能无损压缩，但是图片较大，不适合应用在web页面上；</p><h3 id="92-position-fixed-在手机端下无效怎么处理？"><a href="#92-position-fixed-在手机端下无效怎么处理？" class="headerlink" title="92. position:fixed;在手机端下无效怎么处理？"></a>92. position:fixed;在手机端下无效怎么处理？</h3><p><code>fixed</code>的元素实现相对于整个页面是固定位置的，当在屏幕上滑动时是在滑动整个<code>viewport</code>。原来的网页还在，fixed也没有变过位置，所以说并不是手机端不支持<code>fixed</code>，只是<code>fixed</code>元素不是相对于手机屏幕固定的，因此我们按照以下方式来设计：</p><div class="code-wrapper"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span>/&gt;复制代码</code></pre></div><h3 id="93-css样式引入方式的优缺点对比"><a href="#93-css样式引入方式的优缺点对比" class="headerlink" title="93. css样式引入方式的优缺点对比"></a>93. css样式引入方式的优缺点对比</h3><ul><li>内嵌样式： 优点： 方便书写，权重高；缺点： 没有做到结构和样式分离；</li><li>内联样式： 优点：结构样式相分离； 缺点：没有彻底分离；</li><li>外联样式： 优点： 完全实现了结构和样式相分离； 缺点： 需要引入才能使用；</li></ul><h3 id="94-border-none-与border-0-有什么区别？"><a href="#94-border-none-与border-0-有什么区别？" class="headerlink" title="94. border:none;与border:0;有什么区别？"></a>94. border:none;与border:0;有什么区别？</h3><p><strong>首先是性能差异</strong>：</p><ul><li><code>&#123;border：0;&#125;</code>: 把<code>border</code>设置为0像素，虽然在页面上看不到，但是按<code>border</code>默认值理解，浏览器依然对<code>border-width/border-color</code>进行了渲染，即已经占用内存值；</li><li><code>&#123;border：none；&#125;</code>被理解为<code>border-style:none</code>。<code>boder:0</code>;比<code>border:none</code>多渲染了一个<code>border-width:0</code>,也就是为什么<code>border:none</code>的性能要比<code>border:0</code>高；</li></ul><p><strong>兼容性差异</strong>：</p><ul><li><code>&#123;border:none;&#125;</code>当<code>border</code>为<code>“none”</code>时似乎对<code>IE6/7</code>无效边框依然存在当<code>border</code>为“0”时，感觉比<code>“none”</code>更有效，所有浏览器都一致把边框隐藏。</li></ul><h3 id="95-position-跟-display、overflow、float-这些特性相互叠加后会怎么样？"><a href="#95-position-跟-display、overflow、float-这些特性相互叠加后会怎么样？" class="headerlink" title="95. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？"></a>95. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？</h3><ul><li><code>display</code>属性规定元素应该生成的框的类型；</li><li><code>position</code>属性规定元素的定位类型；</li><li><code>float</code>属性是一种布局方式，定义元素往哪个方向浮动；</li></ul><p><strong>叠加结果</strong>：有点类似于优先机制。<code>position</code>的值– <code>absolute/fixed</code>优先级最高，有他们在时，<code>float</code>不起作用，<code>display</code>值需要调整。<code>float</code>或者<code>absolute</code>定位的元素，只鞥是块元素或者表格。</p><h3 id="96-什么是critical-CSS？"><a href="#96-什么是critical-CSS？" class="headerlink" title="96. 什么是critical CSS？"></a>96. 什么是critical CSS？</h3><p><code>Critical CSS</code>是一种提取首屏中 <code>CSS</code> 的技术，以便尽快将内容呈现给用户。这是快速加载网页首屏的好方法。</p><p>核心思路：</p><p>（1）、抽取出首页的<code>CSS</code>；</p><p>（2）、用行内css样式，加载这部分的<code>css(critical CSS)</code>;</p><p>（3）、等到页面加载完之后，再加载整个<code>css</code>，会有一部分<code>css</code>与<code>critical css</code>重叠；</p><h3 id="97-什么是回流（重排）和重绘以及其区别？"><a href="#97-什么是回流（重排）和重绘以及其区别？" class="headerlink" title="97. 什么是回流（重排）和重绘以及其区别？"></a>97. 什么是回流（重排）和重绘以及其区别？</h3><ul><li>回流（重排），<code>reflow</code>:当<code>render tree</code>中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变时而需要重新构建；</li><li>重绘<code>（repaint</code>）:当<code>render tree</code>中的一些元素需要更新属性，而这些属性只影响元素的外观，风格，而不会影响布局时，称其为<strong>重绘</strong>，例如颜色改变等。</li></ul><p>🍀<strong>注意</strong>：<strong>每个页面至少需要引发一次重排+重绘，而且重排（回流）一定会引发重绘</strong>。</p><p>触发重排（回流）的条件：</p><ul><li>增加或者删除可见的<code>dom</code>元素；</li><li>元素的位置发生了改变；</li><li>元素的尺寸发生了改变，例如边距，宽高等几何属性改变；</li><li>内容改变，例如图片大小，字体大小改变等；</li><li>页面渲染初始化；</li><li>浏览器窗口尺寸改变，例如<code>resize</code>事件发生时等；</li></ul><h3 id="98-css-中可以让文字在垂直和水平方向上重叠的两个属性是什么？"><a href="#98-css-中可以让文字在垂直和水平方向上重叠的两个属性是什么？" class="headerlink" title="98. css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？"></a>98. css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？</h3><ul><li>垂直方向： <code>line-height</code>；</li><li>水平方向： <code>letter-spacing</code>；</li></ul><p>🍀<strong>注意</strong>： <code>letter-spacing</code>还可以用来消除<code>inline-block</code>元素间的换行符空格间隙等问题。</p><h3 id="99-对-WEB-标准以及-W3C-有什么理解与认识？"><a href="#99-对-WEB-标准以及-W3C-有什么理解与认识？" class="headerlink" title="99. 对 WEB 标准以及 W3C 有什么理解与认识？"></a>99. 对 WEB 标准以及 W3C 有什么理解与认识？</h3><ul><li>标签闭合，标签小写，不乱嵌套；</li><li>提高搜索机器人的搜索几率；</li><li>使用外链<code>CSS</code>和<code>JS</code>脚本；</li><li>结构行为标签分离；</li><li>文件下载和页面速度更快；</li><li>内容能被更多的用户以及更广泛的设备访问；</li><li>更少的代码和组件，易于维护，改版方便；</li><li>不需要动页面内容，同时提供打印版本也不需要复制内容，提高网站的易用性；</li></ul><h3 id="100-Happy-Ending💃🍃"><a href="#100-Happy-Ending💃🍃" class="headerlink" title="100. Happy Ending💃🍃"></a>100. Happy Ending💃🍃</h3><p>到了这儿，小编希望本文能帮助到有需要的童鞋，扎实基础知识（亦或是温习遗忘的知识点），温故而知新，逐渐提升。</p><h3 id="写在最后-🌼🌼"><a href="#写在最后-🌼🌼" class="headerlink" title="写在最后 🌼🌼"></a>写在最后 🌼🌼</h3><p>本篇文章会持续保持更新。文中若有不足，亦或是有小伙伴知道还有小编没有写入的知识点的，欢迎留言💌💌，小编看到后会第一时间加上。</p><p>最后，如果觉得文章对自身有所帮助，麻烦支持一下，因为小编最近有点点想升级（一直卡在最后，真是一言难尽），谢谢大家。后继小编会更加努力推出优质的文章回馈给需要的小伙伴。（发完文，感觉生活又开始美好了🌻🌻）</p><p><strong>更新</strong>：有关<a href="https://juejin.cn/post/6844904194474770445" title="https://juejin.cn/post/6844904194474770445">javascript</a>的知识点已更新🌈🌈</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/8/172917eba7a2309f~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp"></p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试的区别</title>
    <link href="/2023/01/29/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/01/29/%E9%9D%A2%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="1-箭头函数和普通函数的区别"><a href="#1-箭头函数和普通函数的区别" class="headerlink" title="1. 箭头函数和普通函数的区别"></a>1. 箭头函数和普通函数的区别</h2><p>a. 箭头函数和普通函数的样式不同，箭头函数语法更加简洁、清晰，箭头函数是<code>=&gt;</code>定义函数,普通函数是<code>function</code>定义函数。  </p><p>b. 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，定义的时候就确定并固定了。  </p><p>c. 箭头函数不能作为构造函数使用，也不能使用new关键字(<code>因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的this，且this指向永远不会改变,作为构造函数其的this要是指向创建的新对象</code>)。  </p><p>d. 箭头函数没有自己的arguments。在箭头函数中访问arguments实际上获得的是外层局部（函数）执行环境中的值。  </p><p>e. call、apply、bind 并不会影响其 this 的指向。  </p><p>f. 箭头函数没有原型prototype。  </p><p>g. 箭头函数不能当作 Generator 函数，不能使用 yield 关键字。  </p><h2 id="2-var，let和const之间的区别"><a href="#2-var，let和const之间的区别" class="headerlink" title="2. var，let和const之间的区别"></a>2. var，let和const之间的区别</h2><p>从以下<code>三个方面</code>说。  </p><p><strong>变量提升方面</strong>：var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined。<br>let和const不存在变量提升问题(<code>注意这个‘问题’后缀，其实是有提升的，只不过是let和const具有一个暂时性死区的概念，即没有到其赋值时，之前就不能用</code>)，即它们所声明的变量一定要在声明后使用，否则报错。  </p><p><strong>块级作用域方面</strong>：var不存在块级作用域,let和const存在块级作用域  </p><p><strong>声明方面</strong>：var允许重复声明变量,let和const在同一作用域不允许重复声明变量。其中const声明一个只读的常量(因为如此，其声明时就一定要赋值，不然报错)。一旦声明，常量的值就不能改变。  </p><p><strong>如何使const声明的对象内属性不可变，只可读呢？</strong><br>如果const声明了一个对象，对象里的属性是可以改变的。</p><div class="code-wrapper"><pre><code class="hljs sqf">const obj=&#123;<span class="hljs-built_in">name</span>:<span class="hljs-string">&#x27;蟹黄&#x27;</span>&#125;;obj.<span class="hljs-built_in">name</span>=<span class="hljs-string">&#x27;同学&#x27;</span>;console.<span class="hljs-built_in">log</span>(obj.<span class="hljs-built_in">name</span>);<span class="hljs-comment">//同学</span>复制代码</code></pre></div><p>因为const声明的obj只是保存着其对象的<strong>引用地址</strong>，只要地址不变，就不会出错。  </p><p>使用<code>Object.freeze(obj)</code> 冻结obj,就能使其内的属性不可变,但它有局限，就是obj对象中要是有属性是对象，该对象内属性还能改变，要全不可变，就需要使用递归等方式一层一层全部冻结。</p><h2 id="3-Bigint和Number的区别"><a href="#3-Bigint和Number的区别" class="headerlink" title="3. Bigint和Number的区别"></a>3. Bigint和Number的区别</h2><p>Number类型的数字<strong>有精度限制</strong>，数值的精度只能到 53 个二进制位（相当于 16 个十进制位, <code>正负9007199254740992</code>），大于这个范围的整数，就无法精确表示了。  </p><p>Bigint<strong>没有位数的限制，任何位数的整数都可以精确表示</strong>。但是其只能用于表示整数，且为了与Number进行区分，BigInt 类型的数据必须添加后缀n。BigInt 可以使用负号（-），但是不能使用正号（+）。  </p><p>另外number类型的数字和Bigint类型的数字<strong>不能</strong>混合计算。</p><p><code>12n+12;//报错</code></p><h2 id="4-基本数据类型和引用数据类型的区别"><a href="#4-基本数据类型和引用数据类型的区别" class="headerlink" title="4. 基本数据类型和引用数据类型的区别"></a>4. 基本数据类型和引用数据类型的区别</h2><p><strong>基本数据类型：</strong><br>a. 基本数据类型的值是不可变的(重新赋值属于改变属性名的指向了，而不是对值进行操作),这里你就可以联想到，<code>是不是所有关于字符串和数字的方法</code>都是带有<code>返回值</code>的，而不是改变原字符串或数字。<br>例如</p><div class="code-wrapper"><pre><code class="hljs arcade">let a=<span class="hljs-string">&#x27;abc&#x27;</span>;a.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&#x27;</span>);<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);<span class="hljs-comment">//abc</span>复制代码</code></pre></div><p>b. 基本数据类型不可以添加属性和方法，虽然不会报错，但也只是一瞬间转为了相应包装对象，操作完又转化回原基本数据类型，不会保存结果。  </p><p>c. 基本数据类型的赋值是简单赋值,基本数据类型的比较是值的比较。  </p><p>d. 基本数据类型是存放在栈区的  </p><p><strong>引用数据类型：</strong><br>a. 引用类型的值是可以改变的,例如对象就可以通过修改对象属性值更改对象。  </p><p>b. 引用类型可以添加属性和方法。  </p><p>c. 引用类型的赋值是对象引用,即声明的变量标识符，存储的只是对象的指针地址。  </p><p>d. 引用类型的比较是引用(<code>指针地址</code>)的比较。  </p><p>e. 引用类型是同时保存在栈区和堆区中的,栈区保存变量标识符和指向堆内存的地址。  </p><h2 id="5-defer和async的区别"><a href="#5-defer和async的区别" class="headerlink" title="5. defer和async的区别"></a>5. defer和async的区别</h2><p><code>大家应该都知道在script标签内有这两个属性async和defer，例如&lt;script src=&quot;./home.js&quot; async defer&gt;&lt;/script&gt;</code>  </p><p><strong>defer</strong>：中文意思是延迟。用途是表示脚本会被延迟到整个页面都解析完毕后再运行。因此，在<code>&lt;script&gt;</code>元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。<br>HTML5规范要求脚本按照它们出现的<code>先后顺序执行</code>，因此第一个延迟脚本会先于第二个延迟脚本执行,但执行脚本之间<code>存在依赖，需要有执行的先后顺序时</code>，就可以使用<code>defer</code>,延迟执行。我觉得把script脚本放在body底部和defer差不多。</p><p><strong>async</strong>：中文意思是异步，这个属性与defer类似，都用于改变处理脚本的行为。同样与defer类似，async只适用于外部脚本文件，并告诉浏览器立即下载文件。当页面继续进行解析时，脚本将被执行。与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。<br>指定async属性的目的是不让页面等待两个脚本下载和执行，从而<code>异步加载页面</code>其他内容,这使用于之间<code>互不依赖</code>的各脚本。</p><h2 id="看到这里，就能知道其的一些作用了"><a href="#看到这里，就能知道其的一些作用了" class="headerlink" title="看到这里，就能知道其的一些作用了"></a>看到这里，就能知道其的一些作用了</h2><p>当网页交给浏览器的HTML解析器转变成一系列的词语（Token）。解释器根据词语构建节点（Node），形成DOM树。因为JavaScript代码可能会修改DOM树的结构，所以节点是JavaScript代码的话，就需要停止当前DOM树的创建，直到JavaScript的资源加载并被JavaScript引擎执行后才继续DOM树的创建。<br>这里就会产生<strong>阻塞</strong>，出现<strong>白屏问题</strong>(白屏问题优化有很多方面，这里就脚本阻塞这一小点)，我们就可以使用<code>async和defer</code>属性来解决JavaScript脚本阻塞问题。  </p><p>当然最稳妥的办法还是把script标签放置在body的底部，没有兼容性问题，不会因此产生白屏问题，没有执行顺序问题。</p><p>最后总结：</p><ul><li>如果 async&#x3D;”async”：脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）</li><li>如果不使用 async 且 defer&#x3D;”defer”：脚本将在页面完成解析时执行</li><li>如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本</li></ul><h2 id="6-async-await对比promise的优缺点"><a href="#6-async-await对比promise的优缺点" class="headerlink" title="6. async await对比promise的优缺点"></a>6. async await对比promise的优缺点</h2><p><strong>async&#x2F;await优点</strong>：<br>a. 它做到了真正的串行的同步写法，代码阅读相对容易  </p><p>b. 对于条件语句和其他流程语句比较友好，可以直接写到判断条件里面  </p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">222</span>)      &#125;, <span class="hljs-number">2222</span>)    &#125;)  &#125;;<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">await</span> <span class="hljs-title function_">a</span>() === <span class="hljs-number">222</span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;yes, it is!&#x27;</span>) <span class="hljs-comment">// 会打印</span>      &#125;    &#125; <span class="hljs-keyword">catch</span> (err) &#123;      <span class="hljs-comment">// ...</span>    &#125;  &#125;复制代码</code></pre></div><p>c. 处理复杂流程时，在代码清晰度方面有优势  </p><p><strong>async&#x2F;await缺点</strong>：<br>a. 无法处理promise返回的reject对象，要借助try…catch…  </p><p>b. 用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</p><div class="code-wrapper"><pre><code class="hljs scss"><span class="hljs-comment">//promise</span>Promise<span class="hljs-selector-class">.all</span>([ajax1(), <span class="hljs-built_in">ajax2</span>()])复制代码</code></pre></div><p>c. try…catch…内部的变量无法传递给下一个try…catch…,Promise和then&#x2F;catch内部定义的变量，能通过then链条的参数传递到下一个then&#x2F;catch，但是async&#x2F;await的try内部的变量，如果用let和const定义则无法传递到下一个try…catch…，只能在外层作用域先定义好。</p><p><strong>但async&#x2F;await确确实实是解决了promise一些问题的。更加灵活的处理异步</strong>  </p><p><strong>promise的一些问题：</strong><br>a. 一旦执行，无法中途取消，链式调用多个then中间不能随便跳出来  </p><p>b. 错误无法在外部被捕捉到，只能在内部进行预判处理，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部  </p><p>c. Promise内部如何执行，监测起来很难，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）  </p><h2 id="7-get和post的区别"><a href="#7-get和post的区别" class="headerlink" title="7. get和post的区别"></a>7. get和post的区别</h2><p>a. GET 是将参数写在 <code>URL 中 ?</code> 的后面，并用 <code>&amp;</code> 分隔不同参数；而 POST 是将信息存放在 <code>Message Body</code> 中传送，参数‘不会’显示在 URL 中(Restful规范中是这样，但post在有需要时可以把参数放URL里)。GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。  </p><p>b. GET请求提交的数据有长度限制（<strong>HTTP 协议本身没有限制 URL 及正文长度</strong>,对 URL 的限制大多是浏览器和服务器的原因），POST请求没有内容长度限制。  </p><p>c. GET请求返回的内容会被浏览器缓存起来。而每次提交POST请求，浏览器不会缓存POST请求返回的内容。  </p><p>d. GET对数据进行查询，POST主要对数据进行增删改！简单说，GET是只读，POST是写。  </p><p>e. 关于安全性，GET 请求方式从浏览器的 URL 地址就可以看到参数；所以post更安全，其实无论是 GET 还是 POST 其实<strong>都是不安全的</strong>，因为 HTTP 协议是明文传输，只要拦截封包便能轻易获取重要资讯。想要安全传输资料，必须使用 SSL&#x2F;TLS来加密封包，也就是 HTTPS。  </p><p><strong>那为什么推崇使用post来处理敏感数据呢？</strong><br>因为get的记录会保存在浏览器，上网日志中，而使用Post，因为数据不会记录存储在浏览器的记录和网址访问记录中，这样会有更大的<strong>安全性</strong>。  </p><p>f.<strong>一个误区</strong> 说GET产生一个TCP数据包；POST产生两个TCP数据包<br><strong>其说法</strong>：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。  </p><p>对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。  </p><p><strong>为其正名</strong>:上面所说的post会比get多一个tcp包其实不太严谨。多发的那个expect 100 continue header报文，是<code>由客户端对http的post和get的请求策略决定</code>的，目的是为了避免浪费资源，如带宽，数据传输消耗的时间等等。所以客户端会在发送header的时候添加expect 100去探探路，如果失败了就不用继续发送data，从而减少了资源的浪费。所以是否再发送一个包取决了客户端的实现策略，和get&#x2F;post并没什么关系。有的客户端比如fireFox就只发送一个包。  </p><h2 id="8-用框架和不用框架的区别，vue和react的区别"><a href="#8-用框架和不用框架的区别，vue和react的区别" class="headerlink" title="8. 用框架和不用框架的区别，vue和react的区别"></a>8. 用框架和不用框架的区别，vue和react的区别</h2><p><strong>首先说说用框架和不用框架的区别：（以使用框架的角度看）</strong><br>框架好处：<br>a. 使用框架工具写项目，在浏览器中代码依然是原生的HTML CSS JS。而框架帮开发者做了很多事情，开发者只关注业务逻辑就可以,极大的加快了开发速度。<br>例如前端框架根本上是解决了<code>UI 与状态同步问题</code>,<code>频繁操作 DOM 性能低下</code>.<code>中间步骤过多,易产生 bug且不易维护</code>,而且<code>心智要求较高不利于开发效率</code>的一系列阻碍  </p><p>b. <code>组件化</code>: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。  </p><p>c. <code>天然分层</code>: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。  </p><p>d. <code>生态</code>: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案  </p><p>e. 待补充。。。(<strong>希望评论区能提出宝贵见解</strong>)</p><p>框架缺点：<br>a. 代码臃肿，使用者使用框架的时候会将整个框架引入，而框架封装了很多功能和组件，使用者必须按照它的规则使用，而实际开发中很多功能和组件是用不到的。  </p><p>b. 框架迭代更新速度非常快，需要时间熟悉它。  </p><p>c. 待补充。。。(<strong>希望评论区能提出宝贵见解</strong>)</p><p><strong>说说Vue和React的区别：</strong><br>这里就说说其思想差异(毕竟面试时不一定就要把两个框架差异说清楚，理解核心就好)：  </p><p><code>react整体是函数式的思想</code>，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；  </p><p><code>vue的思想是响应式的</code>，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。  </p><p>其他的细节差异可以看看这篇文章：<a href="https://juejin.cn/post/6844904040564785159" title="https://juejin.cn/post/6844904040564785159">关于Vue和React的一些对比</a></p><h2 id="9-cookies和session的区别"><a href="#9-cookies和session的区别" class="headerlink" title="9. cookies和session的区别"></a>9. cookies和session的区别</h2><p>a. <code>存储位置不同:</code>cookie的数据信息存放在客户端浏览器上，session的数据信息存放在服务器上。  </p><p>b. <code>存储容量不同:</code>单个cookie保存的数据&lt;&#x3D;4KB，一个站点最多保存20个Cookie，而对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。  </p><p>c. <code>存储方式不同:</code>cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。  </p><p>d. <code>隐私策略不同:</code>cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的，而session存储在服务器上，对客户端是透明的，不存在敏感信息泄漏的风险。  </p><p>e. <code>有效期上不同:</code>开发可以通过设置cookie的属性，达到使cookie长期有效的效果。session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。  </p><p>f. <code>服务器压力不同:</code>cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。  </p><p>g. <code>跨域支持上不同:</code>cookie支持跨域名访问(二级域名是可以共享cookie的)。session不支持跨域名访问。  </p><h2 id="10-宏任务和微任务有什么区别"><a href="#10-宏任务和微任务有什么区别" class="headerlink" title="10. 宏任务和微任务有什么区别"></a>10. 宏任务和微任务有什么区别</h2><p>微任务和宏任务皆为异步任务，它们都属于一个队列，主要<strong>区别在于他们的执行顺序，Event Loop的走向和取值</strong>。  </p><p><strong>宏任务和微任务的一些分配</strong></p><div class="code-wrapper"><pre><code class="hljs coffeescript">         宏任务          浏览器         NodeI/O      ✅✅<span class="hljs-built_in">setTimeout</span>✅✅<span class="hljs-built_in">setInterval</span>✅✅setImmediate    ❌✅requestAnimationFrame           ✅✅         微任务process.nextTick        ❌✅MutationObserver        ✅❌<span class="hljs-built_in">Promise</span>.<span class="hljs-keyword">then</span> <span class="hljs-keyword">catch</span> <span class="hljs-keyword">finally</span>              ✅✅复制代码</code></pre></div><p><strong>宏任务与微任务之间的执行顺序</strong>(同步任务-&gt;微任务-&gt;宏任务)<br>下面说说执行到宏任务后是怎么继续运行的<br>(这里声明下，整段js代码就是第一个大的宏任务，事件循环是由这第一个宏任务开始的，然后分出微任务，这里是为了理解微任务宏任务的执行区别就先跳过这第一层)  </p><p><code>说一个很有名的银行例子</code>：银行柜台前排着一条队伍，都是存钱的人，存钱属于宏任务，这条队伍就是宏任务队列，当一个‘宏大爷’被叫到了自己的号码，就上前去–被处理，处理存钱业务时，‘宏大爷’<strong>突然</strong>想给自己的存款办个微理财(<code>微任务</code>)，那么银行职员就将他的需求添加到自己的微任务队列，大爷就不用再排队了，直接在存钱宏任务进行完后就处理衍生出来的微任务理财，办理财时大爷又说办个信用卡，那就又排到微任务队列里。<strong>但要是</strong>在此次存钱时‘宏大爷’说他还要存钱，且是他老伴要存钱，也是<code>宏任务</code>，但不好意思，需要取号到宏任务队列的后面排队（这里就是在宏任务进行时产生微任务和宏任务的处理方式）。  </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b68f33891a3e418696c2258e96441d7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image"></p><p>结合下面的题目理解理解（这里先不介绍node环境的事件循环的特殊地方，主要以浏览器环境，最好看看底下推荐的文章）：  </p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//宏任务1</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);<span class="hljs-comment">//同步任务1</span></span><span class="language-javascript">      <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//微任务1</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>);<span class="hljs-comment">//同步任务2</span></span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//宏任务2</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;5&#x27;</span>);<span class="hljs-comment">//宏任务2中的同步任务</span></span><span class="language-javascript">      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;</span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;6&#x27;</span>);<span class="hljs-comment">//宏任务2中的同步任务</span></span><span class="language-javascript">        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<span class="hljs-comment">//宏任务2中的微任务</span></span><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x1&#x27;</span>);</span><span class="language-javascript">            <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">          &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;X2&#x27;</span>);</span><span class="language-javascript">          &#125;);</span><span class="language-javascript">        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//宏任务2中的宏任务</span></span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;X3&#x27;</span>);</span><span class="language-javascript">          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<span class="hljs-comment">//宏任务2中的宏任务中的同步任务</span></span><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;X4&#x27;</span>);</span><span class="language-javascript">            <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">          &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//宏任务2中的宏任务中的微任务</span></span><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;X5&#x27;</span>);</span><span class="language-javascript">          &#125;);</span><span class="language-javascript">        &#125;)</span><span class="language-javascript">        <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">      &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//宏任务2中的微任务</span></span><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;7&#x27;</span>);</span><span class="language-javascript">      &#125;);</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//宏任务3</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;8&#x27;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    <span class="hljs-comment">//（对于这段代码node环境和浏览器环境输出一致）</span></span><span class="language-javascript">    <span class="hljs-comment">//输出答案：2,4,3,1,5,6,x1,x2,7,8,x3,x4,x5</span></span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码</code></pre></div><p>上面这个例子我为了测试，可能搞得有点长。。。</p><p><a href="https://juejin.cn/post/6844903657264136200#heading-3" title="https://juejin.cn/post/6844903657264136200#heading-3">更多eventloop详细可看这篇文章</a></p><h2 id="11-fetch-Ajax-axios区别"><a href="#11-fetch-Ajax-axios区别" class="headerlink" title="11. fetch,Ajax,axios区别"></a>11. fetch,Ajax,axios区别</h2><p>Ajax是什么：Ajax是（Asynchronous JavaScript and XML）的缩写。现在，允许浏览器与服务器通信而无须刷新当前页面的技术都被叫做Ajax。核心使用<code>XMLHttpRequest</code>对象。  </p><p>axios是什么：axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上<code>也是对原生XHR</code>的封装，只不过它是Promise的实现版本，符合最新的ES规范。  </p><p>fetch是什么：Fetch被称为下一代Ajax技术,采用Promise方式来处理数据。是一种简洁明了的API，比XMLHttpRequest更加简单易用。  </p><p>所以其主要区别是 axios、fetch请求后都支持Promise对象API，ajax只能用回调函数。  </p><p>具体了解可看此文章<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/89089088" title="https://zhuanlan.zhihu.com/p/89089088">一文秒懂 ajax, fetch, axios</a></p><h2 id="12-TCP和UDP的区别"><a href="#12-TCP和UDP的区别" class="headerlink" title="12. TCP和UDP的区别"></a>12. TCP和UDP的区别</h2><p>a. TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。  </p><p>b. TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠， 面向连接，不会丢失数据因此适合大数据量的交换。  </p><p>c. TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因 此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。  </p><p>d. TCP 只能是 1 对 1 的，而UDP 支持 1 对 1,1 对多。  </p><p>e. TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。  </p><p>f. TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。  </p><h2 id="13-js中的堆和栈-栈和队列有什么区别"><a href="#13-js中的堆和栈-栈和队列有什么区别" class="headerlink" title="13. js中的堆和栈,栈和队列有什么区别"></a>13. js中的堆和栈,栈和队列有什么区别</h2><p><strong>堆(heap)和栈(stack)的区别:</strong>  </p><p>堆：队列优先,<strong>先进先出</strong>；由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。  </p><p>栈：<strong>先进后出</strong>；动态分配的空间 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。  </p><p><strong>栈和队列的区别：</strong>  </p><p>a. 栈只允许在表尾一端进行插入和删除，队列只允许在表尾一端进行插入，在表头一端进行删除。  </p><p>b. 栈是先进后出，队列是先进先出。  </p><h2 id="14-WebSocket和HTTP有什么区别"><a href="#14-WebSocket和HTTP有什么区别" class="headerlink" title="14. WebSocket和HTTP有什么区别"></a>14. WebSocket和HTTP有什么区别</h2><p><strong>相同点</strong><br>a. 都是一样基于TCP的，都是可靠性传输协议。  </p><p>b. 都是应用层协议。  </p><p><strong>不同点</strong><br>a. WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。  </p><p>b. WebSocket是需要握手进行建立连接的(相对HTTP来说，WebSocket是一种持久化的协议。它会基于HTTP协议，来完成一部分握手，HTTP握手部分完成，协议升级为WebSocket)。  </p><p>可以学习这篇文章<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/74326818" title="https://zhuanlan.zhihu.com/p/74326818">WebSocket其实没那么难</a></p><h2 id="15-http和https的区别"><a href="#15-http和https的区别" class="headerlink" title="15. http和https的区别"></a>15. http和https的区别</h2><p>a. HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。  </p><p>b. 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而<strong>需要一定费用</strong>。  </p><p>c. HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。  </p><p>d. http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。  </p><p>e. HTTPS 其实就是建构在 SSL&#x2F;TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。  </p><h2 id="16-px-em-rem-vw-vh区别"><a href="#16-px-em-rem-vw-vh区别" class="headerlink" title="16. px,em,rem,vw,vh区别"></a>16. px,em,rem,vw,vh区别</h2><p>px: px就是pixel的缩写，意为像素。px就是一张图片最小的一个点，一张位图就是千千万万的这样的点构成的。  </p><p>em: <strong>参考物是父元素</strong>的font-size，具有继承的特点。如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。  </p><p>rem: css3新单位，<strong>相对于根元素html</strong>（网页）的font-size，不会像em那样，依赖于父元素的字体大小，而造成混乱。  </p><p>vw: css3新单位，viewpoint width的缩写，<strong>视窗宽度</strong>，1vw等于视窗宽度的1%。<br>举个例子：浏览器宽度1200px, 1 vw &#x3D; 1200px&#x2F;100 &#x3D; 12 px。  </p><p>vh: css3新单位，viewpoint height的缩写，<strong>视窗高度</strong>，1vh等于视窗高度的1%。<br>举个例子：浏览器高度900px, 1 vh &#x3D; 900px&#x2F;100 &#x3D; 9 px。  </p><h2 id="17-wepack中loader和plugin的区别"><a href="#17-wepack中loader和plugin的区别" class="headerlink" title="17. wepack中loader和plugin的区别"></a>17. wepack中loader和plugin的区别</h2><p><strong>什么是loader?</strong><br>loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中  </p><p><strong>什么是plugin？</strong><br>在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果。  </p><p><strong>区别：</strong>  </p><ul><li>对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程</li><li>plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务</li></ul><h2 id="18-bind-call-apply区别"><a href="#18-bind-call-apply区别" class="headerlink" title="18. bind call apply区别"></a>18. bind call apply区别</h2><p>a. 三者都可以改变函数的this对象指向。  </p><p>b. 三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。  </p><p>c. 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。  </p><p>d. bind 改变this指向后不会立即执行，而是返回一个永久改变this指向的函数便于稍后调用； apply, call则是立即调用  </p><h2 id="19-301-和-302-有什么区别"><a href="#19-301-和-302-有什么区别" class="headerlink" title="19. 301 和 302 有什么区别"></a>19. 301 和 302 有什么区别</h2><p><code>301 Moved Permanently:</code> 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应 当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也 是可缓存的。  </p><p><code>302 Found:</code> 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。  </p><p>字面上的区别就是 301 是永久重定向，而 302 是临时重定向。  </p><p>301 比较常用的场景是使用域名跳转。302 用来做临时跳转, 比如未登陆的用户访问用户中心被重定向到登录页面  </p><h2 id="20-进程线程的区别"><a href="#20-进程线程的区别" class="headerlink" title="20. 进程线程的区别"></a>20. 进程线程的区别</h2><p>a. <strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><p>b. <strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><p>c. <strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><p>d. <strong>内存分配</strong>：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p><p>e. <strong>影响关系</strong>：因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程要比多线程健壮。  </p><p>还可看看：<br><a href="https://link.juejin.cn/?target=http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" title="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">阮一峰对进程线程的简单解释</a><br><a href="https://juejin.cn/post/6844903908385488903" title="https://juejin.cn/post/6844903908385488903">深入理解Node.js 中的进程与线程</a></p><h2 id="21-JavaScript和typescript的区别"><a href="#21-JavaScript和typescript的区别" class="headerlink" title="21. JavaScript和typescript的区别"></a>21. JavaScript和typescript的区别</h2><p>a. TypeScript 从核心语言方面和类概念的模塑方面对 JavaScript 对象模型进行扩展。</p><p>b. JavaScript 代码可以在无需任何修改的情况下与 TypeScript 一同工作，同时可以使用编译器将 TypeScript 代码转换为 JavaScript。</p><p>c. TypeScript 通过类型注解提供编译时的静态类型检查。</p><p>d. TypeScript 中的数据要求带有明确的类型，JavaScript不要求。</p><p>e. TypeScript 为函数提供了缺省参数值。</p><p>f. TypeScript 引入了 JavaScript 中没有的“类”概念。</p><p>h. TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。</p><h2 id="22-localstorage、sessionstorage、cookie的区别"><a href="#22-localstorage、sessionstorage、cookie的区别" class="headerlink" title="22. localstorage、sessionstorage、cookie的区别"></a>22. localstorage、sessionstorage、cookie的区别</h2><p>a. 相同点是都是保存在浏览器端、且同源的</p><p>b. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p><p>c. 存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</p><p>d. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭</p><p>e. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</p><p>f. webStorage(<code>webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage</code>)支持事件通知机制，可以将数据更新的通知发送给监听者</p><p>h. webStorage的api接口使用更方便</p><h2 id="23-http-1-0-x2F-1-1-x2F-2-0的不同"><a href="#23-http-1-0-x2F-1-1-x2F-2-0的不同" class="headerlink" title="23. http 1.0&#x2F; 1.1&#x2F; 2.0的不同"></a>23. http 1.0&#x2F; 1.1&#x2F; 2.0的不同</h2><p><strong>http 1.0(构建可扩展性)</strong><br>HTTP原有的应用非常局限，浏览器和服务器迅速扩展使其用途更广：</p><p>a. 版本信息现在会随着每个请求发送（HTTP1.0 被追加到GET行）</p><p>b. 状态代码行也会在响应开始时发送，允许浏览器本身了解请求的成功或失败，并相应地调整其行为（如以特定方式更新或使用本地缓存）</p><p>c. 引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，并使协议非常灵活和可扩展。</p><p>d. Content-Type标头告诉客户端实际返回的内容的内容类型。在Content-Type标头帮助下，增加了传输除纯文本HTML文件外的其他类型文档的能力。</p><p><strong>http 1.1(标准化的协议)</strong><br>HTTP&#x2F;1.0的多种不同的实现运用起来有些混乱，HTTP1.1是第一个标准化版本，重点关注的是校正HTTP设计中的结构性缺陷：</p><p>a. 连接可以重复使用，节省了多次打开它的时间，以显示嵌入到单个原始文档中的资源。</p><p>b. 增加流水线操作，允许在第一个应答被完全发送之前发送第二个请求，以降低通信的延迟。</p><p>c. 支持响应分块。</p><p>d. 引入额外的缓存控制机制。</p><p>e. 引入内容协商，包括语言，编码，或类型，并允许客户端和服务器约定以最适当的内容进行交换。</p><p>f. 通过 Host 头，能够使不同的域名配置在同一个IP地址的服务器。</p><p>g. 安全性得到了提高</p><p><strong>http 2.0(为了更优异的表现)</strong><br>HTTP&#x2F;2在HTTP&#x2F;1.1有几处基本的不同:</p><p>HTTP2是二进制协议而不是文本协议。不再可读和无障碍的手动创建，改善的优化技术现在可被实施。</p><p>这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP&#x2F;1.x中顺序和阻塞的约束。</p><p>压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</p><p>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</p><p><a href="https://link.juejin.cn/?target=https://www.cnblogs.com/zytrue/p/8568181.html" title="https://www.cnblogs.com/zytrue/p/8568181.html">参考自这篇文章</a></p><h2 id="24-MongoDB和MySQL的区别"><a href="#24-MongoDB和MySQL的区别" class="headerlink" title="24. MongoDB和MySQL的区别"></a>24. MongoDB和MySQL的区别</h2><p>直接放上对比表格：  </p><table><thead><tr><th>数据库</th><th>MongoDB</th><th>MySQL</th></tr></thead><tbody><tr><td>数据库模型</td><td>非关系型</td><td>关系型</td></tr><tr><td>存储方式</td><td>以类JSON的文档的格式存储</td><td>不同引擎有不同的存储方式</td></tr><tr><td>查询语句</td><td>MongoDB查询方式（类似JavaScript的函数）</td><td>SQL语句</td></tr><tr><td>数据处理方式</td><td>基于内存，将热数据存放在物理内存中，从而达到高速读写</td><td>不同引擎有自己的特点</td></tr><tr><td>成熟度</td><td>新兴数据库，成熟度较低</td><td>成熟度高</td></tr><tr><td>广泛度</td><td>NoSQL数据库中，比较完善且开源，使用人数在不断增长</td><td>开源数据库，市场份额不断增长</td></tr><tr><td>事务性</td><td>仅支持单文档事务操作，弱一致性</td><td>支持事务操作</td></tr><tr><td>占用空间</td><td>占用空间大</td><td>占用空间小</td></tr><tr><td>join操作</td><td>MongoDB没有join</td><td>MySQL支持join</td></tr></tbody></table><p>希望各位看官指出其中的错误，我必改正！也请对其中的一些问题提出自己的一些看法。这里只是一些大概的总结，想要有最好的学习效果，还是对其中每有一个点进行系统的学习。</p><p>笔者最近也在准备面试和寻找前端实习岗位中！wx：xieHB-frontend-178,加个微信一起学习😜，也希望有大佬介绍个内推和提出学习意见，感谢。哈哈！</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack攻略</title>
    <link href="/2023/01/29/webpack%E6%94%BB%E7%95%A5/"/>
    <url>/2023/01/29/webpack%E6%94%BB%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack简介"><a href="#webpack简介" class="headerlink" title="webpack简介"></a>webpack简介</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本质上，webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。</p><p>webpack的核心概念为以下模块，后续会对以下概念针对性输出文章。</p><ul><li><p>入口（entry）</p></li><li><p>输出（output）</p></li><li><p>loader</p></li><li><p>插件（plugin）</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>webpack 对操作系统没有要求，使用 Windows、Mac、Linux 操作系统均可，它唯一的依赖是 Node.js，所以使用 webpack 前需要先安装 Node.js，安装地址为 [Nodejs]](<a href="https://leetcode.cn/link/?target=http://nodejs.cn/download/">http://nodejs.cn/download/</a>) 推荐安装TLS（长期维护）版本。node 安装完成后，在命令行输入 node -v，可显示版本号即安装成功。<br>接下来，我们需要使用 Node.js 的包管理器 npm 来安装 webpack ，安装模块的方式有两种：一种是全局安装，一种是本地安装，此处我们选择本地安装，主要有以下两点原因：</p><ol><li>如果采用全局安装，那在与他人协作时，由于每个人的 webpack 版本不同，可能导致打包出的内容不一致</li><li>通常会通过运行一个或多个 npm scripts 以在本地 node_modules 目录中查找安装的 webpack，来运行 webpack，所以在这种情况下可能导致本地全局都有，容易造成混淆</li></ol><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>基于以上两点，我们选择在项目内安装，首先新建一个工程目录，并执行 npm 的初始化命令</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> webpack_init &amp;&amp; <span class="hljs-built_in">cd</span> webpack_initnpm init</code></pre></div><p>命令行输入项目的基本信息，如：名称、版本、描述、仓库地址等信息。成功后工程目录中会出现一个 package.json 文件。<br>接下来输入安装webpack的命令：</p><div class="code-wrapper"><pre><code class="hljs q">npm install webpack webpack-cli --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span></code></pre></div><p>webpack v4+ 版本都需要手动安装 webpack-cli，webpack-cli 提供了许多命令用于在命令行中运行 webpack。具体包含命令可查看文档[webpack-cli]](<a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/api/cli/">https://webpack.docschina.org/api/cli/</a>) 检查安装是否成功执行 webpack -v ， webpack-cli -v ，显示对应版本则安装成功</p><h2 id="打包第一个应用"><a href="#打包第一个应用" class="headerlink" title="打包第一个应用"></a>打包第一个应用</h2><p>在 webpack_init 文件夹下添加 index.html、src 文件夹下添加 index.js、hello.js 文件</p><p>index.html</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>src&#x2F;index.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> helloWorld <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hello.js&#x27;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">component</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);   element.<span class="hljs-property">innerHTML</span> = <span class="hljs-title function_">helloWorld</span>();  <span class="hljs-keyword">return</span> element;&#125;<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(<span class="hljs-title function_">component</span>());</code></pre></div><p>src&#x2F;hello.js</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world!!!&#x27;</span>&#125;</code></pre></div><p>在控制台输入打包命令 npx webpack，</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">npx webpack</span></code></pre></div><p>因为 npm 会从全局模块中找 webpack ，但是我并非全局安装，而是项目本地安装，所以报错。所以需要 npx 命令运行命令。npx 会先找当前目录下的 node_modules&#x2F;.bin 目录下的二进制可执行文件，如果当前目录下没有 npx 会在 PATH 目录下继续寻找，如果没有会自动下载安装 webpack。此时，第一步手动安装 npm install webpack –save-dev 可省略。执行命令成功后会在项目中增加一个 dist 文件，文件中有一个打包后的 main.js 文件。<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453743-XEjonp-2.png" alt="2.png"></p><p>此时我们在浏览器中打开 index.html 文件，在页面中看到 hello world!!!<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453821-swEKUQ-1.png" alt="1.png"></p><p>在上面的命令中，我们采用了 webpack 的默认设置，我们也可以在命令行中指定入口文件、输出文件、打包模式等信息</p><div class="code-wrapper"><pre><code class="hljs routeros">npx webpack <span class="hljs-attribute">--entry</span>=./src/index.js <span class="hljs-attribute">--output-filename</span>=bundle.js <span class="hljs-attribute">--mode</span>=development</code></pre></div><p>删除 webpack 默认配置打包的内容，重新执行带配置的命令，打包后在 dist 目录下生成了 bundle.js 文件，将 index.html 中引入 js 文件地址 main.js 改为 bundle.js，在浏览器打开 index.html 发现控制台再一次输出了 hello world!!!。</p><h2 id="使用-npm-scripts"><a href="#使用-npm-scripts" class="headerlink" title="使用 npm scripts"></a>使用 npm scripts</h2><p>从上面的命令行配置打包例子来看，每次打包都需要在命令行输入冗长的命令，这样做会很耗时和容易出错，为了使命令更加简洁，可以在 package.json 文件中的”scripts”对象下添加一个打包命令脚本 build。<br>scripts 是 npm 提供的脚本命令功能，所以在这里我们可以直接使用 webpack 命令取代之前的 npx webpack。</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>在控制台输入npm命令，打包成功<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453846-cPODUe-3.png" alt="3.png"></p><div class="code-wrapper"><pre><code class="hljs routeros">npm <span class="hljs-built_in">run</span> build</code></pre></div><h2 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h2><p>在 webpack4 中，可以无需配置采用默认方式打包，直接在控制台输入 npx webpack 即可打包，然后大多数项目需要很复杂的设置，如项目分包、压缩、懒加载等，所以大多数情况下还是需要一个配置文件，webpack 默认加载的配置文件为 webpack.config.js，也可以指定 webpack 配置文件，需要命令行指定。</p><h3 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><p>在项目 webpack_init 中新建一个 webpack.config.js 文件</p><p>webpack.config.js</p><div class="code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-built_in">module</span>.exports = &#123;  entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,  <span class="hljs-built_in">output</span>: &#123;    filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)  &#125;&#125;;</code></pre></div><p>上面通过 module.exports 导出了一个对象，将之前命令行中输入的 key-value 形式的参数放在这个对象中。<br>这个对象包含连个属性，entry 为项目入口文件，output 为打包出口文件，其中 filename 为打包文件名称，path 为文件打包路径。通过调用 node.js 的path模块，将 __dirname(node.js内置全局变量，__dirname 为当前文件所在目录的绝对路径)与输出路径连接起来，得到了最终资源输出路径。</p><p>现在我们去掉 package.json 中 build 后面的参数去掉，只保留 “build”: “webpack”，然后在控制台输入 npm run build，打包成功了<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453847-kbCvea-4.png" alt="4.png"></p><h3 id="使用不同的配置文件"><a href="#使用不同的配置文件" class="headerlink" title="使用不同的配置文件"></a>使用不同的配置文件</h3><p>出于某种原因，需要根据特定情况使用不同的配置文件，则可以通过在命令行中使用 –config 标志修改<br>删除项目中的 webpack-config.js，新建一个 webpack-config-dev.js，内容和 webpack-config.js 一致。在命令行输入npm run build –config webpack.config.dev.js 或者在 package.json 的 scripts 中增加配置</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.config.dev.js&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span></code></pre></div><p>执行打包命令后。打包结果如下<br><img src="/../imgs/webpack%E6%94%BB%E7%95%A5/1655453849-gYWreG-5.png" alt="5.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在上面我们介绍了</p><ul><li>webpack 的作用及包含核心模块</li><li>如何从零安装一个 webpack 运行环境</li><li>打包第一个 webpack 项目</li><li>告别命令行，通过配置文件打包 webpack</li></ul><p>下一节我们将介绍下 webpack 的配置文件，包含的参数及作用。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端通关手册-React</title>
    <link href="/2023/01/28/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/"/>
    <url>/2023/01/28/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/</url>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h3 id="Hello-React"><a href="#Hello-React" class="headerlink" title="Hello, React :-)"></a>Hello, React :-)</h3><p>React 是用于构建用户界面的 JavaScript 库，React 核心只关注视图，不断优化算法，改进性能，提高开发和交互体验。</p><p>React 迭代稳定，重视兼容和过渡，在国内外，尤其是南方，都有相当多的公司在使用 React。</p><p>渐进式的思想同样表现在 React 的学习曲线上，能够与传统的 Web 技术共存，灵活的 JSX 语法等都会让 React 上手很快， 而庞大生态赋予了 React 更强能力的同时，也让开发者感叹花费了更多时间在社区里遨游。</p><h3 id="React-应用"><a href="#React-应用" class="headerlink" title="React 应用"></a>React 应用</h3><p>React 在前端开发领域应用广泛，使用 React 可以构建 Web，插件，单页应用，App，小程序，桌面端，服务端等，微服务，Serverless，低代码，虚拟现实等都有 React 的用武之地。</p><h3 id="React-面试注意事项"><a href="#React-面试注意事项" class="headerlink" title="React 面试注意事项"></a>React 面试注意事项</h3><p>React 面试题可以分为以下 4 个方面</p><ul><li>基础：ES5+ 作用域，class，箭头函数，this 指向，异步编程，高阶函数的循环等常问</li><li>会用：state，副作用，Hook，加载渲染过程，路由、测试、调试、TS、Redux 等常问</li><li>原理：Virtual DOM，Diff 算法，设计组件，优化性能，原理和实现等高级岗位、大厂常问</li><li>项目：项目结构，技术栈，工具链，解决问题，担任角色，亮点等常问，也是面试问题来源</li></ul><p>新手最好先熟练 ES5+ 的使用，再上手 React 时，可以边阅读边写代码，适当练习若干项目，再看原来生涩的表述，会有亲切的画面感。带着项目去看面试题，联想练习或工作中遇到的实际问题，加上自己的理解，你的回答一定可以比手册总结得更自然，更能得到面试官的肯定。</p><h3 id="对比-React-和-Vue-？"><a href="#对比-React-和-Vue-？" class="headerlink" title="对比 React 和 Vue ？"></a>对比 React 和 Vue ？</h3><p>相同点</p><ul><li>支持 Virtual DOM</li><li>支持响应式和组件化的视图组件</li><li>核心库、路由和状态管理分离</li><li>支持 JSX，移动端都支持原生渲染</li></ul><p>不同点</p><ul><li><p>预编译</p><ul><li>React 可以通过 Prepack 优化 JavaScript 源代码，在编译时执行原本在运行时的计算过程，通过简单的赋值序列提高 JavaScript 代码的执行效率，消除中间计算过程及分配对象操作。缓存 JavaScript 解析结果，优化效果最佳</li><li>Vue 可以静态分析 template，构造 AST 树，通过 PatchFlags 标记节点变化类型</li></ul></li><li><p>渲染</p><ul><li>React 通过 shouldComponentUpdate &#x2F; setState，使用 PureCompoent 等对比前后状态和属性，手动决定是否渲染来优化</li><li>Vue 推荐模板语法，自动追踪组件依赖，精确渲染状态改变的组件</li></ul></li><li><p>事件处理</p><ul><li><p>React</p><ul><li>React 17前，事件委托到 document，之后委托到 根节点</li><li>所有事件被合并为合成事件并兼容不同浏览器</li><li>事件处理函数中的 this 需要手动绑定或使用箭头函数声明</li></ul></li><li><p>Vue</p><ul><li><p>原生事件</p></li><li><p>this 自动绑定执行上下文</p></li></ul></li></ul></li></ul><h3 id="什么是-React"><a href="#什么是-React" class="headerlink" title="什么是 React ?"></a>什么是 React ?</h3><p>React 是用于构建用户界面的 JavaScript 库</p><ul><li>声明式编写 UI，代码可靠，便于调试</li><li>组件化开发，组件逻辑使用 JavaScript 编写而非模板，遵循单向数据流和数据绑定，状态与 DOM 分离</li><li>一次学习，随处编写，使用 Virtual DOM，支持 浏览器、Node 服务器等多种渲染方式 和 React Native 开发原生应用</li></ul><h3 id="对比-React-和-Angular"><a href="#对比-React-和-Angular" class="headerlink" title="对比 React 和 Angular ?"></a>对比 React 和 Angular ?</h3><ul><li>核心功能<ul><li>React 核心库只提供构建 UI 组件的方法，其他功能通过社区提供</li><li>Angular 集成了 路由、异步请求、表单、模块化 CSS 等功能</li></ul></li><li>组件<ul><li>React 组件推荐使用 JSX，可以一个文件包含 HTML、CSS 和 JS，也可以分开</li><li>Angular 组件 HTML、CSS 和 TS 分别是一个文件</li></ul></li><li>DOM<ul><li>React 基于 Virtual DOM，组件会被编译成 JS 对象，数据更改时通过 Diff 算法更新</li><li>Angular 基于 Incremental DOM，组件会被编译成指令，数据更改时就地更新。没有使用规定指令的组件可以被 Tree Shaking</li></ul></li><li>数据绑定<ul><li>React 单向数据绑定，声明状态，更新视图</li><li>Angular 双向数据绑定，数据改变，更新视图</li></ul></li><li>全局状态管理<ul><li>Angualr 可以用 Service 依赖注入实现</li><li>React 可以用全局对象或 Redux 实现</li></ul></li><li>上手成本<ul><li>React 推荐了解 JSX，是库，可以渐进式使用</li><li>Angluar 需要了解 TypeScript，Rxjs，OOP 和装饰器等，是框架，推荐独立使用</li></ul></li></ul><h3 id="你认为-React-的缺点是什么？"><a href="#你认为-React-的缺点是什么？" class="headerlink" title="你认为 React 的缺点是什么？"></a>你认为 React 的缺点是什么？</h3><ul><li>React 核心是 UI 库，路由，状态管理等由社区维护。细粒度需求和问题依赖社区解决</li><li>React 概念和约束较少，容易上手并与现有项目整合。代码风格和项目结构容易产生差别</li><li>React JSX 灵活性高，预编译时可以做的优化相对其他 HTML 分离的库有限</li><li>React setState 提供基于队列异步更新，手动优化渲染流程，需要关注业务之外的逻辑</li><li>React17 以前基于事件委托的合成事件，表现和使用与原生事件存在差异</li></ul><h3 id="什么是声明式编程？"><a href="#什么是声明式编程？" class="headerlink" title="什么是声明式编程？"></a>什么是声明式编程？</h3><ul><li>声明式编程是一种编程范式，描述目标，而不是流程</li><li>通过函数、推理规则或者重写规则，来描述变量间关系</li><li>通过编译器采用固定算法，使得这些关系产生结果</li></ul><h3 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h3><ul><li>函数式编程是一种编程范式，它是声明式编程的子集</li><li>避免使用状态、异变对象，最小化副作用</li><li>基于 lambda 演算，函数可以作为入参和出参</li></ul><h3 id="MVC-和-MVVM-的区别是？"><a href="#MVC-和-MVVM-的区别是？" class="headerlink" title="MVC 和 MVVM 的区别是？"></a>MVC 和 MVVM 的区别是？</h3><p>相同点</p><ul><li>目的相同：分离模型 Model 和视图 View</li></ul><p>不同点</p><ul><li>MVC<ul><li>构成：模型 Model - 视图 View - 控制器 Controller</li><li>分为主动 MVC 和 被动 MVC<ul><li>主动 MVC：视图订阅数据更新</li><li>被动 MVC：控制器操作视图</li></ul></li><li>渲染<ul><li>后端返回 HTML，利于 SEO</li><li>后端返回数据，前端使用模板引擎或操作 DOM</li></ul></li></ul></li><li>MVVM<ul><li>构成：模型 Model - 视图 View - 视图模型 ViewModel</li><li>ViewModel 单向或双向数据绑定 View 和 Model 层，实现自动同步</li><li>渲染<ul><li>后端减少关心视图，前端 SSR 利于 SEO</li><li>前端减少操作 DOM</li></ul></li></ul></li></ul><h3 id="如何组织-React-项目文件结构？"><a href="#如何组织-React-项目文件结构？" class="headerlink" title="如何组织 React 项目文件结构？"></a>如何组织 React 项目文件结构？</h3><p>React 建议</p><ul><li>项目目录嵌套最多3到4个层级</li><li>不要过度思考</li><li>没有官方推荐的组织方式，常见组织方式包括<ul><li>按功能和路由组织：相同功能或路由的 CSS、JS 和 测试文件放入同一目录</li><li>按文件类型组织：组件、页面、API、状态管理、静态文件分类存放</li></ul></li></ul><h3 id="如何组织-React-项目文件结构？-1"><a href="#如何组织-React-项目文件结构？-1" class="headerlink" title="如何组织 React 项目文件结构？"></a>如何组织 React 项目文件结构？</h3><p>React 建议</p><ul><li>项目目录嵌套最多3到4个层级</li><li>不要过度思考</li><li>没有官方推荐的组织方式，常见组织方式包括<ul><li>按功能和路由组织：相同功能或路由的 CSS、JS 和 测试文件放入同一目录</li><li>按文件类型组织：组件、页面、API、状态管理、静态文件分类存放</li></ul></li></ul><h3 id="React-18-都有哪些新特性？"><a href="#React-18-都有哪些新特性？" class="headerlink" title="React 18 都有哪些新特性？"></a>React 18 都有哪些新特性？</h3><ul><li>新的 Root API：ReactDom.creatRoot<ul><li>React 17 及之前版本<ul><li>通过 ReactDom.render 将应用渲染到页面的根元素</li><li>有限的自动批量处理<ul><li>如在浏览器事件触发多个状态更改，自动批量更新</li><li>而在异步函数中多个状态更改，不会批量更新</li></ul></li></ul></li><li>React 18<ul><li>可选通过 ReactDom.creatRoot 将应用渲染到页面的根元素</li><li>确保安全的前提下<ul><li>如对于每个用户触发的事件，在下一个事件前完成渲染</li><li>尽可能地多应用自动批量处理，包括异步函数中的多个状态更新</li></ul></li><li>可选 ReactDom.flushSync 退出批量更新</li></ul></li></ul></li><li>SSR 支持 React.lazy 和 React.Suspense<ul><li>React 17 及之前版本<ul><li>React.lazy() 和 React.Suspense 尚未在 ReactDOMServer 中支持</li></ul></li><li>React 18<ul><li>全新的 SSR 架构内置支持 React.lazy() 和 React.Suspense</li></ul></li></ul></li><li>startTransition<br>* React 17 及以前版本<br>* 所有更新都被紧急渲染<br>* 使用 <code>setTimeout</code> 和 防抖等方式，避免频繁更新<br>* React 18<br>* 所有渲染分为紧急和非紧急<br>* 非紧急渲染使用 <code>startTransition</code> 包裹<br>* 非紧急渲染的延迟时间由设备决定<br>* 非紧急渲染可中断，不会影响响应用户输入、动画等紧急渲染</li></ul><h3 id="什么是-JSX-？"><a href="#什么是-JSX-？" class="headerlink" title="什么是 JSX ？"></a>什么是 JSX ？</h3><ul><li><p>JSX 是 JavaScript 的语法扩展，生成 React 元素</p></li><li><p>JSX 是</p><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(component, props, ...children)</code></pre></div><p>函数的语法糖</p><ul><li>React 17 RC 开始，由编辑器自动引入 <code>import &#123; jsx &#125; from &#39;react/jsx-runtime&#39;</code></li></ul></li><li><p>JSX 支持 HTML 模板语法 和 表达式，支持条件和循环渲染，支持点语法和展开运算符</p></li><li><p>JSX 转义所有输入内容，防止注入攻击</p></li><li><p>JSX 忽略渲染 <code>false</code>，<code>null</code>，<code>undefined</code>，<code>true</code> 子元素</p></li></ul><h3 id="为什么推荐在-React-中使用-JSX-？"><a href="#为什么推荐在-React-中使用-JSX-？" class="headerlink" title="为什么推荐在 React 中使用 JSX ？"></a>为什么推荐在 React 中使用 JSX ？</h3><ul><li>React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合<ul><li>UI 中绑定处理事件</li><li>状态更新时通知 UI</li><li>UI 中展示数据</li></ul></li><li>React 将标记和逻辑共同存放在组件，实现关注点分离</li><li>React 不强制要求使用 JSX，但 JSX 与 UI 一起有视觉辅助作用</li><li>React 通过 JSX 可以显示更多有用错误和警告消息</li></ul><h3 id="为什么-JSX-可以有效降低-XSS-风险？"><a href="#为什么-JSX-可以有效降低-XSS-风险？" class="headerlink" title="为什么 JSX 可以有效降低 XSS 风险？"></a>为什么 JSX 可以有效降低 XSS 风险？</h3><ul><li>React DOM 在渲染所有输入内容前，默认会将它们转义成字符串，有效降低 XSS 风险</li><li>可以通过<code>dangerouslySetInnerHTML = &#123;&#123; __html: HTML &#125;&#125;</code>来显示转义前的内容</li></ul><h3 id="如何在-JSX-中条件渲染？"><a href="#如何在-JSX-中条件渲染？" class="headerlink" title="如何在 JSX 中条件渲染？"></a>如何在 JSX 中条件渲染？</h3><ul><li><p>if &#x2F; else 语句</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">if</span> (condition) <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span></span><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>&#125;</code></pre></div><ul><li><p>三元运算符</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> condition ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span></span> : <span class="hljs-literal">null</span>&#125;</code></pre></div><ul><li><p>逻辑运算符</p></li><li><p>plain</p></li></ul><div class="code-wrapper"><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> condition &amp;&amp; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span></span>&#125;</code></pre></div><ul><li><p>条件渲染组件</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs jsx">render () &#123;<span class="hljs-keyword">const</span> <span class="hljs-title function_">Condition</span> = props =&gt; &#123;<span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">If</span>, children &#125; = props<span class="hljs-keyword">return</span> <span class="hljs-title class_">If</span> &amp;&amp; children&#125;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Condition</span> <span class="hljs-attr">If</span>=<span class="hljs-string">&#123;true&#125;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Condition</span>&gt;</span></span>&#125;</code></pre></div><h3 id="如何在-JSX-中循环控制？"><a href="#如何在-JSX-中循环控制？" class="headerlink" title="如何在 JSX 中循环控制？"></a>如何在 JSX 中循环控制？</h3><ul><li>map 将数组每一项转成 UI，flatMap filter 等能返回数组的循环方法也被支持</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> &#123; data &#125; = props<span class="hljs-keyword">return</span> data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span>)&#125;</code></pre></div><ul><li>使用 javaScript 的循环（for &#x2F; while &#x2F; do while），将结果存储到变量，将变量代入 JSX</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> &#123; data &#125; = props<span class="hljs-keyword">const</span> datas = <span class="hljs-title class_">Array</span>(data.<span class="hljs-property">length</span>)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">const</span> item = data[i]datas[i] = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span>&#125;<span class="hljs-keyword">return</span> datas&#125;</code></pre></div><ul><li>使用 lodash 等第三方库或自定义可以返回数组的方法，以 lodash 为例</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> &#123; data &#125; = props<span class="hljs-keyword">return</span> _.<span class="hljs-title function_">times</span>(data.<span class="hljs-property">length</span>, <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">b</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;data[i].id&#125;</span>&gt;</span>&#123;data[i].text&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span></span>)&#125;</code></pre></div><h3 id="为什么-JSX-中-class-变成了-className"><a href="#为什么-JSX-中-class-变成了-className" class="headerlink" title="为什么 JSX 中 class 变成了 className ?"></a>为什么 JSX 中 class 变成了 className ?</h3><ul><li>JSX 语法上更接近 JavaScript 而不是 HTML<ul><li>HTML 属性值通常为字符串</li><li>HTML DOM 对象属性值可以是任意数据类型</li></ul></li><li>JSX 的 className 更接近 HTML DOM 对象的属性，并且支持属性拓展运算符</li><li>JSX 通过匹配闭合标签提升可读性，而不是代替 HTML<ul><li>JSX 与 HTML 需要转换，直接使用 class 也无法避免其它转换工作</li></ul></li></ul><h3 id="什么是-React-组件？"><a href="#什么是-React-组件？" class="headerlink" title="什么是 React 组件？"></a>什么是 React 组件？</h3><ul><li>React 组件允许用户将 UI 拆分成独立可复用的代码片段，并对每个片段进行独立构思</li><li>React 组件从概念上类似于 JavaScript 函数</li><li>React 组件接受任意的入参 Props，返回用于描述页面展示内容的 React 元素</li></ul><h3 id="React-组件分成哪几类？"><a href="#React-组件分成哪几类？" class="headerlink" title="React 组件分成哪几类？"></a>React 组件分成哪几类？</h3><ul><li>按定义分类<ul><li>类组件，使用 ES6 的 class 定义，维护 state，有生命周期</li><li>函数组件，使用普通函数定义，可以通过 hooks 维护状态和副作用</li></ul></li><li>按状态分<ul><li>有状态组件，组件返回结果，受时间、空间或上下文影响</li><li>无状态组件，通常是纯展示 UI 组件，容易复用</li></ul></li><li>按定位分<ul><li>展示型组件，接收 props，负责 UI 展示</li><li>容器组件，管理 states，负责数据获取和组件间通信，多用于状态提升</li></ul></li><li>按 React 内置类型分类<ul><li>有状态组件<ul><li>ClassComponent，由 class 创建</li><li>ContextProvider，由 createContext 创建</li></ul></li><li>无状态组件<ul><li>IndeterminateComponent，FunctionCompoent 挂载前的初始类型</li><li>FunctionComponent，即函数组件</li><li>ForwardRef，由 React.forwardRef 创建，接收 ref 并转发给子组件</li><li>MemoComponent，由 React.memo 创建，条件渲染子组件</li><li>SimpleMemoCompoent，由 React.memo 创建且不指定条件</li></ul></li><li>FiberNode<ul><li>HostRoot，由 ReactDOM.render 创建</li><li>HostPortal，由 React.createPortal 创建，多用于模态框</li><li>HostComponent，对应元素节点</li><li>HostText，对应文本节点</li></ul></li><li>内置类型<ul><li>Fragment，分组子列表，无需向 DOM 添加额外节点，可用短语法 &lt;&gt;</li><li>Profiler，测量 React 应用多久渲染一次以及渲染一次的“代价”</li><li>StrictMode，严格模式，用来突出显示应用程序中潜在问题的工具</li><li>Suspense，等待目标代码加载，并且可以指定一个加载界面，在用户等待时显示</li><li>PureCompoent，浅层对比 prop 和 state 实现了 shouldComponentUpdate</li></ul></li></ul></li></ul><h3 id="类组件和函数组件的区别是？"><a href="#类组件和函数组件的区别是？" class="headerlink" title="类组件和函数组件的区别是？"></a>类组件和函数组件的区别是？</h3><table><thead><tr><th align="left"></th><th align="left">类组件</th><th align="left">函数组件</th></tr></thead><tbody><tr><td align="left">回调钩子</td><td align="left">生命周期</td><td align="left">useEffect &#x2F; useLayoutEffect</td></tr><tr><td align="left">this</td><td align="left">有，事件处理函数需绑定 this</td><td align="left">无</td></tr><tr><td align="left">state</td><td align="left">有，this.setState 更新</td><td align="left">无，useState &#x2F; useReducer 引入</td></tr><tr><td align="left">实例化</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">性能</td><td align="left">现代浏览器中，闭包和类的原始性能只有在极端场景才会有明显差别</td><td align="left">使用 Hooks 某些情况更加高效,避免了 class 需要的额外成本，如创建类实例和在构造函数绑定事件处理器的成本,符合语言习惯的代码不需要很深的组件库嵌套</td></tr></tbody></table><h3 id="受控组件和非受控组件的区别是？"><a href="#受控组件和非受控组件的区别是？" class="headerlink" title="受控组件和非受控组件的区别是？"></a>受控组件和非受控组件的区别是？</h3><h4 id="面试高频指数：★-★-★-★-☆"><a href="#面试高频指数：★-★-★-★-☆" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul><li>受控组件<ul><li>React 的 state 是表单元素的“唯一数据源”，控制用户输入过程中表单发生的操作</li><li>表单元素的 value 跟随 state 变化，默认值由 defaultValue 设置</li><li>表单元素需要被 React 组件包裹</li><li>每种数据变化都需要编写事件处理函数</li><li>不支持 value 只读的表单元素，如 <code>&lt;input type=&quot;file&quot; /&gt;</code> 的 value 由用户设置</li></ul></li><li>非受控组件<ul><li>表单数据交由 DOM 节点处理</li><li>使用 <code>ref</code> 从 DOM 节点获取表单数据</li><li>表单元素无需被 React 组件包裹</li><li>只关心业务需要的数据变化，减少代码量</li><li>集成 React 和 非 React 代码，不推荐使用</li></ul></li></ul><h3 id="什么是高阶组件？"><a href="#什么是高阶组件？" class="headerlink" title="什么是高阶组件？"></a>什么是高阶组件？</h3><ul><li>高阶组件是参数为组件，返回值为新组件的函数，某种角度上就是高阶函数</li><li>高阶组件是 React 中复用组件逻辑的一种高级技巧</li><li>高阶组件不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式</li></ul><h3 id="什么是-Pure-Components-？"><a href="#什么是-Pure-Components-？" class="headerlink" title="什么是 Pure Components ？"></a>什么是 Pure Components ？</h3><p>React.PureComponent 与 React.Component 相似，区别是</p><ul><li>React.Component 并未实现 shouldComponentUpdate</li><li>React.PureComponent 以浅层对比 prop 和 state 方式实现了 shouldComponentUpdate<ul><li>React.PureComponent 无法检查对象的深层差别</li><li>prop 和 state 使用深层数据结构时<ul><li>调用 <code>forceUpdate()</code> 来确保组件正确更新</li><li>使用 <code>immutable 对象</code> 加速嵌套数据的比较</li></ul></li></ul></li></ul><h3 id="展示组件和容器组件的区别是？"><a href="#展示组件和容器组件的区别是？" class="headerlink" title="展示组件和容器组件的区别是？"></a>展示组件和容器组件的区别是？</h3><p>React 组件按照用途可以分为展示组件和容器组件</p><p>React 推荐所有新组件，无论是展示组件，还是容器组件，都采用函数组件 + Hook 方式编写</p><ul><li>展示组件<ul><li>关心页面 UI，有自己的 HTML 标签和样式</li><li>如果有状态，仅与 UI 相关。与其他组件、store 无关</li><li>不关心数据源，通过 props 获取数据，并执行回调</li></ul></li><li>容器组件<ul><li>关心功能实现，无自己的 HTML 标签和样式</li><li>有状态。包含请求数据源等副作用。状态提升时，维护多个子组件的状态</li><li>可以由第三方库生成，如 React Redux 的 <code>connect()</code> 和 Relay 的 <code>createFragmentContainer</code></li></ul></li></ul><p>React 分离展示组件和容器组件的优势</p><ul><li>关注点分离，便于维护</li><li>提高展示组件的复用度，便于调整 UI</li><li>便于通过如 this.props.children 传递组件本身，减少相同 props 层层传递</li></ul><h3 id="如何劫持-React-组件提高组件复用度？"><a href="#如何劫持-React-组件提高组件复用度？" class="headerlink" title="如何劫持 React 组件提高组件复用度？"></a>如何劫持 React 组件提高组件复用度？</h3><p>劫持 React 组件又被称为渲染劫持</p><p>将已有组件包装，注入新属性和功能，输出高阶组件，来实现组件复用</p><p>劫持需要遵守高阶组件的约定</p><ul><li>不要改变原始组件，仅组合组件</li><li>保持组件的接口与已有组件相似，透传与自身无关的 props 给已有组件</li><li>最大化可组合性，确保函数签名类型一致，输入函数，返回函数，输入组件，返回组件</li><li>包装显示名称便于调试，如 <code>withSubscription(CommentList)</code></li></ul><h3 id="如何设计一个-React-组件？"><a href="#如何设计一个-React-组件？" class="headerlink" title="如何设计一个 React 组件？"></a>如何设计一个 React 组件？</h3><ul><li>根据数据源和原型和 UI 稿，了解数据结构和 UI 视图</li><li>划分组件层级<ul><li>根据单一功能原则分离 UI 与数据源的结构一一对应</li><li>明确组件的包含关系</li></ul></li><li>构建静态版本<ul><li>将静态数据通过 props 父组件到子组件单向传递</li><li>构建应用<ul><li>简单应用，自上而下，从高层组件到低层组件构建</li><li>大型应用，自下而上，从低层组件到高层组件构建，同时为低层组件编写测试</li></ul></li><li>确定 UI state 最小且完整表示<ul><li>排除通过 props 传递来的数据</li><li>排除不随时间变化的数据</li><li>排除可以由其他 state 或 props 计算得出的数据</li></ul></li><li>确定 state 放置位置<ul><li>找出根据 state 渲染的所有组件</li><li>找出这些组件的共同上级组件</li><li>state 应该放置在共同上级组件或者更高层级的组件中</li></ul></li><li>添加反向数据流<ul><li>state 只能由拥有它们的组件更改</li><li>在该组件添加修改 state 的回调函数</li><li>将该回调函数通过 props 传递给子组件，在子组件中，如事件处理函数中调用</li></ul></li></ul></li></ul><h3 id="React-组件与-Web-Components-共存的最佳实践是？"><a href="#React-组件与-Web-Components-共存的最佳实践是？" class="headerlink" title="React 组件与 Web Components 共存的最佳实践是？"></a>React 组件与 Web Components 共存的最佳实践是？</h3><ul><li>访问 Web Components 的命令式 API：使用 <code>ref</code>与 DOM 节点进行交互</li><li>引入第三方 Web Components：编写 React 组件包装该 Web Components</li><li>Web Components 触发事件：React 组件中手动添加事件处理器来处理事件</li></ul><h3 id="什么是-React-的状态？"><a href="#什么是-React-的状态？" class="headerlink" title="什么是 React 的状态？"></a>什么是 React 的状态？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆"><a href="#面试高频指数：★-☆-☆-☆-☆" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li>React 的状态 state 是一个对象<ul><li>类组件中，状态通过 this.state 创建，通过 this.setState 合并更改，异步更新</li><li>React Hook 中，状态通过 this.useState 或 this.useReducer 使用</li></ul></li><li>React 将组件看做状态机，状态改变触发渲染</li><li>React 建议减少有状态的组件，提高组件复用度，利于维护<ul><li>只将无法从 props 传递，无法从其他数据计算，并且随时间可能变化的数据作为 state</li><li>多个组件 state 的数据源相同，应将状态提升到父组件或容器组件</li><li>避免使用 context，仅在 React 的状态管理无法满足需求时使用 Redux</li></ul></li></ul><h3 id="什么是-React-的状态提升？"><a href="#什么是-React-的状态提升？" class="headerlink" title="什么是 React 的状态提升？"></a>什么是 React 的状态提升？</h3><ul><li>React 中，任何可变数据应当只有一个相对应的唯一“数据源”</li><li>多个组件反映相同的变化数据时，共享状态提升到最近的共同父组件<ul><li>state 应首先添加到需要渲染数据的组件</li><li>其他组件也需要这个 state，将它提升至这些组件的最近共同父组件</li></ul></li><li>state 只能由拥有它们的组件修改，bug 排查范围被大大缩减</li></ul><h3 id="状态和属性的区别是什么？"><a href="#状态和属性的区别是什么？" class="headerlink" title="状态和属性的区别是什么？"></a>状态和属性的区别是什么？</h3><p>相同点</p><ul><li>state 和 props 都是原生的 JavaScript 对象</li><li>state 和 props 的变化都会触发生命周期、useEffect &#x2F; useLayoutEffect、和渲染</li><li>state 和 props 相同，渲染结果相同</li><li>state 和 props 都可以在组件内部设置默认值</li></ul><p>不同点</p><ul><li>获取<ul><li>state 由当前组件声明</li><li>props 由父组件传入</li></ul></li><li>更新<ul><li>state<ul><li>由所在组件通过 useState &#x2F; useReducer 或 setState 方法更新</li><li>由子组件通过 state 所在组件传入的回调函数间接更新</li></ul></li><li>props 不允许修改</li></ul></li><li>数据<ul><li>state 通常存储可变数据，避免多层嵌套或使用不可变对象便于优化渲染</li><li>props 除数据外，还多用于回调函数，组件 ( children )，路由 ( history ) 的传递</li></ul></li></ul><h3 id="如何创建动态的状态名称？"><a href="#如何创建动态的状态名称？" class="headerlink" title="如何创建动态的状态名称？"></a>如何创建动态的状态名称？</h3><ul><li>状态是一个 JavaScript 对象，状态名称即对象的属性名称</li><li>从 ECMAScript 2015 开始，对象初始化语法开始支持计算属性名。在 [] 放入表达式，计算结果当做属性名。例如</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> h = &#123;&#125;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>h[i + <span class="hljs-number">1</span>] = i <span class="hljs-comment">// h = &#123;&#x27;1&#x27;: 0&#125;</span></code></pre></div><ul><li>计算属性名支持对象字面量，例：</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; i &#125; = props <span class="hljs-comment">// props = &#123; i : 0 &#125;</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;[i + <span class="hljs-number">1</span>] : i&#125; <span class="hljs-comment">// this.state = &#123; &#x27;1&#x27; : 0 &#125;</span></code></pre></div><h3 id="setState-支持哪些用法？"><a href="#setState-支持哪些用法？" class="headerlink" title="setState 支持哪些用法？"></a>setState 支持哪些用法？</h3><h4 id="面试高频指数：★-★-☆-☆-☆"><a href="#面试高频指数：★-★-☆-☆-☆" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>setState(updater, [callback])<ul><li>updater 函数带有形式参数，基于 state 和 props 构建新对象表示变化</li><li>(state, props) &#x3D;&gt; stateChange，适合后续状态取决于当前状态的情况</li></ul></li><li>setState(stateChange[, callback])<ul><li>stateChange 为传入对象，会浅层合并到新的 state</li><li>同一周期内，后调用的 setState 会覆盖先调用的 setState</li></ul></li><li>setState 的第二参数为可选回调函数<ul><li>回调函数将在 setState 完成合并并重新渲染组件后执行</li><li>React 官方推荐使用 componentDidUpdate() 生命周期代替 setState 的回调函数</li></ul></li></ul><h3 id="setState-和-replaceState-的区别是？"><a href="#setState-和-replaceState-的区别是？" class="headerlink" title="setState 和 replaceState 的区别是？"></a>setState 和 replaceState 的区别是？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-1"><a href="#面试高频指数：★-☆-☆-☆-☆-1" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li>setState 会合并当前状态与之前状态</li><li>replaceState 会丢弃之前状态，用新状态替代</li><li>replaceState 等同于先在 setState 中将状态设置为 false &#x2F; null，再设置新状态</li></ul><h3 id="如何优化-setState，减少不必要更新？"><a href="#如何优化-setState，减少不必要更新？" class="headerlink" title="如何优化 setState，减少不必要更新？"></a>如何优化 setState，减少不必要更新？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-1"><a href="#面试高频指数：★-★-☆-☆-☆-1" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>通过 setState(updater, [callback]) 的用法，第一参数使用带有形式参数的函数</li><li>通过 updater 函数 (state, props) &#x3D;&gt; stateChange 的第一参数，接受原来的 state 状态值</li><li>对比新旧状态值<ul><li>相同，返回 null，不渲染</li><li>不同，返回新状态值，触发异步合并渲染</li></ul></li></ul><p>示例：</p><div class="code-wrapper"><pre><code class="hljs JavaScript">getData = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<span class="hljs-keyword">const</span> &#123; time &#125; = data<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;<span class="hljs-keyword">return</span> state.<span class="hljs-property">time</span> === time ?  <span class="hljs-literal">null</span> : &#123; time &#125;&#125;)&#125;</code></pre></div><h3 id="当-State-值为-Object-时，如何优化？"><a href="#当-State-值为-Object-时，如何优化？" class="headerlink" title="当 State 值为 Object 时，如何优化？"></a>当 State 值为 Object 时，如何优化？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-2"><a href="#面试高频指数：★-★-☆-☆-☆-2" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>避免使用 Object 作为 State 值，使用 PureComponent 的浅比较的自动优化失效</li><li>必要使用 Object 作为 State 值<ul><li>避免嵌套过多层级</li><li>设置更新 state 的前置条件或使用 shouldComponent 手动优化</li></ul></li><li>已经使用 Object 作为 State 值，并且嵌套层级过多<ul><li>拆分 State 到子组件</li><li>使用不可变对象 Immutable，只要 State 更新，返回对象新引用，重新渲染修改节点</li></ul></li></ul><h3 id="什么是-React-的属性？"><a href="#什么是-React-的属性？" class="headerlink" title="什么是 React 的属性？"></a>什么是 React 的属性？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-2"><a href="#面试高频指数：★-☆-☆-☆-☆-2" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li>属性是组件的入参，用法同 HTML 自定义属性，可将任意类型数据从父组件传给子组件</li><li>属性的改变可以触发组件的生命周期流程和渲染</li><li>建议从组件自身的角度，不依赖于调用中间的上下文命名 Props</li><li>属性具有只读性，所有 React 组件必须像纯函数一样保护它们的 props 不被更改</li><li>请避免使用匿名函数作为属性值，避免引起重复渲染</li><li>具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑</li></ul><h3 id="为什么不能直接修改属性？"><a href="#为什么不能直接修改属性？" class="headerlink" title="为什么不能直接修改属性？"></a>为什么不能直接修改属性？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-3"><a href="#面试高频指数：★-☆-☆-☆-☆-3" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li>React 是“单向”数据流，数据通过 props 传递</li><li>从 state 派生数据或 UI 只能影响“低于”它们的组件，设计简单高效，便于调试</li><li>所有 React 组件必须像纯函数一样保护它们的 props 不被更改，保证组件没有副作用</li></ul><h3 id="通过属性传递组件本身的方法有哪些？"><a href="#通过属性传递组件本身的方法有哪些？" class="headerlink" title="通过属性传递组件本身的方法有哪些？"></a>通过属性传递组件本身的方法有哪些？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-3"><a href="#面试高频指数：★-★-☆-☆-☆-3" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>props.children<ul><li>子组件可以获取父组件开始标签和结束标签之间的内容</li></ul></li><li>render props<ul><li>向子组件传入函数，返回组件需要渲染什么内容</li><li>直接在父组件的标签之间，调用函数返回组件</li><li>避免使用匿名函数返回组件，避免重复渲染</li></ul></li></ul><h3 id="使用-key-属性有哪些注意事项？"><a href="#使用-key-属性有哪些注意事项？" class="headerlink" title="使用 key 属性有哪些注意事项？"></a>使用 key 属性有哪些注意事项？</h3><h4 id="面试高频指数：★-★-★-☆-☆"><a href="#面试高频指数：★-★-★-☆-☆" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul><li>key 用来帮助 React 识别哪些元素改变</li><li>key 在数组列表及兄弟节点之间必须唯一</li><li>不建议使用索引作为 key 值，如果不显示指定 key 值，默认使用索引作为 key 值</li><li>key 只有放在就近的数组上下文中才有意义</li><li>key 不会传递给子组件，需要使用 key 属性的值，需使用其他属性显式传递</li></ul><h3 id="如何在-React-中进行静态类型检查？"><a href="#如何在-React-中进行静态类型检查？" class="headerlink" title="如何在 React 中进行静态类型检查？"></a>如何在 React 中进行静态类型检查？</h3><h4 id="面试高频指数：★-★-★-☆-☆-1"><a href="#面试高频指数：★-★-★-☆-☆-1" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul><li>React.PropTypes 或 prop-types 库<ul><li>提供一系列验证器，确保组件接收到的数据类型有效</li><li>PropTypes 仅在开发模下进行检查并在控制台显示警告</li><li>通过特定的 defaultProps 属性来定义 props 的默认值</li></ul></li><li>Flow<ul><li>Flow 是一个针对 JavaScript 代码的静态类型检测器</li><li>Facebook 开发，经常与 React 一起使用</li><li>Flow 通过特殊类型语法为变量、函数以及 React 组件提供注解</li><li>Flow 添加方法<ul><li>将 Flow 添加到项目依赖</li><li>确保编译后的代码已经去除 Flow 语法</li><li>添加类型注解并且运行 Flow 来检查</li></ul></li></ul></li><li>TypeScript<ul><li>TypeScript 是微软开发的编程语言，它是 JavaScript 的类型超集，包含独立编译器</li><li>类型语言，构建时可以发现 bug 和错误</li><li>TypeScript 添加方法<ul><li>将 TypeScript 添加到项目依赖</li><li>配置 TypeScript 编译选项</li><li>使用正确的文件扩展名，React 的 JSX 使用<code>.tsx</code>作为扩展名</li><li>为已经使用的库添加定义，现实其他包的错误和提示</li></ul></li></ul></li><li>新语法和工具链<ul><li>Reason，由 Facebook 开发，经过实战验证的 OCaml 语言</li><li>Kotlin，由 JetBrains 开发的静态类型语言</li></ul></li></ul><h3 id="如何限制某个属性是必须的？"><a href="#如何限制某个属性是必须的？" class="headerlink" title="如何限制某个属性是必须的？"></a>如何限制某个属性是必须的？</h3><p>React 中，可以在任何 PropTypes 属性后加上 isRequired，声明该属性必须</p><ul><li>当必须属性没有被提供值时，控制台打印警告信息</li><li>表示该属性必须，而不限制属性类型，可以使用 PropTypes.any.isRequired</li><li>表示必须包含一个元素，可以使用 PropTypes.element.isRequired</li></ul><h3 id="如何设置属性的默认值？"><a href="#如何设置属性的默认值？" class="headerlink" title="如何设置属性的默认值？"></a>如何设置属性的默认值？</h3><h4 id="面试高频指数：★-★-★-☆-☆-2"><a href="#面试高频指数：★-★-★-☆-☆-2" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>React 中，通过特定 defaultProps 属性来定义 props 默认值</p><ul><li>设置类组件或函数组件的静态属性 defaultProps</li><li>类组件，参考 proposal-class-fields 提案，在 class 内声明静态属性 defaultProps</li><li>当传入属性值为 undefined 时，使用属性的默认值</li></ul><h3 id="React-是否支持-HTML-属性？"><a href="#React-是否支持-HTML-属性？" class="headerlink" title="React 是否支持 HTML 属性？"></a>React 是否支持 HTML 属性？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-4"><a href="#面试高频指数：★-★-☆-☆-☆-4" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>React16 中，任何标准和自定义的 DOM 属性都是完全支持</li><li>React 为 DOM 提供了一套以 JavaScript 为中心的 API<ul><li>标准 DOM 属性采用小驼峰命名</li><li>自定义属性全部小写</li></ul></li><li>React 与 HTML 之间部分属性存在差异<ul><li>checked<ul><li>受控组件 checked</li><li>非受控组件用 defaultChecked 设置组件首次挂载时是否被选中</li></ul></li><li>classNmae<ul><li>用于指定 DOM 节点和 SVG 元素的 class</li><li>React 中，使用 Web Components，使用 class 属性代替</li></ul></li><li>dangerouslySetInnerHTML<ul><li>React 为浏览器 DOM 提供 innerHTML 的替换方案</li><li>需要向该属性传入 key 为 __html 的对象，用来警示跨站脚本（XSS）攻击风险</li></ul></li><li>htmlFor<ul><li>for 是 JavaScript 关键字</li><li>React 元素使用 htmlFor 代替</li></ul></li><li>onChange<ul><li>onChange 事件与预期行为一致：表单字段变化时，事件都会被触发</li><li>与浏览器已有的默认行为不一致：<ul><li>用户更改 <code>&lt;input&gt;</code>,<code>&lt;select&gt;</code> 和 <code>&lt;textarea&gt;</code> 元素的值并提交更改时 <code>change</code> 事件在这些元素上触发</li><li>与 <code>input</code> 事件不一样，<code>change</code> 事件不是每次元素的 <code>value</code> 改变时都会被触发</li></ul></li><li>React 依靠该事件实时处理用户输入</li></ul></li><li>selected<ul><li>将 <code>&lt;option&gt;</code> 标记为已选中状态，请在 <code>select</code> 的 <code>value</code> 中引用该选项的值</li></ul></li><li>style<ul><li>接受小驼峰命名属性的 JavaScript 对象，而不是 CSS 字符串</li><li>与 JavaScript 属性一致，同时会更高效，且能预防跨站脚本（XSS）的安全漏洞</li><li>样式不会自动补齐浏览器私有前缀，除 <code>ms</code> 外，浏览器引擎前缀都应以大写字母开头</li><li>React 自动添加 “px” 后缀到内联样式为数字的属性<ul><li>本来没有单位的属性 <code>zoom</code>,<code>order</code>,<code>flex</code> 不会转换像素字符串</li><li>需使用 “px” 以外单位，请将值设为数字与所需单位组成的字符串</li></ul></li></ul></li><li>suppressContentEditableWaring<ul><li>禁止拥有子节点的元素比标记为 contentEditable 时 React 发出警告</li></ul></li><li>suprressHydrationWarning<ul><li>禁止 React 服务端渲染与客户端渲染不同内容时发出警告</li><li>只会对元素一级深度有效，应急方案使用，不过过度使用</li></ul></li><li>value<ul><li><code>&lt;input&gt;</code>,<code>&lt;select&gt;</code>,<code>&lt;textarea&gt;</code> 组件支持 <code>value</code> 属性</li><li>非受控组件使用 <code>dafaultValue</code> 属性设置组件第一次挂载时的 <code>value</code></li></ul></li></ul></li></ul><h3 id="React-是否支持自定义属性？"><a href="#React-是否支持自定义属性？" class="headerlink" title="React 是否支持自定义属性？"></a>React 是否支持自定义属性？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-5"><a href="#面试高频指数：★-★-☆-☆-☆-5" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>React 16 前会忽略未知的 DOM 属性。JSX 属性 React 无法识别，将被跳过</li><li>React 16 中任何未知的属性都会在 DOM 显示，适用于<ul><li>非标准属性</li><li>尝试实验中的 DOM 接口</li><li>集成第三方库或 Web Components</li></ul></li></ul><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><h3 id="React-父子组件通信有哪些方法？"><a href="#React-父子组件通信有哪些方法？" class="headerlink" title="React 父子组件通信有哪些方法？"></a>React 父子组件通信有哪些方法？</h3><h4 id="面试高频指数：★-★-★-★-★"><a href="#面试高频指数：★-★-★-★-★" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><ul><li>props<ul><li>父组件将需要传递的数据，更改 state 的方法或组件本身通过 props 传递给子组件</li><li>子组件通过 props 传来的回调函数向父组件传递数据或更改状态</li></ul></li><li>refs<ul><li>适合在典型数据流之外强制修改子组件的场景，例如<ul><li>管理焦点，文本选择或媒体播放</li><li>触发强制动画</li><li>集成第三方 DOM 库</li></ul></li><li>DOM refs 打破组件封装，ref 转发更改开发者预期<ul><li>应避免过度使用，用声明式实现和状态提升代替</li><li>一定要使用时，建议添加注释和说明</li></ul></li><li>被修改的子组件可以是 React 组件实例或 DOM 元素</li><li>包含向子组件添加 ref、回调 refs 和 ref 转发三种方式</li></ul></li><li>context<ul><li>适合在组件之间共享如地区偏好，主题等数据，避免逐层传递 props</li><li>存在 context 的 value 更新，内部所有消费组件都重新渲染问题</li><li>过度使用组件的状态与上下文相关，复用度降低</li></ul></li><li>事件订阅发布<ul><li>实现并使用 Event Bus<ul><li>在需要数据的组件监听自定义事件，并传入改变状态更新组件的回调函数</li><li>在获取数据的组件触发自定义事件，并传入数据，执行回调函数</li></ul></li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Eventbus</span> &#123;<span class="hljs-title function_">constructor</span> () &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">fns</span> = []&#125;emit (type, ...args) &#123;<span class="hljs-keyword">const</span> fns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">fns</span>[type]<span class="hljs-keyword">if</span> (fns) fns.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args))&#125;addListener (type, fn) &#123;<span class="hljs-keyword">const</span> fns = <span class="hljs-variable language_">this</span>.<span class="hljs-property">fns</span>[type]fns ? fns.<span class="hljs-title function_">push</span>(fn) : (<span class="hljs-variable language_">this</span>.<span class="hljs-property">fns</span>[type] = [fn])&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>使用 Node.js 的 events</code></pre></div><ul><li>使用状态管理，举例说明特点<ul><li>Redux<ul><li>单一数据源 store</li><li>state 只能通过 action 更改</li><li>使用 reducer 纯函数返回新 state 来更改 state</li></ul></li><li>Recoil<ul><li>任意地方灵活共享 state，并保持高性能</li><li>高效可靠地根据变化的 state 进行计算</li><li>支持持久化日志</li><li>支持 undo</li></ul></li><li>hox<ul><li>只有一个 API</li><li>使用 custom Hooks 定义 model</li><li>支持 TS</li><li>支持多数据源</li></ul></li></ul></li></ul><h3 id="为什么-React-是单向数据流？"><a href="#为什么-React-是单向数据流？" class="headerlink" title="为什么 React 是单向数据流？"></a>为什么 React 是单向数据流？</h3><h4 id="面试高频指数：★-★-★-☆-☆-3"><a href="#面试高频指数：★-★-★-☆-☆-3" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul><li>React 组件不关心其他组件是否有状态和类型<ul><li>父组件可以把它的 state 作为 props 向下传递它的子组件中</li><li>子组件通过 props 接收父组件的数据，不关心数据来源于父组件的 state 或 props</li></ul></li><li>React 中这种自上而下的数据传递被称为单向数据流<ul><li>状态 state 总是所属于特定的组件</li><li>状态 state 派生的任何数据和 UI 只能影响树中“低于”它们的组件</li></ul></li><li>单向数据流单向绑定无关，对比双向绑定<ul><li>坏处：需要绑定更多“样板”代码</li><li>好处：排除和隔离 bug 所需的工作量将会减少<ul><li>状态 state 只有其所在组件自身可修改</li><li>Bug 可以使用 React 开发者工具来检查问题组件的 props</li><li>按照组件树结构逐级向上搜寻，直到定位到负责更新 state 的组件</li></ul></li></ul></li></ul><h3 id="什么是-Context-？"><a href="#什么是-Context-？" class="headerlink" title="什么是 Context ？"></a>什么是 Context ？</h3><h4 id="面试高频指数：★-★-★-★-☆-1"><a href="#面试高频指数：★-★-★-★-☆-1" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul><li>Context 提供了一种无需为每层组件手动添加 props，能在组件树间进行数据传递的方法</li><li>Context 设计目的是共享或缓存组件树的全局数据，如用户认证，地区偏好，主题和语言</li><li>Context 应用场景是不同层级组件访问同样数据，副作用是降低组件的复用性</li><li>Context API<ul><li>React.createContext 创建 Context 对象，订阅该对象的组件从组件树中离自身最近的匹配的 Provider 中读取当前的 context 值</li><li>Context.Provider 接收 value 属性，当其发生变化时，内部所有消费组件都会重新渲染，忽略 shouldComponentUpdate 函数</li><li>Class.contextType 订阅单一 context，在任何生命周期中，使用 this.context 访问</li><li>Context.Consumer<ul><li>在函数式组件中订阅 context 的变更</li><li>需要一个函数作为子元素。函数接收当前 context 值，并返回一个 React 节点<ul><li>context 值由最近的 Provider 提供</li><li>没有 Provider 时等同于 createContext() 的 defaultValue</li></ul></li></ul></li><li>Context.displayName 指定组件在 DevToools 中显示的名称</li></ul></li></ul><h3 id="什么是-ContextType"><a href="#什么是-ContextType" class="headerlink" title="什么是 ContextType ?"></a>什么是 ContextType ?</h3><h4 id="面试高频指数：★-★-★-☆-☆-4"><a href="#面试高频指数：★-★-★-☆-☆-4" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ol><li>ContextType 用于订阅单一的 context</li></ol><ul><li><p>设置 class.contextType 为 React.createContext() 创建的 context 对象</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(defaultValue)<span class="hljs-keyword">class</span> <span class="hljs-title class_">NewClass</span> extend <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> &#123;<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>&#125;&#125;<span class="hljs-title class_">NewClass</span>.<span class="hljs-property">contextType</span> = <span class="hljs-title class_">MyContext</span></code></pre></div><ul><li><p>类组件参考 proposal-class-fields 提案</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> MyContext = React.createContext(defaultValue)<span class="hljs-keyword">class</span> <span class="hljs-title">NewClass</span> <span class="hljs-title">extend</span> <span class="hljs-title">React.Component</span> &#123;<span class="hljs-keyword">static</span> contextType = <span class="hljs-function">MyContext</span><span class="hljs-function"><span class="hljs-title">render</span>()</span> &#123;<span class="hljs-keyword">const</span> <span class="hljs-keyword">value</span> = <span class="hljs-keyword">this</span>.context&#125;&#125;</code></pre></div><ol><li>在 React 组件中，使用 this.context 访问通过 contextType 指定的 Context</li></ol><h3 id="如何优化-Context-？"><a href="#如何优化-Context-？" class="headerlink" title="如何优化 Context ？"></a>如何优化 Context ？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-6"><a href="#面试高频指数：★-★-☆-☆-☆-6" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>为什么要优化 Context ?</li></ul><p>Context 的 value 更新，它内部所有消费组件都会重新渲染，并且不受制于 shouldComponentUpdate 函数</p><ul><li>优化 Context 的方法<ul><li>避免使用对象字面量作为 value</li></ul></li></ul><p>context 使用参考标识（reference identity) 来决定渲染时机，当 Provider 接收 value 为对象字面量时，每次 value 都会被赋值新对象，建议将 value 状态提升到父节点的 state 里</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>拆分 Context</code></pre></div><p>将原来同一个 Context 频繁变化的值拆分出来，分别放入不同的 Context</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>记忆化</code></pre></div><p>使用 React.memo 或 useMemo 包裹组件，指定需要比较的值，只有值变化时重新渲染</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>使用 createContext 的第二参数，不稳定，不推荐</code></pre></div><p>createContext 为函数，两个形参分别为更新前后值，接收 Number 类型作为返回值</p><p>在订阅 context 变化的组件上，使用 unstable_observedBits 设置重新渲染组件的条件</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Consumer</span>, <span class="hljs-title class_">Provider</span> &#125; = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-literal">null</span>, <span class="hljs-function">(<span class="hljs-params">prev, next</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (prev.<span class="hljs-property">value1</span> !== next.<span class="hljs-property">value1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><span class="hljs-keyword">if</span> (prev.<span class="hljs-property">value2</span> !== next.<span class="hljs-property">value2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>&#125;)<span class="hljs-keyword">const</span> <span class="hljs-title class_">Consumer1</span> =&gt; &#123; <span class="hljs-comment">// 只有当 value1 变化重新渲染</span><span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Consumer</span> <span class="hljs-attr">unstable_observedBits</span>=<span class="hljs-string">&#123;1&#125;</span> <span class="hljs-attr">children</span>=<span class="hljs-string">&#123;value</span> =&gt;</span> (</span><span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/&gt;</span></span>)&#125;/&gt;&#125;<span class="hljs-keyword">const</span> <span class="hljs-title class_">Consumer2</span> =&gt; &#123;<span class="hljs-comment">// 只有当 value2 变化重新渲染</span><span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Consumer</span> <span class="hljs-attr">unstable_oberverdBits</span>=<span class="hljs-string">&#123;10&#125;</span> <span class="hljs-attr">children</span>=<span class="hljs-string">&#123;value</span> =&gt;</span> (</span><span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/&gt;</span></span>)&#125;/&gt;&#125;* 使用第三方库    * use-context-selector        * 使用 createContext 创建支持 useContextSelector 的特殊 context        * 使用 useContextSelector 选择 context 某个值，当且仅当该值变化时，重新渲染    * <span class="hljs-title class_">React</span> <span class="hljs-title class_">Tracke</span></code></pre></div><h3 id="什么是-Ref-转发？"><a href="#什么是-Ref-转发？" class="headerlink" title="什么是 Ref 转发？"></a>什么是 Ref 转发？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-7"><a href="#面试高频指数：★-★-☆-☆-☆-7" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li><p>Ref 转发可以将</p><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">ref</span></code></pre></div><p>传递到子组件</p><ul><li>由 <code>React.forwardRef</code> 实现</li><li>向 <code>ref</code> 传入回调函数，函数第一参数是 React 组件实例或 HTML DOM 元素</li></ul></li><li><p>Ref 转发适合应用场景</p><ul><li>转发表单组件的 ref 到 DOM 节点，便于访问 DOM 节点，来管理焦点、选中或动画</li><li>在高阶组件内，转发外层组件的 ref 到 被包裹的组件</li></ul></li><li><p>Ref 转发更改了组件默认的 ref 指向，对组件使用者不可见，不建议使用</p><ul><li>不兼容之前同时使用组件和 ref 的应用</li><li>对组件使用者，ref 结果可能不符合直观预期</li></ul></li><li><p>由</p><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>forwardRef</code></pre></div><p>实现 Ref 转发，可以使用函数决定 ref 转发组件显示的内容</p><ul><li>设置传入 <code>React.forwardRef</code> 函数名称，例如</li></ul></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs reasonml">const newComponent = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>forward<span class="hljs-constructor">Ref(<span class="hljs-params">function</span> <span class="hljs-params">myName</span>(<span class="hljs-params">props</span>, <span class="hljs-params">ref</span>)</span> &#123;return &lt;innerComponent &#123;...props&#125; forwardedRef=&#123;<span class="hljs-built_in">ref</span>&#125; /&gt;&#125;)<span class="hljs-comment">// DevTools DisplayName: ForwardRef(myName)</span><span class="hljs-operator"></span><span class="hljs-operator">* </span>设置函数的 displayName 来包含被包裹组件的名称</code></pre></div><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> my<span class="hljs-constructor">Name(<span class="hljs-params">props</span>, <span class="hljs-params">ref</span>)</span> &#123;return &lt;innerComponent &#123;...props&#125; forwardedRef=&#123;<span class="hljs-built_in">ref</span>&#125;&#125;myName.displayName = &#x27;myDisplayName&#x27;const newComponent = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>forward<span class="hljs-constructor">Ref(<span class="hljs-params">myName</span>)</span><span class="hljs-comment">// DevTools DisplayName: ForwardRef(myDisplayName)</span></code></pre></div><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><h3 id="React-返回空对象有哪些方法？"><a href="#React-返回空对象有哪些方法？" class="headerlink" title="React 返回空对象有哪些方法？"></a>React 返回空对象有哪些方法？</h3><ul><li>false &#x2F; true &#x2F; null &#x2F; undefined 将被忽略，不被渲染</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> / <span class="hljs-literal">true</span> / <span class="hljs-literal">null</span> /<span class="hljs-literal">undefined</span>&#125;</code></pre></div><ul><li>React.Fragment &#x2F; &lt;&gt;</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span> /&gt;</span></span> <span class="hljs-regexp">/ &lt;/</span>&gt;&#125;</code></pre></div><h3 id="如何优化不必要的渲染？"><a href="#如何优化不必要的渲染？" class="headerlink" title="如何优化不必要的渲染？"></a>如何优化不必要的渲染？</h3><h4 id="面试高频指数：★-★-★-★-★-1"><a href="#面试高频指数：★-★-★-★-★-1" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><ul><li><p>优化状态 state</p><ul><li>避免使用多层嵌套对象作为 state，降低比较效率，提高比较难度<ul><li>如果超过3层，建议继续拆分组件，将每一层状态放置在更内层的组件中</li></ul></li><li>状态提升和隔离<ul><li>多个组件需要反映相同的变化数据，共享状态提升到最近的共同父组件</li><li>仅影响组件本身的状态隔离放置在组件内部<ul><li>状态管理库可以使用 Recoil，其使用 Atom 更灵活地管理状态</li></ul></li></ul></li><li>合并状态更新，分离计算和渲染<ul><li>出于性能考虑，React 可能会把多个 setState 调用合并成一个调用</li><li>如果状态更新后，需要根据新状态计算或判断，再更新状态<ul><li>那么更新计算前的状态引发的渲染很可能不必要</li><li>分离计算逻辑，先计算状态的最终值，直接更新状态到最终值</li></ul></li></ul></li></ul></li><li><p>优化属性 props</p><ul><li>除高阶组件等需保持接口一致的场景外，props 保持简单，仅与组件单一职责关联</li><li>避免使用多层嵌套对象作为 props，降低比较效率，提高比较难度</li><li>组件只关心自身相关的 props<ul><li>例如标识单选、复选的选中状态、列表的激活项<ul><li>为每一项添加是否选中，是否激活标识优于额外添加选中项，激活项列表属性</li></ul></li></ul></li><li>避免在 render 等渲染函数中重复创建对象和函数，先赋值到变量再引用<ul><li>避免使用对象字面量作为 props，每次 render 创建新对象，相应子组件重复渲染</li><li>避免使用匿名函数作为 props，每次 render 创建新函数，相应子组件重复渲染</li></ul></li></ul></li><li><p>先比较再更新</p><ul><li>类组件<ul><li>使用 PureComponent 执行一层浅比较 props 或 state，值变化时渲染</li><li>使用 shouldComponentUpdate 函数<ul><li>手动比较前后 props 或 state，返回 true 渲染，false 不渲染</li><li>若 state 为对象，使用不可变对象，简化并加速比较</li></ul></li></ul></li><li>函数式组件<ul><li>使用 React.memo 比较 props 再渲染组件<ul><li>不使用第二参数时，一层浅比较 props，变化时渲染</li><li>使用第二参数时，手动比较前后的 props，返回 false 渲染，true 不渲染</li></ul></li><li>使用 useMemo 指定依赖，细粒度渲染组件<ul><li>使用第二参数，传入依赖数组，当数组中的值发生变化时，更新返回值</li><li>通常包裹函数式组件的返回值，指定依赖的 props 或 state 的具体值</li><li>包裹任意需要复杂计算的函数，指定依赖的变量。能在同一组件中部分和多次使用</li></ul></li><li>使用 useCallback 避免函数重复创建引起渲染<ul><li>当函数式组件重新更新时，内部声明的函数可能会被重复创建<ul><li>将这些函数作为 props 传入的子组件会重复渲染</li><li>使用 useCallback 包裹函数，传入空数组，总是返回相同函数来避免重复创建引起的渲染</li></ul></li></ul></li></ul></li></ul></li><li><p>减少嵌套</p><ul><li>减少不必要的根组件<ul><li>返回一个组件列表数组</li><li>使用内置组件文档碎片<code>React.Fragement</code>或其缩写<code>&lt;&gt;</code></li></ul></li><li>谨慎使用 CSS-in-JS 方案<ul><li>Class + 样式表方案的渲染性能和 CSS 本身的复用度总体优于内联方案</li><li>避免仅为书写内联样式而频繁地创建嵌套组件</li></ul></li></ul></li><li><p>惰性渲染</p><ul><li><p>key 唯一</p><ul><li>使用唯一标识作为 key，而不是 索引，让 React 精确判断变化，复用不变元素</li></ul></li><li><p>条件渲染</p><ul><li>使用 <code>if</code>&#x2F;<code>else</code> 三元运算符或逻辑运算符，仅在条件满足时，渲染组件</li><li>渲染列表时，当条件不满足时，返回 null 或空组件，保留组件位置</li></ul></li><li><p>防抖和节流</p><ul><li><p>使用 <code>window.requestAnimationFrame</code> 或定时器构建防抖或节流函数</p></li><li><p>使用 <code>MutationObserver</code> 代替定时器</p></li><li><p>使用</p><div class="code-wrapper"><pre><code class="hljs arcade"><span class="hljs-built_in">Intersection</span> Observer</code></pre></div><p>代替</p><div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-built_in">window</span>.scroll</code></pre></div><ul><li>懒加载图片<ul><li>只渲染可视区域的图片</li></ul></li><li>懒加载 DOM<ul><li>只渲染可视区域的 DOM，如虚拟列表，商品详情<ul><li>虚拟列表库可以使用 react-virtualized 及其更新 react-window</li></ul></li></ul></li></ul></li></ul></li><li><p>异步路由</p></li></ul></li><li><p>优化 Context，减少 value 更新，内部所有消费组件的重新渲染</p><ul><li>拆分 Context<ul><li>将原属于同一 Context 的值拆分到不同的 Context</li></ul></li><li>记忆化<ul><li>使用 React.memo 或 useMemo 包裹组件，指定需要比较的值，只有值变化时重新渲染</li></ul></li><li>使用 createContext 的第二参数，不稳定，不推荐<ul><li>createContext 为函数，两个形参分别为更新前后值，接收 Number 类型作为返回值</li><li>在订阅 context 变化的组件上，使用 unstable_observedBits 设置重新渲染组件的条件</li></ul></li><li>使用第三方库<ul><li>use-context-selector</li><li>React Tracke</li></ul></li></ul></li></ul><h3 id="React-如何渲染-HTML-，有什么风险？"><a href="#React-如何渲染-HTML-，有什么风险？" class="headerlink" title="React 如何渲染 HTML ，有什么风险？"></a>React 如何渲染 HTML ，有什么风险？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-4"><a href="#面试高频指数：★-☆-☆-☆-☆-4" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li><p><code>dangerouslySetInnerHTML</code> 是 React 为浏览器 DOM 提供 <code>innerHTML</code> 的替换方案</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">newComponent</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">&#123;&#123;__html:</span> &#x27;&lt;<span class="hljs-attr">b</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>&#x27;&#125;&#125; /&gt;</span>&#125;</code></pre></div><ul><li>代码直接设置 HTML 存在风险，很容易无意中使用户暴露于跨站脚本（XSS）攻击</li><li>React 设计此替换方案，通过名称警示开发者</li></ul><h3 id="React-为什么要引入基于-Fiber-协调器的异步渲染？"><a href="#React-为什么要引入基于-Fiber-协调器的异步渲染？" class="headerlink" title="React 为什么要引入基于 Fiber 协调器的异步渲染？"></a>React 为什么要引入基于 Fiber 协调器的异步渲染？</h3><h4 id="面试高频指数：★-★-★-☆-☆-5"><a href="#面试高频指数：★-★-★-☆-☆-5" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul><li>在经典渲染模式下，React 一旦开始渲染一次更新，不能中断包括创建新 DOM 节点和运行组件中代码在内的工作，这种渲染方法为“阻塞渲染”</li><li>渲染阻塞响应用户输入和动画，使用防抖牺牲一定的响应即时性，使用节流降低更新频率，都不能提供最佳用户体验。</li><li>React 提供 Concurrent 模式，将人机交互研究的结果整合到真实 UI 中<ul><li>渲染可中断</li><li>有意的加载顺序<ul><li>React 可以在旧屏幕桑多停留一段时间，跳过不够好的加载状态，直接展示新屏幕</li></ul></li><li>并发，使用启发式方法决定更新紧急性，同时更新多个状态<ul><li>对于 CPU 密集型更新，例如创建新 DOM 节点和运行组件中代码，任意一个更急迫更新可以中断已经开始的渲染</li><li>对于 IO 密集型更新，例如从网络加载代码或数据，在全部数据到达前在内存中渲染，跳过令人不愉快的空白加载状态</li><li>对于超出屏幕显示的更新，延迟它的相关逻辑</li></ul></li></ul></li></ul><h3 id="什么是-React-Fiber"><a href="#什么是-React-Fiber" class="headerlink" title="什么是 React Fiber ?"></a>什么是 React Fiber ?</h3><h4 id="面试高频指数：★-★-☆-☆-☆-8"><a href="#面试高频指数：★-★-☆-☆-☆-8" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li><p>React 组件是数据的函数 <code>v = f(d)</code></p></li><li><p>计算机通过调用栈跟踪程序执行</p><ul><li>函数执行，栈会添加新堆栈结构，代表函数执行的事务</li><li>太多事务同时执行，会导致动画掉帧，用户输入无法及时响应</li><li>现代浏览器提供 API<ul><li><code>requestIdleCallback</code> 调度一个低优先级函数在空闲阶段执行</li><li><code>requestAnimationFrame</code> 调度一个高优先级函数在下一个动画帧执行</li></ul></li><li>需要自定义调用栈行为，来使用这些 API 优化 UI 渲染</li></ul></li><li><p>React Fiber 是专门为 React 组件实现的堆栈重构</p><ul><li><p>堆栈结构可以保存在内存中，手动调度和操作</p></li><li><p>单个 fiber 是虚拟的堆栈结构，对应一个组件实例</p><ul><li><p>包含组件及其输入、输出信息的 JavaScript 对象</p><ul><li><div class="code-wrapper"><pre><code class="hljs">type<pre><code class="hljs autohotkey">     是执行会被堆栈结构跟踪的函数  - 复合函数、组件类 class 或字符串- `key` 决定协调算法 Fiber 是否可重用- ```  child</code></pre></div> 指向- 类组件 class 的 `render` 方法返回值- 函数组件 的`return` 返回值</code></pre></li><li><div class="code-wrapper"><pre><code class="hljs">sibling<pre><code class="hljs markdown">     指向<span class="hljs-bullet">  -</span> 类组件 class 或函数组件返回数组，其中包含多个子节点的情况<span class="hljs-bullet">-</span> <span class="hljs-code">`return`</span> 返回父 fiber<span class="hljs-bullet">-</span> 属性，即函数参数，以下两者相等，则 fiber 可复用<span class="hljs-bullet">  -</span> <span class="hljs-code">`pendingProps`</span> fiber 开始时设置<span class="hljs-bullet">  -</span> <span class="hljs-code">`memoizedProps`</span> fiber 结束时设置<span class="hljs-bullet">-</span> <span class="hljs-code">```</span><span class="hljs-code">  pengdingWorkProiority</span></code></pre></div> 事务优先级数字- 0 表示 `NoWork`- 数字越大，优先级越低- 调度器使用该字段搜索下一个要执行的事务</code></pre></li><li><p>&#96;&#96;&#96;<br>alternate</p><div class="code-wrapper"><pre><code class="hljs autohotkey">  - `flush` 渲染输出结果到屏幕  - `work-in-progress` 进行中的 fiber 代表未返回堆栈结构的 fiber- ```  output</code></pre></div><ul><li><code>host component</code> 是 React 应用的叶子节点，浏览器环境是小写 HTML 标签</li><li>每个 fiber 输出结果由宿主组件创建，向上传递到整个树</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="React-Fiber-异步渲染分为哪几个阶段，对应生命周期是什么？"><a href="#React-Fiber-异步渲染分为哪几个阶段，对应生命周期是什么？" class="headerlink" title="React Fiber 异步渲染分为哪几个阶段，对应生命周期是什么？"></a>React Fiber 异步渲染分为哪几个阶段，对应生命周期是什么？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-9"><a href="#面试高频指数：★-★-☆-☆-☆-9" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>不同于 Stack renconciler，Fiber reconciler 过程分为两个阶段：</p><ul><li><p>render &#x2F; reconciliation 可中断阶段</p><ul><li><p>以 Fiber tree 为蓝本，每个 Fiber 为工作单元，自顶向下构造 workInProgress Tree</p><ul><li><p>判断节点是否需要更新</p><ul><li><p>需要更新，标记当前节点</p><ul><li><p>更新当前节点状态和属性</p></li><li><p>调用</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">shouldComponentUpdate</span></code></pre></div><ul><li><p>返回</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">ture</span></code></pre></div><p>需要更新</p><ul><li><p>调用</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">render</span></code></pre></div><ul><li>返回子节点，并创建对应 <code>fiber</code></li><li>无子节点</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>当前工作单元结束，返回副作用列表</p></li><li><p>检查 fiber 的 sibiling 或 child</p><ul><li>存在，作为下一个工作单元<ul><li>检查剩余可用时间<ul><li>有，立即开始下一个工作单元</li><li>无，等待下一次主线程空闲，开始下一个工作单元，通过 <code>requestIdleCallback</code> 实现</li></ul></li></ul></li><li>没有下一个工作单元，本阶段结束，进入 <code>pendingCommit</code> 状态</li></ul></li></ul></li><li><p><a href="https://leetcode.cn/leetbook/read/react-interview/nafqor/">∨∧Page 2</a></p></li><li><ul><li><a href="https://leetcode.cn/"><img src="/../imgs/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/logo-dark-cn.c42314a8.svg+xml" alt="logo"></a></li><li><a href="https://leetcode.cn/leetbook/">学习</a></li><li><a href="https://leetcode.cn/problemset/all/">题库</a></li><li><a href="https://leetcode.cn/circle/">讨论</a></li><li><a href="https://leetcode.cn/contest/">竞赛</a></li><li><a href="https://leetcode.cn/company/">求职</a></li><li>商店</li></ul></li><li></li><li></li><li></li><li><p><a href="https://leetcode.cn/problems/two-sum/">-</a></p></li><li><p><img src="/../imgs/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/avatar_1645205761.webp" alt="img"><img src="/../imgs/%E5%89%8D%E7%AB%AF%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C-React/plus-light.594ca211.svg+xml" alt="img"></p></li><li><p><a href="https://leetcode.cn/leetbook/detail/react-interview/">返回</a></p></li><li></li></ul></li><li><p>commit 不可中断阶段</p><ul><li>执行副作用列表<ul><li>更新 DOM 树，更新 ref 指向</li><li>调用组件的生命周期函数或 useEffect 声明的钩子</li></ul></li></ul></li></ul><p>对应生命周期</p><ul><li>render &#x2F; reconciliation<ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>shouldComponentUpate</li><li>componentWillUpdate</li></ul></li><li>commit<ul><li>componentDidMount</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="React-组件有哪些生命周期方法？"><a href="#React-组件有哪些生命周期方法？" class="headerlink" title="React 组件有哪些生命周期方法？"></a>React 组件有哪些生命周期方法？</h3><h4 id="面试高频指数：★-★-★-☆-☆-6"><a href="#面试高频指数：★-★-★-☆-☆-6" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>React 每个组件都包含“生命周期”方法</p><p>开发者可以重写这些方法，便于在运行过程中特定阶段执行这些方法</p><ul><li>constructor(props)<ul><li>React 组件挂载之前调用</li><li>用于初始化 state 和 方法绑定，例如绑定事件处理函数的 this</li></ul></li><li>static getDerivedStateFromProps(props, state)<ul><li>React 组件调用 render 方法前，初始挂载及后续更新都会被调用</li><li>用于返回一个对象来更新 state，返回 null 不更新任何内容</li><li>每次渲染都会触发，包括父组件重新渲染以及组件本身调用 setState</li><li>以下场景不使用 getDerivedStateFromProps<ul><li>执行副作用应用 componentDidUpdate</li><li>prop 更改时重新计算某些数据，请使用 memoization helper 代替</li><li>prop 更改时“重置”某些 state<ul><li>请考虑使组件完全受控或使用 key 使组件完全不受控 代替</li></ul></li></ul></li></ul></li><li>shouldComponentUpdate(nextProps, nextState)<ul><li>props 或 state 发生变化时，渲染执行之前被调用</li><li>首次渲染及 forceUpdate() 调用，React 参考返回 true &#x2F; false，决定是否重新渲染</li></ul></li><li>render()<ul><li>class 组件中唯一必须实现的方法，纯函数，每次调用应返回相同结果</li><li>当 render 被调用时，它会检查 this.props 和 this.state 变化，并返回<ul><li>React 元素：通过 JSX 创建</li><li>数组或 fragements：使得 render 方法可以返回多个元素</li><li>Portals：可以渲染子节点到不同 DOM 子树</li><li>字符串或数值类型：可以在 DOM 中被渲染为文本节点</li><li>布尔类型或 null：什么都不渲染</li></ul></li></ul></li><li>getSnapshotBeforeUpdate(prevProps, prevState)<ul><li>在最近一次渲染输出（提交到 DOM 节点）之前调用</li><li>能在组件发生更改之前从 DOM 中捕获信息，例如滚动位置</li><li>此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate 的第三参数</li></ul></li><li>componentDidMount()<ul><li>组件挂载后（插入 DOM 树中），即首次渲染时，立即调用</li><li>适用于放置依赖 DOM 节点、网络请求获取数据、添加订阅等</li><li>可以直接调用 setState()，触发依赖于 DOM 节点大小或位置的渲染</li></ul></li><li>componentDidUpdate(prevProps, prevState, snapshot)<ul><li>组件更新后立即调用，首次渲染不会执行此方法</li><li>可以执行 DOM 操作，比较前后 props，网络请求</li><li>可以直接调用 setState()，它必须被包裹在一个条件语句里，避免死循环</li><li>如果组件实现了 getSnapshotBeforeUpdate() 生命周期，则生命周期的返回值将作为 componentDidUpdate 的第三个参数</li></ul></li><li>componentWillUnmount()<ul><li>组件卸载及销毁之前直接调用</li><li>用于执行必要的清理操作，清除定时器、取消网络请求以及在 componentDidMount() 中创建的订阅等</li><li>不应调用 setState()，避免组件永远不会重新渲染</li></ul></li></ul><h3 id="React-组件的生命周期可分为哪些阶段？"><a href="#React-组件的生命周期可分为哪些阶段？" class="headerlink" title="React 组件的生命周期可分为哪些阶段？"></a>React 组件的生命周期可分为哪些阶段？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-10"><a href="#面试高频指数：★-★-☆-☆-☆-10" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>React 组件的生命周期可以分为三个阶段</p><ul><li>“Render”阶段：纯净且不包含副作用，可能会被 React 暂停、中止或重新启动<ul><li>constructor(props)</li><li>getDerivedStateFromPorps(props, state)</li><li>shouldComponentUpdate(nextProps, nextState)</li><li>render()</li></ul></li><li>“Pre-commit”阶段：可以读取DOM<ul><li>getSnapshotBeforeUpdate(prevProps, prevState)</li></ul></li><li>“Commit”阶段：可以使用 DOM，运行副作用，安排更新<ul><li>挂载时：componentDidMount()</li><li>更新时：componentDidUpdate(prevProps, prevState, snapshot)</li><li>卸载时：componentWillUnmount()</li></ul></li></ul><h3 id="异步数据请求应在哪些生命周期里调用？"><a href="#异步数据请求应在哪些生命周期里调用？" class="headerlink" title="异步数据请求应在哪些生命周期里调用？"></a>异步数据请求应在哪些生命周期里调用？</h3><h4 id="面试高频指数：★-★-★-★-☆-2"><a href="#面试高频指数：★-★-★-★-☆-2" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul><li>通过网络请求获取数据或订阅数据更新<ul><li>componentDidMount()</li><li>原因<ul><li>首次挂载时执行</li><li>不会重复请求或订阅数据更新</li><li>无需条件不容易触发重复渲染</li></ul></li></ul></li><li>有条件地通过网络请求数据<ul><li>componentDidUpdate(prevProps, prevState, snapshot)</li><li>原因<ul><li>可对比更新前后的 props 或 states</li><li>设置条件<ul><li>当且仅当条件满足时，通过网络请求数据</li><li>避免触发重复渲染</li></ul></li></ul></li></ul></li><li>取消网络请求或者清除在 componentDidMount() 中创建的订阅<ul><li>componentWillUnmount()</li></ul></li></ul><h3 id="useEffect-useLayoutEffect-与生命周期的对应关系是？"><a href="#useEffect-useLayoutEffect-与生命周期的对应关系是？" class="headerlink" title="useEffect useLayoutEffect 与生命周期的对应关系是？"></a>useEffect useLayoutEffect 与生命周期的对应关系是？</h3><h4 id="面试高频指数：★-★-★-★-☆-3"><a href="#面试高频指数：★-★-★-★-☆-3" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><p>useLayoutEffect</p><ul><li>执行时机是组件挂载或更新之后，浏览器执行绘制之前<ul><li>与 componentDidMount + componentDidUpdate 一致</li></ul></li><li>支持返回清除函数，函数执行时机是组件卸载之前<ul><li>与 componentWillUnmout 一致</li></ul></li></ul><p>useEffect</p><ul><li>执行时机是组件挂载或更新之后，浏览器完成布局和绘制之后，在一个延迟事件中被调用<ul><li>与 componentDidMount + componentDidUpdate 不同</li></ul></li><li>支持返回清除函数，函数执行时机是组件卸载之前<ul><li>与 componentWillUnmout 一致</li></ul></li></ul><p>两者都适用于在函数组件主体内，即 React 渲染阶段改变 DOM，添加订阅，设置定时器，记录日志以及执行其他包含副作用的操作</p><p>优先使用 useEffect 避免阻塞视觉更新，只在需要读取 DOM 布局，在浏览器绘制前，同步触发重渲染的场景使用 useLayoutEffect</p><h3 id="在-constructor-中使用-super-的意义是？"><a href="#在-constructor-中使用-super-的意义是？" class="headerlink" title="在 constructor 中使用 super 的意义是？"></a>在 constructor 中使用 super 的意义是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-11"><a href="#面试高频指数：★-★-☆-☆-☆-11" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>JavaScript 中，super 指向父类构造函数，React 类组件可以是 React.Component 等</li><li>JavaScript 中，调用 super 前不能用 this。React 中不能声明 this.state 或读取 this.props</li><li>React 中，调用 super(props) 后，可以在 constructor 中访问 this.props</li><li>React 中，调用 super() 不传参，不能在 constructor 中访问 this.props<ul><li>React 在调用构造函数后，将 props 赋值到实例</li><li>可以在其他生命周期中，访问 this.props</li></ul></li><li>不调用 super，参考 proposal-class-fields 提案，可以将 state 等实例属性写在 class 内</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;state = &#123; time : <span class="hljs-number">0</span> &#125;&#125;</code></pre></div><h3 id="对比-React-Hook-与生命周期"><a href="#对比-React-Hook-与生命周期" class="headerlink" title="对比 React Hook 与生命周期"></a>对比 React Hook 与生命周期</h3><h4 id="面试高频指数：★-★-☆-☆-☆-12"><a href="#面试高频指数：★-★-☆-☆-☆-12" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li><p>什么是 React Hook</p><ul><li>React Hook 是 React 16.8 的新增特性</li><li>开发者可以在不编写 Class 的情况下使用 State 以及其他的 React 特性</li></ul></li><li><p>为什么要用 React Hook 代替拥有生命周期的类组件</p><ul><li><p>类组件的弊端</p><ul><li><p>组件之间复用状态逻辑很难</p><ul><li><p>React 没有提供将可复用性行为“附加”到组件的途径</p></li><li><p>使用</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">render props</span></code></pre></div><p>和</p><div class="code-wrapper"><pre><code class="hljs">高阶组件</code></pre></div><ul><li>需要重新组织组件结构，使得代码难以理解</li><li>形成“嵌套地域”，难以调试和维护</li></ul></li></ul></li><li><p>复杂组件变得难以理解</p><ul><li>组件被状态逻辑和副作用充斥</li><li>不相关逻辑被放在同一生命周期，相关逻辑被分散在不同生命周期<ul><li><code>componentDidMount</code>&#x2F;<code>componentDidUpdate</code> 获取数据</li><li><code>componentDidMount</code> 可能还包含事件监听，需在 <code>componentWillUnmount</code> 清除</li></ul></li><li>大量的状态逻辑，许多人使用状态管理库，组件复用和调试都比较困难</li></ul></li><li><p>难以理解的类组件</p><ul><li>大量的 this 绑定，较高学习成本，区分函数组件和类组件的使用场景</li><li>类组件会无意中鼓励开发者使用一些让 <code>Prepack</code> 等组件预编译优化措施无效的方案</li><li>类组件不能被很好的压缩，热重载不稳定，实例化类组件有轻微额外性能消耗</li></ul></li><li><p>有限的是否渲染控制</p><ul><li>使用 PureComponent 执行一层浅比较 props 或 state，值变化时渲染</li><li>使用 shouldComponentUpdate 函数<ul><li>手动比较前后 props 或 state，返回 true 渲染，false 不渲染</li><li>若 state 为对象，使用不可变对象，简化并加速比较</li></ul></li><li>在 setState 前设置判断条件，满足条件后再 setState</li></ul></li></ul></li><li><p>React Hook 解决的问题</p><ul><li>提高组件复用<ul><li>Hook 在无需修改组件结构的情况下，复用状态逻辑，共享 Hook 变得更便捷</li></ul></li><li>简化组件<ul><li>Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</li><li>非按照生命周期划分，可以使用 Reducer 来管理组件内部状态，使其更加可预测</li></ul></li><li>函数组件代替类组件<ul><li>Hook 在不使用类组件的情况下使用 State 以及其他的 React 特性</li><li>Hook 改造类组件为函数组件，容易理解 this 和学习，便于预编译等优化措施</li><li>Hook 拥抱函数式声明式编程，而无需学习复杂的函数式或响应式编程技术</li></ul></li><li>丰富的更细粒度的是否渲染控制<ul><li>使用 React.memo 比较 props 再渲染组件<ul><li>不使用第二参数时，一层浅比较 props，变化时渲染</li><li>使用第二参数时，手动比较前后的 props，返回 false 渲染，true 不渲染</li></ul></li><li>使用 useMemo 指定依赖，细粒度渲染组件<ul><li>使用第二参数，传入依赖数组，当数组中的值发生变化时，更新返回值</li><li>通常包裹函数式组件的返回值，指定依赖的 props 或 state 的具体值</li><li>包裹任意需要复杂计算的函数，指定依赖的变量。能在同一组件中部分和多次使用</li></ul></li><li>使用 useCallback 避免函数重复创建引起渲染<ul><li>当函数式组件重新更新时，内部声明的函数可能会被重复创建<ul><li>将这些函数作为 props 传入的子组件会重复渲染</li><li>使用 useCallback 包裹函数，传入空数组，总是返回相同函数来避免重复创建引起的渲染</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>React 元素的事件处理和 DOM 元素的不同点</p><ul><li>事件命名<ul><li>React：小驼峰式</li><li>DOM：纯小写</li></ul></li><li>事件处理函数传参<ul><li>React：接受函数</li><li>DOM：字符串</li></ul></li><li>阻止默认行为<ul><li>React：显式的使用 preventDefault</li><li>DOM：return false</li></ul></li><li>事件处理函数，第一参数 e<ul><li>React：e 是一个合成事件。React 根据 W3C 规范来定义合成事件</li><li>DOM：e &#x3D; window.event</li></ul></li><li>添加事件监听<ul><li>React：元素初始渲染的时候添加监听器</li><li>DOM：使用 addEventListener</li></ul></li><li>this 指向<ul><li>React：在 class 组件中，手动 bind this，使用匿名箭头函数或者 class fields 语法来让 this 指向组件本身</li><li>DOM：触发事件的目标对象</li></ul></li><li>向事件处理程序传递参数<ul><li>React：通过箭头函数和 Function.prototype.bind 来实现</li><li>DOM：经常通过 DOM attribute 传参，读取参数时，先获取目标对象，再获取目标对象的 attribute</li></ul></li><li>事件委托<ul><li>React：16 及更早版本，对大多数事件执行 <code>document.addEventListener()</code> 17 后调用 <code>rootNode.addEventListener()</code></li><li>DOM：自行添加事件委托</li></ul></li></ul><h3 id="什么是-React-合成事件？"><a href="#什么是-React-合成事件？" class="headerlink" title="什么是 React 合成事件？"></a>什么是 React 合成事件？</h3><h4 id="面试高频指数：★-★-★-★-☆-4"><a href="#面试高频指数：★-★-★-★-☆-4" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul><li>React 合成事件是浏览器的原生事件的跨浏览器包装器<ul><li>兼容所有浏览器</li><li>接口与浏览器原生事件相同，包括 <code>stopPropagation()</code> 和 <code>preventDefault()</code></li><li>合成事件实例将被传递给事件处理函数</li></ul></li><li>事件池<ul><li>React 16 及更早版本，合成事件是合并而来，放入事件池统一管理<ul><li>事件对象可能会被重用<ul><li>在事件回调函数被调用后，所有属性失效</li><li>不能通过异步访问事件属性</li></ul></li><li>异步访问事件属性<ul><li>调用 <code>e.persist()</code>，从事件池中移除合成事件，允许用户代码保留对事件的引用</li><li>通过实例的 <code>nativeEvent</code>属性来使用浏览器的底层事件</li></ul></li></ul></li><li>React 17 合成事件不再放入事件池<ul><li><code>e.persist()</code> 存在，但不再生效</li><li>可以通过异步访问事件属性</li></ul></li></ul></li><li>事件执行顺序<ul><li>原生事件先执行</li><li>合成事件后执行<ul><li>默认事件处理函数在冒泡阶段触发</li><li>注册捕获阶段事件处理函数，应为事件名添加 Capture</li></ul></li></ul></li><li>合成事件会冒泡<ul><li>React 16 及更早版本，冒泡绑定到 document 上</li><li>React 17，冒泡到 rootNode 上，onScroll 事件不再冒泡</li></ul></li></ul><h3 id="如何在-React-事件处理阻止默认行为？"><a href="#如何在-React-事件处理阻止默认行为？" class="headerlink" title="如何在 React 事件处理阻止默认行为？"></a>如何在 React 事件处理阻止默认行为？</h3><p>调用 <code>e.preventDefault</code> 阻止默认行为。</p><h3 id="如何解决-类组件-中，事件处理的-this-为-undefined-的问题？"><a href="#如何解决-类组件-中，事件处理的-this-为-undefined-的问题？" class="headerlink" title="如何解决 类组件 中，事件处理的 this 为 undefined 的问题？"></a>如何解决 类组件 中，事件处理的 this 为 undefined 的问题？</h3><ul><li>使用 Function.pototype.bind，添加事件处理函数时，给函数绑定 this</li><li>使用 public class fields 语法，可以使用 class fields 正确的绑定回调函数</li><li>使用 匿名回调函数 添加事件，不推荐，原因是<ul><li>匿名回调函数成为组件的 prop 传入子组件，可能导致额外的重新渲染</li></ul></li></ul><h3 id="如何传参给事件处理函数？"><a href="#如何传参给事件处理函数？" class="headerlink" title="如何传参给事件处理函数？"></a>如何传参给事件处理函数？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-5"><a href="#面试高频指数：★-☆-☆-☆-☆-5" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>两种方式</p><ul><li>箭头函数<ul><li>声明一个匿名箭头函数，在其中调用事件处理函数并传参</li><li>不推荐，原因是：<ul><li>匿名回调函数成为组件的 prop 传入子组件，可能导致额外的重新渲染</li></ul></li></ul></li><li>Function.pototype.bind<ul><li>bind 将返回一个新函数，新函数的 this 是 bind 的一个参数，其余参数将作为函数的参数，供调用时使用</li></ul></li></ul><h3 id="如何阻止事件处理函数被频繁调用？"><a href="#如何阻止事件处理函数被频繁调用？" class="headerlink" title="如何阻止事件处理函数被频繁调用？"></a>如何阻止事件处理函数被频繁调用？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-13"><a href="#面试高频指数：★-★-☆-☆-☆-13" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li><p>节流</p><ul><li>一定时间内一定调用一次事件处理函数</li><li>核心区别：定时器不重置</li><li>连续重复调用，定时器不重置，只有第一次调用生效，忽略后面调用</li><li>手写代码<ul><li>原生</li></ul></li></ul></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> throttle = (fn, delay) =&gt; &#123;let timer = <span class="hljs-literal">null</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span>timer = setTimeout(() =&gt; &#123;timer = <span class="hljs-literal">null</span>fn.apply(<span class="hljs-keyword">this</span>, args)&#125;, (delay + <span class="hljs-string">&#x27;&#x27;</span>) | <span class="hljs-number">0</span> || <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>)&#125;&#125;    * 原生  + React Hook</code></pre></div><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs zephir"><span class="hljs-keyword">const</span> useThrottle (<span class="hljs-function"><span class="hljs-keyword">fn</span>, <span class="hljs-title">delay</span>) =&gt; </span>&#123;<span class="hljs-keyword">const</span> ref = useRef(<span class="hljs-function"><span class="hljs-keyword">fn</span>)</span><span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">(<span class="hljs-params">()</span> =&gt; &#123;</span></span><span class="hljs-params"><span class="hljs-function">ref.current = fn</span></span><span class="hljs-params"><span class="hljs-function">&#125;)</span></span><span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-title">useCallback</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">throttle<span class="hljs-params">(<span class="hljs-params">(...args)</span> =&gt; ref.current<span class="hljs-params">(...args)</span>, delay)</span>,</span></span><span class="hljs-params"><span class="hljs-function">[delay]</span></span><span class="hljs-params"><span class="hljs-function">)</span></span><span class="hljs-function">&#125;</span></code></pre></div><ul><li><p>防抖</p><ul><li>一定时间内最多调用一次事件处理函数</li><li>核心区别：定时器重置</li><li>连续重复调用，定时器重置，只有最后一次调用生效，忽略前面调用</li><li>手写代码<ul><li>原生</li></ul></li></ul></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> debounce = (fn, delay) =&gt; &#123;let timer = <span class="hljs-literal">null</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<span class="hljs-keyword">if</span> (timer) clearTimeout(timer)timer = setTimeout(() =&gt; &#123;timer = <span class="hljs-literal">null</span>fn.apply(<span class="hljs-keyword">this</span>, args)&#125;, (delay + <span class="hljs-string">&#x27;&#x27;</span>) | <span class="hljs-number">0</span> || <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>)&#125;&#125;    * 原生 + React Hook</code></pre></div><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs zephir"><span class="hljs-keyword">const</span> useDebounce (<span class="hljs-function"><span class="hljs-keyword">fn</span>, <span class="hljs-title">delay</span>) =&gt; </span>&#123;<span class="hljs-keyword">const</span> ref = useRef(<span class="hljs-function"><span class="hljs-keyword">fn</span>)</span><span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">(<span class="hljs-params">()</span> =&gt; &#123;</span></span><span class="hljs-params"><span class="hljs-function">ref.current = fn</span></span><span class="hljs-params"><span class="hljs-function">&#125;)</span></span><span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-title">useCallback</span><span class="hljs-params">(</span></span><span class="hljs-params"><span class="hljs-function">debounce<span class="hljs-params">(<span class="hljs-params">(...args)</span> =&gt; ref.current<span class="hljs-params">(...args)</span>, delay)</span>,</span></span><span class="hljs-params"><span class="hljs-function">[delay]</span></span><span class="hljs-params"><span class="hljs-function">)</span></span><span class="hljs-function">&#125;</span></code></pre></div><h3 id="React-17-对事件处理做了哪些改进？"><a href="#React-17-对事件处理做了哪些改进？" class="headerlink" title="React 17 对事件处理做了哪些改进？"></a>React 17 对事件处理做了哪些改进？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-14"><a href="#面试高频指数：★-★-☆-☆-☆-14" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><ul><li>更改事件委托<ul><li>更加安全地进行新旧版本 React 树嵌套，多版本都必须为 17 或更高版本<ul><li>React 16 及之前版本<ul><li>向 document 附加事件处理器</li><li>大多数事件执行 <code>document.addEventListener</code></li></ul></li><li>React 17<ul><li>向 React 树的根 DOM 容器附加事件处理器</li><li>大多数事件执行 <code>rootNode.addEventListener</code></li></ul></li></ul></li><li>React 嵌入使用其他技术构建的应用程序变得更加容易<ul><li>React 16 及之前版本<ul><li><code>e.stopPropagation()</code> 将被多 React 版本破坏，嵌套树结构中阻止了事件冒泡，但外部树依然能接收到它</li><li><code>e.stopPropagation()</code> 不会阻止其它技术构建应用的冒泡</li></ul></li><li>React 17 的事件冒泡更接近常规 DOM，更符合预期<ul><li><code>e.stopPropagation()</code> 将阻止多 React 版本的事件冒泡，包括前套树和外部树</li><li><code>e.stopPropagation()</code> 将阻止其它技术构建应用的冒泡</li></ul></li></ul></li></ul></li><li>对标浏览器<ul><li>React 16 及之前版本<ul><li><code>onScroll</code> 事件冒泡，<code>onFocus</code> 事件冒泡</li><li><code>onFocus</code> 和 <code>onBlur</code> 事件底层由 React 实现</li><li>捕获事件（例如 <code>onClickCapture</code>）由 React 实现</li></ul></li><li>React 17 与浏览器行为更接近，并提高了互操作性<ul><li><code>onScroll</code> 事件不再冒泡</li><li><code>onFoucs</code> 和 <code>onBlur</code> 事件底层切换为原生的 <code>focusin</code> 和 <code>focusout</code> 事件</li><li>捕获事件（例如 <code>onClickCapture</code>）现在使用的是实际浏览器中的捕获监听器</li></ul></li></ul></li><li>去除事件池<ul><li>React 16 及以前版本<ul><li>使用 event pooling（事件池）</li><li>重用不同事件的事件对象，以提高性能</li><li>所有事件字段会被重置为 <code>null</code>，必须调用 <code>e.persist()</code> 才能正确使用事件，或者读取需要的属性</li></ul></li><li>React 17 去除事件池，事件对象行为符合预期<ul><li>去除事件池</li><li>不再重用事件对象，避免对现代浏览器的负优化</li><li>所有事件对象不会被重置为 <code>null</code>，无需调用 <code>e.persist()</code>，使用和读取属性与原生事件一致。<code>e.persist()</code> 为兼容而保留，已无实际作用</li></ul></li></ul></li></ul><h2 id="样式管理"><a href="#样式管理" class="headerlink" title="样式管理"></a>样式管理</h2><h3 id="如何在-React-中使用样式？"><a href="#如何在-React-中使用样式？" class="headerlink" title="如何在 React 中使用样式？"></a>如何在 React 中使用样式？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-6"><a href="#面试高频指数：★-☆-☆-☆-☆-6" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li>Style<ul><li><code>style</code> 属性接收含有驼峰命名的 javaScript 对象</li><li>属性名与 JS DOM API 一致，防止 XSS</li><li>React 自动添加 px 后缀到内联样式为数字的属性之后</li><li><code>style</code> 多用于在渲染过程中添加动态计算的样式</li><li>从性能角度来说，通常不推荐将 <code>style</code> 属性作为设置元素样式的主要方式，应使用<code>className</code> 属性来引用外部 CSS 样式表中定义的 class</li></ul></li><li>Class<ul><li><code>className</code> 支持字符串</li><li><code>className</code> 支持大括号包裹的 JS 表达式</li></ul></li><li>CSS-in-JS<ul><li>CSS 由 JavaScript 生成而不是在外部文件中定义</li><li>常用的库包括styled-componentsemotion radium 和 aphrodite 等</li><li>React 对样式如何定义没有明确态度<ul><li>存在疑惑时，比较好的方式是使用 <code>*.css</code> 定义样式，通过 <code>className</code> 指定它们</li></ul></li></ul></li><li>动画<ul><li>渐变效果，可选 <code>React Transition Group</code></li><li>动画效果，可选 <code>React Motion</code> 和 <code>React Spring</code></li></ul></li></ul><h3 id="如何按条件加载样式？"><a href="#如何按条件加载样式？" class="headerlink" title="如何按条件加载样式？"></a>如何按条件加载样式？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-7"><a href="#面试高频指数：★-☆-☆-☆-☆-7" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li>Style</li></ul><p><code>style</code> 采用小驼峰命名属性的 JavaScript 对象，可以按照 JavaScript 对象的方式，有条件地改变属性名和属性值</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> style = &#123;[<span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">&#x27;fontSize&#x27;</span> : <span class="hljs-string">&#x27;lineHeight&#x27;</span>] : <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">12</span> : <span class="hljs-number">1</span>&#125; <span class="hljs-comment">// &#123; fontSize: 12 &#125;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;style&#125;</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> <span class="hljs-comment">// style=&quot;font-size: 12px&quot;</span>&#125;</code></pre></div><ul><li>Class</li></ul><p><code>className</code> 属性，可以传入 JavaScript 表达式，有条件改变的类名</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> className = <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">&#x27;menu-active&#x27;</span> : <span class="hljs-string">&#x27;menu&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;className&#125;</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> <span class="hljs-comment">// class=&quot;menu-active&quot;</span>&#125;</code></pre></div><ul><li>CSS-in-JS</li></ul><p>以styled-components 为例</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>模板字符串</code></pre></div><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = styled.<span class="hljs-property">button</span><span class="hljs-string">`</span><span class="hljs-string">background: <span class="hljs-subst">$&#123;props =&gt; props.primary ? <span class="hljs-string">&#x27;palevioletred&#x27;</span> : <span class="hljs-string">&#x27;white&#x27;</span>&#125;</span>,</span><span class="hljs-string">`</span> <span class="hljs-comment">// background: palevioletred</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>&#125;* <span class="hljs-title class_">JavaScript</span> 对象</code></pre></div><p>- </p><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Button</span> = styled.<span class="hljs-title function_">div</span>(<span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> (&#123;<span class="hljs-attr">background</span>: props.<span class="hljs-property">primary</span> ? <span class="hljs-string">&#x27;palevioletred&#x27;</span> : <span class="hljs-string">&#x27;white&#x27;</span>&#125;)); <span class="hljs-comment">// background: palevioletred</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>Hello World!<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>&#125;</code></pre></div><h3 id="如何合并多个内联样式"><a href="#如何合并多个内联样式" class="headerlink" title="如何合并多个内联样式?"></a>如何合并多个内联样式?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-8"><a href="#面试高频指数：★-☆-☆-☆-☆-8" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p><code>style</code>采用小驼峰命名属性的 JavaScript 对象</p><p>任何合并 JavaScript 对象的方法都可以用于合并内联样式</p><ul><li><p>拓展运算符</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> backgroundStyle = &#123; <span class="hljs-attr">background</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<span class="hljs-keyword">const</span> colorStyle = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">...backgroundStyle</span>, <span class="hljs-attr">...colorStyle</span> &#125;&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;</code></pre></div><ul><li><p>Object.assign</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> backgroundStyle = &#123; <span class="hljs-attr">background</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<span class="hljs-keyword">const</span> colorStyle = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;Object.assign(backgroundStyle,</span> <span class="hljs-attr">colorStyle</span>)&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;</code></pre></div><ul><li><p>遍历赋值</p></li><li><p>JavaScript</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> backgroundStyle = &#123; <span class="hljs-attr">background</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<span class="hljs-keyword">const</span> colorStyle = &#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span> &#125;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(colorStyle).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> backgroundStyle[key] = colorStyle[key])<span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span> () &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;backgroundStyle&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;</code></pre></div><h3 id="如何模块化样式，如何避免样式名冲突-？"><a href="#如何模块化样式，如何避免样式名冲突-？" class="headerlink" title="如何模块化样式，如何避免样式名冲突 ？"></a>如何模块化样式，如何避免样式名冲突 ？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-15"><a href="#面试高频指数：★-★-☆-☆-☆-15" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>（1）什么是 CSS 模块化？</p><p>CSS 模块化是将 CSS 规则 拆分成相对独立的模块，便于开发者在项目中更有效率地组织 CSS</p><ul><li>管理层叠关系</li><li>避免命名冲突</li><li>提高复用度，减少冗余</li><li>便于维护或扩展</li></ul><p>CSS 模块化的方式</p><ul><li>基于文件拆分</li><li>不拆分但设置作用域</li><li>CSS in JS</li><li>内联样式、Shadow DOM 等</li></ul><p>无论哪种方式，核心都是通过 保证CSS类命名唯一，或者 避免命名使用内联样式，来模拟出CSS模块作用域的效果</p><p>（2）基于文件的 CSS 模块的加载</p><ul><li><code>&lt;link&gt;</code><br>将不同模块的 CSS 分文件存放，通过 <code>&lt;link&gt;</code> 标签按需引入</li><li><code>@import</code><br>@规则，将其它 CSS 嵌入当前 CSS<br>除现代浏览器外，也得到了 CSS 预处理器 Less、Sass 和 Stylus 的支持</li><li><code>import</code><br>在 Webpack 中，将 CSS 作为资源引入，通过 CSS Modules 生成独一无二的类名</li></ul><p>（3）CSS 模块化的实现方式</p><ul><li><p>分层拆分</p><p>将 CSS规则 分层存放，并约束不同层次间的命名规则</p><ul><li>SMACSS：按功能分成 Base Layout Module State Theme 五层</li><li>ITCSS：按从通用到具体分成 Settings Tools Generic Base Objects Components 七层</li></ul></li><li><p>分块拆分</p><p>将页面中视觉可复用的块独立出来，仅使用类选择器，并确保类名唯一</p><ul><li>OOCSS<ul><li>将盒模型规则与颜色、背景等主题规则拆分</li><li>将视觉可复用的块类名与页面结构解耦</li></ul></li><li>BEM<ul><li>将页面按 Block Element Modifier 划分</li><li>类名规则 block-name__element-name–modifier-name</li></ul></li></ul></li><li><p>原子化拆分</p><p>每个选择器只包含 1 个或少量属性，通过组合选择器定义复杂样式</p><ul><li>ACSS：属性名像函数，属性值像函数参数，像写内联样式一样组合类名</li><li>Utility-First CSS：提供一套可配置的 CSS 实用类库，使用时按需编译</li></ul></li><li><p>CSS in JS</p><ul><li>CSS Modules<ul><li>将 CSS 作为资源引入</li><li>根据内容的哈希字符串，计算出独一无二类名，CSS 规则 只对该类名下的元素生效</li></ul></li><li>styled-components Aphrodite Emotion 等<ul><li>通过 JS 创建包含属性定义的组件</li><li>生成独一无二的类名</li></ul></li><li>Radium 等<ul><li>通过 JS 创建包含属性定义的组件</li><li>生成内联样式</li></ul></li></ul></li><li><p>Shadow DOM<br>通过<code>attachShadow</code>给元素的影子DOM，附加<code>&lt;style&gt;</code>标签，其中规则不会影响外部元素。代表的框架有 Ionic 等</p></li></ul><p>（4）React 中的样式模块化</p><p>React 对样式如何定义，没有明确的态度，如果存在疑虑，比较好的方式是和平常一样，在一个单独的 <code>*.css</code> 定义你的样式，并通过 <code>className</code> 指定它们。此时，你可以参考 CSS 模块化的方案，通过文件或样式命名规则，来实现样式模块化</p><p>行内样式 <code>style</code> 是避免样式命名冲突的经典策略，但由于性能比 <code>className</code> 低，React 通常不推荐将 style 属性作为设置元素样式的主要方式。在多数情况下，应使用 <code>className</code> 属性来引用外部 CSS 样式表重定义的 <code>class</code>。<code>style</code> 在 React 应用中多用于在渲染过程中添加动态计算的样式</p><p>同样地，在 CSS-in-JS 中，早期有基于 <code>style</code> 实现的 Radium 库，现在比较流行的是基于随机 <code>className</code> 的 style-components 库，与之类似的有 Emotion 和 Glamor，还有面向愿意将 CSS 和 JavaScript 分开存放开发者的 JSS 等。</p><h2 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h2><h3 id="什么是-React-Hook"><a href="#什么是-React-Hook" class="headerlink" title="什么是 React Hook?"></a>什么是 React Hook?</h3><p>Hook 是 React 16.8 的新增特性</p><ul><li>允许开发者在函数组件里“钩入”React state 及生命周期等特性的函数<ul><li>React 内置如 useState、useEffect 等 Hook</li></ul></li><li>Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）<ul><li>非强制按照生命周期划分，避免每个生命周期包含不相关的逻辑</li></ul></li><li>开发者可以在不编写 class 的情况下使用 state 以及其他的 React 特性<ul><li>无需考虑 this，无需考虑函数和 class 组件的区别和应用场景</li><li>便于使用 Prepack 试验 component folding，使代码更易于优化</li><li>拥抱函数式编程</li></ul></li><li>Hook 和现有代码可以同时工作，渐进式地使用</li></ul><h3 id="什么是-State-Hook？"><a href="#什么是-State-Hook？" class="headerlink" title="什么是 State Hook？"></a>什么是 State Hook？</h3><h4 id="面试高频指数：★-★-★-☆-☆-7"><a href="#面试高频指数：★-★-★-☆-☆-7" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul><li>State Hook 允许开发者在 React 函数组件中添加 state 的 Hook</li><li>这种 Hook 在 React 的原生实现是 useState，它是一种函数调用时保存变量的方式，它与 class 里面的 this.state 提供的功能完全相同</li><li>useState 的唯一参数是初始 state，支持数字、字符串、对象等类型</li><li>useState 方法的返回值分别是当前 state 以及更新 state 的函数，使用数组解构获取赋值</li><li>state 只在组件首次渲染时创建，下次重新渲染时，返回当前的 state</li></ul><h3 id="什么是-Effect-Hook？"><a href="#什么是-Effect-Hook？" class="headerlink" title="什么是 Effect Hook？"></a>什么是 Effect Hook？</h3><h4 id="面试高频指数：★-★-★-☆-☆-8"><a href="#面试高频指数：★-★-★-☆-☆-8" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><ul><li>Effect Hook 允许开发者在函数组件中执行副作用操作，包括数据获取、设置订阅以及手动更改 React 组件中的 DOM。分为需要清除和不需要清除的</li><li>这种 Hook 在 React 的原生实现是 useEffect</li><li>useEfect 支持两个参数<ul><li>第一个参数为函数，默认在组件第一次渲染和每次更新、浏览器完成画面渲染之后执行，调用时机可以看作 class 组件的 componentDidMount、componentDidUpdate 生命周期 + 浏览器完成画面渲染时</li><li>第二个参数为数组，只有数组元素发生变化时，才会调用第一个参数的函数<ul><li>当第二个参数为空数组 [] 时，第一个参数的函数仅会在组件挂载和卸载时执行</li></ul></li></ul></li><li>useEffect 可以返回一个函数，用于移除订阅等副作用，区别 class 组件的 componetWillUnMount，React 会在执行当前 effect 之前对上一个 effect 进行清除</li><li>useEffect 放在最贱内部可以直接访问 state 和 props</li></ul><h3 id="如何清除-Effect-Hook-的副作用？"><a href="#如何清除-Effect-Hook-的副作用？" class="headerlink" title="如何清除 Effect Hook 的副作用？"></a>如何清除 Effect Hook 的副作用？</h3><h4 id="面试高频指数：★-★-★-★-☆-5"><a href="#面试高频指数：★-★-★-★-☆-5" class="headerlink" title="面试高频指数：★ ★ ★ ★ ☆"></a>面试高频指数：★ ★ ★ ★ ☆</h4><ul><li>在 useEffect 的 effect 函数中，返回一个清除函数<ul><li>可以将添加和清除副作用的逻辑放在一起</li></ul></li><li>effect 在每次渲染的时候会执行，<ul><li>React 会在执行当前 effect 之前对上一个 effect 进行清除</li></ul></li></ul><h3 id="使用-Hook-需要遵循的规则是？"><a href="#使用-Hook-需要遵循的规则是？" class="headerlink" title="使用 Hook 需要遵循的规则是？"></a>使用 Hook 需要遵循的规则是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-16"><a href="#面试高频指数：★-★-☆-☆-☆-16" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>Hook 本质是 JavaScript 函数，使用 Hook 时需要遵循两条规则</p><ul><li>只在最顶层使用 Hook<ul><li>不要在循环，条件或嵌套函数中调用 Hook<ul><li>确保总在 React 函数的最顶层调用 Hook</li><li>确保 Hook 在每一次渲染都按照相同的顺序被调用<ul><li>多次的 useState 和 useEffect 调用中间保持 Hook 状态正确</li></ul></li></ul></li></ul></li><li>只在 React 函数中调用 Hook<ul><li>仅在 React 的函数组件，而不要在普通的 JavaScript 函数中调用 Hook</li><li>在自定义 Hook 中调用其他 Hook</li></ul></li></ul><h3 id="如何校验-Hook-是否遵循规则？"><a href="#如何校验-Hook-是否遵循规则？" class="headerlink" title="如何校验 Hook 是否遵循规则？"></a>如何校验 Hook 是否遵循规则？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-17"><a href="#面试高频指数：★-★-☆-☆-☆-17" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>React 提供了一个名为 eslint-plugin-react-hooks 的 ESLint 插件来校验 Hook 是否遵循规则</p><ul><li><p>安装</p></li><li><p>shell</p></li></ul><div class="code-wrapper"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> eslint-plugin-react-hooks -D</code></pre></div><ul><li><p>ESLint 配置</p></li><li><p>JSON</p></li></ul><div class="code-wrapper"><pre><code class="hljs awk">&#123;<span class="hljs-string">&quot;plugin&quot;</span>: [<span class="hljs-regexp">//</span> ...<span class="hljs-string">&quot;react-hooks&quot;</span>],<span class="hljs-string">&quot;rules&quot;</span>: &#123;<span class="hljs-regexp">//</span> ...<span class="hljs-string">&quot;react-hooks/rules-of-hooks&quot;</span>: <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-regexp">//</span> 检查 Hook 规则<span class="hljs-string">&quot;react-hooks/exhaustive-deps&quot;</span>: <span class="hljs-string">&quot;warn&quot;</span> <span class="hljs-regexp">//</span> 检查 effect 依赖&#125;&#125;</code></pre></div><h3 id="useMemo-和-useCallback-的区别是？"><a href="#useMemo-和-useCallback-的区别是？" class="headerlink" title="useMemo 和 useCallback 的区别是？"></a>useMemo 和 useCallback 的区别是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-18"><a href="#面试高频指数：★-★-☆-☆-☆-18" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>useMemo</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs reasonml">const memoizedValue = use<span class="hljs-constructor">Memo(()</span> =&gt; compute<span class="hljs-constructor">ExpensiveValue(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>, <span class="hljs-literal">[<span class="hljs-identifier">a</span>, <span class="hljs-identifier">b</span>]</span>)</code></pre></div><p>返回一个<code>memoized</code>值，把”创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销计算。<br>useCallback</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs reasonml">const memoizedCallback = use<span class="hljs-constructor">Callback(()</span> =&gt; &#123; <span class="hljs-keyword">do</span><span class="hljs-constructor">Something(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span> &#125;, <span class="hljs-literal">[<span class="hljs-identifier">a</span>, <span class="hljs-identifier">b</span>]</span>)</code></pre></div><p>返回一个<code>memoized</code>回调函数，把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。<br>useCallback 可看作函数组件的<code>shouldCompoentUpdate</code>，使用引用相等性避免非必要渲染</p><p>useCallback 返回的是函数，useMemo 返回的是值，也可以是函数</p><p>useCallback(fn, deps) 相当于 useMemo(() &#x3D;&gt; fn, deps)</p><h3 id="useReducer-和-useState-的区别是？"><a href="#useReducer-和-useState-的区别是？" class="headerlink" title="useReducer 和 useState 的区别是？"></a>useReducer 和 useState 的区别是？</h3><h4 id="面试高频指数：★-★-★-☆-☆-9"><a href="#面试高频指数：★-★-★-☆-☆-9" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>useReducer</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialArg, init)</code></pre></div><p>useReducer 是 useState 的替代方案，它接收一个形如<code>(state, action) =&gt; newState</code>的 reducer，返回当前的 state 及其配套的<code>dispatch</code>方法<br>useReducer 比 useState 更适用于某些场景</p><ul><li>state 逻辑较复杂，并且包含多个子值</li><li>下一个 state 依赖于之前的 state</li></ul><p>useReducer 第二个返回值是 dispatch 而不是回调函数</p><ul><li>可以向子组件传递 dispatch 而不是函数<ul><li>容易会触发深更新的组件做性能优化</li></ul></li></ul><h3 id="useLayoutEffect-和-useEffect-的区别是？"><a href="#useLayoutEffect-和-useEffect-的区别是？" class="headerlink" title="useLayoutEffect 和 useEffect 的区别是？"></a>useLayoutEffect 和 useEffect 的区别是？</h3><h4 id="面试高频指数：★-★-★-☆-☆-10"><a href="#面试高频指数：★-★-★-☆-☆-10" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>useLayoutEffect</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// add effect</span><span class="hljs-keyword">return</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// clean effect</span>&#125;&#125;)</code></pre></div><p>相同</p><ul><li>useLayoutEffect 的签名与 useEffect 相同</li><li>服务端渲染时，useLayoutEffect 和 useEffect 都无法在 Javascript 代码加载完成前执行<ul><li>服务端渲染组件引入 useLayoutEffect 触发 React 告警，解决<ul><li>使用 useEffect 替代 useLayoutEffect</li><li>或将该组件延迟到客户端渲染完成后再显示</li></ul></li></ul></li></ul><p>区别</p><ul><li>useLayoutEffect<ul><li>在所有 DOM 变更之后同步调用 effect，用来读取 DOM 布局并同步触发重渲染</li><li>在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新</li></ul></li><li>useEffect<ul><li>在所有 DOM 变更并且浏览器完成渲染后调用 effect</li><li>尽可能使用标准的 useEffect 以避免阻塞视觉更新<ul><li>只有 useEffect 有问题时，再尝试 useLayoutEffect</li></ul></li></ul></li></ul><h3 id="useRef-和-Refs-的区别是？"><a href="#useRef-和-Refs-的区别是？" class="headerlink" title="useRef 和 Refs 的区别是？"></a>useRef 和 Refs 的区别是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-19"><a href="#面试高频指数：★-★-☆-☆-☆-19" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>useRef</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">ref</span>Container = useRef(initialValue)</code></pre></div><p>useRef 返回一个可变的 ref 对象，其<code>.current</code>属性被初始化传入参数<code>initialValue</code><br>返回的 ref 对象在组件的整个生命周期保持不变</p><p>Refs</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;constructor(props) &#123;<span class="hljs-keyword">super</span>(props)<span class="hljs-keyword">this</span>.myRef = <span class="hljs-type">React</span>.createRef()&#125;render() &#123;<span class="hljs-keyword">return</span> &lt;div ref=&#123;<span class="hljs-keyword">this</span>.myRef&#125; /&gt;&#125;&#125;</code></pre></div><p>Refs 使用 <code>React.createRef()</code> 创建的，并通过 <code>ref</code> 属性附加到 React 元素<br>当 ref 被传递给 <code>render</code> 中的元素时，对节点的引用可以在 ref 的 <code>current</code> 属性中被访问</p><p>区别</p><p>useRef</p><ul><li><p>函数组件可用</p></li><li><p>用途多样，</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">useRef</span><span class="hljs-params">()</span></span></code></pre></div><p>创建一个普通 Javascript 对象，每次渲染时返回同一个 ref 对象</p><ul><li>可以在其<code>.current</code> 属性保存任何可变值</li></ul></li></ul><p>Refs</p><ul><li><p>class 组件或 HTML 元素，函数组件无实例，不可用</p></li><li><p>用途单一，</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-title">.current</span></code></pre></div><p>属性为实例的引用，根据节点的类型不同</p><ul><li>当 <code>ref</code> 属性用于 HTML 元素时，构造函数中使用 <code>React.createRef()</code> 创建的<code>ref</code>接收底层 DOM 元素作为 <code>current</code> 属性</li><li>当 <code>ref</code> 属性用于自定义 class 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性</li></ul></li></ul><h3 id="如何自定义-Hook？"><a href="#如何自定义-Hook？" class="headerlink" title="如何自定义 Hook？"></a>如何自定义 Hook？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-20"><a href="#面试高频指数：★-★-☆-☆-☆-20" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>（1）自定义 Hook 定义</p><p>自定义 Hook，是将组件逻辑提取到可重用的函数，它可以像 <code>render props</code> 和高阶组件来共享组件之间的状态逻辑，而不增加组件</p><p>（2）如何自定义 Hook</p><p>自定义 Hook 是一个函数，可以调用其他的 Hook</p><ul><li>名称以 “use” 开头，表示这是一个 Hook<ul><li>便于 React 判断函数函数内部是否包含对其内部 Hook 的调用</li><li>自动检查 Hook 是否违法 Hook 规则</li></ul></li><li>参数和返回可以自定义，可以像使用函数一样在不同 Hook 间传递信息</li><li>其中所有 state 和副作用完全隔离，每次调用 Hook，都会获取独立的 state</li></ul><p>将两个函数组件的共同的状态逻辑提取到自定义 Hook 中，自定义 Hook 是一种自然遵循 Hook 设计的约定，而不是 React 的特性</p><p>（3）自定义 Hook 作用</p><p>自定义 Hook 解决了以前在 React 组件中无法灵活共享逻辑的问题</p><p>自定义 Hook 可以用于表单处理、动画、订阅声明、计时器等场景</p><p>尽量避免过早地增加抽象逻辑，当函数组件代码行数增多时，可以通过自定义 Hook 简化代码逻辑，解决组件杂乱无章。</p><h3 id="是否有必要使用-Hook-API-重写所有类组件？"><a href="#是否有必要使用-Hook-API-重写所有类组件？" class="headerlink" title="是否有必要使用 Hook API 重写所有类组件？"></a>是否有必要使用 Hook API 重写所有类组件？</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-9"><a href="#面试高频指数：★-☆-☆-☆-☆-9" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>不，React 推荐称为编写 React 组件的主要方式，并且提供了自定义 Hook 等 class 组件无法实现的功能，更利于自动代码优化。但是</p><ul><li>Hook 暂时不能覆盖 class 组件的所有场景，比如生命周期<code>getSnapshotBeforeUpdate</code>，<code>getDerivedStateFromError</code> 和 <code>componentDidCatch</code> 暂无 Hook 等价写法</li><li>没有计划从 React 中移除 class</li></ul><p>所以，React 鼓励写新组件的时候开始尝试 Hook，不推荐用 Hook 重写已有的 class，除非开发者本来就打算重写它们（例如：为了修复 bug）</p><h3 id="useState-返回更新-state-的函数是同步，还是异步的？"><a href="#useState-返回更新-state-的函数是同步，还是异步的？" class="headerlink" title="useState 返回更新 state 的函数是同步，还是异步的？"></a>useState 返回更新 state 的函数是同步，还是异步的？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-21"><a href="#面试高频指数：★-★-☆-☆-☆-21" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>useState 返回更新 state 函数式异步的，接收参数可以是新状态的值，也可以是回调函数</p><p>可以通过两种方式，获取上一个 state 的状态值</p><ul><li>回调函数的第一个参数是上一个状态的值，可以像使用 useReducer 的 reducer 函数一样，基于上一个 state 来生成新的 state</li><li>或者可以在 useEffect 或 useLayoutEffect 中获取更新后的状态，将 useEffect 或 useLayoutEffect 封装到自定义 Hook 同样有效</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="什么是-Virtual-DOM"><a href="#什么是-Virtual-DOM" class="headerlink" title="什么是 Virtual DOM ?"></a>什么是 Virtual DOM ?</h3><h4 id="面试高频指数：★-★-★-★-★-2"><a href="#面试高频指数：★-★-★-★-★-2" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><p>Virtual DOM 是一编程概念</p><ul><li>UI 以一种理想化的，或者说“虚拟的”表现形式被保存在内存中<ul><li>支持可以优化的 Diff 算法</li></ul></li><li>通过 ReactDOM 等类库使之与“真实的” DOM 同步，这一过程叫做协调<ul><li>支持优先级，并行可中断的协调策略</li><li>支持 ReactCanvas 和 ReactNative 等其他渲染方式，甚至非浏览器环境</li></ul></li></ul><p>Virtual DOM 赋予 React 声明式的 API</p><ul><li>告诉 React 希望让 UI 是什么状态，React 就确保 DOM 匹配该状态</li><li>开发者不必关心属性操作、事件处理和手动 DOM 更新这些构建应用程序必要的操作</li></ul><p>Virtual DOM 是一种模式，在 React 中</p><ul><li>Virtual DOM 通常与 React 元素关联，代表用户界面的对象</li><li>fibers 内部对象来存放组件树的附加信息</li><li>React Fiber 是协调引擎，主要目的是使 Virtual DOM 可以增量式渲染</li></ul><h3 id="什么是-React-Diff，对比-Vue-Diff-？"><a href="#什么是-React-Diff，对比-Vue-Diff-？" class="headerlink" title="什么是 React Diff，对比 Vue Diff ？"></a>什么是 React Diff，对比 Vue Diff ？</h3><h4 id="面试高频指数：★-★-★-★-★-3"><a href="#面试高频指数：★-★-★-★-★-3" class="headerlink" title="面试高频指数：★ ★ ★ ★ ★"></a>面试高频指数：★ ★ ★ ★ ★</h4><p>虚拟 DOM 的 Diff 算法</p><ul><li>将新旧虚拟 DOM 看作两棵节点树，节点个数为 n<ul><li>左侧树的节点需要与右侧树的节点一一对比，需要 O(n²) 复杂度</li><li>删除未找到的节点，需要再找合适节点放到被删除位置，需要 O(n) 复杂度</li><li>添加新节点，需要 O(n) 复杂度</li></ul></li><li>综上，Diff 虚拟 DOM 的复杂度是 O(n³)</li></ul><p>React 基于以下两个假设的基础之上提出 O(n) 的启发式算法</p><ul><li>两个不同类型的元素会产生不同的树</li><li>可以通过设置 <code>key</code> 属性，来告知渲染哪些子元素在不同的渲染下可以保存不变</li></ul><p>React Diffing 算法</p><ul><li>Tree Diff<ul><li>对比两棵树时，首选比较两棵树的根节点。不同类型的根节点元素会有不同的形态<ul><li>根节点为不同类型的元素<ul><li>React 会拆卸原有的树并且建立起新的树</li><li>当卸载一棵树时<ul><li>对应的 DOM 节点会被销毁<ul><li>建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中</li></ul></li><li>组件实例将执行 <code>componentWillUnmount()</code> 方法</li></ul></li></ul></li><li>根节点为相同类型的元素<ul><li>React 会保留节点</li><li>仅比对及更新有改变的属性</li></ul></li><li>处理完根节点，React 继续对子节点进行递归</li></ul></li><li>通过 updateDepth 控制 Virtual Dom 树层级</li><li>只比较同一个父节点的子节点</li><li>通过删除和创建节点实现跨层级移动</li><li>避免跨层级移动，优先 CSS 控制显示隐藏</li></ul></li><li>Component Diff<ul><li>同类型组件<ul><li>组件实例会保持不变，因此可以在不同的渲染时保持 state 一致</li><li>React 将更新该组件实例的 props 以及保证与最新的元素保持一致</li><li>调用该实例的 <code>UNSAFE_componentWillReceiveProps</code>、 <code>UNSAFE_componentWillUpdate()</code> 以及 <code>componentDidUpdate()</code> 方法</li><li>调用 <code>render()</code> 方法，diff 算法将在之前的结果以及新的结果中进行递归</li><li>通过 shouldComponentUpdate、useMemo、useCallback 手动优化</li><li>不同类型组件，输出内容相似<ul><li>建议改成同一类型，避免重新渲染组件</li></ul></li></ul></li><li>不同类型组件<ul><li>删除和创建</li></ul></li></ul></li><li>Element Diff<ul><li>默认情况下，React 会同时遍历两个子元素的列表，递归 DOM 节点的子元素<ul><li>产生差异时，生成一个 mutation</li></ul></li><li>用 key 标识节点<ul><li>避免使用索引 index，而应使用例如 id 唯一标识来作为 key</li></ul></li><li>只顺序移动位置变到前面的节点</li><li>相同类型 React 元素，保留 DOM 节点，仅对比及更新改变的属性</li></ul></li></ul><p>Vue 2.x 优化 Diff 算法</p><ul><li>基本优化与 React 相同</li><li>pathNode<ul><li>新老节点相同，不更新</li><li>新老节点都是静态节点，key 相同<ul><li>新节点.elm &#x3D; 老节点.elm</li><li>新节点.componentInstance &#x3D; 老节点.componentInstance</li></ul></li><li>新老节点存在，不相同<ul><li>用 updateChildren 更新</li></ul></li></ul></li><li>updateChildren<ul><li>虚拟 DOM 双指针，真实 DOM 双指针，一一对应</li><li>两端到中间，直到虚拟 DOM 或真实 DOM，左指针 &gt; 右指针</li></ul></li></ul><p>Vue 3.x 优化 Diff 算法</p><ul><li>创建 VNode 确定类型，内容不会变化的 DOM 添加静态标记</li><li>在 mount &#x2F; patch 中用位运算判断 VNode 类型<ul><li>静态提升 hoistStatic<ul><li>不参与更新的元素，只创建一次，渲染时直接复用</li></ul></li><li>事件侦听器缓存 cacheHandlers<ul><li>缓存函数，不追踪变化，提升性能</li></ul></li></ul></li></ul><h3 id="什么是-React-Concurrent-模式"><a href="#什么是-React-Concurrent-模式" class="headerlink" title="什么是 React Concurrent 模式?"></a>什么是 React Concurrent 模式?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-10"><a href="#面试高频指数：★-☆-☆-☆-☆-10" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>Concurrent 模式是一组 React 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整</p><p>Concurrent 模式的特点包括</p><ul><li>可中断渲染<ul><li>中断一项正在执行的更新去做更重要的事情，然后再回到之前正在做的工作</li><li>减少防抖和节流在 UI 中的需求。因为渲染可以终端，不需要人为地延迟工作以避免卡顿</li></ul></li><li>有意的加载顺序<ul><li>React 首先在内存中准备新屏幕</li><li>之前，React 继续显示完全互动，带有内联加载指示器的旧屏幕</li><li>当新屏幕准备就绪之后，React 可以带我们跳转到新屏幕</li></ul></li><li>并发<ul><li>在 Concurrent 模式中，React 可以同时更新多个状态<ul><li>对于 CPU 密集更新（例如创建新的 DOM 节点和运行组件中的代码），并发意味着一个更急迫的更新可以“中断”已经开始的渲染</li><li>对于 IO 密集的更新（例如从网络加载代码或数据），并发意味着 React 甚至可以在全部数据到达之前就在内存中开始渲染</li></ul></li></ul></li></ul><p>Concurrent 模式的任务是帮助将人机交互研究的结果整合到真实的 UI 中</p><ul><li>避免在屏幕之间切换时显示过多的中间加载状态</li><li>对于用户输入、悬停、点击、页面转换等在内部使用不同的“优先级”，大致对应于人类感知研究中的交互类别</li></ul><p>Concurrent 模式的开启</p><ul><li><p>安装 React 实验版本</p></li><li><p>plain</p></li></ul><div class="code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install react@experimental react-dom@experimental</code></pre></div><ul><li>开启 Concurrent 模式<ul><li>blocking 模式：提供了 concurrent 模式的小部分功能，更接近于当前 React 的 legacy 模式<ul><li><code>ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)</code></li></ul></li><li>concurrent 模式：未来 React 默认开发模式<ul><li><code>ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code></li></ul></li></ul></li></ul><p>Concurrent 模式常用 API</p><ul><li>Suspense<ul><li>允许组件在渲染之前进行“等待”，并在等待时显示 fallback 的内容</li></ul></li><li>SuspenseList<ul><li>通过编排向用户显示这些组件的顺序，来帮助协调血多可以挂起的组件</li></ul></li><li>useTransition<ul><li>允许组件在切换到下一个界面之前等待内容加载，从而避免不必要的加载状态</li><li>允许组件将速度较慢的数据获取更新推迟到随后渲染，以便能够立即渲染更重要的更新</li></ul></li><li>useDeferredValue<ul><li>返回一个延迟响应的值，该值可能“延后”的最长时间为 timeoutMs</li><li>适合立即渲染用户输入内容，同时需要等待数据获取的内容，保持接口可响应性的场景</li></ul></li></ul><h3 id="什么是-Suspense"><a href="#什么是-Suspense" class="headerlink" title="什么是 Suspense ?"></a>什么是 Suspense ?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-11"><a href="#面试高频指数：★-☆-☆-☆-☆-11" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><ul><li>Suspense 让组件“等待”某个异步操作，直到该异步操作结束即可渲染</li><li>Suspense 不是一个数据请求的库，而是一个机制<ul><li>这个机制是用来给数据请求库向React通信说明某个组件正在读取的数据当前仍不可用</li><li>通信之后，React可以继续等待数据的返回并更新UI</li></ul></li><li>Suspense不是什么<ul><li>不是数据获取的一种实现</li><li>不是直接用于数据获取的客户端</li><li>不使数据获取与视图层代码耦合</li></ul></li><li>Suspense可做什么<ul><li>让数据获取库与React紧密整合</li><li>让开发者有针对性地安排加载状态的展示</li><li>它能够消除 raceconditions，避免由于代码运行顺序的错误假设而导致的bug<ul><li>不是等到响应报文被接收之后，才去更新 State</li><li>反过来，发出请求之后，马上更新 State（外加开始渲染）</li></ul></li></ul></li><li>Suspense 可以不必等到数据全部返回才开始渲染<ul><li>一发送网络请求，马上开始渲染<ul><li>读取的数据没获取完毕，组件会处于“挂起”状态</li><li>React 会跳过“挂起”组件，继续渲染组件树中的其他组件</li></ul></li><li>随着更多数据的到来，React 将尝试重新渲染，并且每次都可能渲染出更加完整的组件树</li></ul></li></ul><h3 id="React-如何定义任务的优先级？"><a href="#React-如何定义任务的优先级？" class="headerlink" title="React 如何定义任务的优先级？"></a>React 如何定义任务的优先级？</h3><h4 id="面试高频指数：★-★-★-☆-☆-11"><a href="#面试高频指数：★-★-★-☆-☆-11" class="headerlink" title="面试高频指数：★ ★ ★ ☆ ☆"></a>面试高频指数：★ ★ ★ ☆ ☆</h4><p>任务优先级是产生更新对象之后，React去执行一个更新任务，这个任务的优先级</p><p>任务优先级被用来区分多个更新任务的紧急程度，对比前后两次更新的任务优先级</p><ul><li>后者 &gt; 前者，React会取消前者的任务调度</li><li>后者&#x3D;前者，React 会将同等优先级的更新收敛到一次任务中</li><li>后者 &lt; 前者，React会在前者更新完成后，再对后者发起任务调度</li></ul><p>简而言之，任务优先级存在的意义</p><ul><li>保证高优先级任务及时响应</li><li>收敛同等优先级的任务调度</li></ul><p>React定义的任务优先级分为三类</p><ul><li>同步优先级：React的 legacy 同步渲染模式产生的更新任务的优先级</li><li>同步批量优先级：React的 blocking模式产生的更新任务的优先级</li><li>Concurrent 模式优先级：对于用户输入、悬停、点击、页面转换等在内部使用不同的“优先级”，大致对应于人类感知研究中的交互类别</li></ul><p><code>LanePriority</code> 越大，优先级越高</p><ul><li>JavaScript</li></ul><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">export</span> const SyncLanePriority: LanePriority = <span class="hljs-number">17</span><span class="hljs-attribute">export</span> const SyncBatchedLanePriority: LanePriority = <span class="hljs-number">16</span><span class="hljs-attribute">const</span> InputDiscreteHydrationLanePriority: LanePriority = <span class="hljs-number">15</span><span class="hljs-attribute">export</span> const InputDiscreteLanePriority: LanePriority = <span class="hljs-number">14</span><span class="hljs-attribute">const</span> InputContinuousHydrationLanePriority: LanePriority = <span class="hljs-number">13</span><span class="hljs-attribute">export</span> const InputContinuousLanePriority: LanePriority = <span class="hljs-number">12</span><span class="hljs-attribute">const</span> DefaultHydrationLanePriority: LanePriority = <span class="hljs-number">11</span><span class="hljs-attribute">export</span> const DefaultLanePriority: LanePriority = <span class="hljs-number">10</span><span class="hljs-attribute">const</span> TransitionShortHydrationLanePriority: LanePriority = <span class="hljs-number">9</span><span class="hljs-attribute">export</span> const TransitionShortLanePriority: LanePriority = <span class="hljs-number">8</span><span class="hljs-attribute">const</span> TransitionLongHydrationLanePriority: LanePriority = <span class="hljs-number">7</span><span class="hljs-attribute">export</span> const TransitionLongLanePriority: LanePriority = <span class="hljs-number">6</span><span class="hljs-attribute">const</span> RetryLanePriority: LanePriority = <span class="hljs-number">5</span><span class="hljs-attribute">const</span> SelectiveHydrationLanePriority: LanePriority = <span class="hljs-number">4</span><span class="hljs-attribute">const</span> IdleHydrationLanePriority: LanePriority = <span class="hljs-number">3</span><span class="hljs-attribute">const</span> IdleLanePriority: LanePriority = <span class="hljs-number">2</span><span class="hljs-attribute">const</span> OffscreenLanePriority: LanePriority = <span class="hljs-number">1</span><span class="hljs-attribute">export</span> const NoLanePriority: LanePriority = <span class="hljs-number">0</span></code></pre></div><h3 id="什么是-Redux"><a href="#什么是-Redux" class="headerlink" title="什么是 Redux ?"></a>什么是 Redux ?</h3><h4 id="面试高频指数：★-☆-☆-☆-☆-12"><a href="#面试高频指数：★-☆-☆-☆-☆-12" class="headerlink" title="面试高频指数：★ ☆ ☆ ☆ ☆"></a>面试高频指数：★ ☆ ☆ ☆ ☆</h4><p>Redux 是 JavaScript 应用的可预测状态容器</p><ul><li>可预测<ul><li>在不同环境（客户端、服务器和移动端）行为一致，易于测试</li></ul></li><li>集中<ul><li>集中应用状态和逻辑，支持撤销、重做和持久化</li></ul></li><li>可调试<ul><li>Redux DevTools 可以方便地跟踪应用的状态何时、何处、为什么及如何改变</li><li>Rddux 架构允许开发者记录更改，使用“时间旅行调试”，向服务器发送完整错误报告</li></ul></li><li>灵活<ul><li>Redux 可用于任何 UI 层，并拥有一个庞大的插件生态系统来满足您的需求</li></ul></li></ul><h3 id="Flux-和-Redux-的区别是？"><a href="#Flux-和-Redux-的区别是？" class="headerlink" title="Flux 和 Redux 的区别是？"></a>Flux 和 Redux 的区别是？</h3><h4 id="面试高频指数：★-★-☆-☆-☆-22"><a href="#面试高频指数：★-★-☆-☆-☆-22" class="headerlink" title="面试高频指数：★ ★ ☆ ☆ ☆"></a>面试高频指数：★ ★ ☆ ☆ ☆</h4><p>Flux</p><ul><li>Flux 是用于构建用户界面的应用程序架构，通过单向数据流补充 React 可组合的视图组件</li><li>Flux 更像模式而非框架，没有任何硬依赖</li><li>Flux 架构的应用包含 4 部分<ul><li>Action<ul><li>通过 Action creators 创建</li><li>每个 Action 拥有 type 或类似属性</li><li>传递给 Dispatcher</li></ul></li><li>Dispatcher<ul><li>分发 Actions 给所有注册 Store 的回调函数</li></ul></li><li>Store<ul><li>接受 Action 更新数据后，触发 change 事件，通知 View</li><li>可以由多个 Store</li></ul></li><li>View 视图组件，即 Controller-View<ul><li>家庭 change 事件，从 Store 取回数据，将数据传递给子组件或更新组件状态</li><li>响应用户输入，生成新的 Action</li></ul></li></ul></li></ul><p>Redux</p><ul><li><p>Redux 是 JavaScript 应用的可预测状态容器</p></li><li><p>Redux 对不同框架都有完整实现，Facebook 官方推荐使用代替 Flux</p></li><li><p>Redux 架构与 Flux 基本一致，但做了简化</p><ul><li><p>State 只读，更改 State 的方式是返回新的对象，即引入 Reducer 纯函数</p></li><li><p>Action 与 Dispatcher ，只需返回包含 type 和 payload 属性的对象</p></li><li><p>Store</p><ul><li>唯一</li><li><code>createStore</code> 基于 Reducer 纯函数创建</li><li><code>store.dispatch()</code> 调用 Action</li></ul></li><li><p>View</p><ul><li><p>通过 <code>store.getState()</code> 获取最新状态</p></li><li><p>通过</p><div class="code-wrapper"><pre><code class="hljs gcode">store.subscribe<span class="hljs-comment">()</span></code></pre></div><p>订阅状态更新</p><ul><li><code>store.subscribe()</code> 返回函数可取消订阅</li></ul></li></ul></li></ul></li></ul><p>综上，Redux 与 Flux 都基于单向数据流，架构相似，但 Redux 默认应用只有唯一 Store，精简掉 Dispatcher，引入 Reducer 纯函数，通过返回新对象，而不是更改对象，更新状态。</p><p>对比 Flux 的官方实现，Redux 的 API 更简洁，并且提供了如 <code>combineReducers</code>等工具函数及 <code>React-Toolkit</code> 工具集，以及对状态的撤销、重做和持久化等更复杂的功能。提供如 <code>React-Redux</code> 等简化 Redux 与其他第三方库的连接。</p><p>Facebook 官方推荐在生产环境中使用代替 Flux。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习路线</title>
    <link href="/2023/01/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2023/01/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p><strong>HTML &#x2F; CSS &#x2F; JavaScript 基础学习</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web">《Web 入门》</a> MDN 权威入门指南，HTML &#x2F; CSS &#x2F; JavaScript 快速上手</li><li><a href="https://leetcode-cn.com/leetbook/detail/html-css-interview/">《CSS 世界》</a> 讲解细腻，拓展延伸对 CSS 的认识</li><li><a href="https://leetcode.cn/link/?target=https://zh.javascript.info">《现代 JavaScript 教程》</a> 线上教程，简单明了，时效性强</li><li>《JavaScript 高级程序设计》 传说中的红宝书</li><li>《JavaScript 权威指南》 传说中的犀牛书</li></ul><p><strong>jQuery &#x2F; ES6+ &#x2F; 正则 &#x2F; Canvas 进阶学习</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://jquery.cuishifeng.cn">《jQuery 中文文档》</a> 翻译完整，结构清晰</li><li><a href="https://leetcode.cn/link/?target=https://es6.ruanyifeng.com/">《ES6 入门教程》</a> 线上教程，很多前端学习 ES6 的起点和字典</li><li><a href="https://leetcode.cn/link/?target=https://deerchao.cn/tutorials/regex/regex.htm">《正则表达式 30 分钟入门教程》 </a>30 分钟从入门到掌握正则的使用</li><li>《Web 前端开发精品课 HTML5 Canvas 开发详解》图文并茂，代码示例丰富</li><li><a href="https://leetcode-cn.com/leetbook/detail/javascript-interview/">《前端通关手册：JavaScript》</a> 大量面试真题检测 JavaScript 掌握水平</li></ul><p><strong>工程化及框架应用学习</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://nodejs.org/zh-cn/docs/">《Node.js 中文文档》</a></li><li><a href="https://leetcode.cn/link/?target=https://webpack.docschina.org/concepts/">《Webpack 中文文档》</a></li><li><a href="https://leetcode.cn/link/?target=https://cn.vuejs.org/v2/guide/">《Vue.js 中文文档》</a> Vue &#x2F; React &#x2F; Angular 新手建议顺序阅读</li><li><a href="https://leetcode.cn/link/?target=https://zh-hans.reactjs.org/docs/getting-started.html">《React 中文文档》</a></li><li><a href="https://leetcode.cn/link/?target=https://angular.cn/docs">《Angular 中文文档》</a></li></ul><p><strong>网络学习</strong></p><ul><li><a href="https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/">《计算机网络面试突击》</a> 从面试出发学习计算机网络和协议相关知识</li><li><a href="https://leetcode-cn.com/leetbook/detail/illustrate-http/">《图解 HTTP》</a> 172 张图解轻松入门。从基础知识到最新动向，一本书掌握 HTTP 协议</li></ul><p><strong>算法和数据结构及设计模式学习</strong></p><ul><li>《我的第一本算法书》 481 张步骤图详解 26 个算法和 7 个数据结构的基本原理</li><li><a href="https://leetcode-cn.com/leetbook/detail/learn-data-sturcture-in-7-chapters/">《七章刷完数据结构》</a> 学透方法，高效掌握数据结构</li><li><a href="https://leetcode-cn.com/leetbook/detail/grokking-algorithms/">《算法图解》</a> 像小说一样有趣的算法入门书</li><li><a href="https://leetcode-cn.com/leetbook/detail/learning-algorithms-with-leetcode/">《零起步学算法》</a> 以初学者视角，重点讲解算法与数据结构的设计思想</li><li><a href="https://leetcode-cn.com/leetbook/detail/high-frequency-algorithm-exercise/">《高频算法实战》</a> 进阶版算法与数据结构教程，追踪原理，融会贯通</li><li><a href="https://leetcode-cn.com/leetbook/detail/design-patterns/">《深入浅出设计模式》</a> 用生动的例子详解 23 种设计模式</li></ul><p><strong>性能优化</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://developer.mozilla.org/zh-CN/docs/Web/Performance">《Web 性能》</a> MDN 权威文档罗列 Web 性能指标和测量方法</li><li>《高性能网站建设指南》 堪称前端工程师技能精髓，很多前端的性能优化入门书</li><li>《高性能网站建设进阶指南》 进一步学习性能优化，建设指南的进阶版</li><li>《高性能 JavaScript》 编写运行更快的 JavaScript 权威指南</li></ul><p><strong>原理</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://cn.vuejs.org/v2/guide/reactivity.html">《深入响应式原理》</a> Vue.js 权威说明响应式原理</li><li><a href="https://leetcode.cn/link/?target=https://zh-hans.reactjs.org/docs/implementation-notes.html">《React 实现说明》</a> React 实现原理资料汇总</li></ul><p><strong>安全</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://developer.mozilla.org/zh-CN/docs/Web/Security">《Web 安全》</a> MDN 权威文档说明 Web 攻击方式及防御策略</li><li>《Web 安全开发指南》详细介绍Web安全开发的必备知识和攻防实战</li><li><a href="https://leetcode.cn/link/?target=http://xss-quiz.int21h.jp/">《XSS Challenges》</a> 模拟 XSS 攻击并闯关</li></ul><p><strong>调试和测试</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://developer.mozilla.org/zh-CN/docs/Tools/Debugger">《调试器》</a> MDN 权威文档说明如何使用 JavaScript Debugge</li><li><a href="https://leetcode.cn/link/?target=https://jestjs.io/zh-Hans/docs/getting-started">《Jest中文文档》</a> 被广泛使用的测试框架的说明文档</li></ul><p><strong>项目管理</strong></p><ul><li><a href="https://leetcode.cn/link/?target=http://markdown.p2hp.com/getting-started/">《Markdown 入门》</a> 用轻量级的标记语言快速书写格式优雅的文档</li><li><a href="https://leetcode-cn.com/leetbook/detail/how-objects-work/">《面向对象是怎样工作的》</a> 「计算机程序设计思想」图解趣味版</li><li>《OKR 工作法》 如何激励不同团队一起工作，全力以赴实现一个有挑战性的目标</li><li>《敏捷软件开发》 豆瓣评分 9.0 的项目管理入门书</li></ul><p><strong>加分项</strong></p><p><strong>后端和客户端或更底层语言</strong></p><ul><li><a href="https://leetcode-cn.com/leetbook/detail/modern-java-in-action/">《Java 实战》</a> 通过示例全面讲解 Java 8、9、10 新特性</li><li><a href="https://leetcode-cn.com/leetbook/detail/deep-learning-with-python/">《Python 深度学习》</a> 通俗易懂，建立关于机器学习和深度学习核心思想的直觉</li><li><a href="https://leetcode-cn.com/leetbook/detail/java-interview-highlights/">《Java 面试突击》</a> Java 面试必备知识点整理，高效面试通关秘籍</li><li><a href="https://leetcode-cn.com/leetbook/detail/cpp-interview-highlights/">《C++ 面试突击》</a> C++ 面试高频知识点详解</li><li><a href="https://leetcode.cn/link/?target=https://www.wasm.com.cn/">《WebAssembly 中文文档》</a> 将 C、C++ 或 Rust 等编译进浏览器，在 JavaScript 中使用</li></ul><p><strong>操作系统</strong></p><ul><li><a href="https://leetcode-cn.com/leetbook/detail/awesome-linux-handbook/">《硬核 Linux 攻略》</a> 从使用 Linux 写命令，到了解这些指令背后的意义</li><li><a href="https://leetcode-cn.com/leetbook/detail/awesome-os-guide/">《硬核操作系统指南》</a> 进程线程、内存管理、文件系统、IO 流、死锁等角度全面剖析系统</li></ul><p><strong>机器学习</strong></p><ul><li><a href="https://leetcode-cn.com/leetbook/detail/machine-learning-101/">《机器学习 101》</a> 机器学习的基本概念</li></ul><p><strong>SEO</strong></p><ul><li><a href="https://leetcode.cn/link/?target=https://ziyuan.baidu.com/college#/type=4&cate=guides">《百度搜索学堂·搜索规范》</a> 百度官方 SEO 教学</li></ul><p><strong>UX</strong></p><ul><li>《点石成金》 面向 Web 设计和开发的技术人员的经典入门书</li><li>《设计师要懂心理学》 在网页和应用设计中，考虑周边视觉、色盲和目标趋近效应</li><li>《眼动追踪 用户体验优化操作指南》 通过眼动追踪方法实操用户体验优化</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出设计模式</title>
    <link href="/2023/01/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/01/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="概述-Introduction"><a href="#概述-Introduction" class="headerlink" title="概述 Introduction"></a>概述 Introduction</h3><p>设计模式在面试中的考点通常是介绍其原理并说出优缺点。或者对比几个比较相似的模式的异同点。在笔试中可能会出现画出某个设计模式的 UML 图这样的题。虽说面试中占的比重不大，但并不代表它不重要。恰恰相反，设计模式于程序员而言相当重要，它是我们写出优秀程序的保障。设计模式与程序员的架构能力与阅读源码的能力息息相关，非常值得我们深入学习。</p><p>面向对象的特点是 <strong>可维护、可复用、可扩展、灵活性好</strong>，它最强大的地方在于：随着业务变得越来越复杂，面向对象依然能够使得程序结构良好，而面向过程却会导致程序越来越臃肿。</p><p>让面向对象保持结构良好的秘诀就是设计模式，面向对象结合设计模式，才能真正体会到程序变得可维护、可复用、可扩展、灵活性好。设计模式对于程序员而言并不陌生，每个程序员在编程时都会或多或少的接触到设计模式。无论是在大型程序的架构中，亦或是在源码的学习中，设计模式都扮演着非常重要的角色。</p><p>今天我们就一起来探索设计模式的世界！</p><h3 id="设计模式的六大原则-Six-principles"><a href="#设计模式的六大原则-Six-principles" class="headerlink" title="设计模式的六大原则 Six principles"></a>设计模式的六大原则 Six principles</h3><p>设计模式的世界丰富多彩，比如生产一个个“产品”的工厂模式，衔接两个不相关接口的适配器模式，用不同的方式做同一件事的策略模式，构建步骤稳定、根据构建过程的不同配置构建出不同对象的建造者模式等等。</p><p>无论何种设计模式，都是基于六大设计原则：</p><ul><li>开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。</li><li>单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。</li><li>里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。</li><li>依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。</li><li>迪米特法则：又名“最少知道原则”，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。</li><li>接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。</li></ul><h3 id="第一章：构建型模式-Creational-Patterns"><a href="#第一章：构建型模式-Creational-Patterns" class="headerlink" title="第一章：构建型模式 Creational Patterns"></a>第一章：构建型模式 Creational Patterns</h3><h3 id="工厂模式-Factory"><a href="#工厂模式-Factory" class="headerlink" title="工厂模式 Factory"></a>工厂模式 Factory</h3><p>在平时编程中，构建对象最常用的方式是 new 一个对象。乍一看这种做法没什么不好，而实际上这也属于一种硬编码。每 new 一个对象，相当于调用者多知道了一个类，增加了类与类之间的联系，不利于程序的松耦合。其实构建过程可以被封装起来，工厂模式便是用于封装对象的设计模式。</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>举个例子，直接 new 对象的方式相当于当我们需要一个苹果时，我们需要知道苹果的构造方法，需要一个梨子时，需要知道梨子的构造方法。更好的实现方式是有一个水果工厂，我们告诉工厂需要什么种类的水果，水果工厂将我们需要的水果制造出来给我们就可以了。这样我们就无需知道苹果、梨子是怎么种出来的，只用和水果工厂打交道即可。</p><p>水果工厂：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitFactory</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Fruit</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> <span class="hljs-keyword">type</span></span>)&#123;        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">type</span>)&#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;苹果&quot;</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;梨子&quot;</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pear</span>();            <span class="hljs-attr">default</span>: <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;暂时没有这种水果&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><p>调用者：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">FruitFactory</span> <span class="hljs-variable">fruitFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FruitFactory</span>();        <span class="hljs-type">Fruit</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> fruitFactory.create(<span class="hljs-string">&quot;苹果&quot;</span>);        <span class="hljs-type">Fruit</span> <span class="hljs-variable">pear</span> <span class="hljs-operator">=</span> fruitFactory.create(<span class="hljs-string">&quot;梨子&quot;</span>);        apple.eat();        pear.eat();    &#125;&#125;</code></pre></div><p>事实上，将构建过程封装的好处不仅可以降低耦合，如果某个产品构造方法相当复杂，使用工厂模式可以大大减少代码重复。比如，如果生产一个苹果需要苹果种子、阳光、水分，将工厂修改如下：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitFactory</span> </span>&#123;    <span class="hljs-keyword">public</span> Fruit create(<span class="hljs-keyword">String</span> type) &#123;        <span class="hljs-keyword">switch</span> (type) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;苹果&quot;</span>:<span class="hljs-type"></span>                AppleSeed appleSeed = <span class="hljs-keyword">new</span> <span class="hljs-type">AppleSeed</span>();                Sunlight sunlight = <span class="hljs-keyword">new</span> <span class="hljs-type">Sunlight</span>();                Water water = <span class="hljs-keyword">new</span> <span class="hljs-type">Water</span>();                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Apple</span>(appleSeed, sunlight, water);            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;梨子&quot;</span>:<span class="hljs-type"></span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Pear</span>();            <span class="hljs-keyword">default</span>:<span class="hljs-type"></span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;暂时没有这种水果&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><p>调用者的代码则完全不需要变化，而且调用者不需要在每次需要苹果时，自己去构建苹果种子、阳光、水分以获得苹果。苹果的生产过程再复杂，也只是工厂的事。这就是封装的好处，假如某天科学家发明了让苹果更香甜的肥料，要加入苹果的生产过程中的话，也只需要在工厂中修改，调用者完全不用关心。</p><p>不知不觉中，我们就写出了简单工厂模式的代码。工厂模式一共有三种：</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><p>注：在 GoF 所著的《设计模式》一书中，简单工厂模式被划分为工厂方法模式的一种特例，没有单独被列出来。</p><p>总而言之，简单工厂模式就是让一个工厂类承担构建所有对象的职责。调用者需要什么产品，让工厂生产出来即可。它的弊端也显而易见：</p><ul><li>一是如果需要生产的产品过多，此模式会导致工厂类过于庞大，承担过多的职责，变成超级类。当苹果生产过程需要修改时，要来修改此工厂。梨子生产过程需要修改时，也要来修改此工厂。也就是说这个类不止一个引起修改的原因。违背了单一职责原则。</li><li>二是当要生产新的产品时，必须在工厂类中添加新的分支。而开闭原则告诉我们：类应该对修改封闭。我们希望在添加新功能时，只需增加新的类，而不是修改既有的类，所以这就违背了开闭原则。</li></ul><p><img src="/../imgs/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1604290966-DjcYge-1.gif" alt="1.gif"></p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>为了解决简单工厂模式的这两个弊端，工厂方法模式应运而生，它规定每个产品都有一个专属工厂。比如苹果有专属的苹果工厂，梨子有专属的梨子工厂，代码如下：</p><p>苹果工厂：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AppleFactory</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Fruit <span class="hljs-title">create</span>()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple();    &#125;&#125;</code></pre></div><p>梨子工厂：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PearFactory</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Fruit <span class="hljs-title">create</span>()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pear();    &#125;&#125;</code></pre></div><p>调用者：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;        <span class="hljs-type">AppleFactory</span> <span class="hljs-variable">appleFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AppleFactory</span>();        <span class="hljs-type">Fruit</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> appleFactory.create();        <span class="hljs-type">PearFactory</span> <span class="hljs-variable">pearFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PearFactory</span>();        <span class="hljs-type">Fruit</span> <span class="hljs-variable">pear</span> <span class="hljs-operator">=</span> pearFactory.create();        apple.eat();        pear.eat();    &#125;&#125;</code></pre></div><p>有读者可能会开喷了，这样和直接 new 出苹果和梨子有什么区别？上文说工厂是为了减少类与类之间的耦合，让调用者尽可能少的和其他类打交道。用简单工厂模式，我们只需要知道 FruitFactory，无需知道 Apple 、Pear 类，很容易看出耦合度降低了。但用工厂方法模式，调用者虽然不需要和 Apple 、Pear 类打交道了，但却需要和 AppleFactory、PearFactory 类打交道。有几种水果就需要知道几个工厂类，耦合度完全没有下降啊，甚至还增加了代码量！</p><p>这位读者请先放下手中的大刀，仔细想一想，工厂模式的第二个优点在工厂方法模式中还是存在的。当构建过程相当复杂时，工厂将构建过程封装起来，调用者可以很方便的直接使用，同样以苹果生产为例：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleFactory</span> </span>&#123;    <span class="hljs-keyword">public</span> Fruit create()&#123;        AppleSeed appleSeed = <span class="hljs-keyword">new</span> <span class="hljs-type">AppleSeed</span>();        Sunlight sunlight = <span class="hljs-keyword">new</span> <span class="hljs-type">Sunlight</span>();        Water water = <span class="hljs-keyword">new</span> <span class="hljs-type">Water</span>();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Apple</span>(appleSeed, sunlight, water);    &#125;&#125;</code></pre></div><p>调用者无需知道苹果的生产细节，当生产过程需要修改时也无需更改调用端。同时，工厂方法模式解决了简单工厂模式的两个弊端。</p><ul><li>当生产的产品种类越来越多时，工厂类不会变成超级类。工厂类会越来越多，保持灵活。不会越来越大、变得臃肿。如果苹果的生产过程需要修改时，只需修改苹果工厂。梨子的生产过程需要修改时，只需修改梨子工厂。符合单一职责原则。</li><li>当需要生产新的产品时，无需更改既有的工厂，只需要添加新的工厂即可。保持了面向对象的可扩展性，符合开闭原则。</li></ul><p>OK，学以致用，接下来我们来做两个思考题。同样地，在以后的每一篇文章后面，都会附上几个小练习供大家思考。希望大家能够独立思考出问题的答案，当然，在必要时也可参考底部的解析。</p><p>问 1：现有医用口罩和 N95 口罩两种产品，都继承自 Mask 类：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs scala"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mask</span> </span>&#123;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SurgicalMask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mask</span> </span>&#123;    <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@Override</span>    public <span class="hljs-type">String</span> toString() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是医用口罩&quot;</span>;    &#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">N95Mask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mask</span> </span>&#123;    <span class="hljs-meta">@NonNull</span>    <span class="hljs-meta">@Override</span>    public <span class="hljs-type">String</span> toString() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是 N95 口罩&quot;</span>;    &#125;&#125;</code></pre></div><p>请使用简单工厂模式完成以下代码：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaskFactory</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Mask</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> <span class="hljs-keyword">type</span></span>)&#123;        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 使用简单工厂模式实现此处的逻辑</span>    &#125;&#125;</code></pre></div><p>使其通过以下客户端测试：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> &#123;    @Test    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>()</span> &#123;        MaskFactory factory = <span class="hljs-keyword">new</span> MaskFactory();        <span class="hljs-comment">// 输出：这是医用口罩</span>        System.<span class="hljs-keyword">out</span>.println(factory.create(<span class="hljs-string">&quot;Surgical&quot;</span>));        <span class="hljs-comment">// 输出：这是 N95 口罩</span>        System.<span class="hljs-keyword">out</span>.println(factory.create(<span class="hljs-string">&quot;N95&quot;</span>));    &#125;&#125;</code></pre></div><p>答案：</p><ul><li>Java</li></ul><div class="code-wrapper"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaskFactory</span> </span>&#123;    <span class="hljs-keyword">public</span> Mask create(<span class="hljs-keyword">String</span> type)&#123;        <span class="hljs-comment">// 使用简单工厂模式实现此处的逻辑</span>        <span class="hljs-keyword">switch</span> (type)&#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Surgical&quot;</span>:<span class="hljs-type"></span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">SurgicalMask</span>();            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;N95&quot;</span>:<span class="hljs-type"></span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">N95Mask</span>();            <span class="hljs-keyword">default</span>:<span class="hljs-type"></span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unsupported mask type&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><p>问 2：如何用工厂方法模式实现呢？</p><p>客户端测试代码：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">SurgicalMaskFactory</span> <span class="hljs-variable">surgicalMaskFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SurgicalMaskFactory</span>();        <span class="hljs-comment">// 输出：这是医用口罩</span>        System.out.println(surgicalMaskFactory.create());        <span class="hljs-type">N95MaskFactory</span> <span class="hljs-variable">N95MaskFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">N95MaskFactory</span>();        <span class="hljs-comment">// 输出：这是 N95 口罩</span>        System.out.println(N95MaskFactory.create());    &#125;&#125;</code></pre></div><p>答案：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SurgicalMaskFactory</span>&#123;    <span class="hljs-keyword">public</span> Mask <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SurgicalMask</span>();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">N95MaskFactory</span> &#123;    <span class="hljs-keyword">public</span> Mask <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">N95Mask</span>();    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>手撕代码-前端</title>
    <link href="/2023/01/28/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81-%E5%89%8D%E7%AB%AF/"/>
    <url>/2023/01/28/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81-%E5%89%8D%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-数组扁平化"><a href="#第一章-数组扁平化" class="headerlink" title="第一章 数组扁平化"></a>第一章 数组扁平化</h2><h3 id="ES6的flat方法"><a href="#ES6的flat方法" class="headerlink" title="ES6的flat方法"></a>ES6的flat方法</h3><p>flat() 方法将以指定的深度递归遍历数组，并将所有元素与遍历的子数组中的元素合并到一个新数组中以返回。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]],<span class="hljs-number">6</span>]<span class="hljs-keyword">const</span> res = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\[|\]/g</span>,<span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-keyword">const</span> res2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;[&#x27;</span> + res + <span class="hljs-string">&#x27;]&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res2)</code></pre></div><h3 id="方法二：使用正则"><a href="#方法二：使用正则" class="headerlink" title="方法二：使用正则"></a>方法二：使用正则</h3><p>首先是使用 JSON.stringify 把 arr 转为字符串接着使用正则把字符串里面的 [ 和 ] 去掉然后再拼接数组括号转为数组对象。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]],<span class="hljs-number">6</span>]<span class="hljs-keyword">const</span> res = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\[|\]/g</span>,<span class="hljs-string">&#x27;&#x27;</span>)<span class="hljs-keyword">const</span> res2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;[&#x27;</span> + res + <span class="hljs-string">&#x27;]&#x27;</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res2)</code></pre></div><h3 id="方法三：使用递归"><a href="#方法三：使用递归" class="headerlink" title="方法三：使用递归"></a>方法三：使用递归</h3><p>递归，在数学和计算机科学中，是指在函数的定义中使用函数本身的方法。递归这个词经常用来描述以自相似的方式重复事物的过程。通俗的理解是：我调用我自己。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = []<span class="hljs-keyword">const</span>  <span class="hljs-title function_">fn</span> = (<span class="hljs-params">arr</span>)=&gt;&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>; i++)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr[i]))&#123;            <span class="hljs-title function_">fn</span>(arr[i])        &#125;        <span class="hljs-keyword">else</span> &#123;            array.<span class="hljs-title function_">push</span>(arr[i])        &#125;    &#125;&#125;<span class="hljs-title function_">fn</span>(arr)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array)</code></pre></div><h3 id="方法四：使用-reduce"><a href="#方法四：使用-reduce" class="headerlink" title="方法四：使用 reduce"></a>方法四：使用 reduce</h3><p>reduce 方法: 可以用来给数组求和</p><p>concat() 方法用于连接两个或多个数组。</p><p>concat() 方法不会更改现有数组，而是返回一个新数组，其中包含已连接数组的值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">newArr</span> = (<span class="hljs-params">arr</span>)=&gt;&#123;            <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;                <span class="hljs-keyword">return</span> pre.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(cur) ? <span class="hljs-title function_">newArr</span>(cur) : cur)            &#125;,[])        &#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">newArr</span>(arr),<span class="hljs-string">&quot;reduce方法&quot;</span>)</code></pre></div><h3 id="使用栈的思想实现-flat-函数"><a href="#使用栈的思想实现-flat-函数" class="headerlink" title="使用栈的思想实现 flat 函数"></a>使用栈的思想实现 flat 函数</h3><p>栈（stack）又名堆<em>栈</em>，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 栈思想function flat(arr) &#123;</span>  <span class="hljs-keyword">const</span> newArr = [];  <span class="hljs-keyword">const</span> stack = [].<span class="hljs-title function_">concat</span>(arr);  <span class="hljs-comment">// 将数组元素拷贝至栈，直接赋值会改变原数组//如果栈不为空，则循环遍历while (stack.length !== 0) &#123;</span>    <span class="hljs-keyword">const</span> val = stack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 删除数组最后一个元素，并获取它if (Array.isArray(val)) &#123;</span>      stack.<span class="hljs-title function_">push</span>(...val); <span class="hljs-comment">// 如果是数组再次入栈，并且展开了一层</span>    &#125; <span class="hljs-keyword">else</span> &#123;      newArr.<span class="hljs-title function_">unshift</span>(val); <span class="hljs-comment">// 如果不是数组就将其取出来放入结果数组中</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> newArr;&#125;<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">12</span>, <span class="hljs-number">23</span>, [<span class="hljs-number">34</span>, <span class="hljs-number">56</span>, [<span class="hljs-number">78</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>, [<span class="hljs-number">110</span>, <span class="hljs-number">120</span>, <span class="hljs-number">130</span>, <span class="hljs-number">140</span>]]]];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flat</span>(arr));<span class="hljs-comment">// [12, 23, 34, 56, 78, 90, 100, 110, 120, 130, 140]</span></code></pre></div><h2 id="第二章：深拷贝和浅拷贝"><a href="#第二章：深拷贝和浅拷贝" class="headerlink" title="第二章：深拷贝和浅拷贝"></a>第二章：深拷贝和浅拷贝</h2><h3 id="知识点讲解"><a href="#知识点讲解" class="headerlink" title="知识点讲解"></a>知识点讲解</h3><h4 id="1、什么是数据类型？"><a href="#1、什么是数据类型？" class="headerlink" title="1、什么是数据类型？"></a>1、什么是数据类型？</h4><p>数据分为基本数据类型 (String, Number, Boolean, Null, Undefined，Symbol) 和引用数据类型。</p><p>基本数据类型的特点：直接存储在栈 (stack) 中的数据</p><p>引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里</p><p>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。</p><h4 id="2、ES11新增了什么数据类型？"><a href="#2、ES11新增了什么数据类型？" class="headerlink" title="2、ES11新增了什么数据类型？"></a>2、ES11新增了什么数据类型？</h4><p>bigint!</p><p>bigint使用方式：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> max=<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">BigInt</span>(max))<span class="hljs-comment">//9007199254740991n </span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">BigInt</span>(max)+<span class="hljs-title class_">BigInt</span>(<span class="hljs-number">1</span>))<span class="hljs-comment">//9007199254740992n 正确</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">BigInt</span>(max)+<span class="hljs-title class_">BigInt</span>(<span class="hljs-number">2</span>))<span class="hljs-comment">//9007199254740993n 正确</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">BigInt</span>(max)+<span class="hljs-title class_">BigInt</span>(<span class="hljs-number">4</span>))<span class="hljs-comment">//9007199254740995n 正确</span></code></pre></div><h4 id="3、为什么要使用深拷贝？"><a href="#3、为什么要使用深拷贝？" class="headerlink" title="3、为什么要使用深拷贝？"></a>3、为什么要使用深拷贝？</h4><p>我们希望在改变新的数组（对象）的时候，不改变原数组（对象）</p><h4 id="4、赋值和浅拷贝的区别？"><a href="#4、赋值和浅拷贝的区别？" class="headerlink" title="4、赋值和浅拷贝的区别？"></a>4、赋值和浅拷贝的区别？</h4><p>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</p><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝是一点一点地拷贝一个对象。它将创建一个新对象。此对象具有原始对象属性值的精确副本。如果属性是基本类型，它将复制基本类型的值；如果属性是内存地址（引用类型），则复制内存地址。因此，如果一个对象更改地址，另一个对象将受到影响。也就是说，默认复制构造函数只复制浅层复制中的对象（依次复制成员），即只复制对象空间，而不复制资源。</p><div class="code-wrapper"><pre><code class="hljs pgsql">var obj1 =&#123; <span class="hljs-type">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>, age:<span class="hljs-number">8</span>, pal:[<span class="hljs-string">&#x27;王五&#x27;</span>,<span class="hljs-string">&#x27;王六&#x27;</span>,<span class="hljs-string">&#x27;王七&#x27;</span>]&#125;var obj3 = shallowCopy(obj1)<span class="hljs-keyword">function</span> shallowCopy (src)&#123; var newObj = &#123;&#125;; <span class="hljs-keyword">for</span>(var prop <span class="hljs-keyword">in</span> src )&#123;     console.log(prop)     <span class="hljs-keyword">if</span>(src.hasOwnProperty(prop))&#123;         newObj[prop] = src[prop]     &#125; &#125; <span class="hljs-keyword">return</span> newObj&#125; obj3.name = <span class="hljs-string">&#x27;李四&#x27;</span> obj3.pal[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;王麻子&#x27;</span>   console.log(&quot;obj1&quot;, obj1); //&#123;age: <span class="hljs-number">8</span>, <span class="hljs-type">name</span>: &quot;张三&quot;, pal: [<span class="hljs-string">&#x27;王麻子&#x27;</span>, <span class="hljs-string">&#x27;王六&#x27;</span>, <span class="hljs-string">&#x27;王七&#x27;</span>]&#125;console.log(&quot;obj3&quot;, obj3); //&#123;age: <span class="hljs-number">8</span>, <span class="hljs-type">name</span>: &quot;李四&quot;, pal: [<span class="hljs-string">&#x27;王麻子&#x27;</span>, <span class="hljs-string">&#x27;王六&#x27;</span>, <span class="hljs-string">&#x27;王七&#x27;</span>]&#125;</code></pre></div><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="方法一：递归实现深拷贝"><a href="#方法一：递归实现深拷贝" class="headerlink" title="方法一：递归实现深拷贝"></a>方法一：递归实现深拷贝</h4><p>实现<strong>深拷贝</strong>原理的递归方法：遍历对象、数组甚至内部都是基本的数据类型，然后复制它们，即深度复制。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;   <span class="hljs-comment">//原数据，包含字符串、对象、函数、数组等不同的类型</span>       <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;test&quot;</span>,       <span class="hljs-attr">main</span>:&#123;           <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,           <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>       &#125;,       <span class="hljs-attr">fn</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;                  &#125;,        <span class="hljs-attr">friends</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">22</span>,<span class="hljs-number">33</span>]]   &#125;    <span class="hljs-keyword">function</span> <span class="hljs-title function_">copy</span>(<span class="hljs-params">obj</span>)&#123;        <span class="hljs-keyword">let</span> newobj = <span class="hljs-literal">null</span>;   <span class="hljs-comment">//声明一个变量用来储存拷贝之后的内容</span>             <span class="hljs-comment">//判断数据类型是否是复杂类型，如果是则调用自己，再次循环，如果不是，直接赋值即可，</span>     <span class="hljs-comment">//由于null不可以循环但类型又是object，所以这个需要对null进行判断</span>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_">typeof</span>(obj) == <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; obj !== <span class="hljs-literal">null</span>)&#123;                 <span class="hljs-comment">//声明一个变量用以储存拷贝出来的值,根据参数的具体数据类型声明不同的类型来储存</span>            newobj = obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>? [] : &#123;&#125;;                       <span class="hljs-comment">//循环obj 中的每一项，如果里面还有复杂数据类型，则直接利用递归再次调用copy函数</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> obj)&#123;                  newobj[i] = <span class="hljs-title function_">copy</span>(obj[i])            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            newobj = obj        &#125;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;77&#x27;</span>,newobj)      <span class="hljs-keyword">return</span> newobj;    <span class="hljs-comment">//函数必须有返回值，否则结构为undefined</span>   &#125;     <span class="hljs-keyword">var</span> obj2 = <span class="hljs-title function_">copy</span>(obj)    obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;修改成功&#x27;</span>    obj2.<span class="hljs-property">main</span>.<span class="hljs-property">a</span> = <span class="hljs-number">100</span>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2)作者：力扣 (<span class="hljs-title class_">LeetCode</span>)链接：<span class="hljs-attr">https</span>:<span class="hljs-comment">//leetcode.cn/leetbook/read/interview-coding-frontend/dqvyxd/</span>来源：力扣（<span class="hljs-title class_">LeetCode</span>）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h4 id="方法二：递归实现深拷贝"><a href="#方法二：递归实现深拷贝" class="headerlink" title="方法二：递归实现深拷贝"></a>方法二：递归实现深拷贝</h4><ul><li><p>递归处理 引用类型</p></li><li><p>保持数组类型</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">target</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;                <span class="hljs-keyword">const</span> newTarget = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) ? [] : <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> target) &#123;                        newTarget[key] = <span class="hljs-title function_">deepCopy</span>(target[key])                &#125;                <span class="hljs-keyword">return</span> newTarget        &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> target        &#125;&#125;作者：力扣 (<span class="hljs-title class_">LeetCode</span>)链接：<span class="hljs-attr">https</span>:<span class="hljs-comment">//leetcode.cn/leetbook/read/interview-coding-frontend/dqwshh/</span>来源：力扣（<span class="hljs-title class_">LeetCode</span>）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h4 id="方法三：递归实现深拷贝"><a href="#方法三：递归实现深拷贝" class="headerlink" title="方法三：递归实现深拷贝"></a>方法三：递归实现深拷贝</h4><ul><li><p>哈希表 Map 支持 循环引用</p><ul><li>Map 支持引用类型数据作为键</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">target, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span></span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;                <span class="hljs-keyword">if</span> (h.<span class="hljs-title function_">has</span>(target)) <span class="hljs-keyword">return</span> h.<span class="hljs-title function_">get</span>(target)                <span class="hljs-keyword">const</span> newTarget = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) ? [] : <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> target) &#123;                        newTarget[key] = <span class="hljs-title function_">deepCopy</span>(target[key], h)                &#125;                h.<span class="hljs-title function_">set</span>(target, newTarget)                <span class="hljs-keyword">return</span> newTarget        &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> target        &#125;&#125;作者：力扣 (<span class="hljs-title class_">LeetCode</span>)链接：<span class="hljs-attr">https</span>:<span class="hljs-comment">//leetcode.cn/leetbook/read/interview-coding-frontend/dqd6j3/</span>来源：力扣（<span class="hljs-title class_">LeetCode</span>）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h4 id="方法四：递归实现深拷贝"><a href="#方法四：递归实现深拷贝" class="headerlink" title="方法四：递归实现深拷贝"></a>方法四：递归实现深拷贝</h4><p>哈希表 WeakMap 代替 Map</p><p>WeakMap 的键是弱引用，告诉 JS 垃圾回收机制，当键回收时，对应 WeakMap 也可以回收，更适合大量数据深拷</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dq08bm/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dq08bm/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">target, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span></span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;      <span class="hljs-keyword">if</span> (h.<span class="hljs-title function_">has</span>(target)) <span class="hljs-keyword">return</span> h.<span class="hljs-title function_">get</span>(target)      <span class="hljs-keyword">const</span> newTarget = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) ? [] : <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> target) &#123;        newTarget[key] = <span class="hljs-title function_">deepCopy</span>(target[key], h)      &#125;      h.<span class="hljs-title function_">set</span>(target, newTarget)      <span class="hljs-keyword">return</span> newTarget    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> target    &#125;&#125;作者：力扣 (<span class="hljs-title class_">LeetCode</span>)链接：<span class="hljs-attr">https</span>:<span class="hljs-comment">//leetcode.cn/leetbook/read/interview-coding-frontend/dq08bm/</span>来源：力扣（<span class="hljs-title class_">LeetCode</span>）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h2 id="第三章-防抖节流"><a href="#第三章-防抖节流" class="headerlink" title="第三章 防抖节流"></a>第三章 防抖节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>防抖是指短时间内大量触发同一事件，只会在最后一次事件完成后延迟执行一次函数。例如，在输入用户名的过程中，需要反复验证用户名。此时，您应该等待用户停止输入，然后进行验证，否则将影响用户体验。 防抖实现的原理是在触发事件后设置计时器。在计时器延迟过程中，如果事件再次触发，则重置计时器。在没有触发事件之前，计时器将再次触发并执行相应的功能。</p><p>声明定时器</p><p>返回函数</p><p>一定时间间隔，执行回调函数</p><p>回调函数</p><p>已执行：清空定时器<br>未执行：重置定时器</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dq896c/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dq896c/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay</span>) &#123;        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;                <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer)                timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;                        timer = <span class="hljs-literal">null</span>                        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)                &#125;, (delay + <span class="hljs-string">&#x27;&#x27;</span>) | <span class="hljs-number">0</span> || <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>)        &#125;&#125;作者：力扣 (<span class="hljs-title class_">LeetCode</span>)链接：<span class="hljs-attr">https</span>:<span class="hljs-comment">//leetcode.cn/leetbook/read/interview-coding-frontend/dq896c/</span>来源：力扣（<span class="hljs-title class_">LeetCode</span>）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流是指每隔一段时间就执行一次函数。就像未拧紧的水龙头一样，水龙头每隔一段时间就会滴水。即使在这段时间管道里有更多的水，水龙头也不会掉更多的水。</p><p>节流的原理是在触发事件后设置计时器。在计时器延迟过程中，即使事件再次触发，计时器的延迟时间也不会改变。在计时器执行功能之前，计时器不会复位。</p><p>声明定时器</p><p>返回函数</p><p>一定时间间隔，执行回调函数</p><p>回调函数</p><p>已执行：清空定时器<br>未执行：返回</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dq3hqi/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dq3hqi/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, interval</span>) &#123;        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;                <span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span>                timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;                        timer = <span class="hljs-literal">null</span>                        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)                &#125;, (interval +<span class="hljs-string">&#x27;&#x27;</span>)| <span class="hljs-number">0</span> || <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>)        &#125;&#125;作者：力扣 (<span class="hljs-title class_">LeetCode</span>)链接：<span class="hljs-attr">https</span>:<span class="hljs-comment">//leetcode.cn/leetbook/read/interview-coding-frontend/dq3hqi/</span>来源：力扣（<span class="hljs-title class_">LeetCode</span>）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h2 id="第四章：for-in-和-for-of-用法"><a href="#第四章：for-in-和-for-of-用法" class="headerlink" title="第四章：for..in 和 for..of 用法"></a>第四章：for..in 和 for..of 用法</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for..in"></a>for..in</h3><p>for…in 循环只遍历可枚举属性（包括它的原型链上的可枚举属性）。像 Array 和 Object 使用内置构造函数所创建的对象都会继承自 Object.prototype 和 String.prototype 的不可枚举属性，例如 String 的 indexOf() 方法或 Object 的 toString() 方法。循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dq3b3e/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dq3b3e/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h3><p>Q: ES6 的 for of 可以遍历对象吗?</p><p>A: ES6 的 “for of” 不能遍历对象。</p><p>原因：ES6 中引入了 Iterator 接口，只有提供了 Iterator 接口的数据类型才可以使用 “for-of” 来循环遍历；而普通对象默认没有提供 Iterator 接口，因此无法用 “for-of” 来进行遍历。</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dqq1tg/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dqq1tg/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="第五章：从数组-1-2-3-4-5-6-中找出值为-2-的元素"><a href="#第五章：从数组-1-2-3-4-5-6-中找出值为-2-的元素" class="headerlink" title="第五章：从数组 [1,2,3,4,5,6] 中找出值为 2 的元素"></a>第五章：从数组 [1,2,3,4,5,6] 中找出值为 2 的元素</h2><p>本章讲实现数组中找值问题的 2 种方法。</p><h3 id="方法一：filter"><a href="#方法一：filter" class="headerlink" title="方法一：filter()"></a>方法一：filter()</h3><p>filter() 方法创建一个新数组, 包含通过所提供函数实现的测试的所有元素。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isBigEnough</span>(<span class="hljs-params">element</span>) &#123;  <span class="hljs-keyword">return</span> element == <span class="hljs-number">2</span>;&#125;<span class="hljs-keyword">var</span> filtered = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>].<span class="hljs-title function_">filter</span>(isBigEnough);</code></pre></div><h3 id="方法二：find"><a href="#方法二：find" class="headerlink" title="方法二：find()"></a>方法二：find()</h3><p>find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<span class="hljs-keyword">function</span> <span class="hljs-title function_">finds</span>(<span class="hljs-params">x</span>) &#123;    <span class="hljs-keyword">return</span> x === <span class="hljs-string">&#x27;2&#x27;</span>;&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(finds));</code></pre></div><h3 id="常用方法总结："><a href="#常用方法总结：" class="headerlink" title="常用方法总结："></a>常用方法总结：</h3><table><thead><tr><th>方法名</th><th>参数</th><th>描述</th><th>返回值</th></tr></thead><tbody><tr><td>includes<br/></td><td>searchElement,fromlndex<br/></td><td>判断数组中是否包含指定的值<br/></td><td>布尔值<br/></td></tr><tr><td>indexOf<br/></td><td>searchElement,fromlndex<br/></td><td>查找元素在数组中首次出现的索引值<br/></td><td>索引值，或者-1<br/></td></tr><tr><td>lastIndexOf<br/></td><td>searchElement,fromlndex<br/></td><td>查找元素在数组中最后一次出现的索引值<br/></td><td>索引值，或者-1<br/></td></tr><tr><td>some<br/></td><td>callback[,thisArg]<br/></td><td>判断数组中是否有符合条件的元素<br/></td><td>布尔值<br/></td></tr><tr><td>every<br/></td><td>callback[,thisArg]<br/></td><td>判断数组中是否每个元素都符合条件<br/></td><td>布尔值<br/></td></tr><tr><td>filter<br/></td><td>callback[,thisArg]<br/></td><td>返回符合条件的所有元素组成的数组<br/></td><td>数组<br/></td></tr><tr><td>find<br/></td><td>callback[,thisArg]<br/></td><td>返回数组中符合条件的第一个元素<br/></td><td>数组中的元素，或者undefined<br/></td></tr><tr><td>findIndex<br/></td><td>callback[,thisArg]<br/></td><td>返回符合条件的第一个元素的索引<br/></td><td>索引值，或者-1</td></tr></tbody></table><h2 id="第六章：两栏布局和三栏布局"><a href="#第六章：两栏布局和三栏布局" class="headerlink" title="第六章：两栏布局和三栏布局"></a>第六章：两栏布局和三栏布局</h2><h3 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h3><p>两栏布局非常常见，往往是以一个定宽栏和一个自适应的栏并排展示存在。</p><p><img src="/../imgs/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81-%E5%89%8D%E7%AB%AF/image-20230128103818724.png" alt="image-20230128103818724"></p><h4 id="方法一：浮动布局"><a href="#方法一：浮动布局" class="headerlink" title="方法一：浮动布局"></a>方法一：浮动布局</h4><ul><li>使用 float 左浮左边栏</li><li>右边模块使用 margin-left 撑出内容块做内容展示</li><li>为父级元素添加 BFC，防止下方元素飞到上方内容</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.box</span>&#123;</span><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden; 添加BFC</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: gray;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">210px</span>;</span><span class="language-css">        <span class="hljs-attribute">background-color</span>: lightgray;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dq4vvd/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h4 id="方法二：flex-弹性布局"><a href="#方法二：flex-弹性布局" class="headerlink" title="方法二：flex 弹性布局"></a>方法二：flex 弹性布局</h4><p>flex 容器的一个默认属性值: align-items: stretch;</p><p>这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: align-items: flex-start。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.box</span>&#123;</span><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dq1anh/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><p><img src="/../imgs/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81-%E5%89%8D%E7%AB%AF/image-20230128104025419.png" alt="image-20230128104025419"></p><p>实现三栏布局中间自适应的布局方式有：</p><ol><li>两边使用 float，中间使用 margin</li><li>两边使用 absolute，中间使用 margin</li><li>两边使用 float 和负 margin</li><li>flex 实现</li><li>grid 网格布局</li></ol><h4 id="方法一：两边使用-float，中间使用-margin"><a href="#方法一：两边使用-float，中间使用-margin" class="headerlink" title="方法一：两边使用 float，中间使用 margin"></a>方法一：两边使用 float，中间使用 margin</h4><p>需要将中间的内容放在 <code>html</code> 结构最后，否则右侧会臣在中间内容的下方</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.wrap</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#eee</span>;</span><span class="language-css">        <span class="hljs-attribute">overflow</span>: hidden; &lt;!-- 生成BFC，计算高度时考虑浮动的元素 --&gt;</span><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><span class="language-css">        <span class="hljs-attribute">background</span>: coral;</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">120px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">float</span>: right;</span><span class="language-css">        <span class="hljs-attribute">background</span>: lightblue;</span><span class="language-css">    &#125;</span><span class="language-css">    <span class="hljs-selector-class">.middle</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">220px</span>;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: lightpink;</span><span class="language-css">        <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">140px</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dqj1e5/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h4 id="方法二：两边使用-absolute，中间使用-margin"><a href="#方法二：两边使用-absolute，中间使用-margin" class="headerlink" title="方法二：两边使用 absolute，中间使用 margin"></a>方法二：两边使用 absolute，中间使用 margin</h4><p>基于绝对定位的三栏布局：注意绝对定位的元素脱离文档流，相对于最近的已经定位的祖先元素进行定位。无需考虑 HTML 中结构的顺序</p><p>左右两边使用绝对定位，固定在两侧。</p><p>中间占满一行，但通过 margin 和左右两边留出 10px 的间隔</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.container</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">position</span>: relative;</span><span class="language-css">  &#125;</span><span class="language-css">  </span><span class="language-css">  <span class="hljs-selector-class">.left</span>,</span><span class="language-css">  <span class="hljs-selector-class">.right</span>,</span><span class="language-css">  <span class="hljs-selector-class">.main</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">    <span class="hljs-attribute">text-align</span>: center;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">position</span>: absolute;</span><span class="language-css">    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><span class="language-css">    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">    <span class="hljs-attribute">background</span>: green;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">position</span>: absolute;</span><span class="language-css">    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><span class="language-css">    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">    <span class="hljs-attribute">background</span>: green;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.main</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">110px</span>;</span><span class="language-css">    <span class="hljs-attribute">background</span>: black;</span><span class="language-css">    <span class="hljs-attribute">color</span>: white;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左边固定宽度<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右边固定宽度<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>中间自适应<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h4 id="方法三：两边使用-float-和负-margin"><a href="#方法三：两边使用-float-和负-margin" class="headerlink" title="方法三：两边使用 float 和负 margin"></a>方法三：两边使用 float 和负 margin</h4><p>实现过程：</p><p>中间使用了双层标签，外层是浮动的，以便左中右能在同一行展示</p><p>左边通过使用负 margin-left:-100%，相当于中间的宽度，所以向上偏移到左侧</p><p>右边通过使用负 margin-left:-100px，相当于自身宽度，所以向上偏移到最右侧</p><p>缺点：</p><p>增加了 .main-wrapper 一层，结构变复杂</p><p>使用负 margin，调试也相对麻烦</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.left</span>,</span><span class="language-css">  <span class="hljs-selector-class">.right</span>,</span><span class="language-css">  <span class="hljs-selector-class">.main</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">    <span class="hljs-attribute">text-align</span>: center;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.main-wrapper</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.main</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">110px</span>;</span><span class="language-css">    <span class="hljs-attribute">background</span>: black;</span><span class="language-css">    <span class="hljs-attribute">color</span>: white;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.left</span>,</span><span class="language-css">  <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><span class="language-css">    <span class="hljs-attribute">background</span>: green;</span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="language-css">  <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>; <span class="hljs-comment">/* 同自身宽度 */</span></span><span class="language-css">  &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main-wrapper&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>中间自适应<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左边固定宽度<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右边固定宽度<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/d6h6x2/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h4 id="方法四：使用-flex-实现"><a href="#方法四：使用-flex-实现" class="headerlink" title="方法四：使用 flex 实现"></a>方法四：使用 flex 实现</h4><p>利用 flex 弹性布局，可以简单实现中间自适应。</p><p>实现过程：</p><p>仅需将容器设置为 display:flex; ，</p><p>盒内元素两端对其，将中间元素设置为 100% 宽度，或者设为 flex:1 ，即可填充空白</p><p>盒内元素的高度撑开容器的高度</p><p>优点：</p><p>结构简单直观</p><p>可以结合 flex 的其他功能实现更多效果，例如使用 order 属性调整显示顺序，让主体内容优先加载，但展示在中间</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/d6xtfc/">https://leetcode.cn/leetbook/read/interview-coding-frontend/d6xtfc/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.wrap</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><span class="language-css">        <span class="hljs-attribute">justify-content</span>: space-between;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.left</span>,</span><span class="language-css">    <span class="hljs-selector-class">.right</span>,</span><span class="language-css">    <span class="hljs-selector-class">.middle</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: coral;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">120px</span>;</span><span class="language-css">        <span class="hljs-attribute">background</span>: lightblue;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.middle</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#555</span>;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">20px</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/d6xtfc/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h4 id="方法五：grid-网格布局"><a href="#方法五：grid-网格布局" class="headerlink" title="方法五：grid 网格布局"></a>方法五：grid 网格布局</h4><p>跟 <code>flex</code> 弹性布局一样的简单</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.wrap</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">display</span>: grid;</span><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">300px</span> auto <span class="hljs-number">300px</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.left</span>,</span><span class="language-css">    <span class="hljs-selector-class">.right</span>,</span><span class="language-css">    <span class="hljs-selector-class">.middle</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: coral;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: lightblue;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="language-css">    <span class="hljs-selector-class">.middle</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">background</span>: <span class="hljs-number">#555</span>;</span><span class="language-css">    &#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span>中间<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右侧<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/d65lji/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h2 id="第七章：实现多行文本溢出的省略"><a href="#第七章：实现多行文本溢出的省略" class="headerlink" title="第七章：实现多行文本溢出的省略"></a>第七章：实现多行文本溢出的省略</h2><p>本章讲实现多行文本溢出的省略问题的 2 种方法。</p><h3 id="方法一：使用定位伪元素遮盖末尾文字"><a href="#方法一：使用定位伪元素遮盖末尾文字" class="headerlink" title="方法一：使用定位伪元素遮盖末尾文字"></a>方法一：使用定位伪元素遮盖末尾文字</h3><p><strong>给父元素设置:</strong></p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;<span class="hljs-comment">/* 溢出隐藏 */</span><span class="hljs-attribute">line-height</span>: <span class="hljs-number">20px</span>;<span class="hljs-comment">/* 设置行高与容器高度成倍数关系，这样避免文本溢出时，文字显示一半 */</span><span class="hljs-attribute">text-align</span>: justify;<span class="hljs-comment">/* 设置文本对齐方式为两端对齐，这样在伪元素内容遮盖末尾文字时才能对齐*/</span><span class="hljs-attribute">position</span>: relative;<span class="hljs-comment">/* 子绝父相，这里是为了给伪元素设置定位*/</span>   作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dg4wsi/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><p><strong>给父元素设置伪元素 ::after ，并为其设置属性：</strong></p><div class="code-wrapper"><pre><code class="hljs css">     <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;...&quot;</span>;<span class="hljs-comment">/* 省略号是放在文本最后面的 */</span>     <span class="hljs-attribute">width</span>: <span class="hljs-number">1em</span>;<span class="hljs-comment">/* 设置伪元素的宽度为1em，是为了遮盖的时候正好遮盖中原来的一个字的大小*/</span>     <span class="hljs-attribute">background-color</span>: pink;<span class="hljs-comment">/* 设置与父元素相同的背景颜色，同理，也是为了和原来的内容样式保持一致*/</span>     <span class="hljs-attribute">position</span>: absolute;<span class="hljs-comment">/*设置定位，其位置就是文本的右下角 */</span>     <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dg4wsi/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h3 id="方法二：-利用旧版弹性盒"><a href="#方法二：-利用旧版弹性盒" class="headerlink" title="方法二： 利用旧版弹性盒"></a>方法二： 利用旧版弹性盒</h3><p>步骤：</p><p>给容器元素类型转换为 display:-webkit-box ;</p><p>设置弹性盒子垂直排列 -webkit-box-orient:vertical ;</p><p>控制要显示的行数 -webkit-line-clamp:数值 ；</p><p>溢出隐藏 overflow:hidden ;</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dg12ze/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dg12ze/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-comment">/* 多行文本溢出隐藏显示省略号方法二：</span></span><span class="hljs-comment"><span class="language-css">          兼容性写法,因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端</span></span><span class="hljs-comment"><span class="language-css">        */</span></span><span class="language-css">        <span class="hljs-selector-class">.box</span>&#123;</span><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css">            <span class="hljs-comment">/* height: 100px; 如果设置了高度，且高度超过文本显示行数，在第三行会正常出现省略号，但是三行之后的仍然正常显示*/</span></span><span class="language-css">            <span class="hljs-attribute">background-color</span>: pink;</span><span class="language-css">            <span class="hljs-comment">/* 设置高度是行高的倍数，防止文本露出一半 */</span></span><span class="language-css">            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">20px</span>;</span><span class="language-css">            <span class="hljs-comment">/* 旧版弹性盒 */</span></span><span class="language-css">            <span class="hljs-attribute">display</span>: -webkit-box;</span><span class="language-css">            <span class="hljs-comment">/* 弹性盒子元素垂直排列 */</span></span><span class="language-css">            -webkit-box-orient: vertical;</span><span class="language-css">            <span class="hljs-comment">/* 控制要显示的行数 */</span></span><span class="language-css">            -webkit-line-clamp: <span class="hljs-number">3</span>;</span><span class="language-css">            <span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">        &#125;</span><span class="language-css">        </span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>        我是文本我是文本我是文本我是文我是文我是文我是文我是文我是文我是文我是是文本我是文本我是文本我是文本我是文本我是文本我是文本我是文本我是文本    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dg12ze/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h2 id="第八章：用-CSS-实现三角符号"><a href="#第八章：用-CSS-实现三角符号" class="headerlink" title="第八章：用 CSS 实现三角符号"></a>第八章：用 CSS 实现三角符号</h2><p>本章讲用 CSS 实现三角符号问题的 8 种类型。</p><ol><li>类型一：上三角</li><li>类型二：下三角</li><li>类型三：左三角</li><li>类型四：右三角</li><li>类型五：左下三角</li><li>类型六：右下三角</li><li>类型七：右上三角</li><li>类型八：左上三角</li></ol><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/d3b2kh/">https://leetcode.cn/leetbook/read/interview-coding-frontend/d3b2kh/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="第九章：实现九宫格布局"><a href="#第九章：实现九宫格布局" class="headerlink" title="第九章：实现九宫格布局"></a>第九章：实现九宫格布局</h2><p>本章讲实现九宫格布局的 4 种方法。</p><p><a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dz5ud3/"></a><a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dz97wm/">方法一：flex</a><a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dzewn1/">方法二：float</a><a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dzo227/">方法三：grid</a>[方法四：table</p><h2 id="第十章：单行多行文字隐藏显示省略号"><a href="#第十章：单行多行文字隐藏显示省略号" class="headerlink" title="第十章：单行多行文字隐藏显示省略号"></a>第十章：单行多行文字隐藏显示省略号</h2><p>本章讲解实现单行多行文字隐藏显示省略号的不同方法。</p><h3 id="单行文字实现"><a href="#单行文字实现" class="headerlink" title="单行文字实现"></a>单行文字实现</h3><p>文字单行隐藏：给它设定一个宽和高，对于文字超出部分进行隐藏，多余的部分用省略号来表示。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">text-overflow</span>: ellipsis;<span class="hljs-attribute">overflow</span>: hidden ;<span class="hljs-attribute">white-space</span>: nowrap;</code></pre></div><h3 id="多行文字实现"><a href="#多行文字实现" class="headerlink" title="多行文字实现"></a>多行文字实现</h3><p>多行隐藏：多行隐藏的 div 的高度不能设置，让其自动 3 行隐藏即可。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span> : hidden;-webkit-line-clamp: <span class="hljs-number">3</span>;-webkit-box-orient: vertical;<span class="hljs-attribute">display</span>: -webkit-box;</code></pre></div><h2 id="第十一章-函数柯里化"><a href="#第十一章-函数柯里化" class="headerlink" title="第十一章 函数柯里化"></a>第十一章 函数柯里化</h2><p>本章讲解实现函数柯里化的不同方法。</p><h3 id="什么是函数柯里化"><a href="#什么是函数柯里化" class="headerlink" title="什么是函数柯里化"></a>什么是函数柯里化</h3><p>函数柯里化是指将使用多个参数的函数转化成一系列使用一个参数的函数的技术, 它返回一个新的函数, 这个新函数去处理剩余的参数</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ex:</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;    <span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><span class="hljs-comment">// 柯里化const addCurry = curry(add);addCurry(1)(2) // 3</span></code></pre></div><h3 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h3><p>实现思路: 通过函数的 length 属性获取函数的形参个数, 形参的个数就是所需参数的个数</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn</span>) &#123;  <span class="hljs-keyword">return</span> _curry.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, fn, fn.<span class="hljs-property">length</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">_curry</span>(<span class="hljs-params">fn, len, ...args</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...params</span>) &#123;    <span class="hljs-keyword">const</span> _args = args.<span class="hljs-title function_">concat</span>(params);    <span class="hljs-keyword">if</span> (_args.<span class="hljs-property">length</span> &gt;= len) &#123;      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, _args);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> _curry.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, fn, len, ..._args);    &#125;  &#125;&#125;<span class="hljs-comment">// test</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span> (a, b, c, d) &#123;  <span class="hljs-keyword">return</span> a + b + c + d;&#125;<span class="hljs-keyword">const</span> addCurry = <span class="hljs-title function_">curry</span>(add);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addCurry</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)) <span class="hljs-comment">// 10</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addCurry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)) <span class="hljs-comment">// 10</span></code></pre></div><h3 id="函数柯里化的作用"><a href="#函数柯里化的作用" class="headerlink" title="函数柯里化的作用"></a>函数柯里化的作用</h3><p>1、参数复用: 本质上来说就是降低通用性, 提高适用性</p><p>假如一个函数需要两个参数, 其中一个参数可能多次调用并不会发生更改, 比如商品打折的力度, 此时可以根据折扣进行封装</p><p>2、提前返回</p><p>经典实例: 元素绑定事件监听器, 区分 IE 浏览器的 attachEvent 方法</p><p>3、延迟计算: 柯里化函数不会立即执行计算，第一次只是返回一个函数，后面的调用才会进行计算</p><h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 实现一个add方法，使计算结果能够满足如下预期：</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)) <span class="hljs-comment">// 6;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)) <span class="hljs-comment">// 10;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)) <span class="hljs-comment">// 15;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>];  <span class="hljs-keyword">function</span> <span class="hljs-title function_">_add</span>(<span class="hljs-params"></span>) &#123;    args = args.<span class="hljs-title function_">concat</span>([...<span class="hljs-variable language_">arguments</span>]);    <span class="hljs-keyword">return</span> _add;  &#125;  _add.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> pre + cur;    &#125;)  &#125;  <span class="hljs-keyword">return</span> _add;&#125;</code></pre></div><h2 id="第十二章-图片懒加载"><a href="#第十二章-图片懒加载" class="headerlink" title="第十二章 图片懒加载"></a>第十二章 图片懒加载</h2><p>本章讲实现图片懒加载问题的 3 种方法。</p><h3 id="方法一：滚动监听-scrollTop-offsetTop-innerHeight"><a href="#方法一：滚动监听-scrollTop-offsetTop-innerHeight" class="headerlink" title="方法一：滚动监听 + scrollTop + offsetTop + innerHeight"></a>方法一：滚动监听 + scrollTop + offsetTop + innerHeight</h3><ul><li><p>scrollTop：指网页元素被滚动条卷去的部分。</p></li><li><p>offsetTop：元素相对父元素的位置</p></li><li><p>innerHeight：当前浏览器窗口的大小。需要注意兼容性问题。</p></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">img</span> &#123;</span><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;./img/loading.gif&#x27;</span>) no-repeat center;</span><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;</span><span class="language-css">            <span class="hljs-attribute">display</span>: block;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/1.jpeg&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/2.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/3.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/4.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/5.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/6.webp&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-keyword">let</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;img&#x27;</span>)</span><span class="language-javascript">        <span class="hljs-comment">// 1. 一上来立即执行一次</span></span><span class="language-javascript">        <span class="hljs-title function_">fn</span>()</span><span class="language-javascript">        <span class="hljs-comment">// 2. 监听滚动事件</span></span><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-title function_">lazyload</span>(fn, <span class="hljs-literal">true</span>)</span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-comment">// 获取视口高度和内容的偏移量</span></span><span class="language-javascript">            <span class="hljs-keyword">let</span> clietH = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientHeight</span>;</span><span class="language-javascript">            <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageYOffset</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span>;</span><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clietH, scrollTop);</span><span class="language-javascript">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; imgs.<span class="hljs-property">length</span>; i++) &#123;</span><span class="language-javascript">                <span class="hljs-keyword">let</span> x = scrollTop + clietH - imgs[i].<span class="hljs-property">offsetTop</span> <span class="hljs-comment">//当内容的偏移量+视口高度&gt;图片距离内容顶部的偏移量时，说明图片在视口内</span></span><span class="language-javascript">                <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">                    imgs[i].<span class="hljs-property">src</span> = imgs[i].<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-url&#x27;</span>); <span class="hljs-comment">//从dataurl中取出真实的图片地址赋值给url</span></span><span class="language-javascript">                &#125;</span><span class="language-javascript">            &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript">          <span class="hljs-comment">// 函数节流</span></span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyload</span>(<span class="hljs-params">fn, immediate</span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span></span><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">                <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;</span><span class="language-javascript">                <span class="hljs-keyword">if</span> (!timer) &#123;</span><span class="language-javascript">                    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">                        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>)</span><span class="language-javascript">                        timer = <span class="hljs-literal">null</span></span><span class="language-javascript">                    &#125;, <span class="hljs-number">200</span>)</span><span class="language-javascript">                &#125;</span><span class="language-javascript">            &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dzv8fv/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h3 id="方法二：滚动监听-getBoundingClientRect"><a href="#方法二：滚动监听-getBoundingClientRect" class="headerlink" title="方法二：滚动监听 + getBoundingClientRect()"></a>方法二：滚动监听 + getBoundingClientRect()</h3><ul><li><p>rectObject.top：元素上边到视窗上边的距离;</p></li><li><p>rectObject.right：元素右边到视窗左边的距离;</p></li><li><p>rectObject.bottom：元素下边到视窗上边的距离;</p></li><li><p>rectObject.left：元素左边到视窗左边的距离;</p></li><li><p>rectObject.width：元素自身的宽度;</p></li><li><p>rectObject.height：元素自身的高度;</p></li></ul><div class="code-wrapper"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        * &#123;</span><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><span class="language-css">        &#125;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">img</span> &#123;</span><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;./img/loading.gif&#x27;</span>) no-repeat center;</span><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;</span><span class="language-css">            <span class="hljs-attribute">display</span>: block;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/1.jpeg&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/2.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/3.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/4.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/5.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/6.webp&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-keyword">let</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;img&#x27;</span>)</span><span class="language-javascript">        <span class="hljs-comment">// 1. 一上来立即执行一次</span></span><span class="language-javascript">        <span class="hljs-title function_">fn</span>()</span><span class="language-javascript">        <span class="hljs-comment">// 2. 监听滚动事件</span></span><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-title function_">lazyload</span>(fn, <span class="hljs-literal">true</span>)</span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-comment">// 获取视口高度和内容的偏移量</span></span><span class="language-javascript">            <span class="hljs-keyword">let</span> offsetHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span></span><span class="language-javascript">            <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(imgs).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;</span><span class="language-javascript">                <span class="hljs-keyword">let</span> oBounding = item.<span class="hljs-title function_">getBoundingClientRect</span>() <span class="hljs-comment">//返回一个矩形对象，包含上下左右的偏移值</span></span><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index, oBounding.<span class="hljs-property">top</span>, offsetHeight);</span><span class="language-javascript">                <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt;= oBounding.<span class="hljs-property">top</span> &amp;&amp; oBounding.<span class="hljs-property">top</span> &lt;= offsetHeight) &#123;</span><span class="language-javascript">                    item.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>, item.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-url&#x27;</span>))</span><span class="language-javascript">                &#125;</span><span class="language-javascript">            &#125;)</span><span class="language-javascript">        &#125;</span><span class="language-javascript">        <span class="hljs-comment">// 函数节流</span></span><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyload</span>(<span class="hljs-params">fn, immediate</span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span></span><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">                <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>;</span><span class="language-javascript">                <span class="hljs-keyword">if</span> (!timer) &#123;</span><span class="language-javascript">                    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">                        fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>)</span><span class="language-javascript">                        timer = <span class="hljs-literal">null</span></span><span class="language-javascript">                    &#125;, <span class="hljs-number">200</span>)</span><span class="language-javascript">                &#125;</span><span class="language-javascript">            &#125;</span><span class="language-javascript">        &#125;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>作者：力扣 (LeetCode)链接：https://leetcode.cn/leetbook/read/interview-coding-frontend/dzwibj/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><h3 id="方法三-intersectionObserve"><a href="#方法三-intersectionObserve" class="headerlink" title="方法三: intersectionObserve()"></a>方法三: intersectionObserve()</h3><ul><li><p>IntersectionObserver : 浏览器原生提供的构造函数，接收两个参数</p></li><li><p>IntersectionObserver API 是异步的，不会与目标元素的滚动同步触发</p></li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">img</span> &#123;</span><span class="language-css">            <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;./img/loading.gif&#x27;</span>) no-repeat center;</span><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span>;</span><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">250px</span>;</span><span class="language-css">            <span class="hljs-attribute">display</span>: block;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/1.jpeg&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/2.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/3.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/4.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/5.jfif&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./img/pixel.gif&quot;</span> <span class="hljs-attr">data-url</span>=<span class="hljs-string">&quot;./img/6.webp&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-keyword">let</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;img&#x27;</span>)</span><span class="language-javascript">        <span class="hljs-comment">// 1. 一上来立即执行一次</span></span><span class="language-javascript">        <span class="hljs-keyword">let</span> io = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">entires</span>) &#123;</span><span class="language-javascript">            <span class="hljs-comment">//图片进入视口时就执行回调</span></span><span class="language-javascript">            entires.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;</span><span class="language-javascript">                <span class="hljs-comment">// 获取目标元素</span></span><span class="language-javascript">                <span class="hljs-keyword">let</span> oImg = item.<span class="hljs-property">target</span></span><span class="language-javascript">                <span class="hljs-comment">// console.log(item);</span></span><span class="language-javascript">                <span class="hljs-comment">// 当图片进入视口的时候，就赋值图片的真实地址</span></span><span class="language-javascript">                <span class="hljs-keyword">if</span> (item.<span class="hljs-property">intersectionRatio</span> &gt; <span class="hljs-number">0</span> &amp;&amp; item.<span class="hljs-property">intersectionRatio</span> &lt;= <span class="hljs-number">1</span>) &#123;</span><span class="language-javascript">                    oImg.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>, oImg.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-url&#x27;</span>))</span><span class="language-javascript">                &#125;</span><span class="language-javascript">            &#125;)</span><span class="language-javascript">        &#125;)</span><span class="language-javascript">        <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(imgs).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;</span><span class="language-javascript">            io.<span class="hljs-title function_">observe</span>(element)  <span class="hljs-comment">//给每一个图片设置监听</span></span><span class="language-javascript">        &#125;);</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="第十三章：bind、apply、call-的用法"><a href="#第十三章：bind、apply、call-的用法" class="headerlink" title="第十三章：bind、apply、call 的用法"></a>第十三章：bind、apply、call 的用法</h2><p>本章讲解 call、apply、bind 的相同点和不同点以及手撕代码。</p><h3 id="相同点和不同点"><a href="#相同点和不同点" class="headerlink" title="相同点和不同点"></a>相同点和不同点</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol><li><p>三个都是用于改变 this 指向；</p></li><li><p>接收的第一个参数都是 this 要指向的对象；</p></li><li><p>都可以利用后续参数传参。</p></li></ol><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol><li><p>call 和 bind 传参相同，多个参数依次传入的；</p></li><li><p>apply 只有两个参数，第二个参数为数组；</p></li><li><p>call 和 apply 都是对函数进行直接调用，而 bind 方法不会立即调用函数，而是返回一个修改 this 后的函数。</p></li></ol><h3 id="call的用法"><a href="#call的用法" class="headerlink" title="call的用法"></a>call的用法</h3><div class="code-wrapper"><pre><code class="hljs JavaScript">fn.<span class="hljs-title function_">call</span>(thisArg, arg1, arg2, arg3, ...)</code></pre></div><p>调用 fn.call 时会将 fn 中的 this 指向修改为传入的第一个参数 thisArg；将后面的参数传入给 fn,并立即执行函数 fn。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaoming&quot;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>,        <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">job, hobby</span>) &#123;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我叫<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>,今年<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁。我的工作是: <span class="hljs-subst">$&#123;job&#125;</span>，我的爱好是: <span class="hljs-subst">$&#123;hobby&#125;</span>。`</span>);        &#125;    &#125;    obj.<span class="hljs-title function_">sayHello</span>(<span class="hljs-string">&#x27;程序员&#x27;</span>, <span class="hljs-string">&#x27;看美女&#x27;</span>); <span class="hljs-comment">// 我叫xiaoming,今年24岁。我的工作是: 程序员，我的爱好是: 看美女。</span>    <span class="hljs-keyword">let</span> obj1 = &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lihua&quot;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>    &#125;    <span class="hljs-comment">// obj1.sayHello(); // Uncaught TypeError: obj1.sayHello is not a function</span>    obj.<span class="hljs-property">sayHello</span>.<span class="hljs-title function_">call</span>(obj1, <span class="hljs-string">&#x27;设计师&#x27;</span>, <span class="hljs-string">&#x27;画画&#x27;</span>); <span class="hljs-comment">// 我叫lihua,今年30岁。我的工作是: 设计师，我的爱好是: 画画。</span></code></pre></div><p>手撕call的写法：</p><ul><li><p>第一参数接收 this 对象</p></li><li><p>改变 this 指向：将函数作为传入 this 对象的方法</p></li><li><p>展开语法，支持传入和调用参数列表</p></li><li><p>调用并删除方法，返回结果</p></li></ul><div class="code-wrapper"><pre><code class="hljs actionscript">Function.prototype.myCall = <span class="hljs-keyword">function</span><span class="hljs-params">(_this, <span class="hljs-rest_arg">...args</span>)</span> &#123;        <span class="hljs-keyword">if</span> (!_this) _this = Object.create(<span class="hljs-literal">null</span>)        _this.fn = <span class="hljs-keyword">this</span>        <span class="hljs-keyword">const</span> res = _this.fn(...args)        <span class="hljs-keyword">delete</span> _this.fn        <span class="hljs-keyword">return</span> res&#125;<span class="hljs-comment">// 使用</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> <span class="hljs-params">(a, b)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.v + a + b&#125;sum.myCall(&#123;v: <span class="hljs-number">1</span>&#125;, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 6</span></code></pre></div><h3 id="apply的用法"><a href="#apply的用法" class="headerlink" title="apply的用法"></a>apply的用法</h3><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-title function_">apply</span>(thisArg, [argsArr])</code></pre></div><p>fn.apply 的作用和 call 相同：修改 this 指向，并立即执行 fn。区别在于传参形式不同， apply 接受两个参数，第一个参数是要指向的 this 对象，第二个参数是一个数组，数组里面的元素会被展开传入 fn , 作为 fn 的参数。</p><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> obj = &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;xiaoming&quot;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>,        <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">job, hobby</span>) &#123;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我叫<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>,今年<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>岁。我的工作是: <span class="hljs-subst">$&#123;job&#125;</span>，我的爱好是: <span class="hljs-subst">$&#123;hobby&#125;</span>。`</span>);        &#125;    &#125;    obj.<span class="hljs-title function_">sayHello</span>(<span class="hljs-string">&#x27;程序员&#x27;</span>, <span class="hljs-string">&#x27;看美女&#x27;</span>); <span class="hljs-comment">// 我叫xiaoming,今年24岁。我的工作是: 程序员，我的爱好是: 看美女。</span>    <span class="hljs-keyword">let</span> obj1 = &#123;        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lihua&quot;</span>,        <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>    &#125;    obj.<span class="hljs-property">sayHello</span>.<span class="hljs-title function_">apply</span>(obj1, [<span class="hljs-string">&#x27;设计师&#x27;</span>, <span class="hljs-string">&#x27;画画&#x27;</span>]); <span class="hljs-comment">// 我叫lihua,今年30岁。我的工作是: 设计师，我的爱好是: 画画。</span></code></pre></div><p>手撕 apply 的写法：</p><ul><li><p>第一参数接收 this 对象</p></li><li><p>改变 this 指向：将函数作为传入 this 对象的方法</p></li><li><p>第二个参数默认数组</p></li><li><p>展开语法，支持调用参数列表</p></li><li><p>调用并删除方法，返回结果</p></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">_this, args = []</span>) &#123;        <span class="hljs-keyword">if</span> (!_this) _this = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)        _this.<span class="hljs-property">fn</span> =<span class="hljs-variable language_">this</span>        <span class="hljs-keyword">const</span> res = _this.<span class="hljs-title function_">fn</span>(...args)        <span class="hljs-keyword">delete</span> _this.<span class="hljs-property">fn</span>        <span class="hljs-keyword">return</span> res&#125;<span class="hljs-comment">// 使用</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> (a, b) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">v</span> + a + b&#125;sum.<span class="hljs-title function_">myApply</span>(&#123;<span class="hljs-attr">v</span>: <span class="hljs-number">1</span>&#125;, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// 6</span></code></pre></div><h3 id="bind-的用法"><a href="#bind-的用法" class="headerlink" title="bind 的用法"></a>bind 的用法</h3><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-title function_">bind</span>(thisArg, arg1, arg2, arg3, ...)</code></pre></div><p>fn.bind 的作用是只修改 this 指向，但不会立即执行 fn ；会返回一个修改了 this 指向后的 fn 。需要调用才会执行: bind(thisArg, arg1, arg2, arg3, …)()。bind 的传参和 call 相同。</p><p>手撕bind的写法：</p><ul><li><p>第一个参数接收 this 对象</p></li><li><p>返回函数，根据使用方式</p></li></ul><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dzi9zh/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dzi9zh/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">_this, ...args</span>) &#123;        <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">this</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params">...args2</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> F ? <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>(...args, ...args2)                : fn.<span class="hljs-title function_">apply</span>(_this, args.<span class="hljs-title function_">concat</span>(args2))        &#125;&#125;<span class="hljs-comment">//使用</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Sum</span> (a, b) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">v</span>= (<span class="hljs-variable language_">this</span>.<span class="hljs-property">v</span> || <span class="hljs-number">0</span>)+ a + b        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>&#125;<span class="hljs-keyword">const</span> <span class="hljs-title class_">NewSum</span> = <span class="hljs-title class_">Sum</span>.<span class="hljs-title function_">myBind</span>(&#123;<span class="hljs-attr">v</span>: <span class="hljs-number">1</span>&#125;, <span class="hljs-number">2</span>)<span class="hljs-title class_">NewSum</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 调用：&#123;v: 6&#125;</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">NewSum</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 构造函数：&#123;v: 5&#125; 忽略 myBind 绑定this</span></code></pre></div><h2 id="第十四章：手写-new"><a href="#第十四章：手写-new" class="headerlink" title="第十四章：手写 new"></a>第十四章：手写 new</h2><ul><li>第一参数作为构造函数，其余参数作为构造函数参数</li><li>继承构造函数原型创建新对象</li><li>执行构造函数</li><li>结果为对象，返回结果，反之，返回新对象</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params">...args</span>) &#123;        <span class="hljs-keyword">const</span> <span class="hljs-title class_">Constructor</span> = args[<span class="hljs-number">0</span>]        <span class="hljs-keyword">const</span> o = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)        <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(o, args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>))        <span class="hljs-keyword">return</span> res <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? res : o&#125;<span class="hljs-comment">// 使用</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">P</span>(<span class="hljs-params">v</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">v</span> = v&#125;<span class="hljs-keyword">const</span> p = <span class="hljs-title function_">myNew</span>(P, <span class="hljs-number">1</span>) <span class="hljs-comment">// P &#123;v: 1&#125;</span></code></pre></div><h2 id="第十五章：promise-的用法"><a href="#第十五章：promise-的用法" class="headerlink" title="第十五章：promise 的用法"></a>第十五章：promise 的用法</h2><p>本章讲解 promise 的用法及对应函数的手撕代码。</p><h3 id="promise-相关概念"><a href="#promise-相关概念" class="headerlink" title="promise 相关概念"></a>promise 相关概念</h3><p>回调方法：就是将一个方法 func2 作为参数传入另一个方法 func1 中，当 func1 执行到某一步或者满足某种条件的时候才执行传入的参数 func2</p><p>Promise 是 ES6 引入的异步编程的新解决方案。</p><p>Promise 对象三种状态：初始化、成功、失败 pending-进行中、resolved-已完成、rejected-已失败</p><p>就好像，你跟你女朋友求婚，她跟你说她要考虑一下，明天才能给你答案，这就是承诺（promise）。同时，这也是一个等待的过程（pending），然后你就等，等到明天你女朋友给你答复，同意（resolved）或者拒绝（rejected），如果同意就准备结婚了，如果不同意就等下次再求婚，哈哈哈。</p><p>promise 是用来解决两个问题的：</p><ul><li><p>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象</p></li><li><p>promise 可以支持多个并发的请求，获取并发请求中的数据</p></li><li><p>这个 promise 可以解决异步的问题，本身不能说 promise 是异步的</p></li></ul><h3 id="promise-基本用法"><a href="#promise-基本用法" class="headerlink" title="promise 基本用法"></a>promise 基本用法</h3><p>这样构造 promise 实例，然后调用 .then.then.then 的编写代码方式，就是 promise。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">//    调用了Promise构造函数</span>  <span class="hljs-comment">// 做一些事情</span>  <span class="hljs-comment">// 然后在某些条件下resolve，或者reject</span>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 条件随便写^_^ */</span>) &#123;    <span class="hljs-title function_">resolve</span>()  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-title function_">reject</span>()  &#125;&#125;)p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;                                 <span class="hljs-comment">//    调用了promise实例的.then方法</span>    <span class="hljs-comment">// 如果p的状态被resolve了，就进入这里</span>&#125;, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-comment">// 如果p的状态被reject</span>&#125;)</code></pre></div><h3 id="声明一个-Promise-对象"><a href="#声明一个-Promise-对象" class="headerlink" title="声明一个 Promise 对象"></a>声明一个 Promise 对象</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;     <span class="hljs-comment">// 这两个方法主要是用来修改状态的</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;开始求婚。&quot;</span>)    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;。。。。。&quot;</span>)    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;考虑一下。&quot;</span>)    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (isHandsome || isRich) &#123; <span class="hljs-comment">// 当我们调用 resolve 函数的时候，Promise 的状态就变成 resolved</span>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;我同意！&#x27;</span>)        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 当我们调用 reject 函数的时候，Promise 的状态就变成 reject</span>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;拒绝：我们八字不合&quot;</span>)        &#125;    &#125;, <span class="hljs-number">2000</span>)&#125;)<span class="hljs-comment">// 如果一个 promise 已经被兑现（resolved）或被拒绝（rejected），那么我们也可以说它处于已敲定（settled）状态。</span></code></pre></div><h3 id="Promise-prototype-then-方法"><a href="#Promise-prototype-then-方法" class="headerlink" title="Promise.prototype.then 方法"></a>Promise.prototype.then 方法</h3><p>已成功 <strong>resolved 的回调和已失败 rejected 的回调</strong></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 调用 Promise 对象的then方法，两个参数为函数</span>p.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123; <span class="hljs-comment">// 成功</span>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">season</span>)&#123; <span class="hljs-comment">// 失败</span>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(season);&#125;);</code></pre></div><p>getNumber()</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">getNumber</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);&#125;);</code></pre></div><h3 id="Promise-prototype-catch-方法"><a href="#Promise-prototype-catch-方法" class="headerlink" title="Promise.prototype.catch 方法"></a>Promise.prototype.catch 方法</h3><p>catch() 的作用是捕获 Promise 的错误</p><p>其实它和 then 的第二个参数一样，用来指定 reject 的回调，用法是这样：</p><p>在执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死 js，而是会进到这个 catch 方法中。请看下面的代码：</p><p>作者：力扣 (LeetCode)<br>链接：<a href="https://leetcode.cn/leetbook/read/interview-coding-frontend/dz36t5/">https://leetcode.cn/leetbook/read/interview-coding-frontend/dz36t5/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><div class="code-wrapper"><pre><code class="hljs javascript">promise.<span class="hljs-title function_">then</span>(    <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this is success callback&#x27;</span>) &#125;).<span class="hljs-title function_">catch</span>(    <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err) &#125;)</code></pre></div><p>效果和写在 then 的第二个参数里面一样。不过它还有另外一个作用：在执行 resolve 的回调（也就是上面 then 中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死 js ，而是会进到这个 catch 方法中。请看下面的代码：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">getNumber</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(somedata);  <span class="hljs-comment">//此处的somedata未定义</span>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);&#125;);</code></pre></div><h3 id="Promise-all-方法"><a href="#Promise-all-方法" class="headerlink" title="Promise.all() 方法"></a>Promise.all() 方法</h3><p>有了 all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。</p><p>「谁跑的慢，以谁为准执行回调」</p><p>Promise 的 all 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">runAsync1</span>(), <span class="hljs-title function_">runAsync2</span>(), <span class="hljs-title function_">runAsync3</span>()]).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">results</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results);&#125;);</code></pre></div><p>Promise.all 手撕代码题:</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">myPromiseAll</span> =(<span class="hljs-params">arr</span>)=&gt;&#123;     <span class="hljs-keyword">let</span> result = [];     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Peomise</span> (<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;             arr[i].<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;                 result[i] = data;                 <span class="hljs-keyword">if</span>(result.<span class="hljs-property">length</span> === arr.<span class="hljs-property">length</span>)<span class="hljs-comment">//所有的都成功才执行成功的回调</span>                 &#123;                     <span class="hljs-title function_">resolve</span>(result)                   &#125;<span class="hljs-comment">//这里可以用计数器更好点</span>             &#125;,reject)<span class="hljs-comment">//有一个失败则执行失败的回调</span>         &#125;     &#125;)&#125;</code></pre></div><h3 id="Promise-race-方法"><a href="#Promise-race-方法" class="headerlink" title="Promise.race() 方法"></a>Promise.race() 方法</h3><ul><li><p>「谁跑的快，以谁为准执行回调」</p></li><li><p>1 秒后 runAsync1 已经执行完了，此时then里面的就执行了</p></li><li><p>在 then 里面的回调开始执行时，runAsync2() 和 runAsync3() 并没有停止，仍旧再执行。</p></li><li><p>于是再过 1 秒后，输出了他们结束的标志。</p></li></ul><div class="code-wrapper"><pre><code class="hljs JavaScript">  <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)&#123;        <span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();        img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;            <span class="hljs-title function_">resolve</span>(img);        &#125;        img.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;xxxxxx&#x27;</span>;    &#125;);    <span class="hljs-keyword">return</span> p;&#125;<span class="hljs-comment">//延时函数，用于给请求计时</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)&#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;图片请求超时&#x27;</span>);        &#125;, <span class="hljs-number">5000</span>);    &#125;);    <span class="hljs-keyword">return</span> p;&#125;<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-title function_">requestImg</span>(), <span class="hljs-title function_">timeout</span>()]).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">results</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results);&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);&#125;);</code></pre></div><p>Promise.race()手撕代码用法：</p><div class="code-wrapper"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promiseRace</span>(<span class="hljs-params">promises</span>) &#123;     <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(promises)) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;promises must be an array&quot;</span>)     &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;         promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span>             <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;                 <span class="hljs-title function_">resolve</span>(data)                 &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                 <span class="hljs-title function_">reject</span>(err)             &#125;)         )     &#125;) &#125;</code></pre></div><h3 id="Promise-prototype-finally-方法"><a href="#Promise-prototype-finally-方法" class="headerlink" title="Promise.prototype.finally() 方法"></a>Promise.prototype.finally() 方法</h3><p>finally 方法用于指定无论 Promise 对象的最终状态如何，都将执行 finally。Finally 不接受参数。Finally 独立于先前的执行状态，不依赖于先前的运行结果。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x + <span class="hljs-number">1</span>);&#125;);promise4  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;你好&quot;</span>);&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);&#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;finally&quot;</span>);&#125;);<span class="hljs-comment">// finally</span></code></pre></div><h2 id="第十六章：解析-URL"><a href="#第十六章：解析-URL" class="headerlink" title="第十六章：解析 URL"></a>第十六章：解析 URL</h2><h3 id="什么是解析URL？"><a href="#什么是解析URL？" class="headerlink" title="什么是解析URL？"></a>什么是解析URL？</h3><p>js解析url，就是将如下url： <code>const url = https://www.baidu.com/m?f=8&amp;ie=utf-8&amp;rsv_bp=1&amp;tn=monline_3_dg&amp;wd=session</code> 解析为：</p><div class="code-wrapper"><pre><code class="hljs css">&#123;f:<span class="hljs-string">&#x27;8&#x27;</span>,ie:<span class="hljs-string">&#x27;utf-8&#x27;</span>rsv_bp:<span class="hljs-string">&#x27;1&#x27;</span>,tn:<span class="hljs-string">&#x27;monline_3_dg&#x27;</span>,wd:<span class="hljs-string">&#x27;session&#x27;</span>&#125;</code></pre></div><h3 id="方法一：利用-splice-分割-循环依次取出"><a href="#方法一：利用-splice-分割-循环依次取出" class="headerlink" title="方法一：利用 splice 分割 + 循环依次取出"></a>方法一：利用 splice 分割 + 循环依次取出</h3><ul><li>解析 url 并将其存储在新对象中，因此初始化一个空对象，让 obj &#x3D; {}</li><li>首先判断 url 后面是否有 ？传参, 如果没有 ? 传参，直接返回空对象</li></ul><p>if (url.indexOf(‘?’) &lt; 0) return obj</p><ul><li>用 <code>？</code> 进行参数分割 let arr &#x3D; url.split(‘?’)</li></ul><p>此时的效果是将 ? 前后，一分为二</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">queryURLparams</span>(<span class="hljs-params">url</span>) &#123;    <span class="hljs-keyword">let</span> obj = &#123;&#125;    <span class="hljs-keyword">if</span> (url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;?&#x27;</span>) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> obj    <span class="hljs-keyword">let</span> arr = url.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;?&#x27;</span>)    url = arr[<span class="hljs-number">1</span>]    <span class="hljs-keyword">let</span> array = url.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>)    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;        <span class="hljs-keyword">let</span> arr2 = array[i]        <span class="hljs-keyword">let</span> arr3 = arr2.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;=&#x27;</span>)        obj[arr3[<span class="hljs-number">0</span>]] = arr3[<span class="hljs-number">1</span>]    &#125;    <span class="hljs-keyword">return</span> obj&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">queryURLparams</span>(url)); <span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;https://www.baidu.com/m?f=8&amp;ie=utf-8&amp;rsv_bp=1&amp;tn=monline_3_dg&amp;wd=session&quot;</span>;   <span class="hljs-keyword">function</span> <span class="hljs-title function_">getURL</span>(<span class="hljs-params">url</span>)&#123;      <span class="hljs-keyword">let</span> str = url.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;?&quot;</span>)[<span class="hljs-number">1</span>];      <span class="hljs-keyword">let</span> str1 = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&amp;&quot;</span>);      <span class="hljs-keyword">let</span> obj = &#123;&#125;;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt;str1.<span class="hljs-property">length</span>; i++)&#123;          <span class="hljs-keyword">let</span> str2 = str1[i].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>);          <span class="hljs-keyword">let</span> key = str2[<span class="hljs-number">0</span>];          <span class="hljs-keyword">let</span> value = str2[<span class="hljs-number">1</span>];          obj[key] = value;      &#125;      <span class="hljs-keyword">return</span> obj;  &#125;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getURL</span>(url))</code></pre></div><h3 id="方法二-正则-arguments"><a href="#方法二-正则-arguments" class="headerlink" title="方法二: 正则 + arguments"></a>方法二: 正则 + arguments</h3><ul><li>正则匹配规则 <code>/([^?=&amp;]+)=([^?=&amp;]+)/g</code></li><li>利用 replace 替换</li><li>用伪数组进行键值对拼接</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">queryURLparamsRegEs5</span>(<span class="hljs-params">url</span>) &#123;    <span class="hljs-keyword">let</span> obj = &#123;&#125;    <span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/([^?=&amp;]+)=([^?=&amp;]+)/g</span>    url.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;        obj[<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]] = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">2</span>]    &#125;)    <span class="hljs-keyword">return</span> obj&#125;</code></pre></div><h3 id="方法三-正则-arg"><a href="#方法三-正则-arg" class="headerlink" title="方法三: 正则 + ..arg"></a>方法三: 正则 + ..arg</h3><ul><li>就是用 ES6 的 …arg</li><li>其实和 arguments 差不多 ，就是 arguments 是伪数组，…arg 是真数组</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">queryURLparamsRegEs6</span>(<span class="hljs-params">url</span>) &#123;    <span class="hljs-keyword">let</span> obj = &#123;&#125;    <span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/([^?=&amp;]+)=([^?=&amp;]+)/g</span>    url.<span class="hljs-title function_">replace</span>(reg, <span class="hljs-function">(<span class="hljs-params">...arg</span>) =&gt;</span> &#123;        obj[arg[<span class="hljs-number">1</span>]] = arg[<span class="hljs-number">2</span>]    &#125;)    <span class="hljs-keyword">return</span> obj&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>跨域方式实现原理</title>
    <link href="/2023/01/27/%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2023/01/27/%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="九种跨域方式实现原理"><a href="#九种跨域方式实现原理" class="headerlink" title="九种跨域方式实现原理"></a>九种跨域方式实现原理</h1><p>前后端数据交互经常会碰到请求跨域，什么是跨域，以及有哪几种跨域方式，这是本文要探讨的内容。</p><p><strong>本文完整的源代码请猛戳<a href="https://link.juejin.cn/?target=https://github.com/ljianshu/Blog">github博客</a>，纸上得来终觉浅，建议大家动手敲敲代码。</strong></p><h2 id="一、什么是跨域？"><a href="#一、什么是跨域？" class="headerlink" title="一、什么是跨域？"></a>一、什么是跨域？</h2><h3 id="1-什么是同源策略及其限制内容？"><a href="#1-什么是同源策略及其限制内容？" class="headerlink" title="1.什么是同源策略及其限制内容？"></a>1.什么是同源策略及其限制内容？</h3><p>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p><img src="/../imgs/%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1638b3579d9eeb32tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="url的组成"></p><p><strong>同源策略限制内容有：</strong></p><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容</li><li>DOM 节点</li><li>AJAX 请求发送后，结果被浏览器拦截了</li></ul><p>但是有三个标签是允许跨域加载资源：</p><ul><li><code>&lt;img src=XXX&gt;</code></li><li><code>&lt;link href=XXX&gt;</code></li><li><code>&lt;script src=XXX&gt;</code></li></ul><h3 id="2-常见跨域场景"><a href="#2-常见跨域场景" class="headerlink" title="2.常见跨域场景"></a>2.常见跨域场景</h3><p><strong>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域</strong>。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：</p><p><img src="/../imgs/%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1638b3579dde630etplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p><p>特别说明两点：</p><p><strong>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。</strong></p><p><strong>第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”</strong>。</p><p>这里你或许有个疑问：<strong>请求跨域了，那么请求到底发出去没有？</strong></p><p><strong>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了</strong>。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p><h2 id="二、跨域解决方案"><a href="#二、跨域解决方案" class="headerlink" title="二、跨域解决方案"></a>二、跨域解决方案</h2><h3 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1.jsonp"></a>1.jsonp</h3><h4 id="1-JSONP原理"><a href="#1-JSONP原理" class="headerlink" title="1) JSONP原理"></a>1) JSONP原理</h4><p><strong>利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。</strong></p><h4 id="2-JSONP和AJAX对比"><a href="#2-JSONP和AJAX对比" class="headerlink" title="2) JSONP和AJAX对比"></a>2) JSONP和AJAX对比</h4><p>JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）</p><h4 id="3-JSONP优缺点"><a href="#3-JSONP优缺点" class="headerlink" title="3) JSONP优缺点"></a>3) JSONP优缺点</h4><p>JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。<strong>缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。</strong></p><h4 id="4-JSONP的实现流程"><a href="#4-JSONP的实现流程" class="headerlink" title="4) JSONP的实现流程"></a>4) JSONP的实现流程</h4><ul><li>声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。</li><li>创建一个<code>&lt;script&gt;</code>标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback&#x3D;show）。</li><li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是<code>show(&#39;我不爱你&#39;)</code>。</li><li>最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</li></ul><p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// index.html</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">&#123; url, params, callback &#125;</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)    <span class="hljs-variable language_">window</span>[callback] = <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;      <span class="hljs-title function_">resolve</span>(data)      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(script)    &#125;    params = &#123; ...params, callback &#125; <span class="hljs-comment">// wd=b&amp;callback=show</span>    <span class="hljs-keyword">let</span> arrs = []    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> params) &#123;      arrs.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;params[key]&#125;</span>`</span>)    &#125;    script.<span class="hljs-property">src</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?<span class="hljs-subst">$&#123;arrs.join(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;</span>`</span>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script)  &#125;)&#125;<span class="hljs-title function_">jsonp</span>(&#123;  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000/say&#x27;</span>,  <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">wd</span>: <span class="hljs-string">&#x27;Iloveyou&#x27;</span> &#125;,  <span class="hljs-attr">callback</span>: <span class="hljs-string">&#x27;show&#x27;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)&#125;)复制代码</code></pre></div><p>上面这段代码相当于向<code>http://localhost:3000/say?wd=Iloveyou&amp;callback=show</code>这个地址请求数据，然后后台返回<code>show(&#39;我不爱你&#39;)</code>，最后会运行show()这个函数，打印出’我不爱你’</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// server.js</span><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-keyword">let</span> app = <span class="hljs-title function_">express</span>()app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/say&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;  <span class="hljs-keyword">let</span> &#123; wd, callback &#125; = req.<span class="hljs-property">query</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wd) <span class="hljs-comment">// Iloveyou</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(callback) <span class="hljs-comment">// show</span>  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;callback&#125;</span>(&#x27;我不爱你&#x27;)`</span>)&#125;)app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)复制代码</code></pre></div><h4 id="5-jQuery的jsonp形式"><a href="#5-jQuery的jsonp形式" class="headerlink" title="5) jQuery的jsonp形式"></a>5) jQuery的jsonp形式</h4><p><strong>JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。</strong></p><div class="code-wrapper"><pre><code class="hljs javascript">$.<span class="hljs-title function_">ajax</span>(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&quot;http://crossdomain.com/jsonServerResponse&quot;</span>,<span class="hljs-attr">dataType</span>:<span class="hljs-string">&quot;jsonp&quot;</span>,<span class="hljs-attr">type</span>:<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-comment">//可以省略</span><span class="hljs-attr">jsonpCallback</span>:<span class="hljs-string">&quot;show&quot;</span>,<span class="hljs-comment">//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span><span class="hljs-attr">jsonp</span>:<span class="hljs-string">&quot;callback&quot;</span>,<span class="hljs-comment">//-&gt;把传递函数名的那个形参callback，可省略</span><span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);&#125;&#125;);复制代码</code></pre></div><h3 id="2-cors"><a href="#2-cors" class="headerlink" title="2.cors"></a>2.cors</h3><p><strong>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现</strong>。</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><h4 id="1-简单请求"><a href="#1-简单请求" class="headerlink" title="1) 简单请求"></a>1) 简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求</p><p>条件1：使用下列方法之一：</p><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><p>条件2：Content-Type 的值仅限于下列三者之一：</p><ul><li>text&#x2F;plain</li><li>multipart&#x2F;form-data</li><li>application&#x2F;x-www-form-urlencoded</li></ul><p>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。</p><h4 id="2-复杂请求"><a href="#2-复杂请求" class="headerlink" title="2) 复杂请求"></a>2) 复杂请求</h4><p>不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p><p>我们用<code>PUT</code>向后台请求时，属于复杂请求，后台需做如下配置：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 允许哪个方法访问我</span>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;PUT&#x27;</span>)<span class="hljs-comment">// 预检的存活时间</span>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="hljs-number">6</span>)<span class="hljs-comment">// OPTIONS请求不做任何处理</span><span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;  res.<span class="hljs-title function_">end</span>() &#125;<span class="hljs-comment">// 定义后台返回的内容</span>app.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">headers</span>)  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;我不爱你&#x27;</span>)&#125;)复制代码</code></pre></div><p>接下来我们看下一个完整复杂请求的例子，并且介绍下CORS请求相关的字段</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// index.html</span><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&#x27;name=xiamen&#x27;</span> <span class="hljs-comment">// cookie不能跨域</span>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">// 前端设置是否带cookie</span>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;PUT&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:4000/getData&#x27;</span>, <span class="hljs-literal">true</span>)xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;xiamen&#x27;</span>)xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;    <span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt; <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> === <span class="hljs-number">304</span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">response</span>)      <span class="hljs-comment">//得到响应头，后台需设置Access-Control-Expose-Headers</span>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-title function_">getResponseHeader</span>(<span class="hljs-string">&#x27;name&#x27;</span>))    &#125;  &#125;&#125;xhr.<span class="hljs-title function_">send</span>()复制代码<span class="hljs-comment">//server1.js</span><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">let</span> app = <span class="hljs-title function_">express</span>();app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(__dirname));app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);复制代码<span class="hljs-comment">//server2.js</span><span class="hljs-keyword">let</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<span class="hljs-keyword">let</span> app = <span class="hljs-title function_">express</span>()<span class="hljs-keyword">let</span> whitList = [<span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>] <span class="hljs-comment">//设置白名单</span>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;  <span class="hljs-keyword">let</span> origin = req.<span class="hljs-property">headers</span>.<span class="hljs-property">origin</span>  <span class="hljs-keyword">if</span> (whitList.<span class="hljs-title function_">includes</span>(origin)) &#123;    <span class="hljs-comment">// 设置哪个源可以访问我</span>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, origin)    <span class="hljs-comment">// 允许携带哪个头访问我</span>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>)    <span class="hljs-comment">// 允许哪个方法访问我</span>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;PUT&#x27;</span>)    <span class="hljs-comment">// 允许携带cookie</span>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="hljs-literal">true</span>)    <span class="hljs-comment">// 预检的存活时间</span>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="hljs-number">6</span>)    <span class="hljs-comment">// 允许返回的头</span>    res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Expose-Headers&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>)    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> === <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;      res.<span class="hljs-title function_">end</span>() <span class="hljs-comment">// OPTIONS请求不做任何处理</span>    &#125;  &#125;  <span class="hljs-title function_">next</span>()&#125;)app.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">headers</span>)  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;jw&#x27;</span>) <span class="hljs-comment">//返回一个响应头，后台需设置</span>  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;我不爱你&#x27;</span>)&#125;)app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/getData&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">headers</span>)  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;我不爱你&#x27;</span>)&#125;)app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(__dirname))app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">4000</span>)复制代码</code></pre></div><p>上述代码由<code>http://localhost:3000/index.html</code>向<code>http://localhost:4000/</code>跨域请求，正如我们上面所说的，后端是实现 CORS 通信的关键。</p><h3 id="3-postMessage"><a href="#3-postMessage" class="headerlink" title="3.postMessage"></a>3.postMessage</h3><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p><strong>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递</strong>。</p><blockquote><p>otherWindow.postMessage(message, targetOrigin, [transfer]);</p></blockquote><ul><li>message: 将要发送到其他 window的数据。</li><li>targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li><li>transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul><p>接下来我们看个例子： <code>http://localhost:3000/a.html</code>页面向<code>http://localhost:4000/b.html</code>传递“我爱你”,然后后者传回”我不爱你”。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// a.html</span>  &lt;iframe src=<span class="hljs-string">&quot;http://localhost:4000/b.html&quot;</span> frameborder=<span class="hljs-string">&quot;0&quot;</span> id=<span class="hljs-string">&quot;frame&quot;</span> onload=<span class="hljs-string">&quot;load()&quot;</span>&gt;&lt;<span class="hljs-regexp">/iframe&gt; /</span><span class="hljs-regexp">/等它加载完触发一个事件</span><span class="hljs-regexp">  /</span><span class="hljs-regexp">/内嵌在http:/</span><span class="hljs-regexp">/localhost:3000/</span>a.<span class="hljs-property">html</span>    &lt;script&gt;      <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">let</span> frame = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;frame&#x27;</span>)        frame.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;我爱你&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:4000&#x27;</span>) <span class="hljs-comment">//发送数据</span>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123; <span class="hljs-comment">//接受返回数据</span>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>) <span class="hljs-comment">//我不爱你</span>        &#125;      &#125;    &lt;/script&gt;复制代码<span class="hljs-comment">// b.html</span>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>) <span class="hljs-comment">//我爱你</span>    e.<span class="hljs-property">source</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;我不爱你&#x27;</span>, e.<span class="hljs-property">origin</span>) &#125;复制代码</code></pre></div><h3 id="4-websocket"><a href="#4-websocket" class="headerlink" title="4.websocket"></a>4.websocket</h3><p>Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 <strong>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据</strong>。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p><p>原生WebSocket API使用起来不太方便，我们使用<code>Socket.io</code>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>我们先来看个例子：本地文件socket.html向<code>localhost:3000</code>发生数据和接受数据</p><div class="code-wrapper"><pre><code class="hljs xml">// socket.html<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">let</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:3000&#x27;</span>);</span><span class="language-javascript">    socket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;我爱你&#x27;</span>);<span class="hljs-comment">//向服务器发送数据</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript">    socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>);<span class="hljs-comment">//接收服务器返回的数据</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码// server.jslet express = require(&#x27;express&#x27;);let app = express();let WebSocket = require(&#x27;ws&#x27;);//记得安装wslet wss = new WebSocket.Server(&#123;port:3000&#125;);wss.on(&#x27;connection&#x27;,function(ws) &#123;  ws.on(&#x27;message&#x27;, function (data) &#123;    console.log(data);    ws.send(&#x27;我不爱你&#x27;)  &#125;);&#125;)复制代码</code></pre></div><h3 id="5-Node中间件代理-两次跨域"><a href="#5-Node中间件代理-两次跨域" class="headerlink" title="5. Node中间件代理(两次跨域)"></a>5. Node中间件代理(两次跨域)</h3><p>实现原理：<strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong> 代理服务器，需要做以下几个步骤：</p><ul><li><p>接受客户端请求 。</p></li><li><p>将请求 转发给服务器。</p></li><li><p>拿到服务器 响应 数据。</p></li><li><p>将 响应 转发给客户端。</p><p><img src="/../imgs/%E8%B7%A8%E5%9F%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1685c5bed77e7788tplv-t2oaga2asx-zoom-in-crop-mark4536000.webp" alt="img"></p></li></ul><p>我们先来看个例子：本地文件index.html文件，通过代理服务器<code>http://localhost:3000</code>向目标服务器<code>http://localhost:4000</code>请求数据。</p><div class="code-wrapper"><pre><code class="hljs xml">// index.html(http://127.0.0.1:5500) <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      $.<span class="hljs-title function_">ajax</span>(&#123;</span><span class="language-javascript">        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>,</span><span class="language-javascript">        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;post&#x27;</span>,</span><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiamen&#x27;</span>, <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span> &#125;,</span><span class="language-javascript">        <span class="hljs-attr">contentType</span>: <span class="hljs-string">&#x27;application/json;charset=utf-8&#x27;</span>,</span><span class="language-javascript">        <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// &#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span></span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg)</span><span class="language-javascript">        &#125;</span><span class="language-javascript">      &#125;)</span><span class="language-javascript">     </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码// server1.js 代理服务器(http://localhost:3000)const http = require(&#x27;http&#x27;)// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; &#123;  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段  response.writeHead(200, &#123;    &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;,    &#x27;Access-Control-Allow-Methods&#x27;: &#x27;*&#x27;,    &#x27;Access-Control-Allow-Headers&#x27;: &#x27;Content-Type&#x27;  &#125;)  // 第二步：将请求转发给服务器  const proxyRequest = http    .request(      &#123;        host: &#x27;127.0.0.1&#x27;,        port: 4000,        url: &#x27;/&#x27;,        method: request.method,        headers: request.headers      &#125;,      serverResponse =&gt; &#123;        // 第三步：收到服务器的响应        var body = &#x27;&#x27;        serverResponse.on(&#x27;data&#x27;, chunk =&gt; &#123;          body += chunk        &#125;)        serverResponse.on(&#x27;end&#x27;, () =&gt; &#123;          console.log(&#x27;The data is &#x27; + body)          // 第四步：将响应结果转发给浏览器          response.end(body)        &#125;)      &#125;    )    .end()&#125;)server.listen(3000, () =&gt; &#123;  console.log(&#x27;The proxyServer is running at http://localhost:3000&#x27;)&#125;)复制代码// server2.js(http://localhost:4000)const http = require(&#x27;http&#x27;)const data = &#123; title: &#x27;fontend&#x27;, password: &#x27;123456&#x27; &#125;const server = http.createServer((request, response) =&gt; &#123;  if (request.url === &#x27;/&#x27;) &#123;    response.end(JSON.stringify(data))  &#125;&#125;)server.listen(4000, () =&gt; &#123;  console.log(&#x27;The server is running at http://localhost:4000&#x27;)&#125;)复制代码</code></pre></div><p>上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出<code>&#123;&quot;title&quot;:&quot;fontend&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</code></p><h3 id="6-nginx反向代理"><a href="#6-nginx反向代理" class="headerlink" title="6.nginx反向代理"></a>6.nginx反向代理</h3><p>实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。</p><p>使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>先下载<a href="https://link.juejin.cn/?target=http://nginx.org/en/download.html">nginx</a>，然后将nginx目录下的nginx.conf修改如下:</p><div class="code-wrapper"><pre><code class="hljs ini">// proxy服务器server &#123;    listen       81<span class="hljs-comment">;</span>    server_name  www.domain1.com<span class="hljs-comment">;</span>    location / &#123;        proxy_pass   http://www.domain2.com:8080<span class="hljs-comment">;  #反向代理</span>        proxy_cookie_domain www.domain2.com www.domain1.com<span class="hljs-comment">; #修改cookie里域名</span>        index  index.html index.htm<span class="hljs-comment">;</span>        <span class="hljs-comment"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span>        add_header Access-Control-Allow-Origin http://www.domain1.com<span class="hljs-comment">;  #当前端只跨域不带cookie时，可为*</span>        add_header Access-Control-Allow-Credentials true<span class="hljs-comment">;</span>    &#125;&#125;复制代码</code></pre></div><p>最后通过命令行<code>nginx -s reload</code>启动nginx</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">// index.html</span><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<span class="hljs-comment">// 前端开关：浏览器是否读写cookie</span>xhr.withCredentials = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 访问nginx中的代理服务器</span>xhr.open(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;http://www.domain1.com:81/?user=admin&#x27;</span>, <span class="hljs-literal">true</span>);xhr.send();复制代码<span class="hljs-comment">// server.js</span><span class="hljs-keyword">var</span> http = require(<span class="hljs-string">&#x27;http&#x27;</span>);<span class="hljs-keyword">var</span> server = http.createServer();<span class="hljs-keyword">var</span> qs = require(<span class="hljs-string">&#x27;querystring&#x27;</span>);server.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, function(req, res) &#123;    <span class="hljs-keyword">var</span> <span class="hljs-keyword">params</span> = qs.parse(req.url.substring(<span class="hljs-number">2</span>));    <span class="hljs-comment">// 向前台写cookie</span>    res.writeHead(<span class="hljs-number">200</span>, &#123;        <span class="hljs-string">&#x27;Set-Cookie&#x27;</span>: <span class="hljs-string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>   <span class="hljs-comment">// HttpOnly:脚本无法读取</span>    &#125;);    res.write(JSON.stringify(<span class="hljs-keyword">params</span>));    res.end();&#125;);server.listen(<span class="hljs-string">&#x27;8080&#x27;</span>);console.log(<span class="hljs-string">&#x27;Server is running at port 8080...&#x27;</span>);复制代码</code></pre></div><h3 id="7-window-name-iframe"><a href="#7-window-name-iframe" class="headerlink" title="7.window.name + iframe"></a>7.window.name + iframe</h3><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>其中a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p><div class="code-wrapper"><pre><code class="hljs ini"> // a.html(http://localhost:3000/b.html)  &lt;iframe <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:4000/c.html&quot;</span> frameborder=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-literal">on</span>load=<span class="hljs-string">&quot;load()&quot;</span> id=<span class="hljs-string">&quot;iframe&quot;</span>&gt;&lt;/iframe&gt;  &lt;script&gt;    let <span class="hljs-attr">first</span> = <span class="hljs-literal">true</span>    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name    function load() &#123;      if(first)&#123;      // 第1次onload(跨域页)成功后，切换到同域代理页面        let <span class="hljs-attr">iframe</span> = document.getElementById(<span class="hljs-string">&#x27;iframe&#x27;</span>)<span class="hljs-comment">;</span>        <span class="hljs-attr">iframe.src</span> = <span class="hljs-string">&#x27;http://localhost:3000/b.html&#x27;</span><span class="hljs-comment">;</span>        <span class="hljs-attr">first</span> = <span class="hljs-literal">false</span><span class="hljs-comment">;</span>      &#125;else&#123;      // 第2次onload(同域b.html页)成功后，读取同域window.name中数据        console.log(iframe.contentWindow.name)<span class="hljs-comment">;</span>      &#125;    &#125;  &lt;/script&gt;复制代码</code></pre></div><p>b.html为中间代理页，与a.html同域，内容为空。</p><div class="code-wrapper"><pre><code class="hljs xml"> // c.html(http://localhost:4000/c.html)  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;我不爱你&#x27;</span>  </span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码</code></pre></div><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="8-location-hash-iframe"><a href="#8-location-hash-iframe" class="headerlink" title="8.location.hash + iframe"></a>8.location.hash + iframe</h3><p>实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。 同样的，a.html和b.html是同域的，都是<code>http://localhost:3000</code>;而c.html是<code>http://localhost:4000</code></p><div class="code-wrapper"><pre><code class="hljs xml"> // a.html  <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:4000/c.html#iloveyou&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//检测hash的变化</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hash</span>);</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码 // b.html  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span> = location.<span class="hljs-property">hash</span> </span><span class="language-javascript">    <span class="hljs-comment">//b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span></span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>复制代码 // c.html console.log(location.hash);  let iframe = document.createElement(&#x27;iframe&#x27;);  iframe.src = &#x27;http://localhost:3000/b.html#idontloveyou&#x27;;  document.body.appendChild(iframe);复制代码</code></pre></div><h3 id="9-document-domain-iframe"><a href="#9-document-domain-iframe" class="headerlink" title="9.document.domain + iframe"></a>9.document.domain + iframe</h3><p><strong>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式</strong>。 只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>我们看个例子：页面<code>a.zf1.cn:3000/a.html</code>获取页面<code>b.zf1.cn:3000/b.html</code>中a的值</p><div class="code-wrapper"><pre><code class="hljs xml">// a.html<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> helloa  <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://b.zf1.cn:3000/b.html&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;load()&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;frame&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;zf1.cn&#x27;</span></span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(frame.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">a</span>);</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>复制代码// b.html<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>   hellob   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">     <span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;zf1.cn&#x27;</span></span><span class="language-javascript">     <span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span>;</span><span class="language-javascript">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>复制代码</code></pre></div><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><ul><li>CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案</li><li>JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</li><li>不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。</li><li>日常工作中，用得比较多的跨域方案是cors和nginx反向代理</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://link.juejin.cn/?target=http://www.zhufengpeixun.cn/main/course/index.html">珠峰架构课(强烈推荐)</a></li><li><a href="https://link.juejin.cn/?target=http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a></li><li><a href="https://juejin.cn/book/6844733763675488269/section/6844733763771957261">前端面试之道</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage">window.postMessage</a></li><li><a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000011145364">前端常见跨域解决方案（全）</a></li><li><a href="https://juejin.cn/post/6844903607297376263">深入跨域问题(4) - 利用代理解决跨域</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2023/01/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/01/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机操作系统知识点总结"><a href="#计算机操作系统知识点总结" class="headerlink" title="计算机操作系统知识点总结"></a>计算机操作系统知识点总结</h1><h2 id="一、操作系统概述"><a href="#一、操作系统概述" class="headerlink" title="一、操作系统概述"></a>一、操作系统概述</h2><h3 id="1-1-操作系统的定义与目标"><a href="#1-1-操作系统的定义与目标" class="headerlink" title="1.1 操作系统的定义与目标"></a>1.1 操作系统的定义与目标</h3><p>定义：操作系统是控制管理计算机系统的硬软件，分配调度资源的系统软件。</p><p>目标：方便性，有效性（提高系统资源的利用率、提高系统的吞吐量），可扩充性，开放性。</p><h3 id="1-2-操作系统的基本功能"><a href="#1-2-操作系统的基本功能" class="headerlink" title="1.2 操作系统的基本功能"></a>1.2 操作系统的基本功能</h3><p>统一管理计算机资源：处理器资源，IO设备资源，存储器资源，文件资源;<br>实现了对计算机资源的抽象：IO设备管理软件提供读写接口，文件管理软件提供操作文件接;<br>提供了用户与计算机之间的接口：GUI（图形用户界面），命令形式，系统调用形式。</p><h3 id="1-3-操作系统的特征"><a href="#1-3-操作系统的特征" class="headerlink" title="1.3 操作系统的特征"></a>1.3 操作系统的特征</h3><p>最基本的特征，互为存在条件：并发，共享；</p><p>（1）并行：指两个或多个事件可以在同一个时刻发生，多核CPU可以实现并行，一个cpu同一时刻只有一个程序在运行；</p><p>（2）并发：指两个或多个事件可以在同一个时间间隔发生，用户看起来是每个程序都在运行，实际上是每个程序都交替执行。</p><p>image-20210830104953215</p><p>（3）共享性：操作系统的中资源可供多个并发的程序共同使用，这种形式称之为资源共享。</p><p>互斥共享：当资源被程序占用时，其它想使用的程序只能等待。<br>同时访问：某种资源并发的被多个程序访问。<br>虚拟和异步特性前提是具有并发性。</p><p>（4）虚拟性：表现为把一个物理实体转变为若干个逻辑实体。</p><p>时分复用技术：资源在时间上进行复用，不同程序并发使用，多道程序分时使用计算机的硬件资源，提高资源的利用率。<br>空分复用技术：用来实现虚拟磁盘（物理磁盘虚拟为逻辑磁盘，电脑上的C盘、D盘等）、虚拟内存（在逻辑上扩大程序的存储容量）等，提高资源的利用率，提高编程效率。<br>（5）异步性：在多道程序环境下，允许多个进程并发执行，但由于资源等因素的限制，使进程的执行以“停停走走”的方式运行，而且每个进程执行的情况（运行、暂停、速度、完成）也是未知的。</p><h3 id="1-4-操作系统的中断处理"><a href="#1-4-操作系统的中断处理" class="headerlink" title="1.4 操作系统的中断处理"></a>1.4 操作系统的中断处理</h3><p>中断机制的作用：为了在多道批处理系统中让用户进行交互；</p><p>中断产生：</p><p>发生中断时，CPU立马切换到管态，开展管理工作；（管态又叫特权态，系统态或核心态，是操作系统管理的程序执行时，机器所处的状态。）<br>发生中断后，当前运行的进程回暂停运行，由操作系统内核对中断进行处理；<br>对于不同的中断信号，会进行不同的处理。<br>中断的分类：</p><p>内中断（也叫“异常”、“例外”、“陷入”）——- 信号来源：CPU内部，与当前执行指令有关；<br>外中断（中断）———-信号来源：CPU外部，与当前执行指令无关。<br>外中断的处理过程：</p><p>每执行完一个指令后，CPU都需要检查当前是否有外部中断 信号；<br>如果检查到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW，程序计数器PC、各种通用寄存器）把他们存储在PCB（进程控制块中）；<br>根据中断信号类型转入相应的中断处理程序；<br>恢复原进程的CPU环境并退出中断，返回原进程继续执行。</p><h2 id="二、进程管理"><a href="#二、进程管理" class="headerlink" title="二、进程管理"></a>二、进程管理</h2><h3 id="2-1-进程管理之进程实体"><a href="#2-1-进程管理之进程实体" class="headerlink" title="2.1 进程管理之进程实体"></a>2.1 进程管理之进程实体</h3><p>为什么需要进程：</p><p>进程是系统进行资源分配和调度的基本单位；<br>进程作为程序独立运行的载体保障程序正常执行；<br>进程的存在使得操作系统资源的利用率大幅提升。+<br>进程控制块（PCB）：用于描述和控制进程运行的通用数据结构,记录进程当前状态和控制进程运行的全部信息，是进程存在的唯一标识。</p><p>进程（Process）与线程（Thread）：</p><p>线程：操作系统进行<strong>运行调度的最小单位</strong>。<br>进程：系统进行<strong>资源分配和调度的基本单位</strong>。<br>区别与联系：</p><p>一个进程可以有一个或多个线程；<br>线程包含在进程之中，是进程中实际运行工作的单位；<br>进程的线程共享进程资源；<br>一个进程可以并发多个线程，每个线程执行不同的任务。<br>image-20210826153718544</p><h3 id="2-2-进程管理之五状态模型"><a href="#2-2-进程管理之五状态模型" class="headerlink" title="2.2 进程管理之五状态模型"></a>2.2 进程管理之五状态模型</h3><p>就绪状态：其它资源（进程控制块、内存、栈空间、堆空间等）都准备好、只差CPU的状态。<br>  执行状态：进程获得CPU，其程序正在执行。<br>  阻塞状态：进程因某种原因放弃CPU的状态，阻塞进程以队列的形式放置。<br>  创建状态：创建进程时拥有PCB但其它资源尚未就绪。<br>  终止状态：进程结束由系统清理或者归还PCB的状态。</p><p>image-20210830134139425</p><h3 id="2-3-进程管理之进程同步"><a href="#2-3-进程管理之进程同步" class="headerlink" title="2.3 进程管理之进程同步"></a>2.3 进程管理之进程同步</h3><p>生产者-消费者问题：有一群生产者进程在生产产品，并将这些产品提供给消费者进程进行消费，生产者进程和消费者进程可以并发执行，在两者之间设置了一个具有n个缓冲区的缓冲池，生产者进程需要将所生产的产品放到缓冲区中（+1操作），消费者进程可以从缓冲区取走产品消费（-1操作）。</p><p>image-20210826155239580</p><p>image-20210826155306444</p><p>产生问题：当两者并发执行时可能出差错，导致预期的结果与真实的结果不相符：当执行生产者+1和消费者-1操作之后，缓冲区的值从10变为了11。</p><p>哲学家进餐问题：有5个哲学家，他们的生活方式是交替的思考和进餐，哲学家们共同使用一张圆桌，分别坐在5张椅子上，圆桌上有5只碗和5只筷子。平时哲学家们只进行思考，饥饿时则试图取靠近他们的左右两只筷子，只有两只筷子都被拿到的时候才能进餐，否则等待，进餐完毕后，放下左右筷子进行思考。</p><p>这会导致以下的问题，筷子就相当于临界资源：</p><p>临界资源指的是一些虽作为共享资源却又无法同时被多个线程共同访问的共享资源。当有进程在使用临界资源时，其他进程必须依据操作系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源。</p><p>进程同步的作用：对竞争资源在多进程间进行使用次序的协调，使得并发执行的多个进程之间可以有效使用资源和相互合作。</p><p>进程间同步的四原则：</p><p>空闲让进：资源无占用，允许使用；<br>忙则等待：资源被占用，请求进程等待；<br>有限等待：保证有限等待时间能够使用资源；<br>让权等待：等待时，进程需要让出CPU。</p><h4 id="2-3-1进程同步的方法（重要）"><a href="#2-3-1进程同步的方法（重要）" class="headerlink" title="2.3.1进程同步的方法（重要）"></a>2.3.1进程同步的方法（重要）</h4><p>1.使用fork系统调用创建进程：使用fork系统调用无参数，fork会返回两次，分别返回子进程id和0，返回子进程id的是父进程，返回0的是子进程。</p><p>fork系统调用是用于创建进程的；<br>fork创建的进程初始化状态与父进程一样；<br>系统会为fork的进程分配新的资源<br>2.共享内存：在某种程度上，多进程是共同使用物理内存的，但是由于操作系统的进程管理，进程间的内存空间是独立的，因此进程默认是不能访问进程空间之外的内存空间的。</p><p>共享存储允许不相关的进程访问同一片物理内存；<br>共享内存是两个进程之间共享和传递数据最快的方式；<br>共享内存未提供同步机制，需要借助其他机制管理访问；<br>image-20210826223244411</p><p>3.Unix域套接字</p><p>域套接字是一种高级的进程间通信的方法，可以用于同一机器进程间通信。</p><p>套接字（socket）：为网络通信中使用的术语。</p><p>Unix系统提供的域套接字提供了网络套接字类似的功能，如Nfinx、uWSGI等。</p><p>服务端和客户端分别使用Unix域套接字的过程：</p><p>image-20210826223709480</p><h4 id="2-3-2-线程同步的方法（重要）"><a href="#2-3-2-线程同步的方法（重要）" class="headerlink" title="2.3.2 线程同步的方法（重要）"></a>2.3.2 线程同步的方法（重要）</h4><p>线程同步的方法：</p><p>互斥锁：互斥锁是最简单的线程同步的方法，也称为互斥量，处于两态之一的变量：解锁和加锁，两个状态可以保证资源访问的串行。 原子性：指一系列操作不可被中断的特性，要么全部执行完成，要么全部没有执行。</p><p>image-20210826220013572</p><p>自旋锁：自旋锁是一种多线程同步的变量，使用自旋锁的线程会反复检查锁变量是否可用，自旋锁不会让出CPU，是一种忙等待状态，即死循环等待锁被释放，自旋锁的效率远高于互斥锁。特点：避免了进程或者线程上下文切换的开销，但是不适合在单核CPU使用。</p><p>读写锁：是一种特殊的自旋锁，允许多个读操作同时访问资源以提高读性能，但是对写操作是互斥的，即<strong>对多读少写的操作效率提升</strong>很显著。</p><p>条件变量：是一种相对比较复杂的线程同步方法，条件变量允许线程睡眠，直到满足某种条件，当<strong>满足条件时，可以给该线程信号通知唤醒</strong>。</p><p>2.3.3 线程同步方法对比（重要）<br>image-20210826222325975</p><p>image-20210826222346498</p><p>image-20210826222400048</p><p>2.4 Linux的进程管理<br>进程的类型：</p><p>前台进程：具有终端，可以和用户交互；<br>后台进程：没有占用终端，基本不和用户交互，优先级比前台进程低（将需要执行的命令以“&amp;”符号结束）；<br>守护进程：特殊的后台进程，在系统引导时启动，一直运行直到系统关闭（进程名字以“d”结尾的一般都是守护进程），如crond、sshd、httpd、mysqld…<br>进程的标记：</p><p>进程ID：非负整数，进程的唯一标记，每个进程拥有不同的ID；<br>进程的状态标记：R表示进程处于运行状态，S表示进程处于睡眠状态…</p><p>操作Linux进程的相关命令：</p><p>ps命令：列出当前的进程，结合-aux可以打印进程的详细信息（ps -aux）；<br>top命令：查看所有进程的状态；<br>kill命令：给进程发送信号。</p><h2 id="三、作业管理"><a href="#三、作业管理" class="headerlink" title="三、作业管理"></a>三、作业管理</h2><p>3.1 作业管理之进程调度<br>定义：指计算机通过决策决定哪个就绪进程可以获得CPU使用权。</p><p>什么时候需要进程调度？</p><p>主动放弃：进程正常终止；运行过程中发生异常而终止；主动阻塞（如等待I&#x2F;O）；<br>被动放弃：分给进程的时间片用完；有更高优先级的进程进入就绪队列；有更紧急的事情需要处理（如I&#x2F;O中断）；<br>进程调度方式：</p><p>非抢占式调度：只能由当前运行的进程主动放弃CPU；</p><p>处理器一旦分配给某个进程，就让该进程一直使用下去；<br>调度程序不以任何原因抢占正在被使用的处理器；<br>调度程序不以任何原因抢占正在被使用的处理器；<br>抢占式调度：可由操作系统剥夺当前进程的CPU使用权。</p><p>允许调度程序以一定的策略暂停当前运行的进程；<br>保存好旧进程的上下文信息，分配处理器给新进程；<br>image-20210826162907842</p><p>进程调度的三大机制：</p><p>就绪队列的排队机制：为了提高进程调度的效率，将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程。</p><p>image-20210830141937877</p><p>选择运行进程的委派机制：调度程序以一定的策略，选择就绪进程，将CPU资源分配给它。</p><p>新老进程的上下文切换机制：保存当前进程的上下文信息，装入被委派执行进程的运行上下文。<br>image-20210830141949702</p><p>进程调度算法：</p><p>先来先服务算法：按照在就绪队列中的先后顺序执行。<br>短进程优先调度算法：优先选择就绪队列中估计运行时间最短的进程，不利于长作业进程的执行。<br>高优先权优先调度算法：进程附带优先权，优先选择权重高的进程，可以使得紧迫的任务优先处理。<br>时间片轮转调度算法：按照FIFO的原则排列就绪进程，每次从队列头部取出待执行进程，分配一个时间片执行，是相对公平的调度算法，但是不能保证就是响应用户。<br>3.2 作业管理之死锁<br>3.2.1 进程死锁、饥饿、死循环的区别：<br>死锁：两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。永远在互相等待的进程称为死锁进程。</p><p>饥饿：由于长期得不到资源导致进程无法推进；</p><p>死循环：代码逻辑BUG。</p><p>死锁的产生：竞争资源（共享资源数量不满足各进程需求）、进程调度顺序不当，当调度顺序为A-&gt;B-&gt;C-&gt;D时会产生死锁，但改为A-&gt;D-&gt;B-&gt;C则不会产生。</p><p>image-20210826163418015</p><p>死锁的四个必要条件：</p><p>互斥条件：必须互斥使用资源才会产生死锁；<br>请求保持条件：进程至少保持一个资源，又提出新的资源请求，新资源被占用，请求被阻塞，被阻塞的进程不释放自己保持的资源；<br>不可剥夺条件：进程获得的资源在未完成使用前不能被剥夺（包括OS），只能由进程自身释放；<br>环路等待条件：发生死锁时，必然存在进程-资源环形链,环路等待不一定造成死锁，但是死锁一定有循环等待。<br>死锁的处理策略：</p><p>一.预防死锁的方法：破坏四个必要条件的中一个或多个。</p><p>破坏互斥条件：将临界资源改造成共享资源（Spooling池化技术）；（可行性不高，很多时候无法破坏互斥条件）<br>破坏请求保持条件：系统规定进程运行之前，一次性申请所有需要的资源；（资源利用率低，可能导致别的线程饥饿）<br>破坏不可剥夺条件：当一个进程请求新的资源得不到满足时，必须释放占有的资源；（实现复杂，剥夺资源可能导致部分工作失效，反复申请和释放造成额外的系统开销）<br>破坏环路等待条件：可用资源线性排序，申请必须按照需要递增申请；（进程实际使用资源顺序和编号顺序不同，会导致资源浪费）<br>二.银行家算法：检查当前资源剩余是否可以满足某个进程的最大需求；如果可以，就把该进程加入安全序列，等待进程允许完成，回收所有资源；重复1，2，直到当前没有线程等待资源；</p><p>三.死锁的检测和解除：死锁检测算法，资源剥夺法，撤销进程法（终止进程法），进程回退法；</p><h2 id="四、存储管理"><a href="#四、存储管理" class="headerlink" title="四、存储管理"></a>四、存储管理</h2><p>存储管理为了确保计算机有足够的内存处理数据；确保程序可以从可用内存中获取一部分内存使用；确保程序可以归还使用后的内存以供其他程序使用。</p><p>4.1 存储管理之内存分配与回收<br>内存分配的过程：单一连续分配（已经过时）、固定分区分配、动态分区分配（根据实际需要，动态的分配内存）。<br>  动态分区分配算法：</p><p>首次适应算法：分配内存时，从开始顺序查找适合内存区，若无合适内存区，则分配失败，每次从头部开始，使得头部地址空间不断被划分；<br>最佳适应算法：要求空闲区链表按照容量大小排序，遍历以找到最佳适合的空闲区（会留下越来越多的内部碎片）。<br>快速适应算法：要求有多个空闲区链表，每个空闲区链表存储一种容量的空闲区。<br>内存回收的过程：</p><p>回收区在空闲区下方：不需要新建空闲链表节点；只需要把空闲区1的容量增大即可；<br>回收区在空闲区上方：将回收区与空闲区合并；新的空闲区使用回收区的地址；<br>回收区在空闲区中间方：将空闲区1、空闲区2和回收区合并；新的空闲区使用空闲区1的地址；<br>仅仅剩余回收区：为回收区创建新的空闲节点；插入到相应的空闲区链表中去；<br>4.2 存储管理之段页式存储管理<br>页式存储管理：将进程逻辑空间等分成若干大小的页面，相应的把物理内存空间分成与页面大小的物理块，以页面为单位把进程空间装进物理内存中分散的物理块。</p><p>页面大小应该适中，过大难以分配，过小内存碎片过多；页面大小通常是512B~8K；</p><p>现代计算机系统中，可以支持非常大的逻辑地址空间(232~264)，具有32位逻辑地址空间的分页系统，规定页面大小为4KB，则在每个进程页表中的页表项可达1M(2个20)个，如果每个页表项占用1Byte，故每个进程仅仅页表就要占用1MB的内存空间。</p><p>image-20210830150815294</p><p>段式存储管理：将进程逻辑空间分成若干段（不等分），段的长度由连续逻辑的长度决定。</p><p>页式和者段式存储管理相比：</p><p>段式存储和页式存储都离散地管理了进程的逻辑空间；<br>页是物理单位，段是逻辑单位；<br>分页是为了合理利用空间，分段是满足用户要求页大小由硬件固定，段长度可动态变化；<br>页表信息是一维的，段表信息是二维的；<br>段页式存储管理：现将逻辑空间按照段式管理分成若干段，再将内存空间按照页式管理分成若干页，分页可以有效提高内存利用率，分段可以更好的满足用户需求。</p><p>image-20210826165620416</p><p>4.3 存储管理之虚拟内存<br>虚拟内存概述：是操作系统内存管理的关键技术，使得多道程序运行和大程序运行成为现实，把程序使用内存划分，将部分暂时不使用的内存放置在辅存，实际是对物理内存的扩充。<br>  局部性原理：指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。<br>  虚拟内存的置换算法：先进先出（FIFO）、最不经常使用（LFU）、最近最少使用（LRU）</p><p>虚拟内存的特征：</p><p>多次性：无需再作业运行时一次性全部装入内存，而是允许被分成多次调入内存；<br>对换性：无需在作业运行时一直常驻内存，而是允许在作业运行过程中，将作业换入、换出；<br>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存用来，远大于实际的容量；<br>4.4 Linux的存储管理<br>Buddy内存管理算法：经典的内存管理算法，为解决内存外碎片的问题，算法基于计算机处理二进制的优势具有极高的效率。<br>  Linux交换空间：交换空间（Swap）是磁盘的一个分区，Linux内存满时，会把一些内存交换至Swap空间，Swap空间是初始化系统时配置的。<br>  Swap空间与虚拟内存的对比：</p><p>image-20210830151958862</p><p>五、文件管理<br>5.1 操作系统的文件管理<br>文件的逻辑结构：</p><p>逻辑结构的文件类型：有结构文件（文本文件，文档，媒体文件）、无结构文件（二进制文件、链接库）。<br>顺序文件：按顺序放在存储介质中的文件，在逻辑文件当中存储效率最高，但不适合存储可变长文件。<br>索引文件：为解决可变长文件存储而发明，需要配合索引表存储。<br>辅存的存储空间分配：</p><p>辅存的分配方式：连续分配（读取文件容易，速度快）、链接分配（隐式链接和显式链接）、索引分配<br>辅存的存储空间管理：空闲表、空闲链表、位示图。<br>目录树：使得任何文件或目录都有唯一的路径。</p><p>image-20210830152736217</p><p>Linux文件的基本操作：参考链接</p><p>image-20210826213430203</p><p>img</p><p>image-20210826214028660</p><p>Linux的文件系统：FAT、NTFS（对FAT进行改进）、EXT2&#x2F;3&#x2F;4（扩展文件系统，Linux的文件系统）</p><p>六、设备管理<br>I&#x2F;O设备的基本概念：将数据输入输出计算机的外部设备；</p><p>广义的IO设备：</p><p>按照使用特性分类：存储设备（内存、磁盘、U盘）和交互IO设备（键盘、显示器、鼠标）；<br>按照信息交换分类：块设备（磁盘、SD卡）和字符设备（打印机、shell终端）；<br>按照设备共享属性分类：独占设备，共享设备，虚拟设备；<br>按照传输速率分类：低速设备，高速设备；<br>IO设备的缓冲区：减少CPU处理IO请求的频率，提高CPU与IO设备之间的并行性。</p><p>SPOOLing技术：虚拟设备技术，把同步调用低速设备改为异步调用，在输入、输出之间增加了排队转储环节(输入井、输出井)，SPoOLing负责输入（出）井与低速设备之间的调度，逻辑上，进程直接与高速设备交互，减少了进程的等待时间。</p><p>七、实现支持异步任务的线程池<br>线程池：线程池是存放多个线程的容器，CPU调度线程执行后不会销毁线程，将线程放回线程池重新利用。</p><p>使用线程池的原因：</p><p>线程是稀缺资源 ，不应该频繁创建和销毁；<br>架构解耦，业务创建和业务处理解耦，更加优雅；<br>线程池是使用线程的最佳实践。<br>实现线程安全的队列Queue</p><p>队列：用于存放多个元素，是存放各种元素的“池”。<br>实现的基本功能：获取当前队列元素数量，往队列放入元素，往队列取出元素。<br>注意：队列可能有多个线程同时操作，因此需要保证线程安全，如下两种情况：<br>image-20210830160845040</p><p>实现基本任务对象Task<br>实现的基本功能：任务参数，任务唯一标记（UUID），任务具体的执行逻辑</p><p>实现任务处理线程ProcessThread：任务处理线程需要不断地从任务队列里取任务执行，任务处理线程需要有一个标记，标记线程什么时候应该停止。<br>实现的基本功能：基本属性（任务队列、标记），线程执行的逻辑（run），线程停止（stop）。</p><p>实现任务处理线程池Pool：存放多个任务处理线程，负责多个线程的启停，管理向线程池的提交任务，下发给线程去执行。<br>实现的基本过程：基本属性，提交任务（put，batch_put），线程启停（start，join），线程池大小（size）。</p><p>实现异步任务处理AsyncTask：给任务添加一个标记，任务完成后，则标记为完成；任务完成时可直接获取任务运行结果；任务未完成时，获取任务结果，会阻塞获取线程。<br>主要实现的两个函数：设置运行结果（set_result），获取运行结果（get_result)</p><p>文章知识点与官方知识档案匹配，可进一步学习相关知识<br>CS入门技能树Linux入门初识Linux17162 人正在系统学习中</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript数组常用方法总结</title>
    <link href="/2023/01/27/JavaScript%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2023/01/27/JavaScript%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript常用的数组方法的总结"><a href="#JavaScript常用的数组方法的总结" class="headerlink" title="JavaScript常用的数组方法的总结"></a>JavaScript常用的数组方法的总结</h1><p>此篇属于前端算法入门系列的第一篇，主要介绍常用的<code>数组方法</code>、<code>字符串方法</code>、<code>遍历方法</code>、<code>高阶函数</code>、<code>正则表达式</code>以及相关<code>数学知识</code>。</p><blockquote><p><strong>文章主要包含以下内容：</strong></p><ul><li>数组常用方法</li><li>字符串常用方法</li><li>常用遍历方法&amp;高阶函数</li><li>常用正则表达式</li><li>数学知识</li></ul></blockquote><h2 id="一、数组常用方法"><a href="#一、数组常用方法" class="headerlink" title="一、数组常用方法"></a>一、数组常用方法</h2><h3 id="1-push"><a href="#1-push" class="headerlink" title="1.push()"></a>1.push()</h3><p>在尾部追加，类似于压栈，原数组会改变。</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">8</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3, 8]</span></code></pre></div><h3 id="2-pop"><a href="#2-pop" class="headerlink" title="2.pop()"></a>2.pop()</h3><p>在尾部弹出，类似于出栈，原数组会变。数组的 <code>push</code> &amp; <code>pop</code> 可以模拟常见数据结构之一：栈。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-keyword">const</span> popVal = arr.<span class="hljs-title function_">pop</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(popVal) <span class="hljs-comment">// 3</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2]</span><span class="hljs-comment">// 数组模拟常见数据结构之一：栈</span><span class="hljs-keyword">const</span> stack = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 压栈</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack) <span class="hljs-comment">// [0, 1, 2]</span><span class="hljs-keyword">const</span> popValue = stack.<span class="hljs-title function_">pop</span>() <span class="hljs-comment">// 出栈</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(popValue) <span class="hljs-comment">// 2</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack) <span class="hljs-comment">// [0, 1]</span></code></pre></div><h3 id="3-unshift"><a href="#3-unshift" class="headerlink" title="3.unshift()"></a>3.unshift()</h3><p>在头部压入数据，类似于入队，原数组会变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">0</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [0, 1, 2, 3]</span></code></pre></div><h3 id="4-shift"><a href="#4-shift" class="headerlink" title="4.shift()"></a>4.shift()</h3><p>在头部弹出数据，原数组会变。数组的 <code>push</code>（入队） &amp; <code>shift</code>（出队） 可以模拟常见数据结构之一：队列。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-keyword">const</span> shiftVal = arr.<span class="hljs-title function_">shift</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(shiftVal) <span class="hljs-comment">// 1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [2, 3]</span><span class="hljs-comment">// 数组模拟常见数据结构之一：队列</span><span class="hljs-keyword">const</span> queue = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]queue.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 入队</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue) <span class="hljs-comment">// [0, 1, 2]</span><span class="hljs-keyword">const</span> shiftValue = queue.<span class="hljs-title function_">shift</span>() <span class="hljs-comment">// 出队</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(shiftValue) <span class="hljs-comment">// 0</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue) <span class="hljs-comment">// [1, 2]</span></code></pre></div><h3 id="5-concat"><a href="#5-concat" class="headerlink" title="5.concat()"></a>5.concat()</h3><p><code>concat</code>会在当前数组尾部拼接传入的数组，然后返回一个新数组，原数组不变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-keyword">const</span> arr2 = arr.<span class="hljs-title function_">concat</span>([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2) <span class="hljs-comment">// [1, 2, 3, 7, 8, 9]</span></code></pre></div><h3 id="6-indexOf"><a href="#6-indexOf" class="headerlink" title="6.indexOf()"></a>6.indexOf()</h3><p>在数组中寻找该值，找到则返回其下标，找不到则返回<code>-1</code>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">0</span>)) <span class="hljs-comment">// -1</span></code></pre></div><h3 id="7-includes"><a href="#7-includes" class="headerlink" title="7.includes()"></a>7.includes()</h3><p>在数组中寻找该值，找到则返回<code>true</code>，找不到则返回<code>false</code>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">2</span>)) <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">4</span>)) <span class="hljs-comment">// false</span></code></pre></div><h3 id="8-join"><a href="#8-join" class="headerlink" title="8.join()"></a>8.join()</h3><p>将数组转化成字符串，并返回该字符串，不传值则默认逗号隔开，原数组不变。</p><div class="code-wrapper"><pre><code class="hljs arcade">const arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.join()) <span class="hljs-comment">// ‘1, 2, 3’</span><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr) <span class="hljs-comment">// [1, 2, 3]</span></code></pre></div><h3 id="9-reverse"><a href="#9-reverse" class="headerlink" title="9.reverse()"></a>9.reverse()</h3><p>翻转原数组，并返回已完成翻转的数组，原数组改变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">reverse</span>()) <span class="hljs-comment">// [3, 2, 1]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [3, 2, 1]</span></code></pre></div><h3 id="10-slice-start，end"><a href="#10-slice-start，end" class="headerlink" title="10.slice(start，end)"></a>10.slice(start，end)</h3><p>从<code>start</code> 开始截取到<code>end</code>，但是不包括<code>end</code></p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)) <span class="hljs-comment">// [2, 3, 4]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3, 4, 5]</span></code></pre></div><h3 id="11-splice-start-deleteCount-item1-item2……"><a href="#11-splice-start-deleteCount-item1-item2……" class="headerlink" title="11.splice(start, deleteCount, item1, item2……)"></a>11.splice(start, deleteCount, item1, item2……)</h3><ul><li><code>start</code>参数 开始的位置</li><li><code>deleteCount</code>要截取的个数</li><li>后面的<code>items</code>为要添加的元素</li><li>如果<code>deleteCount</code>为<code>0</code>，则表示不删除元素，从<code>start</code>位置开始添加后面的几个元素到原始的数组里面。</li><li>返回值为由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</li><li>这个方法会改变原始数组，数组的长度会发生变化</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr3 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-string">&quot;f1&quot;</span>, <span class="hljs-string">&quot;f2&quot;</span>];<span class="hljs-keyword">const</span> arr4 = arr3.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 删除第三个元素以后的三个数组元素(包含第三个元素)</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr4); <span class="hljs-comment">// [3, 4, 5];</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr3); <span class="hljs-comment">// [1, 2, 6, 7, &quot;f1&quot;, &quot;f2&quot;]; 原始数组被改变</span><span class="hljs-keyword">const</span> arr5 = arr3.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;wu&quot;</span>, <span class="hljs-string">&quot;leon&quot;</span>); <span class="hljs-comment">// 从第2位开始删除0个元素，插入&quot;wu&quot;,&quot;leon&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr5); <span class="hljs-comment">// [] 返回空数组</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr3); <span class="hljs-comment">// [1, 2, &quot;wu&quot;, &quot;leon&quot;, 6, 7, &quot;f1&quot;, &quot;f2&quot;]; 原始数组被改变</span><span class="hljs-keyword">const</span> arr6 = arr3.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;xiao&quot;</span>, <span class="hljs-string">&quot;long&quot;</span>);<span class="hljs-comment">// 从第 2 位开始删除 3 个元素，插入&quot;xiao&quot;, &quot;long&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr6); <span class="hljs-comment">// [&quot;wu&quot;, &quot;leon&quot;, 6]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr3); <span class="hljs-comment">//[ 1, 2, &quot;xiao&quot;, &quot;long&quot;, 7, &quot;f1&quot;, &quot;f2&quot;]</span><span class="hljs-keyword">const</span> arr7 = arr3.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 从第三个元素开始删除所有的元素</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr7);<span class="hljs-comment">// [&quot;xiao&quot;, &quot;long&quot;, 7, &quot;f1&quot;, &quot;f2&quot;]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr3); <span class="hljs-comment">// [1, 2]</span></code></pre></div><h3 id="12-sort"><a href="#12-sort" class="headerlink" title="12.sort()"></a>12.sort()</h3><ul><li>对数组的元素进行排序，并返回数组。</li><li>默认排序顺序是在将元素转换为字符串，然后比较它们的<code>UTF-16</code>代码单元值序列时构建的。</li><li>由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。</li></ul><p>可参考 <strong>MDN：Sort</strong>[5]</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [3, 2, 1]</span></code></pre></div><h3 id="13-toString"><a href="#13-toString" class="headerlink" title="13.toString()"></a>13.toString()</h3><p>将数组转化成字符串，并返回该字符串，逗号隔开，原数组不变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">// ‘1, 2, 3, 4, 5’</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// [1, 2, 3, 4, 5]</span></code></pre></div><h2 id="二、字符串常用方法"><a href="#二、字符串常用方法" class="headerlink" title="二、字符串常用方法"></a>二、字符串常用方法</h2><h3 id="1-charAt"><a href="#1-charAt" class="headerlink" title="1.charAt()"></a>1.charAt()</h3><p>返回指定索引位置处的字符。类似于数组用中括号获取相应下标位置的数据。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abcdefg&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 输出 &#x27;c&#x27; </span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str[<span class="hljs-number">2</span>]) <span class="hljs-comment">// 输出 &#x27;c&#x27;</span></code></pre></div><h3 id="2-concat"><a href="#2-concat" class="headerlink" title="2.concat()"></a>2.concat()</h3><p>类似数组的concat()，用来返回一个合并拼接两个或两个以上字符串。原字符串不变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str1 = <span class="hljs-string">&#x27;abcdefg&#x27;</span><span class="hljs-keyword">const</span> str2 = <span class="hljs-string">&#x27;1234567&#x27;</span><span class="hljs-keyword">const</span> str3 = str1.<span class="hljs-title function_">concat</span>(str2)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str3) <span class="hljs-comment">// 输出 &#x27;abcdefg1234567&#x27;</span></code></pre></div><h3 id="3-indexOf-、lastIndexOf"><a href="#3-indexOf-、lastIndexOf" class="headerlink" title="3.indexOf()、lastIndexOf()"></a>3.indexOf()、lastIndexOf()</h3><p><code>indexOf</code>,返回一个字符在字符串中首次出现的位置,<code>lastIndexOf</code>返回一个字符在字符串中最后一次出现的位置。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdcefcg&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;c&#x27;</span>)) <span class="hljs-comment">// 输出 &#x27;2&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&#x27;c&#x27;</span>)) <span class="hljs-comment">// 输出 &#x27;7&#x27;</span></code></pre></div><h3 id="4-slice"><a href="#4-slice" class="headerlink" title="4.slice()"></a>4.slice()</h3><p>提取字符串的片断，并把提取的字符串作为新的字符串返回出来。原字符串不变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abcdefg&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">slice</span>()) <span class="hljs-comment">// 输出 &#x27;abcdefg&#x27;, 不传递参数默认复制整个字符串</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 输出 &#x27;bcdefg&#x27;,传递一个，则为提取的起点，然后到字符串结尾</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>, str.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>)) <span class="hljs-comment">// 输出&#x27;cdef&#x27;,传递两个，为提取的起始点和结束点</span></code></pre></div><h3 id="5-split"><a href="#5-split" class="headerlink" title="5.split()"></a>5.split()</h3><p>使用指定的分隔符将一个字符串拆分为多个子字符串数组并返回，原字符串不变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;A*B*C*D*E*F*G&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;*&#x27;</span>)) <span class="hljs-comment">// 输出 [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;]</span></code></pre></div><h3 id="6-substr-substring"><a href="#6-substr-substring" class="headerlink" title="6.substr(), substring()"></a>6.substr(), substring()</h3><ul><li>这两个方法的功能都是截取一个字符串的片段，并返回截取的字符串。</li><li><code>substr</code>和<code>substring</code>这两个方法不同的地方就在于参数二，<code>substr</code>的参数二是截取返回出来的这个字符串指定的长度，<code>substring</code>的参数二是截取返回这个字符串的结束点，并且不包含这个结束点。而它们的参数一，都是一样的功能，截取的起始位置。</li><li><strong>注意事项</strong>：<code>substr</code>的参数二如果为<code>0</code>或者负数，则返回一个空字符串，如果未填入，则会截取到字符串的结尾去。<code>substring</code>的参数一和参数二为<code>NAN</code>或者负数，那么它将被替换为<code>0</code>。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;ABCDEFGHIJKLMN&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>))  <span class="hljs-comment">// 输出 &#x27;CDEFGHIJKLMN&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 输出 &#x27;CDEFGHIJKLMN&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>))  <span class="hljs-comment">// 输出 &#x27;CDEFGHIJK&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>))  <span class="hljs-comment">// 输出 &#x27;CDEFGHI&#x27;</span></code></pre></div><h3 id="7-match"><a href="#7-match" class="headerlink" title="7.match()"></a>7.match()</h3><p><code>match()</code>方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配，并返回一个包含该搜索结果的数组。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;2018年结束了，2019年开始了，2020年就也不远了&#x27;</span><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\d+/g</span>  <span class="hljs-comment">// 这里是定义匹配规则，匹配字符串里的1到多个数字</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg))  <span class="hljs-comment">// 输出符合匹配规则的内容，以数组形式返回 [&#x27;2018&#x27;, &#x27;2019&#x27;, &#x27;2020&#x27;]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(<span class="hljs-string">&#x27;20&#x27;</span>))  <span class="hljs-comment">// 不使用正则 [&quot;20&quot;, index: 0, input: &quot;2018年结束了，2019年开始了&quot;]</span></code></pre></div><p><strong>注意事项</strong>:如果<code>match</code>方法没有找到匹配，将返回<code>null</code>。如果找到匹配，则 <code>match</code>方法会把匹配到以数组形式返回，如果正则规则未设置全局修饰符<code>g</code>，则 <code>match</code>方法返回的数组有两个特性：<code>input</code>和<code>index</code>。<code>input</code>属性包含整个被搜索的字符串。<code>index</code>属性包含了在整个被搜索字符串中匹配的子字符串的位置。</p><h3 id="8-replace"><a href="#8-replace" class="headerlink" title="8.replace()"></a>8.replace()</h3><p><code>replace</code>接收两个参数，参数一是需要替换掉的字符或者一个正则的匹配规则，参数二，需要替换进去的字符，仔实际的原理当中，参数二，你可以换成一个回调函数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;2018年结束了，2019年开始了，2020年就也不远了&#x27;</span><span class="hljs-keyword">const</span> rex = <span class="hljs-regexp">/\d+/g</span>  <span class="hljs-comment">// 这里是定义匹配规则，匹配字符串里的1到多个数字</span><span class="hljs-keyword">const</span> str1 = str.<span class="hljs-title function_">replace</span>(rex, <span class="hljs-string">&#x27;****&#x27;</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str1) <span class="hljs-comment">// 输出：&quot;****年结束了，****年开始了,****年也不远了&quot;</span><span class="hljs-keyword">const</span> str2 = str.<span class="hljs-title function_">replace</span>(rex, <span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)  <span class="hljs-comment">// 看下面的图片</span>    <span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;零&#x27;</span>, <span class="hljs-string">&#x27;壹&#x27;</span>, <span class="hljs-string">&#x27;贰&#x27;</span>, <span class="hljs-string">&#x27;叁&#x27;</span>, <span class="hljs-string">&#x27;肆&#x27;</span>, <span class="hljs-string">&#x27;伍&#x27;</span>, <span class="hljs-string">&#x27;陆&#x27;</span>, <span class="hljs-string">&#x27;柒&#x27;</span>, <span class="hljs-string">&#x27;捌&#x27;</span>, <span class="hljs-string">&#x27;玖&#x27;</span>]    <span class="hljs-keyword">let</span> newStr = <span class="hljs-string">&#x27;&#x27;</span>    item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)&#123;            newStr += arr[i]    &#125;)         <span class="hljs-keyword">return</span> newStr       &#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2) <span class="hljs-comment">// 输出：贰零壹捌年结束了，贰零壹玖年开始了,贰零贰零年也不远了</span></code></pre></div><h3 id="9-search"><a href="#9-search" class="headerlink" title="9.search()"></a>9.search()</h3><p>在目标字符串中搜索与正则规则相匹配的字符，搜索到，则返回第一个匹配项在目标字符串当中的位置，没有搜索到则返回一个<code>-1</code>。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;2018年结束了，2019年开始了，2020年就也不远了&#x27;</span><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\d+/i</span>  <span class="hljs-comment">// 这里是定义匹配规则,匹配字符串里的1到多个数字</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">search</span>(reg)) <span class="hljs-comment">// 输出 0  这里搜索到的第一项是从位置0开始的</span></code></pre></div><h3 id="10-toLowerCase-toUpperCase"><a href="#10-toLowerCase-toUpperCase" class="headerlink" title="10.toLowerCase(),toUpperCase()"></a>10.toLowerCase(),toUpperCase()</h3><p><code>toLowerCase</code>把字母转换成小写，<code>toUpperCase()</code>则是把字母转换成大写。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str1 = <span class="hljs-string">&#x27;abcdefg&#x27;</span><span class="hljs-keyword">const</span> str2 = <span class="hljs-string">&#x27;ABCDEFG&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2.<span class="hljs-title function_">toLowerCase</span>())  <span class="hljs-comment">// 输出：&#x27;abcdefg&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str1.<span class="hljs-title function_">toUpperCase</span>())  <span class="hljs-comment">// 输出：&#x27;ABCDEFG&#x27;</span></code></pre></div><h3 id="11-includes-startsWith-endsWith"><a href="#11-includes-startsWith-endsWith" class="headerlink" title="11.includes(), startsWith(), endsWith()"></a>11.includes(), startsWith(), endsWith()</h3><p><code>includes</code>、<code>startsWith</code>、<code>endsWith</code>，<code>es6</code>的新增方法，<code>includes</code> 用来检测目标字符串对象是否包含某个字符，返回一个布尔值，<code>startsWith</code>用来检测当前字符是否是目标字符串的起始部分，相对的<code>endwith</code>是用来检测是否是目标字符串的结尾部分。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;Excuse me, how do I get to park road?&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;how&#x27;</span>)) <span class="hljs-comment">// 输出：true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;Excuse&#x27;</span>)) <span class="hljs-comment">// 输出： true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;?&#x27;</span>)) <span class="hljs-comment">// 输出： true</span></code></pre></div><h3 id="12-repeat"><a href="#12-repeat" class="headerlink" title="12.repeat()"></a>12.repeat()</h3><p>返回一个新的字符串对象，新字符串等于重复了指定次数的原始字符串。接收一个参数，就是指定重复的次数。原字符串不变。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;http&#x27;</span><span class="hljs-keyword">const</span> str2 = str.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str) <span class="hljs-comment">// 输出：&#x27;http&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2) <span class="hljs-comment">// 输出：&#x27;httphttphttp&#x27;</span></code></pre></div><h2 id="三、常用遍历方法-amp-高阶函数"><a href="#三、常用遍历方法-amp-高阶函数" class="headerlink" title="三、常用遍历方法&amp;高阶函数"></a>三、常用遍历方法&amp;高阶函数</h2><h3 id="1-for"><a href="#1-for" class="headerlink" title="1.for()"></a>1.for()</h3><p>最常用的<code>for</code>循环，经常用的数组遍历，也可以遍历字符串。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc&#x27;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i])    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str[i])&#125;</code></pre></div><h3 id="2-while-x2F-do-while"><a href="#2-while-x2F-do-while" class="headerlink" title="2.while() &#x2F; do while()"></a>2.while() &#x2F; do while()</h3><p><code>while</code>、<code>do while</code>主要的功能是，当满足<code>while</code>后边所跟的条件时，来执行相关业务。这两个的区别是，<code>while</code>会先判断是否满足条件，然后再去执行花括号里面的任务，而<code>do while</code>则是先执行一次花括号中的任务，再去执行<code>while</code>条件，判断下次还是否再去执行<code>do</code>里面的操作。也就是说 <strong><code>do while</code>至少会执行一次操作</strong>.</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span>(条件)&#123;     执行...&#125;------------<span class="hljs-keyword">do</span>&#123;    执行...&#125;<span class="hljs-keyword">while</span>(条件)</code></pre></div><h3 id="3-forEach"><a href="#3-forEach" class="headerlink" title="3.forEach()"></a>3.forEach()</h3><p>拷贝一份遍历原数组。</p><ul><li><code>return</code>无法终止循环。不过可以起到<code>continue</code>效果。</li><li>本身是不支持的<code>continue</code>与<code>break</code>语句的我们可以通过<code>some</code>和 <code>every</code>来实现。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>]arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (item &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`索引：<span class="hljs-subst">$&#123;index&#125;</span>，数值：<span class="hljs-subst">$&#123;item&#125;</span>`</span>)    arr[<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<span class="hljs-comment">// 打印结果：</span><span class="hljs-comment">// 索引：0，数值：5</span><span class="hljs-comment">// 索引：2，数值：3</span><span class="hljs-comment">// 索引：3，数值：7</span><span class="hljs-comment">// 索引：4，数值：4</span><span class="hljs-comment">// [5, 1, 3, 7, 4, 0]</span></code></pre></div><h3 id="4-for…in"><a href="#4-for…in" class="headerlink" title="4.for…in"></a>4.for…in</h3><ul><li><code>for...in</code> 是 ES5 标准， 此方法遍历数组效率低，主要是用来循环遍历对象的属性。</li><li>遍历数组的缺点：数组的下标<code>index</code>值是数字，<code>for-in</code>遍历的<code>index</code>值<code>&quot;0&quot;,&quot;1&quot;,&quot;2&quot;</code>等是字符串。</li><li><code>Object.defineProperty</code>，建立的属性，默认不可枚举。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,    <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(foo, <span class="hljs-string">&quot;age&quot;</span>, &#123; value : <span class="hljs-number">18</span> &#125;)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> foo)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`可枚举属性：<span class="hljs-subst">$&#123;key&#125;</span>`</span>)&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`age属性：<span class="hljs-subst">$&#123;foo.age&#125;</span>`</span>)<span class="hljs-comment">// 打印结果：</span><span class="hljs-comment">// 可枚举属性：name</span><span class="hljs-comment">// 可枚举属性：sex</span><span class="hljs-comment">// age属性：18</span></code></pre></div><h3 id="5-for…of"><a href="#5-for…of" class="headerlink" title="5.for…of"></a>5.for…of</h3><p><code>for…of</code>是<code>ES6</code>新增的方法，但是<code>for…of</code>不能去遍历普通的对象，**<code>for…of</code>的好处是可以使用<code>break</code>跳出循环。**</p><ul><li><code>for-of</code>这个方法避开了<code>for-in</code>循环的所有缺陷</li><li>与<code>forEach()</code>不同的是，它可以正确响应<code>break</code>、<code>continue</code>和<code>return</code>语句</li><li><code>for-of</code>循环不仅支持数组，还支持大多数类数组对象，例如<code>DOM</code> <strong>NodeList对象</strong>[6]。</li><li><code>for-of</code>循环也支持字符串遍历</li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// for of 循环直接得到的就是值</span><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> arr) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)&#125;</code></pre></div><p><strong>面试官：说一下 <code>for...in</code> 和 <code>for...of</code> 区别？</strong></p><div class="code-wrapper"><pre><code class="hljs javascript">（<span class="hljs-number">1</span>）<span class="hljs-keyword">for</span>…<span class="hljs-keyword">in</span> 用于可枚举数据，如对象、数组、字符串（<span class="hljs-number">2</span>）<span class="hljs-keyword">for</span>…<span class="hljs-keyword">of</span> 用于可迭代数据，如数组、字符串、<span class="hljs-title class_">Map</span>、<span class="hljs-title class_">Set</span></code></pre></div><h3 id="6-every-x2F-some"><a href="#6-every-x2F-some" class="headerlink" title="6.every &#x2F; some"></a>6.every &#x2F; some</h3><p><strong>返回一个布尔值</strong>。当我们需要判定数组中的元素是否满足某些条件时，可以使用<code>every</code> &#x2F; <code>some</code>。这两个的区别是，<code>every</code>会去判断判断数组中的每一项，而 <code>some</code>则是当某一项满足条件时返回。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// every</span><span class="hljs-keyword">const</span> foo = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>].<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`索引：<span class="hljs-subst">$&#123;index&#125;</span>，数值：<span class="hljs-subst">$&#123;item&#125;</span>`</span>)    <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">2</span>&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<span class="hljs-comment">// every 打印：</span><span class="hljs-comment">// 索引：0，数值：5</span><span class="hljs-comment">// 索引：1，数值：1</span><span class="hljs-comment">// false</span><span class="hljs-comment">// some</span><span class="hljs-keyword">const</span> foo = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>].<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`索引：<span class="hljs-subst">$&#123;index&#125;</span>，数值：<span class="hljs-subst">$&#123;item&#125;</span>`</span>)    <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">2</span>&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<span class="hljs-comment">// some 打印：</span><span class="hljs-comment">// 索引：0，数值：5</span><span class="hljs-comment">// true</span></code></pre></div><h3 id="7-filter"><a href="#7-filter" class="headerlink" title="7.filter()"></a>7.filter()</h3><ul><li><code>filter</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</li><li>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为<code>true</code>的成员组成一个新数组返回。</li><li>该方法不会改变原数组。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript">javascriptjavascriptconst foo = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>].<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item,index</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`索引：<span class="hljs-subst">$&#123;index&#125;</span>，数值：<span class="hljs-subst">$&#123;item&#125;</span>`</span>)    <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">2</span>&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<span class="hljs-comment">// 打印结果：</span><span class="hljs-comment">// 索引：0，数值：5</span><span class="hljs-comment">// 索引：1，数值：1</span><span class="hljs-comment">// 索引：2，数值：3</span><span class="hljs-comment">// 索引：3，数值：7</span><span class="hljs-comment">// 索引：4，数值：4</span><span class="hljs-comment">// [5, 3, 7, 4]</span></code></pre></div><h3 id="8-map"><a href="#8-map" class="headerlink" title="8.map()"></a>8.map()</h3><ul><li><code>map</code>即是 “映射”的意思 ，原数组被“映射”成对应新数组。</li><li><code>map：</code>支持<code>return</code>，相当与原数组克隆了一份，把克隆的每项改变了，也不影响原数组。</li></ul><div class="code-wrapper"><pre><code class="hljs javascript">javascriptjavascriptjavascriptconst foo = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item,index</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`索引：<span class="hljs-subst">$&#123;index&#125;</span>，数值：<span class="hljs-subst">$&#123;item&#125;</span>`</span>)    <span class="hljs-keyword">return</span> item + <span class="hljs-number">2</span>&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<span class="hljs-comment">// 打印结果：</span><span class="hljs-comment">// 索引：0，数值：5</span><span class="hljs-comment">// 索引：1，数值：1</span><span class="hljs-comment">// 索引：2，数值：3</span><span class="hljs-comment">// 索引：3，数值：7</span><span class="hljs-comment">// 索引：4，数值：4</span><span class="hljs-comment">// [7, 3, 5, 9, 6]</span></code></pre></div><h3 id="9-reduce-x2F-reduceRight"><a href="#9-reduce-x2F-reduceRight" class="headerlink" title="9. reduce() &#x2F; reduceRight()"></a>9. reduce() &#x2F; reduceRight()</h3><p><code>reduce</code> 从左到右将数组元素做“叠加”处理，返回一个值。<code>reduceRight</code> 从右到左。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, cur</span>) =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`叠加：<span class="hljs-subst">$&#123;total&#125;</span>，当前：<span class="hljs-subst">$&#123;cur&#125;</span>`</span>)    <span class="hljs-keyword">return</span> total + cur&#125;)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)<span class="hljs-comment">// 打印结果：</span><span class="hljs-comment">// 叠加：5，当前：1</span><span class="hljs-comment">// 叠加：6，当前：3</span><span class="hljs-comment">// 叠加：9，当前：7</span><span class="hljs-comment">// 叠加：16，当前：4</span><span class="hljs-comment">// 20</span></code></pre></div><h3 id="10-Object-keys遍历对象的属性"><a href="#10-Object-keys遍历对象的属性" class="headerlink" title="10.Object,keys遍历对象的属性"></a>10.Object,keys遍历对象的属性</h3><p><code>Object.keys</code>方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名，且只返回可枚举的属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">p1</span>: <span class="hljs-number">123</span>,  <span class="hljs-attr">p2</span>: <span class="hljs-number">456</span>&#125;;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj) <span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;]</span></code></pre></div><h3 id="11-Object-getOwnPropertyNames-遍历对象的属性"><a href="#11-Object-getOwnPropertyNames-遍历对象的属性" class="headerlink" title="11.Object.getOwnPropertyNames() 遍历对象的属性"></a>11.Object.getOwnPropertyNames() 遍历对象的属性</h3><p><code>Object.getOwnPropertyNames</code>方法与<code>Object.keys</code>类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。但它能返回不可枚举的属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;World&#x27;</span>];<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(arr) <span class="hljs-comment">// [&quot;0&quot;, &quot;1&quot;]</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(arr) <span class="hljs-comment">// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span></code></pre></div><h3 id="以上遍历方法的区别："><a href="#以上遍历方法的区别：" class="headerlink" title="以上遍历方法的区别："></a>以上遍历方法的区别：</h3><div class="code-wrapper"><pre><code class="hljs javascript">一：<span class="hljs-title function_">map</span>()，<span class="hljs-title function_">forEach</span>()，<span class="hljs-title function_">filter</span>()循环的共同之处：  <span class="hljs-number">1.</span>forEach，map，filter循环中途是无法停止的，总是会将所有成员遍历完。  <span class="hljs-number">2.</span>他们都可以接受第二个参数，用来绑定回调函数内部的 <span class="hljs-variable language_">this</span> 变量，将回调函数内部的 <span class="hljs-variable language_">this</span> 对象，指向第二个参数，间接操作这个参数（一般是数组）。二：<span class="hljs-title function_">map</span>()、<span class="hljs-title function_">filter</span>()循环和<span class="hljs-title function_">forEach</span>()循环的不同：   forEach 循环没有返回值；map，filter 循环有返回值。三：<span class="hljs-title function_">map</span>()和<span class="hljs-title function_">filter</span>()都会跳过空位，<span class="hljs-keyword">for</span> 和 <span class="hljs-keyword">while</span> 不会四：<span class="hljs-title function_">some</span>()和<span class="hljs-title function_">every</span>():   <span class="hljs-title function_">some</span>()只要有一个是<span class="hljs-literal">true</span>，便返回<span class="hljs-literal">true</span>；而<span class="hljs-title function_">every</span>()只要有一个是<span class="hljs-literal">false</span>，便返回<span class="hljs-literal">false</span>.五：<span class="hljs-title function_">reduce</span>()，<span class="hljs-title function_">reduceRight</span>()：   reduce是从左到右处理（从第一个成员到最后一个成员），reduceRight则是从右到左（从最后一个成员到第一个成员）。六：<span class="hljs-title class_">Object</span>对象的两个遍历 <span class="hljs-title class_">Object</span>.<span class="hljs-property">keys</span> 与 <span class="hljs-title class_">Object</span>.<span class="hljs-property">getOwnPropertyNames</span>：   他们都是遍历对象的属性，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。但<span class="hljs-title class_">Object</span>.<span class="hljs-property">keys</span>不能返回不可枚举的属性；<span class="hljs-title class_">Object</span>.<span class="hljs-property">getOwnPropertyNames</span>能返回不可枚举的属性。</code></pre></div><h2 id="四、常用正则表达式"><a href="#四、常用正则表达式" class="headerlink" title="四、常用正则表达式"></a>四、常用正则表达式</h2><p>这里罗列一些我在刷算法题中遇到的正则表达式，如果有时间可认真学一下<strong>正则表达式不要背</strong>[7]。</p><h3 id="1-判断字符"><a href="#1-判断字符" class="headerlink" title="1.判断字符"></a>1.判断字符</h3><div class="code-wrapper"><pre><code class="hljs javascript">由<span class="hljs-number">26</span>个英文字母组成的字符串：^[A-<span class="hljs-title class_">Za</span>-z]+$由<span class="hljs-number">26</span>个大写英文字母组成的字符串：^[A-Z]+$由<span class="hljs-number">26</span>个小写英文字母组成的字符串：^[a-z]+$由数字和<span class="hljs-number">26</span>个英文字母组成的字符串：^[A-<span class="hljs-title class_">Za</span>-z0-<span class="hljs-number">9</span>]+$</code></pre></div><h3 id="2-判断数字"><a href="#2-判断数字" class="headerlink" title="2.判断数字"></a>2.判断数字</h3><div class="code-wrapper"><pre><code class="hljs javascript">数字：^[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]*$</code></pre></div><p>持续更新，敬请期待……</p><h2 id="五、数学知识"><a href="#五、数学知识" class="headerlink" title="五、数学知识"></a>五、数学知识</h2><h3 id="1-质数"><a href="#1-质数" class="headerlink" title="1.质数"></a>1.质数</h3><p>若一个正整数无法被除了<code>1</code> 和它自身之外的任何自然数整除，则称该数为质数（或素数），否则称该正整数为合数。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">judgePrime</span>(<span class="hljs-params">n</span>) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++) &#123;        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></div><h3 id="2-斐波那契数列"><a href="#2-斐波那契数列" class="headerlink" title="2.斐波那契数列"></a>2.斐波那契数列</h3><div class="code-wrapper"><pre><code class="hljs c">function <span class="hljs-title function_">Fibonacci</span><span class="hljs-params">(n)</span> &#123;    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n      <span class="hljs-keyword">return</span> Fibonacci(n - <span class="hljs-number">1</span>) + Fibonacci(n - <span class="hljs-number">2</span>)&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript面试题总结</title>
    <link href="/2023/01/23/TypeScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2023/01/23/TypeScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScrip—面试题"><a href="#TypeScrip—面试题" class="headerlink" title="TypeScrip—面试题"></a>TypeScrip—面试题</h1><p>类型 支持ES6新特性 添加ES6不具备的新特性 丰富的配置选项</p><h2 id="什么是-Typescript？"><a href="#什么是-Typescript？" class="headerlink" title="什么是 Typescript？"></a><strong>什么是 Typescript？</strong></h2><p>Typescript 是 Javascript 的超集</p><h2 id="1、-TypeScript-的主要特点是什么？"><a href="#1、-TypeScript-的主要特点是什么？" class="headerlink" title="1、 TypeScript 的主要特点是什么？"></a><strong>1、 TypeScript 的主要特点是什么？</strong></h2><p><strong>跨平台</strong>：TypeScript 编译器可以安装在任何操作系统上，包括 Windows、macOS 和 Linux。</p><p><strong>ES6 特性</strong>：TypeScript 包含计划中的 ECMAScript 2015 (ES6) 的大部分特性，例如箭头函数。</p><p><strong>面向对象的语言</strong>：TypeScript 提供所有标准的 OOP 功能，如类、接口和模块。</p><p><strong>静态类型检查</strong>：TypeScript 使用静态类型并帮助在编译时进行类型检查。因此，你可以在编写代码时发现编译时错误，而无需运行脚本。</p><p><strong>可选的静态类型</strong>：如果你习惯了 JavaScript 的动态类型，TypeScript 还允许可选的静态类型。</p><p><strong>DOM 操作</strong>：您可以使用 TypeScript 来操作 DOM 以添加或删除客户端网页元素。</p><h2 id="2、使用-TypeScript-有什么好处？"><a href="#2、使用-TypeScript-有什么好处？" class="headerlink" title="2、使用 TypeScript 有什么好处？"></a><strong>2、使用 TypeScript 有什么好处？</strong></h2><p>TypeScript 更具表现力，这意味着它的语法混乱更少。</p><p>由于高级调试器专注于在编译时之前捕获逻辑错误，因此调试很容易。</p><p>静态类型使 TypeScript 比 JavaScript 的动态类型更易于阅读和结构化。</p><p>由于通用的转译，它可以跨平台使用，在客户端和服务器端项目中。</p><h2 id="3、TypeScript-的内置数据类型有哪些？"><a href="#3、TypeScript-的内置数据类型有哪些？" class="headerlink" title="3、TypeScript 的内置数据类型有哪些？"></a><strong>3、TypeScript 的内置数据类型有哪些？</strong></h2><p><strong>数字类型</strong>：用于表示数字类型的值。TypeScript 中的所有数字都存储为浮点值。</p><p>let identifier: number &#x3D; value;</p><p><strong>布尔类型</strong>：一个逻辑二进制开关，包含true或false</p><p>let identifier: string &#x3D; “ “;</p><p><strong>Null 类型</strong>：Null 表示值未定义的变量。</p><p>let identifier: bool &#x3D; Boolean value;</p><p><strong>未定义类型</strong>：一个未定义的字面量，它是所有变量的起点。</p><p>let num: number &#x3D; null;、、、、、、、</p><p><strong>void 类型</strong>：分配给没有返回值的方法的类型。</p><p>let unusable: void &#x3D; undefined;</p><h2 id="4、TypeScript-目前的稳定版本是什么？"><a href="#4、TypeScript-目前的稳定版本是什么？" class="headerlink" title="4、TypeScript 目前的稳定版本是什么？"></a><strong>4、TypeScript 目前的稳定版本是什么？</strong></h2><p>当前的稳定版本是 4.2.3。</p><h2 id="5、TypeScript-中的接口是什么？"><a href="#5、TypeScript-中的接口是什么？" class="headerlink" title="5、TypeScript 中的接口是什么？"></a><strong>5、TypeScript 中的接口是什么？</strong></h2><p>接口为使用该接口的对象定义契约或结构。</p><p>接口是用关键字定义的interface，它可以包含使用函数或箭头函数的属性和方法声明。</p><p>interface IEmployee { empCode: number; empName: string; getSalary: (number) &#x3D;&gt; number; &#x2F;&#x2F; arrow function getManagerName(number): string; }</p><h2 id="6、TypeScript-中的模块是什么？"><a href="#6、TypeScript-中的模块是什么？" class="headerlink" title="6、TypeScript 中的模块是什么？"></a><strong>6、TypeScript 中的模块是什么？</strong></h2><p>TypeScript 中的模块是相关变量、函数、类和接口的集合。</p><p>你可以将模块视为包含执行任务所需的一切的容器。可以导入模块以轻松地在项目之间共享代码。</p><p>module module_name{class xyz{export sum(x, y){return x+y;}}</p><h2 id="7、后端如何使用TypeScript？"><a href="#7、后端如何使用TypeScript？" class="headerlink" title="7、后端如何使用TypeScript？"></a><strong>7、后端如何使用TypeScript？</strong></h2><p>你可以将 Node.js 与 TypeScript 结合使用，将 TypeScript 的优势带入后端工作。</p><p>只需输入以下命令，即可将 TypeScript 编译器安装到你的 Node.js 中：</p><p>npm i -g typescript  &#x2F;&#x2F;全局安装</p><h2 id="8、TypeScript-中的类型断言是什么？"><a href="#8、TypeScript-中的类型断言是什么？" class="headerlink" title="8、TypeScript 中的类型断言是什么？"></a><strong>8、TypeScript 中的类型断言是什么？</strong></h2><p>TypeScript 中的类型断言的工作方式类似于其他语言中的类型转换，但没有 C# 和 Java 等语言中可能的类型检查或数据重组。类型断言对运行时没有影响，仅由编译器使用。</p><p>类型断言本质上是类型转换的软版本，它建议编译器将变量视为某种类型，但如果它处于不同的形式，则不会强制它进入该模型。</p><h2 id="9、如何在-TypeScript-中创建变量？"><a href="#9、如何在-TypeScript-中创建变量？" class="headerlink" title="9、如何在 TypeScript 中创建变量？"></a><strong>9、如何在 TypeScript 中创建变量？</strong></h2><p>你可以通过三种方式创建变量：var，let，和const。</p><p>var是严格范围变量的旧风格。你应该尽可能避免使用，var因为它会在较大的项目中导致问题。</p><p>var num:number &#x3D; 1;</p><p>let是在 TypeScript 中声明变量的默认方式。与var相比，let减少了编译时错误的数量并提高了代码的可读性。</p><p>let num:number &#x3D; 1;</p><p>const创建一个其值不能改变的常量变量。它使用相同的范围规则，let并有助于降低整体程序的复杂性。</p><p>const num:number &#x3D; 100;</p><h2 id="10、在TypeScript中如何从子类调用基类构造函数？"><a href="#10、在TypeScript中如何从子类调用基类构造函数？" class="headerlink" title="10、在TypeScript中如何从子类调用基类构造函数？"></a><strong>10、在TypeScript中如何从子类调用基类构造函数？</strong></h2><p>你可以使用该super()函数来调用基类的构造函数。</p><p>class Animal { name: string; constructor(theName: string) { this.name &#x3D; theName; } move(distanceInMeters: number &#x3D; 0) { console.log(<code>$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.</code>); }}class Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters &#x3D; 5) { console.log(“Slithering…”); super.move(distanceInMeters); }}</p><h2 id="11、解释如何使用-TypeScript-mixin。"><a href="#11、解释如何使用-TypeScript-mixin。" class="headerlink" title="11、解释如何使用 TypeScript mixin。"></a><strong>11、解释如何使用 TypeScript mixin。</strong></h2><p>Mixin 本质上是在相反方向上工作的继承。Mixins 允许你通过组合以前类中更简单的部分类设置来构建新类。</p><p>相反，类A继承类B来获得它的功能，类B从类A需要返回一个新类的附加功能。</p><h2 id="12、TypeScript-中如何检查-null-和-undefined？"><a href="#12、TypeScript-中如何检查-null-和-undefined？" class="headerlink" title="12、TypeScript 中如何检查 null 和 undefined？"></a><strong>12、TypeScript 中如何检查 null 和 undefined？</strong></h2><p>你可以使用 juggle-check，它检查 null 和 undefined，或者使用 strict-check，它返回true设置为null的值，并且不会评估true未定义的变量。</p><p>&#x2F;&#x2F;juggleif (x &#x3D;&#x3D; null) { }</p><p>var a: number; var b: number &#x3D; null; function check(x, name) { if (x &#x3D;&#x3D; null) { console.log(name + ‘ &#x3D;&#x3D; null’); } if (x &#x3D;&#x3D;&#x3D; null) { console.log(name + ‘ &#x3D;&#x3D;&#x3D; null’); } if (typeof x &#x3D;&#x3D;&#x3D; ‘undefined’) { console.log(name + ‘ is undefined’); } } check(a, ‘a’); check(b, ‘b’);</p><h2 id="13、TypeScript-中的-getter-x2F-setter-是什么？你如何使用它们？"><a href="#13、TypeScript-中的-getter-x2F-setter-是什么？你如何使用它们？" class="headerlink" title="13、TypeScript 中的 getter&#x2F;setter 是什么？你如何使用它们？"></a><strong>13、TypeScript 中的 getter&#x2F;setter 是什么？你如何使用它们？</strong></h2><p>Getter 和 setter 是特殊类型的方法，可帮助你根据程序的需要委派对私有变量的不同级别的访问。</p><p>Getters 允许你引用一个值但不能编辑它。Setter 允许你更改变量的值，但不能查看其当前值。这些对于实现封装是必不可少的。</p><p>例如，新雇主可能能够了解get公司的员工人数，但无权set了解员工人数。</p><p>const fullNameMaxLength &#x3D; 10;class Employee { private _fullName: string &#x3D; “”; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (newName &amp;&amp; newName.length &gt; fullNameMaxLength) { throw new Error(“fullName has a max length of “ + fullNameMaxLength); } this._fullName &#x3D; newName; }}let employee &#x3D; new Employee();employee.fullName &#x3D; “Bob Smith”;if (employee.fullName) { console.log(employee.fullName);}</p><h2 id="14、-如何允许模块外定义的类可以访问？"><a href="#14、-如何允许模块外定义的类可以访问？" class="headerlink" title="14、 如何允许模块外定义的类可以访问？"></a><strong>14、 如何允许模块外定义的类可以访问？</strong></h2><p>你可以使用export关键字打开模块以供在模块外使用。</p><p>module Admin { &#x2F;&#x2F; use the export keyword in TypeScript to access the class outside export class Employee { constructor(name: string, email: string) { } } let alex &#x3D; new Employee(‘alex’, ‘<a href="mailto:&#x61;&#x6c;&#x65;&#x78;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;">&#x61;&#x6c;&#x65;&#x78;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;</a>‘);}&#x2F;&#x2F; The Admin variable will allow you to access the Employee class outside the module with the help of the export keyword in TypeScriptlet nick &#x3D; new Admin.Employee(‘nick’, ‘<a href="mailto:&#x6e;&#105;&#99;&#107;&#x40;&#x79;&#97;&#x68;&#111;&#111;&#46;&#x63;&#x6f;&#x6d;">&#x6e;&#105;&#99;&#107;&#x40;&#x79;&#97;&#x68;&#111;&#111;&#46;&#x63;&#x6f;&#x6d;</a>‘);</p><h2 id="15、如何使用-Typescript-将字符串转换为数字？"><a href="#15、如何使用-Typescript-将字符串转换为数字？" class="headerlink" title="15、如何使用 Typescript 将字符串转换为数字？"></a><strong>15、如何使用 Typescript 将字符串转换为数字？</strong></h2><p>与 JavaScript 类似，你可以使用parseInt或parseFloat函数分别将字符串转换为整数或浮点数。你还可以使用一元运算符+将字符串转换为最合适的数字类型，“3”成为整数，3而“3.14”成为浮点数3.14。</p><p>var x &#x3D; “32”;var y: number &#x3D; +x;</p><h2 id="16、什么是-map-文件，为什么-x2F-如何使用它？"><a href="#16、什么是-map-文件，为什么-x2F-如何使用它？" class="headerlink" title="16、什么是 .map 文件，为什么&#x2F;如何使用它？"></a><strong>16、什么是 .map 文件，为什么&#x2F;如何使用它？</strong></h2><p>甲.map文件是源地图，显示原始打字稿代码是如何解释成可用的JavaScript代码。它们有助于简化调试，因为你可以捕获任何奇怪的编译器行为。</p><p>调试工具还可以使用这些文件来允许你编辑底层的 TypeScript 而不是发出的 JavaScript 文件。</p><h2 id="17、TypeScript-中的类是什么？你如何定义它们？"><a href="#17、TypeScript-中的类是什么？你如何定义它们？" class="headerlink" title="17、TypeScript 中的类是什么？你如何定义它们？"></a><strong>17、TypeScript 中的类是什么？你如何定义它们？</strong></h2><p>类表示一组相关对象的共享行为和属性。</p><p>例如，我们的类可能是Student，其所有对象都具有该attendClass方法。另一方面，John是一个单独的 type 实例，Student可能有额外的独特行为，比如attendExtracurricular.</p><p>你使用关键字声明类class：</p><p>class Student { studCode: number; studName: string; constructor(code: number, name: string) { this.studName &#x3D; name; this.studCode &#x3D; code; }</p><h2 id="18、TypeScript-与-JavaScript-有什么关系？"><a href="#18、TypeScript-与-JavaScript-有什么关系？" class="headerlink" title="18、TypeScript 与 JavaScript 有什么关系？"></a><strong>18、TypeScript 与 JavaScript 有什么关系？</strong></h2><p>TypeScript 是 JavaScript 的开源语法超集，可编译为 JavaScript。所有原始 JavaScript 库和语法仍然有效，但 TypeScript 增加了 JavaScript 中没有的额外语法选项和编译器功能。</p><p>TypeScript 还可以与大多数与 JavaScript 相同的技术接口，例如 Angular 和 jQuery。</p><h2 id="19、TypeScript-中的-JSX-是什么？"><a href="#19、TypeScript-中的-JSX-是什么？" class="headerlink" title="19、TypeScript 中的 JSX 是什么？"></a><strong>19、TypeScript 中的 JSX 是什么？</strong></h2><p>JSX 是一种可嵌入的类似于 XML 的语法，允许你创建 HTML。TypeScript 支持嵌入、类型检查和将 JSX 直接编译为 JavaScript。</p><h2 id="20、TypeScript-支持哪些-JSX-模式？"><a href="#20、TypeScript-支持哪些-JSX-模式？" class="headerlink" title="20、TypeScript 支持哪些 JSX 模式？"></a><strong>20、TypeScript 支持哪些 JSX 模式？</strong></h2><p>TypeScript有内置的支持preserve，react和react-native。</p><p>preserve 保持 JSX 完整以用于后续转换。</p><p>react不经过 JSX 转换，而是react.createElement作为.js文件扩展名发出和输出。</p><p>react-native结合起来preserve，react因为它维护所有 JSX 和输出作为.js扩展。</p><h2 id="21、如何编译-TypeScript-文件？"><a href="#21、如何编译-TypeScript-文件？" class="headerlink" title="21、如何编译 TypeScript 文件？"></a><strong>21、如何编译 TypeScript 文件？</strong></h2><p>你需要调用 TypeScript 编译器tsc来编译文件。你需要安装 TypeScript 编译器，你可以使用npm.</p><p>npm install -g typescripttsc <TypeScript File Name></p><h2 id="22、-TypeScript-中有哪些范围可用？这与JS相比如何？"><a href="#22、-TypeScript-中有哪些范围可用？这与JS相比如何？" class="headerlink" title="22、 TypeScript 中有哪些范围可用？这与JS相比如何？"></a><strong>22、 TypeScript 中有哪些范围可用？这与JS相比如何？</strong></h2><p>全局作用域：在任何类之外定义，可以在程序中的任何地方使用。</p><p>函数&#x2F;类范围：在函数或类中定义的变量可以在该范围内的任何地方使用。</p><p>局部作用域&#x2F;代码块：在局部作用域中定义的变量可以在该块中的任何地方使用。</p><h2 id="23、TypeScript-中的箭头-x2F-lambda-函数是什么？"><a href="#23、TypeScript-中的箭头-x2F-lambda-函数是什么？" class="headerlink" title="23、TypeScript 中的箭头&#x2F;lambda 函数是什么？"></a><strong>23、TypeScript 中的箭头&#x2F;lambda 函数是什么？</strong></h2><p>胖箭头函数是用于定义匿名函数的函数表达式的速记语法。它类似于其他语言中的 lambda 函数。箭头函数可让你跳过function关键字并编写更简洁的代码。</p><h2 id="24、解释rest参数和声明rest参数的规则。"><a href="#24、解释rest参数和声明rest参数的规则。" class="headerlink" title="24、解释rest参数和声明rest参数的规则。"></a><strong>24、解释rest参数和声明rest参数的规则。</strong></h2><p>其余参数允许你将不同数量的参数（零个或多个）传递给函数。当你不确定函数将接收多少参数时，这很有用。其余符号之后的所有参数…都将存储在一个数组中。</p><p>例如：</p><p>function Greet(greeting: string, …names: string[]) { return greeting + “ “ + names.join(“, “) + “!”;}Greet(“Hello”, “Steve”, “Bill”); &#x2F;&#x2F; returns “Hello Steve, Bill!”Greet(“Hello”);&#x2F;&#x2F; returns “Hello !”</p><p>rest 参数必须是参数定义的最后一个，并且每个函数只能有一个 rest 参数。</p><h2 id="25、什么是三斜线指令？有哪些三斜杠指令？"><a href="#25、什么是三斜线指令？有哪些三斜杠指令？" class="headerlink" title="25、什么是三斜线指令？有哪些三斜杠指令？"></a><strong>25、什么是三斜线指令？有哪些三斜杠指令？</strong></h2><p>三斜线指令是单行注释，包含用作编译器指令的 XML 标记。每个指令都表示在编译过程中要加载的内容。三斜杠指令仅在其文件的顶部工作，并且将被视为文件中其他任何地方的普通注释。</p><p>&#x2F;&#x2F;&#x2F; <reference path="..." /> 是最常见的指令，定义文件之间的依赖关系。</p><p>&#x2F;&#x2F;&#x2F; <reference types="..." />类似于path但定义了包的依赖项。</p><p>&#x2F;&#x2F;&#x2F; <reference lib="..." />允许您显式包含内置lib文件。</p><h2 id="26、Omit类型有什么作用？"><a href="#26、Omit类型有什么作用？" class="headerlink" title="26、Omit类型有什么作用？"></a><strong>26、Omit类型有什么作用？</strong></h2><p>Omit是实用程序类型的一种形式，它促进了常见的类型转换。Omit允许你通过传递电流Type并选择Keys在新类型中省略来构造类型。</p><p>Omit&lt;Type, Keys&gt;</p><p>例如：</p><p>interface Todo { title: string; description: string; completed: boolean; createdAt: number;}type TodoPreview &#x3D; Omit&lt;Todo, “description”&gt;;</p><h2 id="27、TypeScript中如何实现函数重载？"><a href="#27、TypeScript中如何实现函数重载？" class="headerlink" title="27、TypeScript中如何实现函数重载？"></a><strong>27、TypeScript中如何实现函数重载？</strong></h2><p>要在 TypeScript 中重载函数，只需创建两个名称相同但参数&#x2F;返回类型不同的函数。两个函数必须接受相同数量的参数。这是 TypeScript 中多态性的重要组成部分。</p><p>例如，你可以创建一个add函数，如果它们是数字，则将两个参数相加，如果它们是字符串，则将它们连接起来。</p><p>function add(a:string, b:string):string;function add(a:number, b:number): number;function add(a: any, b:any): any { return a + b;}add(“Hello “, “Steve”); &#x2F;&#x2F; returns “Hello Steve” add(10, 20); &#x2F;&#x2F; returns 30</p><h2 id="28、如何让接口的所有属性都可选？"><a href="#28、如何让接口的所有属性都可选？" class="headerlink" title="28、如何让接口的所有属性都可选？"></a><strong>28、如何让接口的所有属性都可选？</strong></h2><p>你可以使用partial映射类型轻松地将所有属性设为可选。</p><h2 id="29、什么时候应该使用关键字unknown？"><a href="#29、什么时候应该使用关键字unknown？" class="headerlink" title="29、什么时候应该使用关键字unknown？"></a><strong>29、什么时候应该使用关键字unknown？</strong></h2><p>unknown，如果你不知道预先期望哪种类型，但想稍后分配它，则应该使用该any关键字，并且该关键字将不起作用。</p><h2 id="30、什么是装饰器，它们可以应用于什么？"><a href="#30、什么是装饰器，它们可以应用于什么？" class="headerlink" title="30、什么是装饰器，它们可以应用于什么？"></a><strong>30、什么是装饰器，它们可以应用于什么？</strong></h2><p>装饰器是一种特殊的声明，它允许你通过使用@<name>注释标记来一次性修改类或类成员。每个装饰器都必须引用一个将在运行时评估的函数。</p><p>例如，装饰器@sealed将对应于sealed函数。任何标有 的@sealed都将用于评估sealed函数。</p><p>function sealed(target) { &#x2F;&#x2F; do something with ‘target’ …}</p><p>它们可以附加到：</p><p>类声明</p><p>方法</p><p>配件</p><p>特性</p><p>参数</p>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解ES6</title>
    <link href="/2023/01/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/"/>
    <url>/2023/01/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/</url>
    
    <content type="html"><![CDATA[<h3 id="ECMAScript简介"><a href="#ECMAScript简介" class="headerlink" title="ECMAScript简介"></a>ECMAScript简介</h3><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><p>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和ActionScript），日常场合，这两个词是可以互换的。</p><h3 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>ES6 新增了<code>let</code>和<code>const</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>和<code>const</code>命令所在的代码块内有效。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> j=<span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> k=<span class="hljs-number">1</span>;</code></pre></div><p>var：存在变量提升，可以在声明前使用，值为<code>undefined</code>。</p><p>let：存在块级作用域，声明的变量一定要在声明过后使用，不然会报错，不可重复声明。</p><p>const：常量的值不能改变。，不可重复声明</p><p>ES5 只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6 除了添加<code>let</code>和<code>const</code>命令，还有另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6 一共有 6 种声明变量的方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3的组合式API详解</title>
    <link href="/2023/01/23/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/01/23/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h1><div class="code-wrapper"><pre><code class="hljs bash">npm install</code></pre></div><p>文档地址：<a href="https://cn.vuejs.org/api/">API 参考 | Vue.js (vuejs.org)</a></p><p>Vue3 组合式 API（Composition API） 主要用于在大型组件中提高代码逻辑的可复用性。</p><p>传统的组件随着业务复杂度越来越高，代码量会不断的加大，整个代码逻辑都不易阅读和理解。</p><p>Vue3 使用组合式 API 的代码地方为 setup。</p><p>在 setup 中，我们可以按逻辑关注点对部分代码进行分组，然后提取逻辑片段并与其他组件共享代码。因此，组合式 API（Composition API）允许我们编写更有条理的代码。</p><p>vue3 API主要包含以下六个部分：</p><ol><li>全局API —— 全局会用到的API</li><li>组合式API —— vue3所拥有的组合式API</li><li>选项式API —— vue2所拥有的选项式API</li><li>内置内容 —— 指令、组件、特殊元素和特殊属性</li><li>单文件组件 —— 语法定义</li><li>进阶API —— 渲染函数、服务端渲染、TS工具类型和自定义渲染</li></ol><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/1.png"></p><h1 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h1><p>Vue3的全局API包含两个部分：应用实例和通用API。</p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/3.jpg"></p><h2 id="通用API"><a href="#通用API" class="headerlink" title="通用API"></a>通用API</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/4.png"></p><h1 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h1><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/5.png"></p><h2 id="响应式：核心"><a href="#响应式：核心" class="headerlink" title="响应式：核心"></a>响应式：核心</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/5.png"></p><h2 id="响应式：工具函数"><a href="#响应式：工具函数" class="headerlink" title="响应式：工具函数"></a>响应式：工具函数</h2><p>![]222222</p><h2 id="响应式：进阶"><a href="#响应式：进阶" class="headerlink" title="响应式：进阶"></a>响应式：进阶</h2><p>![22222</p><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><p>![22222</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/5.png"></p><h1 id="选项式API"><a href="#选项式API" class="headerlink" title="选项式API"></a>选项式API</h1><h2 id="状态选项"><a href="#状态选项" class="headerlink" title="状态选项"></a>状态选项</h2><p>111</p><h2 id="渲染选项"><a href="#渲染选项" class="headerlink" title="渲染选项"></a>渲染选项</h2><p>1111</p><h2 id="生命周期选项"><a href="#生命周期选项" class="headerlink" title="生命周期选项"></a>生命周期选项</h2><p>11111</p><h2 id="组合选项"><a href="#组合选项" class="headerlink" title="组合选项"></a>组合选项</h2><p>!1111</p><h2 id="其他杂项"><a href="#其他杂项" class="headerlink" title="其他杂项"></a>其他杂项</h2><p>111</p><h2 id="组件实例"><a href="#组件实例" class="headerlink" title="组件实例"></a>组件实例</h2><p>!11111</p><h1 id="内置内容"><a href="#内置内容" class="headerlink" title="内置内容"></a>内置内容</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>!11111</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>!1111</p><h2 id="特殊元素"><a href="#特殊元素" class="headerlink" title="特殊元素"></a>特殊元素</h2><p>!11111</p><h2 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h2><p>![](111111</p><h1 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h1><h2 id="SFC语法定义"><a href="#SFC语法定义" class="headerlink" title="SFC语法定义"></a>SFC语法定义</h2><p>![]1111</p><h2 id="单文件组件script-setup"><a href="#单文件组件script-setup" class="headerlink" title="单文件组件script setup"></a>单文件组件script setup</h2><p>![111111</p><h2 id="css功能"><a href="#css功能" class="headerlink" title="css功能"></a>css功能</h2><p>1111</p><h1 id="进阶API"><a href="#进阶API" class="headerlink" title="进阶API"></a>进阶API</h1><h2 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h2><p>1111</p><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>1111</p><h2 id="TypeScript工具类型"><a href="#TypeScript工具类型" class="headerlink" title="TypeScript工具类型"></a>TypeScript工具类型</h2><p>1111</p><h2 id="自定义渲染"><a href="#自定义渲染" class="headerlink" title="自定义渲染"></a>自定义渲染</h2><p>1111</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对包依赖管理工具的了解</title>
    <link href="/2023/01/23/%E5%AF%B9%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
    <url>/2023/01/23/%E5%AF%B9%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>npm</tag>
      
      <tag>yarn</tag>
      
      <tag>pnpm</tag>
      
      <tag>cnpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS面试记录</title>
    <link href="/2023/01/22/CSS%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/22/CSS%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="如何实现一个元素的水平垂直居中？"><a href="#如何实现一个元素的水平垂直居中？" class="headerlink" title="如何实现一个元素的水平垂直居中？"></a>如何实现一个元素的水平垂直居中？</h2><p>要求对行内元素、块状元素及不定宽高的块状元素均可适用：</p><h2 id="css3-有哪些新特性？"><a href="#css3-有哪些新特性？" class="headerlink" title="css3 有哪些新特性？"></a>css3 有哪些新特性？</h2><ul><li>rgba 和 透明度</li><li>background-image、background-origin、background-size、background-repeat</li><li>word-wrap: break-word（对长的不可分割的单词换行）</li><li>文字阴影 text-shadow</li><li>font-face属性，定义自己的字体</li><li>border-radius</li><li>边框图片 border-image</li><li>盒阴影 box-shadow</li><li>媒体查询：定义多套 css，当浏览器尺寸发生变化时采用不同的属性</li></ul><h2 id="style-标签写在-body-后与-body-前有什么区别？"><a href="#style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="style 标签写在 body 后与 body 前有什么区别？"></a>style 标签写在 body 后与 body 前有什么区别？</h2><ol><li>写在 body 标签前有利于浏览器逐步渲染： resources downloading –&gt; cssDOM + DOM –&gt; Render Tree –&gt; layout –&gt; paint</li><li>写在 body 标签后： 由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载且解析样式完成后重新渲染；在 windows 的 IE 下可能出现样式失效导致的页面闪烁问题。</li></ol><h2 id="CSS选择器及优先级"><a href="#CSS选择器及优先级" class="headerlink" title="CSS选择器及优先级"></a>CSS选择器及优先级</h2><ol><li>选择器<ul><li>id选择器(#myid)</li><li>类选择器(.myclass)</li><li>属性选择器(a[rel&#x3D;”external”])</li><li>伪类选择器(a:hover, li:nth-child)</li><li>标签选择器(div, h1, p)</li><li>伪元素选择器(p::first-line)</li><li>相邻选择器（h1 + p）</li><li>子选择器(ul &gt; li)</li><li>后代选择器(li a)</li><li>通配符选择器(*)</li></ul></li><li>优先级<ul><li><code>!important</code></li><li>内联样式（1000）</li><li>ID选择器（0100）</li><li>类选择器 &#x2F; 属性选择器 &#x2F; 伪类选择器（0010）</li><li>标签选择器 &#x2F; 伪元素选择器（0001）</li><li>关系选择器 &#x2F; 通配符选择器（0000）</li></ul></li></ol><p>带 !important 标记的样式属性优先级最高；样式表的来源相同时：<code>!important &gt; 行内样式&gt; ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</code></p><h2 id="rgba-和-opacity-设置透明度的区别是什么？"><a href="#rgba-和-opacity-设置透明度的区别是什么？" class="headerlink" title="rgba() 和 opacity 设置透明度的区别是什么？"></a>rgba() 和 opacity 设置透明度的区别是什么？</h2><p>rgba() 和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度；而 rgba() 只作用于元素的颜色或其背景色，设置 rgba() 透明的元素的子元素不会继承透明效果。</p><h2 id="浏览器是如何解析-css-选择器等？"><a href="#浏览器是如何解析-css-选择器等？" class="headerlink" title="浏览器是如何解析 css 选择器等？"></a>浏览器是如何解析 css 选择器等？</h2><p><code>从右向左解析的。</code>若从左向右匹配，发现不符合规则，需要回溯，会损失很多性能。若从右向左匹配，先找到所有的最后节点，对于每一个节点，向上寻找其父节点直到查找至根元素或满足条件的匹配规则，则结束这个分支的遍历。</p><p>在 css 解析完毕后，需将解析结果 css 规则树和 DOM Tree 一起进行分析建立一颗 Render Tree，最终用来进行绘图。</p><h2 id="display-none-和-visibility-hidden-两者的区别"><a href="#display-none-和-visibility-hidden-两者的区别" class="headerlink" title="display: none 和 visibility: hidden 两者的区别"></a>display: none 和 visibility: hidden 两者的区别</h2><ol><li>display: none 隐藏后不占用文档流；而 visibility: hidden 会占用文档流。</li><li>visibility 具有继承性，给父元素设置 “visibility: hidden”，子元素也会继承该属性，但如果重新给子元素设置 “visibility: visible”，则子元素又会显示出来。</li><li>visibility: hidden 不会影响计数器的计数，虽然隐藏了，但计数器依然运行着。</li><li>在 css3 中 transition 支持 visibility 属性，但不支持 display。因为 transition 可以延迟执行，因此配合 visibility 使用纯 css 延时显示效果可以提高用户体验。</li><li>display: none 会引起回流（重排）和重绘；visibility: hidden 会引起重绘。</li></ol><h2 id="简述-transform，transition，animation-的作用"><a href="#简述-transform，transition，animation-的作用" class="headerlink" title="简述 transform，transition，animation 的作用"></a>简述 transform，transition，animation 的作用</h2><ol><li><code>transform</code>：描述了元素的静态样式，本身不会呈现动画效果，可以对元素进行旋转 rotate、扭曲 skew、缩放 scale 和移动 translate 以及矩阵变形 matrix。<code>transition</code> 和 <code>animation</code> 两者都能实现动画效果。<code>transform</code> 常配合<code>transition</code> 和 <code>animation</code> 使用。</li><li><code>transition</code>：样式过渡，从一种效果逐渐改变为另一种效果，它是一个合写属性。transition: transition-property transition-duration transition-timing-function transition-delay 从左到右，依次是：过渡效果的css属性名称、过渡效果花费时间、速度曲线、过渡开始的延迟时间 <code>transition</code> 通常和 hover 等事件配合使用，需要由事件来触发过渡。</li><li><code>animation</code>：动画，有 <code>@keyframes</code> 来描述每一帧的样式。</li></ol><p>区别：</p><ul><li><code>transform</code> 仅描述元素的静态样式，常配合<code>transition</code> 和 <code>animation</code> 使用。</li><li><code>transition</code> 通常和 hover 等事件配合使用；<code>animation</code> 是自发的，立即播放。</li><li><code>animation</code> 可以设置循环次数。</li><li><code>animation</code> 可以设置每一帧的样式和时间，<code>transition</code> 只能设置头尾。</li><li><code>transition</code> 可以与 js 配合使用， js 设定要变化的样式，<code>transition</code> 负责动画效果。</li></ul><h2 id="line-height-如何继承？"><a href="#line-height-如何继承？" class="headerlink" title="line-height 如何继承？"></a>line-height 如何继承？</h2><ul><li>父元素的 <code>line-height</code> 是具体数值，则子元素 <code>line-height</code> 继承该值。</li><li>父元素的 <code>line-height</code> 是比例值，如’2’，则子元素 <code>line-height</code> 继承该比例。</li><li>父元素的 <code>line-height</code> 是百分比，则子元素 <code>line-height</code> 继承的是父元素的 font-size * 百分比 计算出来的值。</li></ul><h2 id="如何让-chrome-支持-10px-的文字？"><a href="#如何让-chrome-支持-10px-的文字？" class="headerlink" title="如何让 chrome 支持 10px 的文字？"></a>如何让 chrome 支持 10px 的文字？</h2><ol><li>font-size: 12px; -webkit-transform: scale(0.84);</li><li>font-size: 20px; -webkit-transform: scale(0.5);</li></ol><h2 id="position-属性的值有哪些？"><a href="#position-属性的值有哪些？" class="headerlink" title="position 属性的值有哪些？"></a>position 属性的值有哪些？</h2><ol><li><code>static</code>：默认定位。元素出现在正常的文档流中（忽略top，bottom，left，right 或 z-index声明）</li><li><code>relative</code>：相对定位。如果对一个元素进行相对定位，将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，使其“相对于”它的起点进行移动。使用相对定位时，无论是否移动，元素仍然占据原来的空间；移动元素会导致其覆盖其他元素。</li><li><code>absolute</code>：绝对定位。元素的位置相对于最近的已定位的父元素，如果元素没有已定位的父元素，则相对于根元素（即 html 元素）定位。绝对定位的元素会脱离文档流，不占据空间，会与其他元素重叠。</li><li><code>fixed</code>：固定定位。元素的位置相对于浏览器窗口是固定位置，即使窗口滚动它也不会移动。固定定位的元素会脱离文档流，不占据空间，会与其他元素重叠。</li><li><code>sticky</code>：粘性定位。粘性定位可以被认为是相对定位和固定定位的混合，元素在跨越特定阈值前为相对定位，之后为固定定位。top，right，buttom，left，必须指定这四个阈值中的一个，才可以使粘性定位生效，否则行为与其相对定位相同。</li><li><code>inherit</code>：规定应该从父元素继承 position 属性的值。</li></ol><h2 id="css-盒模型？"><a href="#css-盒模型？" class="headerlink" title="css 盒模型？"></a>css 盒模型？</h2><ul><li><code>标准盒模型</code>，width 指 content 部分的宽度，总宽度 &#x3D; width + border(左右) + padding（左右）+ margin（左右）；高度同理。</li><li><code>怪异盒模型（IE盒模型）</code>，width 指 content + border（左右） + padding（左右）三部分的宽度，因此，总宽度 &#x3D; width + margin（左右）；高度同理。</li></ul><h2 id="box-sizing-属性"><a href="#box-sizing-属性" class="headerlink" title="box-sizing 属性"></a>box-sizing 属性</h2><ol><li><code>content-box</code>，对应标准盒模型。</li><li><code>border-box</code>，IE盒模型。</li><li><code>inherit</code>，继承父元素的 box-sizing 值。</li></ol><h2 id="BFC（块级格式上下文）"><a href="#BFC（块级格式上下文）" class="headerlink" title="BFC（块级格式上下文）"></a>BFC（块级格式上下文）</h2><ol><li>概念： BFC（Block Formatting Context），块级格式上下文。BFC 是 css 布局的一个概念，是一个独立的渲染区域，规定了内部 box 如何布局，且这个区域内的子元素不会影响到外面的元素。</li><li>布局规则：</li></ol><ul><li>内部的 box 会在垂直方向一个接一个的放置</li><li>box 垂直方向的距离由 margin 决定，同一个 BFC 相邻的 box 的 margin 会发生重叠</li><li>每个 box 的 margin 左边，与包含块的左 border 相接触（对于从左往右的格式化，否则相反）</li><li>BFC 的区域不会与 float box 重叠</li><li>BFC 是一个独立容器，容器内的子元素不会影响到外面的元素</li><li>计算 BFC 高度时，浮动元素也参与计算高度</li></ul><ol start="3"><li>如何创建 BFC ？</li></ol><ul><li>根元素，即 html 元素</li><li>float 值不为 none</li><li>position 值为 absolute 或 fixed</li><li>display 的值为 inline-block、tabl-cell、table-caption</li><li>overflow 的值不为 visible</li></ul><ol start="4"><li>BFC 的使用场景</li></ol><ul><li>去除边距重叠问题</li><li>清除浮动（让父元素的高度包含子浮动元素）</li><li>阻止元素被浮动元素覆盖</li></ul><h2 id="让一个元素水平-x2F-垂直居中"><a href="#让一个元素水平-x2F-垂直居中" class="headerlink" title="让一个元素水平&#x2F;垂直居中"></a>让一个元素水平&#x2F;垂直居中</h2><ol><li>水平居中</li></ol><ul><li>行内元素：<code>text-align: center;</code></li><li>对于确定宽度的块级元素<ul><li>width 和 margin 实现： <code>mragin: 0 auto;</code></li><li>绝对定位和 margin-left 实现： <code>margin-left: (父width - 子 width)/2；</code>(前提是父元素相对定位)</li></ul></li><li>对于宽度未知的块级元素<ul><li>table 标签配合 margin 左右 auto 实现</li><li>inline-block 实现：<code>display: inline-block; text-align: center;</code></li><li>绝对定位和 transform 实现， translateX 可以移动本身元素的50%</li><li>flex 布局 <code>justify-content: center</code></li></ul></li></ul><ol start="2"><li>垂直居中</li></ol><ul><li>纯文字类，设置 line-height 等于 height</li><li>子绝父相，子元素通过 margin 实现自适应居中</li><li>子绝父相，通过位移 transform 实现</li><li>flex 布局，<code>align-items: center;</code></li><li>table 布局，父级通过转换为表格形式，子级设置 vertical-align 实现</li></ul><h2 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h2><p>flex 布局，是一种弹性盒布局模型，给子元素提供了空间分布和对齐能力，由<code>container</code>（容器）及<code>item</code>（项目）组成。该布局模型提供了一种更加高效的方式来对容器中的项目进行布局、对齐和分配空间。适用于在不同尺寸的屏幕中创建可自动扩展和收缩布局，通常可用于<code>水平/垂直居中</code>，<code>两栏</code>、<code>三栏布局</code>等的场景里。</p><p>其中<code>flex</code>属性是<code>flex-grow</code>，<code>flex-shrink</code>和<code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。<strong>该属性有两个快捷值：<code>auto (1 1 auto)</code> 和 <code>none (0 0 auto)</code>。</strong></p><ul><li><p><code>flex-grow</code>：定义项目的放大比例，默认值为 0，即如果存在剩余空间，也不放大。如果所有项目的<code>flex-grow</code>属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p></li><li><p><code>flex-shrink</code>：项目的缩小比例，默认为 1，即如果空间不足，项目将缩小。如果所有项目的<code>flex-shrink</code>属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</p></li><li><p><code>flex-basis</code>：定义了在分配多余空间之前，项目占据的主轴空间。浏览器会根据该属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。当设置为 0 的是，会根据内容撑开。也可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如 350px），则项目将占据固定空间。</p></li></ul><p><code>flex</code>常用的属性值：</p><ul><li>flex: 1 –&gt; flex: 1 1 0%</li><li>flex: 2 –&gt; flex: 2 1 0%</li><li>flex: auto –&gt; flex: 1 1 auto</li><li>flex: none –&gt; flex: 0 0 auto【常用于固定尺寸不伸缩】</li></ul><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><ol><li>直接把 <code>&lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;</code>作为最后一个子标签<ul><li>优点：通俗易懂，容易掌握；</li><li>缺点：会添加较多无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦</li></ul></li><li>.clearfix { overflow: hidden; zoom: 1; }<ul><li>优点：不存在结构和语义化问题，代码量极少</li><li>缺点：内容增多时容易造成不自动换行，导致内容被隐藏掉，无法显示需要溢出的元素</li></ul></li><li>建立伪类选择器</li></ol><p><img src="/../imgs/CSS%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/98e2353e3275475095bd26ecedfa32e9tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="image.png"></p><h2 id="css-中优雅降级和渐进增强有什么区别？"><a href="#css-中优雅降级和渐进增强有什么区别？" class="headerlink" title="css 中优雅降级和渐进增强有什么区别？"></a>css 中优雅降级和渐进增强有什么区别？</h2><p>优雅降级和渐进增强是随着 css3 流出来的一个概念。由于低级浏览器不支持 css3， 但 css3 的效果又很优秀不忍放弃，所以在高级浏览器中使用 css3 ，而在低级浏览器只保证最基本的功能。二者最关键的区别是它们所侧重的内容，以及这种不同所造成的工作流程的差异。</p><ul><li><code>优雅降级</code>：一开始就构建完整的功能，然后针对浏览器测试和修复。</li><li><code>渐进增强</code>：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能以达到更好的体验。</li></ul><h2 id="img-的-alt-和-title-的异同？实现图片懒加载的原理？"><a href="#img-的-alt-和-title-的异同？实现图片懒加载的原理？" class="headerlink" title="img 的 alt 和 title 的异同？实现图片懒加载的原理？"></a>img 的 alt 和 title 的异同？实现图片懒加载的原理？</h2><ul><li><code>alt</code>是图片加载失败时显示在网页上的替代文字；<code>title</code>是鼠标放在图片上面时显示的文字，是对图片的进一步描述和说明。</li><li><code>alt</code>是 img 的必要属性；<code>title</code>不是。</li><li>对于网站 SEO 优先来说，搜索引擎对图片意思的判断，主要是靠<code>alt</code>属性，所以在图片<code>alt</code>属性中以简要文字说明，同时包含关键字，也是页面优化的一部分。</li></ul><p><code>懒加载原理</code>：先设置图片的 <code>data-set</code> 属性值（也可以是其他任意的，只要不发生 http 请求就可以，作用是为了存取值）为图片路径，由于不是 <code>src</code> 属性，故不会发生 http 请求。然后计算出页面的 scrollTop 的高度和浏览器的高度之和，如果图片距页面顶端距离小于前两者之和，说明图片要显示出来了，这时将 <code>data-set</code> 属性替换为 <code>src</code> 属性即可。</p><h2 id="css-sprites-（雪碧图-x2F-精灵图）"><a href="#css-sprites-（雪碧图-x2F-精灵图）" class="headerlink" title="css sprites （雪碧图&#x2F;精灵图）"></a>css sprites （雪碧图&#x2F;精灵图）</h2><p>css sprites 就是把网页中一些小图片整合到一张图片文件中，再利用 css 的 background-image、background-repeat、background-position 的组合进行背景定位。</p><p>优点： 减少图片体积；减少 http 请求次数</p><p>缺点：维护比较麻烦；不能随便改变大小，会失真模糊</p><h2 id="什么是字体图标？"><a href="#什么是字体图标？" class="headerlink" title="什么是字体图标？"></a>什么是字体图标？</h2><p>字体图标简单的说，就是一种特殊的字体，通过这种字体，显示给用户的就像一个个图片一样。字体图标最大的好处，在于它不会变形和加载速度快。字体图标可以像文字一样，随意通过 css 来控制它的大小和颜色，非常方便。</p><h2 id="主流浏览器内核私有属性-css-前缀？"><a href="#主流浏览器内核私有属性-css-前缀？" class="headerlink" title="主流浏览器内核私有属性 css 前缀？"></a>主流浏览器内核私有属性 css 前缀？</h2><ul><li>mozilla(firefox、flock等): -moz</li><li>webkit 内核(safari、chrome等): -webkit</li><li>opera 内核(opera浏览器): -o</li><li>trident 内核(ie 浏览器): -ms</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML面试记录</title>
    <link href="/2023/01/22/HTML%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/22/HTML%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><ol><li>语义化，指对文本内容的结构化（内容语义化），选择合乎语义的标签（代码语义化）。</li><li>语义化标签：<code>header</code>、<code>nav</code>、<code>main</code>、<code>article</code>、<code>section</code>、<code>aside</code>、<code>footer</code>等。</li><li>优点：<ul><li>代码结构清晰，易于阅读，有利于维护</li><li>方便其他设备解析（如：屏幕阅读器）</li><li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li></ul></li></ol><p>建议阅读文章：<a href="https://link.juejin.cn/?target=https://rainylog.com/post/ife-note-1/" title="https://rainylog.com/post/ife-note-1/">百度ife的h5语义化文章</a></p><p><a href="https://zhuanlan.zhihu.com/p/32570423">初探 · HTML5语义化</a></p><h2 id="script-标签中属性-async-和-defer-的区别？"><a href="#script-标签中属性-async-和-defer-的区别？" class="headerlink" title="script 标签中属性 async 和 defer 的区别？"></a>script 标签中属性 async 和 defer 的区别？</h2><ul><li><code>script</code> 会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML</li><li><code>async script</code>：解析 HTML 的过程中会进行脚本的异步下载，下载成功后立马执行，因此有可能会阻断 HTML 的解析。多个脚本的执行顺序无法保证。</li><li><code>defer script</code>：也是异步下载脚步，加载完成后，如果此时 HTML 还没有解析完，浏览器不会暂停解析去执行 JS 代码，而是等待 HTML 解析完毕再执行 JS 代码，如果存在多个 <code>defer script</code> 标签，浏览器（IE9及以下除外）会保证它们按照在 HTML 中出现的顺序执行，不会破坏 JS 脚本之间的依赖关系。</li></ul><p>建议阅读文章：<a href="https://juejin.cn/post/6894629999215640583" title="https://juejin.cn/post/6894629999215640583">图解 script 标签中的 async 和 defer 属性</a></p><h2 id="DOCTYPE-的作用是什么？"><a href="#DOCTYPE-的作用是什么？" class="headerlink" title="DOCTYPE 的作用是什么？"></a>DOCTYPE 的作用是什么？</h2><p><code>&lt;!DOCTYE&gt;</code> 声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以“标准模式”进行文档解析，否则就以“兼容模式”进行解析。</p><ul><li>在<code>标准模式</code>下，浏览器的解析规则都是按照最新的标准进行解析的。</li><li>而在<code>兼容模式</code>下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站能正常访问。</li></ul><h2 id="SGML、HTML、XML-和-XHTML的区别"><a href="#SGML、HTML、XML-和-XHTML的区别" class="headerlink" title="SGML、HTML、XML 和 XHTML的区别"></a>SGML、HTML、XML 和 XHTML的区别</h2><ul><li><code>SGML</code> 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。</li><li><code>HTML</code> 是超文本标记语言，主要是用于规定怎样显示网页。</li><li><code>XML</code> 是可扩展标记语言，是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。</li><li><code>XHTML</code> 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</li></ul><h2 id="HTML5-有哪些新特性、移除了哪些元素？"><a href="#HTML5-有哪些新特性、移除了哪些元素？" class="headerlink" title="HTML5 有哪些新特性、移除了哪些元素？"></a>HTML5 有哪些新特性、移除了哪些元素？</h2><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像、位置、存储、多任务等功能的增加。</p><p>新增的：</p><ul><li>绘图 <code>canvas</code></li><li>用于媒介回放的 <code>video</code> 和 <code>audio</code> 元素</li><li>本地离线存储 <code>localStorage</code> 、<code>sessionStorage</code></li><li>语义化更好的内容元素，如：<code>header</code>、<code>article</code>、<code>nav</code>、<code>section</code>、<code>footer</code>等</li><li>表单控件 <code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code> 等</li><li>新的技术 <code>webworker</code>、<code>websocket</code></li><li>新的文档属性 <code>document.visibilityState</code></li></ul><p>移除的：</p><ul><li>纯表现的元素：<code>basefont</code>、<code>big</code>、<code>center</code>、<code>s</code>、<code>tt</code>、<code>u</code></li><li>对可用性产生负面影响的元素：<code>frame</code>、<code>frameset</code>、<code>noframes</code></li></ul><h2 id="对浏览器内核的理解"><a href="#对浏览器内核的理解" class="headerlink" title="对浏览器内核的理解"></a>对浏览器内核的理解</h2><p>主要分为两部分：渲染引擎和JS引擎。</p><ul><li><code>渲染引擎</code>：其职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 HTML、 XML 文档及图片，它也可以借助一些浏览器扩展插件显示其他类型数据，如：使用PDF阅读器插件可以显示 PDF 格式。</li><li><code>JS引擎</code>：解析和执行 JavaScript 来实现网页的动态效果。</li></ul><p>最开始渲染引擎和JS引擎并没有区分的很明显，后来JS引擎越来越独立，内核就倾向于只指渲染引擎了。</p><h2 id="什么是文档的预解析？"><a href="#什么是文档的预解析？" class="headerlink" title="什么是文档的预解析？"></a>什么是文档的预解析？</h2><p>当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载，从而使整体速度更快。</p><p>需要注意的是，预解析并不改变DOM树，它将这个工作交给主解析过程，自己只解析外部资源的引用，比如：外部脚本、样式及图片。</p><h2 id="浏览器的渲染原理"><a href="#浏览器的渲染原理" class="headerlink" title="浏览器的渲染原理"></a>浏览器的渲染原理</h2><p>简记： 生成DOM树 –&gt; 生成CSS规则树 –&gt; 构建渲染树 –&gt; 布局 –&gt; 绘制</p><ol><li>首先解析收到的文档，根据文档定义构建一颗 <code>DOM 树</code>，DOM 树是由 DOM 元素及属性节点组成的。</li><li>然后对 CSS 进行解析，生成一颗 <code>CSS 规则树</code>。</li><li>根据 DOM 树和 CSS 规则树构建<code>渲染树</code>。渲染树的节点被称为渲染对象，它是一个包含有颜色等属性的矩形。渲染对象和 DOM 元素相对应，但这种关系不是一对一的，不可见的 DOM 元素不会插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行<code>布局</code>（也可以叫做回流）。这一阶段浏览器要做的是计算出各个节点在页面中确切位置和大小。通常这一行为也被称为自动重排。</li><li>布局阶段结束后是<code>绘制</code>阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示到屏幕上。值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎会尽早的将内容呈现到屏幕上，并不会等到所有 HMTL 内容都解析完之后再去构建和布局渲染树，它是解析完一部分内容就显示一部分内容，同时，可能还通过网络下载其余内容。</li></ol><h2 id="什么是回流和重绘？"><a href="#什么是回流和重绘？" class="headerlink" title="什么是回流和重绘？"></a>什么是回流和重绘？</h2><p>1.概念：</p><ul><li><code>回流</code>：当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做回流（也可以叫做重排）。表现为重新生成布局，重新排列元素。</li><li><code>重绘</code>：当一个元素的外观发生改变，重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。</li></ul><p>2.常见引起回流和重绘的属性和方法：</p><p>任何会改变元素几何信息（元素的位置和尺寸大小）的操作都会触发回流。</p><ul><li>添加或删除可见的 DOM 元素</li><li>元素尺寸改变–边距、填充、宽度、高度</li><li>浏览器尺寸改变– resize 事件发生时</li><li>计算 offsetWidth 和 offsetHeight 属性</li><li>设置 style 属性的值</li><li>修改网页默认字体</li></ul><p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong></p><p><strong>回流所需的成本比重绘高得多</strong></p><p>建议阅读文章：<a href="https://juejin.cn/post/6844903779700047885" title="https://juejin.cn/post/6844903779700047885">你真的了解回流和重绘吗</a></p><h2 id="如何减少回流？"><a href="#如何减少回流？" class="headerlink" title="如何减少回流？"></a>如何减少回流？</h2><ul><li>使用 transform 代替 top</li><li>不要把节点的属性值放在一个循环里，当成循环里的变量</li><li>不要使用 table 布局，可能很小的一个改动会造成整个 table 的重新布局</li><li>把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM</li><li>不要一条一条的修改样式，可以预先定义好 class，然后修改 DOM 的 className</li><li>使用 absolute 或 fixed 使元素脱离文档流</li></ul><h2 id="sessionStorage，localStorage-和-cookie-的区别"><a href="#sessionStorage，localStorage-和-cookie-的区别" class="headerlink" title="sessionStorage，localStorage 和 cookie 的区别"></a>sessionStorage，localStorage 和 cookie 的区别</h2><ol><li>共同点：都是保存在浏览器端，且同源的</li><li>区别:</li></ol><ul><li>cookie 始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器之间来回传递；而 sessionStorage 和 localStorage 不会自动把数据发送到服务器，仅在本地保存。cookie 还有路径（path）的概念，可以限制 cookie 只属于某个路径下。</li><li>存储大小限制不同。cookie 不能超过 4K，因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如：会话标识。sessionStorage 和 localStorage 虽然也有存储大小限制，但比 cookie 大得多，可以达到 5M 或更大。</li><li>数据有效期不同。sessionStorage 仅在当前浏览器窗口关闭之前有效；localStorage 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前有效。</li><li>作用域不同。sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和 cookie 在所有同源窗口中都是共享的。</li></ul><h2 id="iframe-有哪些优缺点？"><a href="#iframe-有哪些优缺点？" class="headerlink" title="iframe 有哪些优缺点？"></a>iframe 有哪些优缺点？</h2><p>优点：</p><ol><li>iframe 能原封不动的把嵌入的网页展现出来。</li><li>如果有多个网页引用 iframe，只需修改 iframe 的内容，就可以实现调用每一个页面的更改，方便快捷。</li></ol><p>缺点：</p><ol><li>iframe 会阻塞主页面的 onload 事件。</li><li>iframe 和主页面共享链接池，而浏览器对相同域的链接有限制，所以会影响页面的并行加载。</li><li>不利于 SEO，代码复杂，无法一下被搜索引擎索引到。</li><li>iframe 框架页面会增加服务器的 http 请求，对于大型网站不可取。</li><li>很多移动设备无法完全显示框架，设备兼容性差。</li></ol><p>注意：通过动态给 iframe 添加 src 属性值，可解决前两个问题。</p><h2 id="什么是-canvas，基本用法是什么？"><a href="#什么是-canvas，基本用法是什么？" class="headerlink" title="什么是 canvas，基本用法是什么？"></a>什么是 canvas，基本用法是什么？</h2><p>canvas 元素是 HTML5 的一部分，允许脚步语言动态渲染位图像。canvas 由一个可控制区域 HTML 代码中的属性定义决定高度和宽度。JavaScript 代码可以访问该区域，通过一套完整的绘图功能类似于其他通用二维的 API，从而生成动态的图形。</p><ol><li>创建 canvas 标签</li></ol><div class="code-wrapper"><pre><code class="hljs routeros">&lt;canvas <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;150&quot;</span> <span class="hljs-attribute">height</span>=<span class="hljs-string">&quot;150&quot;</span>&gt;该浏览器不支持canvas&lt;/canvas&gt;复制代码</code></pre></div><ol start="2"><li>渲染上下文</li></ol><div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);复制代码</code></pre></div><p>代码第一行通过使用 <code>document.getElementById()</code> 方法获取 <code>&lt;canvas&gt;</code> 元素对应的 DOM 对象，然后可以通过使用它的 <code>getContext()</code> 方法来绘制上下文。 创建 canvas 标签时可以在标签内写上不支持的提示信息；也可以通过 <code>getContext()</code> 方法判读是否支持编程。</p><div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);<span class="hljs-keyword">if</span> (canvas.getContext) &#123;  <span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);  <span class="hljs-comment">// other code</span>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 不支持 canvas 的其他代码</span>&#125;复制代码</code></pre></div><p>用途：</p><p>canvas 可用于游戏和图表（echarts.js、heightchart.js 都是基于 canvas 来绘图）制作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo创建博客</title>
    <link href="/2023/01/22/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/01/22/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo部署博客的命令"><a href="#hexo部署博客的命令" class="headerlink" title="hexo部署博客的命令"></a>hexo部署博客的命令</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>- </p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
