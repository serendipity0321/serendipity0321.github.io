<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TypeScript面试题总结</title>
    <link href="/2023/01/23/TypeScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2023/01/23/TypeScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScrip—面试题"><a href="#TypeScrip—面试题" class="headerlink" title="TypeScrip—面试题"></a>TypeScrip—面试题</h1><p>类型 支持ES6新特性 添加ES6不具备的新特性 丰富的配置选项</p><h2 id="什么是-Typescript？"><a href="#什么是-Typescript？" class="headerlink" title="什么是 Typescript？"></a><strong>什么是 Typescript？</strong></h2><p>Typescript 是 Javascript 的超集</p><h2 id="1、-TypeScript-的主要特点是什么？"><a href="#1、-TypeScript-的主要特点是什么？" class="headerlink" title="1、 TypeScript 的主要特点是什么？"></a><strong>1、 TypeScript 的主要特点是什么？</strong></h2><p><strong>跨平台</strong>：TypeScript 编译器可以安装在任何操作系统上，包括 Windows、macOS 和 Linux。</p><p><strong>ES6 特性</strong>：TypeScript 包含计划中的 ECMAScript 2015 (ES6) 的大部分特性，例如箭头函数。</p><p><strong>面向对象的语言</strong>：TypeScript 提供所有标准的 OOP 功能，如类、接口和模块。</p><p><strong>静态类型检查</strong>：TypeScript 使用静态类型并帮助在编译时进行类型检查。因此，你可以在编写代码时发现编译时错误，而无需运行脚本。</p><p><strong>可选的静态类型</strong>：如果你习惯了 JavaScript 的动态类型，TypeScript 还允许可选的静态类型。</p><p><strong>DOM 操作</strong>：您可以使用 TypeScript 来操作 DOM 以添加或删除客户端网页元素。</p><h2 id="2、使用-TypeScript-有什么好处？"><a href="#2、使用-TypeScript-有什么好处？" class="headerlink" title="2、使用 TypeScript 有什么好处？"></a><strong>2、使用 TypeScript 有什么好处？</strong></h2><p>TypeScript 更具表现力，这意味着它的语法混乱更少。</p><p>由于高级调试器专注于在编译时之前捕获逻辑错误，因此调试很容易。</p><p>静态类型使 TypeScript 比 JavaScript 的动态类型更易于阅读和结构化。</p><p>由于通用的转译，它可以跨平台使用，在客户端和服务器端项目中。</p><h2 id="3、TypeScript-的内置数据类型有哪些？"><a href="#3、TypeScript-的内置数据类型有哪些？" class="headerlink" title="3、TypeScript 的内置数据类型有哪些？"></a><strong>3、TypeScript 的内置数据类型有哪些？</strong></h2><p><strong>数字类型</strong>：用于表示数字类型的值。TypeScript 中的所有数字都存储为浮点值。</p><p>let identifier: number &#x3D; value;</p><p><strong>布尔类型</strong>：一个逻辑二进制开关，包含true或false</p><p>let identifier: string &#x3D; “ “;</p><p><strong>Null 类型</strong>：Null 表示值未定义的变量。</p><p>let identifier: bool &#x3D; Boolean value;</p><p><strong>未定义类型</strong>：一个未定义的字面量，它是所有变量的起点。</p><p>let num: number &#x3D; null;、、、、、、、</p><p><strong>void 类型</strong>：分配给没有返回值的方法的类型。</p><p>let unusable: void &#x3D; undefined;</p><h2 id="4、TypeScript-目前的稳定版本是什么？"><a href="#4、TypeScript-目前的稳定版本是什么？" class="headerlink" title="4、TypeScript 目前的稳定版本是什么？"></a><strong>4、TypeScript 目前的稳定版本是什么？</strong></h2><p>当前的稳定版本是 4.2.3。</p><h2 id="5、TypeScript-中的接口是什么？"><a href="#5、TypeScript-中的接口是什么？" class="headerlink" title="5、TypeScript 中的接口是什么？"></a><strong>5、TypeScript 中的接口是什么？</strong></h2><p>接口为使用该接口的对象定义契约或结构。</p><p>接口是用关键字定义的interface，它可以包含使用函数或箭头函数的属性和方法声明。</p><p>interface IEmployee { empCode: number; empName: string; getSalary: (number) &#x3D;&gt; number; &#x2F;&#x2F; arrow function getManagerName(number): string; }</p><h2 id="6、TypeScript-中的模块是什么？"><a href="#6、TypeScript-中的模块是什么？" class="headerlink" title="6、TypeScript 中的模块是什么？"></a><strong>6、TypeScript 中的模块是什么？</strong></h2><p>TypeScript 中的模块是相关变量、函数、类和接口的集合。</p><p>你可以将模块视为包含执行任务所需的一切的容器。可以导入模块以轻松地在项目之间共享代码。</p><p>module module_name{class xyz{export sum(x, y){return x+y;}}</p><h2 id="7、后端如何使用TypeScript？"><a href="#7、后端如何使用TypeScript？" class="headerlink" title="7、后端如何使用TypeScript？"></a><strong>7、后端如何使用TypeScript？</strong></h2><p>你可以将 Node.js 与 TypeScript 结合使用，将 TypeScript 的优势带入后端工作。</p><p>只需输入以下命令，即可将 TypeScript 编译器安装到你的 Node.js 中：</p><p>npm i -g typescript  &#x2F;&#x2F;全局安装</p><h2 id="8、TypeScript-中的类型断言是什么？"><a href="#8、TypeScript-中的类型断言是什么？" class="headerlink" title="8、TypeScript 中的类型断言是什么？"></a><strong>8、TypeScript 中的类型断言是什么？</strong></h2><p>TypeScript 中的类型断言的工作方式类似于其他语言中的类型转换，但没有 C# 和 Java 等语言中可能的类型检查或数据重组。类型断言对运行时没有影响，仅由编译器使用。</p><p>类型断言本质上是类型转换的软版本，它建议编译器将变量视为某种类型，但如果它处于不同的形式，则不会强制它进入该模型。</p><h2 id="9、如何在-TypeScript-中创建变量？"><a href="#9、如何在-TypeScript-中创建变量？" class="headerlink" title="9、如何在 TypeScript 中创建变量？"></a><strong>9、如何在 TypeScript 中创建变量？</strong></h2><p>你可以通过三种方式创建变量：var，let，和const。</p><p>var是严格范围变量的旧风格。你应该尽可能避免使用，var因为它会在较大的项目中导致问题。</p><p>var num:number &#x3D; 1;</p><p>let是在 TypeScript 中声明变量的默认方式。与var相比，let减少了编译时错误的数量并提高了代码的可读性。</p><p>let num:number &#x3D; 1;</p><p>const创建一个其值不能改变的常量变量。它使用相同的范围规则，let并有助于降低整体程序的复杂性。</p><p>const num:number &#x3D; 100;</p><h2 id="10、在TypeScript中如何从子类调用基类构造函数？"><a href="#10、在TypeScript中如何从子类调用基类构造函数？" class="headerlink" title="10、在TypeScript中如何从子类调用基类构造函数？"></a><strong>10、在TypeScript中如何从子类调用基类构造函数？</strong></h2><p>你可以使用该super()函数来调用基类的构造函数。</p><p>class Animal { name: string; constructor(theName: string) { this.name &#x3D; theName; } move(distanceInMeters: number &#x3D; 0) { console.log(<code>$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.</code>); }}class Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters &#x3D; 5) { console.log(“Slithering…”); super.move(distanceInMeters); }}</p><h2 id="11、解释如何使用-TypeScript-mixin。"><a href="#11、解释如何使用-TypeScript-mixin。" class="headerlink" title="11、解释如何使用 TypeScript mixin。"></a><strong>11、解释如何使用 TypeScript mixin。</strong></h2><p>Mixin 本质上是在相反方向上工作的继承。Mixins 允许你通过组合以前类中更简单的部分类设置来构建新类。</p><p>相反，类A继承类B来获得它的功能，类B从类A需要返回一个新类的附加功能。</p><h2 id="12、TypeScript-中如何检查-null-和-undefined？"><a href="#12、TypeScript-中如何检查-null-和-undefined？" class="headerlink" title="12、TypeScript 中如何检查 null 和 undefined？"></a><strong>12、TypeScript 中如何检查 null 和 undefined？</strong></h2><p>你可以使用 juggle-check，它检查 null 和 undefined，或者使用 strict-check，它返回true设置为null的值，并且不会评估true未定义的变量。</p><p>&#x2F;&#x2F;juggleif (x &#x3D;&#x3D; null) { }</p><p>var a: number; var b: number &#x3D; null; function check(x, name) { if (x &#x3D;&#x3D; null) { console.log(name + ‘ &#x3D;&#x3D; null’); } if (x &#x3D;&#x3D;&#x3D; null) { console.log(name + ‘ &#x3D;&#x3D;&#x3D; null’); } if (typeof x &#x3D;&#x3D;&#x3D; ‘undefined’) { console.log(name + ‘ is undefined’); } } check(a, ‘a’); check(b, ‘b’);</p><h2 id="13、TypeScript-中的-getter-x2F-setter-是什么？你如何使用它们？"><a href="#13、TypeScript-中的-getter-x2F-setter-是什么？你如何使用它们？" class="headerlink" title="13、TypeScript 中的 getter&#x2F;setter 是什么？你如何使用它们？"></a><strong>13、TypeScript 中的 getter&#x2F;setter 是什么？你如何使用它们？</strong></h2><p>Getter 和 setter 是特殊类型的方法，可帮助你根据程序的需要委派对私有变量的不同级别的访问。</p><p>Getters 允许你引用一个值但不能编辑它。Setter 允许你更改变量的值，但不能查看其当前值。这些对于实现封装是必不可少的。</p><p>例如，新雇主可能能够了解get公司的员工人数，但无权set了解员工人数。</p><p>const fullNameMaxLength &#x3D; 10;class Employee { private _fullName: string &#x3D; “”; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (newName &amp;&amp; newName.length &gt; fullNameMaxLength) { throw new Error(“fullName has a max length of “ + fullNameMaxLength); } this._fullName &#x3D; newName; }}let employee &#x3D; new Employee();employee.fullName &#x3D; “Bob Smith”;if (employee.fullName) { console.log(employee.fullName);}</p><h2 id="14、-如何允许模块外定义的类可以访问？"><a href="#14、-如何允许模块外定义的类可以访问？" class="headerlink" title="14、 如何允许模块外定义的类可以访问？"></a><strong>14、 如何允许模块外定义的类可以访问？</strong></h2><p>你可以使用export关键字打开模块以供在模块外使用。</p><p>module Admin { &#x2F;&#x2F; use the export keyword in TypeScript to access the class outside export class Employee { constructor(name: string, email: string) { } } let alex &#x3D; new Employee(‘alex’, ‘<a href="mailto:&#x61;&#108;&#x65;&#x78;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;">&#x61;&#108;&#x65;&#x78;&#x40;&#103;&#109;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;</a>‘);}&#x2F;&#x2F; The Admin variable will allow you to access the Employee class outside the module with the help of the export keyword in TypeScriptlet nick &#x3D; new Admin.Employee(‘nick’, ‘<a href="mailto:&#x6e;&#x69;&#99;&#x6b;&#x40;&#121;&#x61;&#x68;&#111;&#111;&#x2e;&#99;&#x6f;&#x6d;">&#x6e;&#x69;&#99;&#x6b;&#x40;&#121;&#x61;&#x68;&#111;&#111;&#x2e;&#99;&#x6f;&#x6d;</a>‘);</p><h2 id="15、如何使用-Typescript-将字符串转换为数字？"><a href="#15、如何使用-Typescript-将字符串转换为数字？" class="headerlink" title="15、如何使用 Typescript 将字符串转换为数字？"></a><strong>15、如何使用 Typescript 将字符串转换为数字？</strong></h2><p>与 JavaScript 类似，你可以使用parseInt或parseFloat函数分别将字符串转换为整数或浮点数。你还可以使用一元运算符+将字符串转换为最合适的数字类型，“3”成为整数，3而“3.14”成为浮点数3.14。</p><p>var x &#x3D; “32”;var y: number &#x3D; +x;</p><h2 id="16、什么是-map-文件，为什么-x2F-如何使用它？"><a href="#16、什么是-map-文件，为什么-x2F-如何使用它？" class="headerlink" title="16、什么是 .map 文件，为什么&#x2F;如何使用它？"></a><strong>16、什么是 .map 文件，为什么&#x2F;如何使用它？</strong></h2><p>甲.map文件是源地图，显示原始打字稿代码是如何解释成可用的JavaScript代码。它们有助于简化调试，因为你可以捕获任何奇怪的编译器行为。</p><p>调试工具还可以使用这些文件来允许你编辑底层的 TypeScript 而不是发出的 JavaScript 文件。</p><h2 id="17、TypeScript-中的类是什么？你如何定义它们？"><a href="#17、TypeScript-中的类是什么？你如何定义它们？" class="headerlink" title="17、TypeScript 中的类是什么？你如何定义它们？"></a><strong>17、TypeScript 中的类是什么？你如何定义它们？</strong></h2><p>类表示一组相关对象的共享行为和属性。</p><p>例如，我们的类可能是Student，其所有对象都具有该attendClass方法。另一方面，John是一个单独的 type 实例，Student可能有额外的独特行为，比如attendExtracurricular.</p><p>你使用关键字声明类class：</p><p>class Student { studCode: number; studName: string; constructor(code: number, name: string) { this.studName &#x3D; name; this.studCode &#x3D; code; }</p><h2 id="18、TypeScript-与-JavaScript-有什么关系？"><a href="#18、TypeScript-与-JavaScript-有什么关系？" class="headerlink" title="18、TypeScript 与 JavaScript 有什么关系？"></a><strong>18、TypeScript 与 JavaScript 有什么关系？</strong></h2><p>TypeScript 是 JavaScript 的开源语法超集，可编译为 JavaScript。所有原始 JavaScript 库和语法仍然有效，但 TypeScript 增加了 JavaScript 中没有的额外语法选项和编译器功能。</p><p>TypeScript 还可以与大多数与 JavaScript 相同的技术接口，例如 Angular 和 jQuery。</p><h2 id="19、TypeScript-中的-JSX-是什么？"><a href="#19、TypeScript-中的-JSX-是什么？" class="headerlink" title="19、TypeScript 中的 JSX 是什么？"></a><strong>19、TypeScript 中的 JSX 是什么？</strong></h2><p>JSX 是一种可嵌入的类似于 XML 的语法，允许你创建 HTML。TypeScript 支持嵌入、类型检查和将 JSX 直接编译为 JavaScript。</p><h2 id="20、TypeScript-支持哪些-JSX-模式？"><a href="#20、TypeScript-支持哪些-JSX-模式？" class="headerlink" title="20、TypeScript 支持哪些 JSX 模式？"></a><strong>20、TypeScript 支持哪些 JSX 模式？</strong></h2><p>TypeScript有内置的支持preserve，react和react-native。</p><p>preserve 保持 JSX 完整以用于后续转换。</p><p>react不经过 JSX 转换，而是react.createElement作为.js文件扩展名发出和输出。</p><p>react-native结合起来preserve，react因为它维护所有 JSX 和输出作为.js扩展。</p><h2 id="21、如何编译-TypeScript-文件？"><a href="#21、如何编译-TypeScript-文件？" class="headerlink" title="21、如何编译 TypeScript 文件？"></a><strong>21、如何编译 TypeScript 文件？</strong></h2><p>你需要调用 TypeScript 编译器tsc来编译文件。你需要安装 TypeScript 编译器，你可以使用npm.</p><p>npm install -g typescripttsc <TypeScript File Name></p><h2 id="22、-TypeScript-中有哪些范围可用？这与JS相比如何？"><a href="#22、-TypeScript-中有哪些范围可用？这与JS相比如何？" class="headerlink" title="22、 TypeScript 中有哪些范围可用？这与JS相比如何？"></a><strong>22、 TypeScript 中有哪些范围可用？这与JS相比如何？</strong></h2><p>全局作用域：在任何类之外定义，可以在程序中的任何地方使用。</p><p>函数&#x2F;类范围：在函数或类中定义的变量可以在该范围内的任何地方使用。</p><p>局部作用域&#x2F;代码块：在局部作用域中定义的变量可以在该块中的任何地方使用。</p><h2 id="23、TypeScript-中的箭头-x2F-lambda-函数是什么？"><a href="#23、TypeScript-中的箭头-x2F-lambda-函数是什么？" class="headerlink" title="23、TypeScript 中的箭头&#x2F;lambda 函数是什么？"></a><strong>23、TypeScript 中的箭头&#x2F;lambda 函数是什么？</strong></h2><p>胖箭头函数是用于定义匿名函数的函数表达式的速记语法。它类似于其他语言中的 lambda 函数。箭头函数可让你跳过function关键字并编写更简洁的代码。</p><h2 id="24、解释rest参数和声明rest参数的规则。"><a href="#24、解释rest参数和声明rest参数的规则。" class="headerlink" title="24、解释rest参数和声明rest参数的规则。"></a><strong>24、解释rest参数和声明rest参数的规则。</strong></h2><p>其余参数允许你将不同数量的参数（零个或多个）传递给函数。当你不确定函数将接收多少参数时，这很有用。其余符号之后的所有参数…都将存储在一个数组中。</p><p>例如：</p><p>function Greet(greeting: string, …names: string[]) { return greeting + “ “ + names.join(“, “) + “!”;}Greet(“Hello”, “Steve”, “Bill”); &#x2F;&#x2F; returns “Hello Steve, Bill!”Greet(“Hello”);&#x2F;&#x2F; returns “Hello !”</p><p>rest 参数必须是参数定义的最后一个，并且每个函数只能有一个 rest 参数。</p><h2 id="25、什么是三斜线指令？有哪些三斜杠指令？"><a href="#25、什么是三斜线指令？有哪些三斜杠指令？" class="headerlink" title="25、什么是三斜线指令？有哪些三斜杠指令？"></a><strong>25、什么是三斜线指令？有哪些三斜杠指令？</strong></h2><p>三斜线指令是单行注释，包含用作编译器指令的 XML 标记。每个指令都表示在编译过程中要加载的内容。三斜杠指令仅在其文件的顶部工作，并且将被视为文件中其他任何地方的普通注释。</p><p>&#x2F;&#x2F;&#x2F; <reference path="..." /> 是最常见的指令，定义文件之间的依赖关系。</p><p>&#x2F;&#x2F;&#x2F; <reference types="..." />类似于path但定义了包的依赖项。</p><p>&#x2F;&#x2F;&#x2F; <reference lib="..." />允许您显式包含内置lib文件。</p><h2 id="26、Omit类型有什么作用？"><a href="#26、Omit类型有什么作用？" class="headerlink" title="26、Omit类型有什么作用？"></a><strong>26、Omit类型有什么作用？</strong></h2><p>Omit是实用程序类型的一种形式，它促进了常见的类型转换。Omit允许你通过传递电流Type并选择Keys在新类型中省略来构造类型。</p><p>Omit&lt;Type, Keys&gt;</p><p>例如：</p><p>interface Todo { title: string; description: string; completed: boolean; createdAt: number;}type TodoPreview &#x3D; Omit&lt;Todo, “description”&gt;;</p><h2 id="27、TypeScript中如何实现函数重载？"><a href="#27、TypeScript中如何实现函数重载？" class="headerlink" title="27、TypeScript中如何实现函数重载？"></a><strong>27、TypeScript中如何实现函数重载？</strong></h2><p>要在 TypeScript 中重载函数，只需创建两个名称相同但参数&#x2F;返回类型不同的函数。两个函数必须接受相同数量的参数。这是 TypeScript 中多态性的重要组成部分。</p><p>例如，你可以创建一个add函数，如果它们是数字，则将两个参数相加，如果它们是字符串，则将它们连接起来。</p><p>function add(a:string, b:string):string;function add(a:number, b:number): number;function add(a: any, b:any): any { return a + b;}add(“Hello “, “Steve”); &#x2F;&#x2F; returns “Hello Steve” add(10, 20); &#x2F;&#x2F; returns 30</p><h2 id="28、如何让接口的所有属性都可选？"><a href="#28、如何让接口的所有属性都可选？" class="headerlink" title="28、如何让接口的所有属性都可选？"></a><strong>28、如何让接口的所有属性都可选？</strong></h2><p>你可以使用partial映射类型轻松地将所有属性设为可选。</p><h2 id="29、什么时候应该使用关键字unknown？"><a href="#29、什么时候应该使用关键字unknown？" class="headerlink" title="29、什么时候应该使用关键字unknown？"></a><strong>29、什么时候应该使用关键字unknown？</strong></h2><p>unknown，如果你不知道预先期望哪种类型，但想稍后分配它，则应该使用该any关键字，并且该关键字将不起作用。</p><h2 id="30、什么是装饰器，它们可以应用于什么？"><a href="#30、什么是装饰器，它们可以应用于什么？" class="headerlink" title="30、什么是装饰器，它们可以应用于什么？"></a><strong>30、什么是装饰器，它们可以应用于什么？</strong></h2><p>装饰器是一种特殊的声明，它允许你通过使用@<name>注释标记来一次性修改类或类成员。每个装饰器都必须引用一个将在运行时评估的函数。</p><p>例如，装饰器@sealed将对应于sealed函数。任何标有 的@sealed都将用于评估sealed函数。</p><p>function sealed(target) { &#x2F;&#x2F; do something with ‘target’ …}</p><p>它们可以附加到：</p><p>类声明</p><p>方法</p><p>配件</p><p>特性</p><p>参数</p>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解ES6</title>
    <link href="/2023/01/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/"/>
    <url>/2023/01/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/</url>
    
    <content type="html"><![CDATA[<h3 id="ECMAScript简介"><a href="#ECMAScript简介" class="headerlink" title="ECMAScript简介"></a>ECMAScript简介</h3><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><p>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和ActionScript），日常场合，这两个词是可以互换的。</p><h3 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>ES6 新增了<code>let</code>和<code>const</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>和<code>const</code>命令所在的代码块内有效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> j=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> k=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>var：存在变量提升，可以在声明前使用，值为<code>undefined</code>。</p><p>let：存在块级作用域，声明的变量一定要在声明过后使用，不然会报错，不可重复声明。</p><p>const：常量的值不能改变。，不可重复声明</p><p>ES5 只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6 除了添加<code>let</code>和<code>const</code>命令，还有另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6 一共有 6 种声明变量的方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3的组合式API详解</title>
    <link href="/2023/01/23/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/01/23/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install <br></code></pre></td></tr></table></figure><p>文档地址：<a href="https://cn.vuejs.org/api/">API 参考 | Vue.js (vuejs.org)</a></p><p>Vue3 组合式 API（Composition API） 主要用于在大型组件中提高代码逻辑的可复用性。</p><p>传统的组件随着业务复杂度越来越高，代码量会不断的加大，整个代码逻辑都不易阅读和理解。</p><p>Vue3 使用组合式 API 的代码地方为 setup。</p><p>在 setup 中，我们可以按逻辑关注点对部分代码进行分组，然后提取逻辑片段并与其他组件共享代码。因此，组合式 API（Composition API）允许我们编写更有条理的代码。</p><p>vue3 API主要包含以下六个部分：</p><ol><li>全局API —— 全局会用到的API</li><li>组合式API —— vue3所拥有的组合式API</li><li>选项式API —— vue2所拥有的选项式API</li><li>内置内容 —— 指令、组件、特殊元素和特殊属性</li><li>单文件组件 —— 语法定义</li><li>进阶API —— 渲染函数、服务端渲染、TS工具类型和自定义渲染</li></ol><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/1.png"></p><h1 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h1><p>Vue3的全局API包含两个部分：应用实例和通用API。</p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/3.jpg"></p><h2 id="通用API"><a href="#通用API" class="headerlink" title="通用API"></a>通用API</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/4.png"></p><h1 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h1><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/5.png"></p><h2 id="响应式：核心"><a href="#响应式：核心" class="headerlink" title="响应式：核心"></a>响应式：核心</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/5.png"></p><h2 id="响应式：工具函数"><a href="#响应式：工具函数" class="headerlink" title="响应式：工具函数"></a>响应式：工具函数</h2><p>![]222222</p><h2 id="响应式：进阶"><a href="#响应式：进阶" class="headerlink" title="响应式：进阶"></a>响应式：进阶</h2><p>![22222</p><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><p>![22222</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p><img src="/imgs/Vue3%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8FAPI%E8%AF%A6%E8%A7%A3/5.png"></p><h1 id="选项式API"><a href="#选项式API" class="headerlink" title="选项式API"></a>选项式API</h1><h2 id="状态选项"><a href="#状态选项" class="headerlink" title="状态选项"></a>状态选项</h2><p>111</p><h2 id="渲染选项"><a href="#渲染选项" class="headerlink" title="渲染选项"></a>渲染选项</h2><p>1111</p><h2 id="生命周期选项"><a href="#生命周期选项" class="headerlink" title="生命周期选项"></a>生命周期选项</h2><p>11111</p><h2 id="组合选项"><a href="#组合选项" class="headerlink" title="组合选项"></a>组合选项</h2><p>!1111</p><h2 id="其他杂项"><a href="#其他杂项" class="headerlink" title="其他杂项"></a>其他杂项</h2><p>111</p><h2 id="组件实例"><a href="#组件实例" class="headerlink" title="组件实例"></a>组件实例</h2><p>!11111</p><h1 id="内置内容"><a href="#内置内容" class="headerlink" title="内置内容"></a>内置内容</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>!11111</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>!1111</p><h2 id="特殊元素"><a href="#特殊元素" class="headerlink" title="特殊元素"></a>特殊元素</h2><p>!11111</p><h2 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h2><p>![](111111</p><h1 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h1><h2 id="SFC语法定义"><a href="#SFC语法定义" class="headerlink" title="SFC语法定义"></a>SFC语法定义</h2><p>![]1111</p><h2 id="单文件组件script-setup"><a href="#单文件组件script-setup" class="headerlink" title="单文件组件script setup"></a>单文件组件script setup</h2><p>![111111</p><h2 id="css功能"><a href="#css功能" class="headerlink" title="css功能"></a>css功能</h2><p>1111</p><h1 id="进阶API"><a href="#进阶API" class="headerlink" title="进阶API"></a>进阶API</h1><h2 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h2><p>1111</p><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>1111</p><h2 id="TypeScript工具类型"><a href="#TypeScript工具类型" class="headerlink" title="TypeScript工具类型"></a>TypeScript工具类型</h2><p>1111</p><h2 id="自定义渲染"><a href="#自定义渲染" class="headerlink" title="自定义渲染"></a>自定义渲染</h2><p>1111</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对包依赖管理工具的了解</title>
    <link href="/2023/01/23/%E5%AF%B9%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
    <url>/2023/01/23/%E5%AF%B9%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>npm</tag>
      
      <tag>yarn</tag>
      
      <tag>pnpm</tag>
      
      <tag>cnpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS面试记录</title>
    <link href="/2023/01/22/CSS%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/22/CSS%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="如何实现一个元素的水平垂直居中？"><a href="#如何实现一个元素的水平垂直居中？" class="headerlink" title="如何实现一个元素的水平垂直居中？"></a>如何实现一个元素的水平垂直居中？</h2><p>要求对行内元素、块状元素及不定宽高的块状元素均可适用：</p><h2 id="css3-有哪些新特性？"><a href="#css3-有哪些新特性？" class="headerlink" title="css3 有哪些新特性？"></a>css3 有哪些新特性？</h2><ul><li>rgba 和 透明度</li><li>background-image、background-origin、background-size、background-repeat</li><li>word-wrap: break-word（对长的不可分割的单词换行）</li><li>文字阴影 text-shadow</li><li>font-face属性，定义自己的字体</li><li>border-radius</li><li>边框图片 border-image</li><li>盒阴影 box-shadow</li><li>媒体查询：定义多套 css，当浏览器尺寸发生变化时采用不同的属性</li></ul><h2 id="style-标签写在-body-后与-body-前有什么区别？"><a href="#style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="style 标签写在 body 后与 body 前有什么区别？"></a>style 标签写在 body 后与 body 前有什么区别？</h2><ol><li>写在 body 标签前有利于浏览器逐步渲染： resources downloading –&gt; cssDOM + DOM –&gt; Render Tree –&gt; layout –&gt; paint</li><li>写在 body 标签后： 由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载且解析样式完成后重新渲染；在 windows 的 IE 下可能出现样式失效导致的页面闪烁问题。</li></ol><h2 id="CSS选择器及优先级"><a href="#CSS选择器及优先级" class="headerlink" title="CSS选择器及优先级"></a>CSS选择器及优先级</h2><ol><li>选择器<ul><li>id选择器(#myid)</li><li>类选择器(.myclass)</li><li>属性选择器(a[rel&#x3D;”external”])</li><li>伪类选择器(a:hover, li:nth-child)</li><li>标签选择器(div, h1, p)</li><li>伪元素选择器(p::first-line)</li><li>相邻选择器（h1 + p）</li><li>子选择器(ul &gt; li)</li><li>后代选择器(li a)</li><li>通配符选择器(*)</li></ul></li><li>优先级<ul><li><code>!important</code></li><li>内联样式（1000）</li><li>ID选择器（0100）</li><li>类选择器 &#x2F; 属性选择器 &#x2F; 伪类选择器（0010）</li><li>标签选择器 &#x2F; 伪元素选择器（0001）</li><li>关系选择器 &#x2F; 通配符选择器（0000）</li></ul></li></ol><p>带 !important 标记的样式属性优先级最高；样式表的来源相同时：<code>!important &gt; 行内样式&gt; ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</code></p><h2 id="rgba-和-opacity-设置透明度的区别是什么？"><a href="#rgba-和-opacity-设置透明度的区别是什么？" class="headerlink" title="rgba() 和 opacity 设置透明度的区别是什么？"></a>rgba() 和 opacity 设置透明度的区别是什么？</h2><p>rgba() 和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度；而 rgba() 只作用于元素的颜色或其背景色，设置 rgba() 透明的元素的子元素不会继承透明效果。</p><h2 id="浏览器是如何解析-css-选择器等？"><a href="#浏览器是如何解析-css-选择器等？" class="headerlink" title="浏览器是如何解析 css 选择器等？"></a>浏览器是如何解析 css 选择器等？</h2><p><code>从右向左解析的。</code>若从左向右匹配，发现不符合规则，需要回溯，会损失很多性能。若从右向左匹配，先找到所有的最后节点，对于每一个节点，向上寻找其父节点直到查找至根元素或满足条件的匹配规则，则结束这个分支的遍历。</p><p>在 css 解析完毕后，需将解析结果 css 规则树和 DOM Tree 一起进行分析建立一颗 Render Tree，最终用来进行绘图。</p><h2 id="display-none-和-visibility-hidden-两者的区别"><a href="#display-none-和-visibility-hidden-两者的区别" class="headerlink" title="display: none 和 visibility: hidden 两者的区别"></a>display: none 和 visibility: hidden 两者的区别</h2><ol><li>display: none 隐藏后不占用文档流；而 visibility: hidden 会占用文档流。</li><li>visibility 具有继承性，给父元素设置 “visibility: hidden”，子元素也会继承该属性，但如果重新给子元素设置 “visibility: visible”，则子元素又会显示出来。</li><li>visibility: hidden 不会影响计数器的计数，虽然隐藏了，但计数器依然运行着。</li><li>在 css3 中 transition 支持 visibility 属性，但不支持 display。因为 transition 可以延迟执行，因此配合 visibility 使用纯 css 延时显示效果可以提高用户体验。</li><li>display: none 会引起回流（重排）和重绘；visibility: hidden 会引起重绘。</li></ol><h2 id="简述-transform，transition，animation-的作用"><a href="#简述-transform，transition，animation-的作用" class="headerlink" title="简述 transform，transition，animation 的作用"></a>简述 transform，transition，animation 的作用</h2><ol><li><code>transform</code>：描述了元素的静态样式，本身不会呈现动画效果，可以对元素进行旋转 rotate、扭曲 skew、缩放 scale 和移动 translate 以及矩阵变形 matrix。<code>transition</code> 和 <code>animation</code> 两者都能实现动画效果。<code>transform</code> 常配合<code>transition</code> 和 <code>animation</code> 使用。</li><li><code>transition</code>：样式过渡，从一种效果逐渐改变为另一种效果，它是一个合写属性。transition: transition-property transition-duration transition-timing-function transition-delay 从左到右，依次是：过渡效果的css属性名称、过渡效果花费时间、速度曲线、过渡开始的延迟时间 <code>transition</code> 通常和 hover 等事件配合使用，需要由事件来触发过渡。</li><li><code>animation</code>：动画，有 <code>@keyframes</code> 来描述每一帧的样式。</li></ol><p>区别：</p><ul><li><code>transform</code> 仅描述元素的静态样式，常配合<code>transition</code> 和 <code>animation</code> 使用。</li><li><code>transition</code> 通常和 hover 等事件配合使用；<code>animation</code> 是自发的，立即播放。</li><li><code>animation</code> 可以设置循环次数。</li><li><code>animation</code> 可以设置每一帧的样式和时间，<code>transition</code> 只能设置头尾。</li><li><code>transition</code> 可以与 js 配合使用， js 设定要变化的样式，<code>transition</code> 负责动画效果。</li></ul><h2 id="line-height-如何继承？"><a href="#line-height-如何继承？" class="headerlink" title="line-height 如何继承？"></a>line-height 如何继承？</h2><ul><li>父元素的 <code>line-height</code> 是具体数值，则子元素 <code>line-height</code> 继承该值。</li><li>父元素的 <code>line-height</code> 是比例值，如’2’，则子元素 <code>line-height</code> 继承该比例。</li><li>父元素的 <code>line-height</code> 是百分比，则子元素 <code>line-height</code> 继承的是父元素的 font-size * 百分比 计算出来的值。</li></ul><h2 id="如何让-chrome-支持-10px-的文字？"><a href="#如何让-chrome-支持-10px-的文字？" class="headerlink" title="如何让 chrome 支持 10px 的文字？"></a>如何让 chrome 支持 10px 的文字？</h2><ol><li>font-size: 12px; -webkit-transform: scale(0.84);</li><li>font-size: 20px; -webkit-transform: scale(0.5);</li></ol><h2 id="position-属性的值有哪些？"><a href="#position-属性的值有哪些？" class="headerlink" title="position 属性的值有哪些？"></a>position 属性的值有哪些？</h2><ol><li><code>static</code>：默认定位。元素出现在正常的文档流中（忽略top，bottom，left，right 或 z-index声明）</li><li><code>relative</code>：相对定位。如果对一个元素进行相对定位，将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，使其“相对于”它的起点进行移动。使用相对定位时，无论是否移动，元素仍然占据原来的空间；移动元素会导致其覆盖其他元素。</li><li><code>absolute</code>：绝对定位。元素的位置相对于最近的已定位的父元素，如果元素没有已定位的父元素，则相对于根元素（即 html 元素）定位。绝对定位的元素会脱离文档流，不占据空间，会与其他元素重叠。</li><li><code>fixed</code>：固定定位。元素的位置相对于浏览器窗口是固定位置，即使窗口滚动它也不会移动。固定定位的元素会脱离文档流，不占据空间，会与其他元素重叠。</li><li><code>sticky</code>：粘性定位。粘性定位可以被认为是相对定位和固定定位的混合，元素在跨越特定阈值前为相对定位，之后为固定定位。top，right，buttom，left，必须指定这四个阈值中的一个，才可以使粘性定位生效，否则行为与其相对定位相同。</li><li><code>inherit</code>：规定应该从父元素继承 position 属性的值。</li></ol><h2 id="css-盒模型？"><a href="#css-盒模型？" class="headerlink" title="css 盒模型？"></a>css 盒模型？</h2><ul><li><code>标准盒模型</code>，width 指 content 部分的宽度，总宽度 &#x3D; width + border(左右) + padding（左右）+ margin（左右）；高度同理。</li><li><code>怪异盒模型（IE盒模型）</code>，width 指 content + border（左右） + padding（左右）三部分的宽度，因此，总宽度 &#x3D; width + margin（左右）；高度同理。</li></ul><h2 id="box-sizing-属性"><a href="#box-sizing-属性" class="headerlink" title="box-sizing 属性"></a>box-sizing 属性</h2><ol><li><code>content-box</code>，对应标准盒模型。</li><li><code>border-box</code>，IE盒模型。</li><li><code>inherit</code>，继承父元素的 box-sizing 值。</li></ol><h2 id="BFC（块级格式上下文）"><a href="#BFC（块级格式上下文）" class="headerlink" title="BFC（块级格式上下文）"></a>BFC（块级格式上下文）</h2><ol><li>概念： BFC（Block Formatting Context），块级格式上下文。BFC 是 css 布局的一个概念，是一个独立的渲染区域，规定了内部 box 如何布局，且这个区域内的子元素不会影响到外面的元素。</li><li>布局规则：</li></ol><ul><li>内部的 box 会在垂直方向一个接一个的放置</li><li>box 垂直方向的距离由 margin 决定，同一个 BFC 相邻的 box 的 margin 会发生重叠</li><li>每个 box 的 margin 左边，与包含块的左 border 相接触（对于从左往右的格式化，否则相反）</li><li>BFC 的区域不会与 float box 重叠</li><li>BFC 是一个独立容器，容器内的子元素不会影响到外面的元素</li><li>计算 BFC 高度时，浮动元素也参与计算高度</li></ul><ol start="3"><li>如何创建 BFC ？</li></ol><ul><li>根元素，即 html 元素</li><li>float 值不为 none</li><li>position 值为 absolute 或 fixed</li><li>display 的值为 inline-block、tabl-cell、table-caption</li><li>overflow 的值不为 visible</li></ul><ol start="4"><li>BFC 的使用场景</li></ol><ul><li>去除边距重叠问题</li><li>清除浮动（让父元素的高度包含子浮动元素）</li><li>阻止元素被浮动元素覆盖</li></ul><h2 id="让一个元素水平-x2F-垂直居中"><a href="#让一个元素水平-x2F-垂直居中" class="headerlink" title="让一个元素水平&#x2F;垂直居中"></a>让一个元素水平&#x2F;垂直居中</h2><ol><li>水平居中</li></ol><ul><li>行内元素：<code>text-align: center;</code></li><li>对于确定宽度的块级元素<ul><li>width 和 margin 实现： <code>mragin: 0 auto;</code></li><li>绝对定位和 margin-left 实现： <code>margin-left: (父width - 子 width)/2；</code>(前提是父元素相对定位)</li></ul></li><li>对于宽度未知的块级元素<ul><li>table 标签配合 margin 左右 auto 实现</li><li>inline-block 实现：<code>display: inline-block; text-align: center;</code></li><li>绝对定位和 transform 实现， translateX 可以移动本身元素的50%</li><li>flex 布局 <code>justify-content: center</code></li></ul></li></ul><ol start="2"><li>垂直居中</li></ol><ul><li>纯文字类，设置 line-height 等于 height</li><li>子绝父相，子元素通过 margin 实现自适应居中</li><li>子绝父相，通过位移 transform 实现</li><li>flex 布局，<code>align-items: center;</code></li><li>table 布局，父级通过转换为表格形式，子级设置 vertical-align 实现</li></ul><h2 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h2><p>flex 布局，是一种弹性盒布局模型，给子元素提供了空间分布和对齐能力，由<code>container</code>（容器）及<code>item</code>（项目）组成。该布局模型提供了一种更加高效的方式来对容器中的项目进行布局、对齐和分配空间。适用于在不同尺寸的屏幕中创建可自动扩展和收缩布局，通常可用于<code>水平/垂直居中</code>，<code>两栏</code>、<code>三栏布局</code>等的场景里。</p><p>其中<code>flex</code>属性是<code>flex-grow</code>，<code>flex-shrink</code>和<code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。<strong>该属性有两个快捷值：<code>auto (1 1 auto)</code> 和 <code>none (0 0 auto)</code>。</strong></p><ul><li><p><code>flex-grow</code>：定义项目的放大比例，默认值为 0，即如果存在剩余空间，也不放大。如果所有项目的<code>flex-grow</code>属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p></li><li><p><code>flex-shrink</code>：项目的缩小比例，默认为 1，即如果空间不足，项目将缩小。如果所有项目的<code>flex-shrink</code>属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</p></li><li><p><code>flex-basis</code>：定义了在分配多余空间之前，项目占据的主轴空间。浏览器会根据该属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。当设置为 0 的是，会根据内容撑开。也可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如 350px），则项目将占据固定空间。</p></li></ul><p><code>flex</code>常用的属性值：</p><ul><li>flex: 1 –&gt; flex: 1 1 0%</li><li>flex: 2 –&gt; flex: 2 1 0%</li><li>flex: auto –&gt; flex: 1 1 auto</li><li>flex: none –&gt; flex: 0 0 auto【常用于固定尺寸不伸缩】</li></ul><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><ol><li>直接把 <code>&lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;</code>作为最后一个子标签<ul><li>优点：通俗易懂，容易掌握；</li><li>缺点：会添加较多无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦</li></ul></li><li>.clearfix { overflow: hidden; zoom: 1; }<ul><li>优点：不存在结构和语义化问题，代码量极少</li><li>缺点：内容增多时容易造成不自动换行，导致内容被隐藏掉，无法显示需要溢出的元素</li></ul></li><li>建立伪类选择器</li></ol><p><img src="/../imgs/CSS%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/98e2353e3275475095bd26ecedfa32e9tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="image.png"></p><h2 id="css-中优雅降级和渐进增强有什么区别？"><a href="#css-中优雅降级和渐进增强有什么区别？" class="headerlink" title="css 中优雅降级和渐进增强有什么区别？"></a>css 中优雅降级和渐进增强有什么区别？</h2><p>优雅降级和渐进增强是随着 css3 流出来的一个概念。由于低级浏览器不支持 css3， 但 css3 的效果又很优秀不忍放弃，所以在高级浏览器中使用 css3 ，而在低级浏览器只保证最基本的功能。二者最关键的区别是它们所侧重的内容，以及这种不同所造成的工作流程的差异。</p><ul><li><code>优雅降级</code>：一开始就构建完整的功能，然后针对浏览器测试和修复。</li><li><code>渐进增强</code>：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能以达到更好的体验。</li></ul><h2 id="img-的-alt-和-title-的异同？实现图片懒加载的原理？"><a href="#img-的-alt-和-title-的异同？实现图片懒加载的原理？" class="headerlink" title="img 的 alt 和 title 的异同？实现图片懒加载的原理？"></a>img 的 alt 和 title 的异同？实现图片懒加载的原理？</h2><ul><li><code>alt</code>是图片加载失败时显示在网页上的替代文字；<code>title</code>是鼠标放在图片上面时显示的文字，是对图片的进一步描述和说明。</li><li><code>alt</code>是 img 的必要属性；<code>title</code>不是。</li><li>对于网站 SEO 优先来说，搜索引擎对图片意思的判断，主要是靠<code>alt</code>属性，所以在图片<code>alt</code>属性中以简要文字说明，同时包含关键字，也是页面优化的一部分。</li></ul><p><code>懒加载原理</code>：先设置图片的 <code>data-set</code> 属性值（也可以是其他任意的，只要不发生 http 请求就可以，作用是为了存取值）为图片路径，由于不是 <code>src</code> 属性，故不会发生 http 请求。然后计算出页面的 scrollTop 的高度和浏览器的高度之和，如果图片距页面顶端距离小于前两者之和，说明图片要显示出来了，这时将 <code>data-set</code> 属性替换为 <code>src</code> 属性即可。</p><h2 id="css-sprites-（雪碧图-x2F-精灵图）"><a href="#css-sprites-（雪碧图-x2F-精灵图）" class="headerlink" title="css sprites （雪碧图&#x2F;精灵图）"></a>css sprites （雪碧图&#x2F;精灵图）</h2><p>css sprites 就是把网页中一些小图片整合到一张图片文件中，再利用 css 的 background-image、background-repeat、background-position 的组合进行背景定位。</p><p>优点： 减少图片体积；减少 http 请求次数</p><p>缺点：维护比较麻烦；不能随便改变大小，会失真模糊</p><h2 id="什么是字体图标？"><a href="#什么是字体图标？" class="headerlink" title="什么是字体图标？"></a>什么是字体图标？</h2><p>字体图标简单的说，就是一种特殊的字体，通过这种字体，显示给用户的就像一个个图片一样。字体图标最大的好处，在于它不会变形和加载速度快。字体图标可以像文字一样，随意通过 css 来控制它的大小和颜色，非常方便。</p><h2 id="主流浏览器内核私有属性-css-前缀？"><a href="#主流浏览器内核私有属性-css-前缀？" class="headerlink" title="主流浏览器内核私有属性 css 前缀？"></a>主流浏览器内核私有属性 css 前缀？</h2><ul><li>mozilla(firefox、flock等): -moz</li><li>webkit 内核(safari、chrome等): -webkit</li><li>opera 内核(opera浏览器): -o</li><li>trident 内核(ie 浏览器): -ms</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML面试记录</title>
    <link href="/2023/01/22/HTML%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/01/22/HTML%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><ol><li>语义化，指对文本内容的结构化（内容语义化），选择合乎语义的标签（代码语义化）。</li><li>语义化标签：<code>header</code>、<code>nav</code>、<code>main</code>、<code>article</code>、<code>section</code>、<code>aside</code>、<code>footer</code>等。</li><li>优点：<ul><li>代码结构清晰，易于阅读，有利于维护</li><li>方便其他设备解析（如：屏幕阅读器）</li><li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li></ul></li></ol><p>建议阅读文章：<a href="https://link.juejin.cn/?target=https://rainylog.com/post/ife-note-1/" title="https://rainylog.com/post/ife-note-1/">百度ife的h5语义化文章</a></p><h2 id="script-标签中属性-async-和-defer-的区别？"><a href="#script-标签中属性-async-和-defer-的区别？" class="headerlink" title="script 标签中属性 async 和 defer 的区别？"></a>script 标签中属性 async 和 defer 的区别？</h2><ul><li><code>script</code> 会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML</li><li><code>async script</code>：解析 HTML 的过程中会进行脚本的异步下载，下载成功后立马执行，因此有可能会阻断 HTML 的解析。多个脚本的执行顺序无法保证。</li><li><code>defer script</code>：也是异步下载脚步，加载完成后，如果此时 HTML 还没有解析完，浏览器不会暂停解析去执行 JS 代码，而是等待 HTML 解析完毕再执行 JS 代码，如果存在多个 <code>defer script</code> 标签，浏览器（IE9及以下除外）会保证它们按照在 HTML 中出现的顺序执行，不会破坏 JS 脚本之间的依赖关系。</li></ul><p>建议阅读文章：<a href="https://juejin.cn/post/6894629999215640583" title="https://juejin.cn/post/6894629999215640583">图解 script 标签中的 async 和 defer 属性</a></p><h2 id="DOCTYPE-的作用是什么？"><a href="#DOCTYPE-的作用是什么？" class="headerlink" title="DOCTYPE 的作用是什么？"></a>DOCTYPE 的作用是什么？</h2><p><code>&lt;!DOCTYE&gt;</code> 声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以“标准模式”进行文档解析，否则就以“兼容模式”进行解析。</p><ul><li>在<code>标准模式</code>下，浏览器的解析规则都是按照最新的标准进行解析的。</li><li>而在<code>兼容模式</code>下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站能正常访问。</li></ul><h2 id="SGML、HTML、XML-和-XHTML的区别"><a href="#SGML、HTML、XML-和-XHTML的区别" class="headerlink" title="SGML、HTML、XML 和 XHTML的区别"></a>SGML、HTML、XML 和 XHTML的区别</h2><ul><li><code>SGML</code> 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。</li><li><code>HTML</code> 是超文本标记语言，主要是用于规定怎样显示网页。</li><li><code>XML</code> 是可扩展标记语言，是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。</li><li><code>XHTML</code> 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</li></ul><h2 id="HTML5-有哪些新特性、移除了哪些元素？"><a href="#HTML5-有哪些新特性、移除了哪些元素？" class="headerlink" title="HTML5 有哪些新特性、移除了哪些元素？"></a>HTML5 有哪些新特性、移除了哪些元素？</h2><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像、位置、存储、多任务等功能的增加。</p><p>新增的：</p><ul><li>绘图 <code>canvas</code></li><li>用于媒介回放的 <code>video</code> 和 <code>audio</code> 元素</li><li>本地离线存储 <code>localStorage</code> 、<code>sessionStorage</code></li><li>语义化更好的内容元素，如：<code>header</code>、<code>article</code>、<code>nav</code>、<code>section</code>、<code>footer</code>等</li><li>表单控件 <code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code> 等</li><li>新的技术 <code>webworker</code>、<code>websocket</code></li><li>新的文档属性 <code>document.visibilityState</code></li></ul><p>移除的：</p><ul><li>纯表现的元素：<code>basefont</code>、<code>big</code>、<code>center</code>、<code>s</code>、<code>tt</code>、<code>u</code></li><li>对可用性产生负面影响的元素：<code>frame</code>、<code>frameset</code>、<code>noframes</code></li></ul><h2 id="对浏览器内核的理解"><a href="#对浏览器内核的理解" class="headerlink" title="对浏览器内核的理解"></a>对浏览器内核的理解</h2><p>主要分为两部分：渲染引擎和JS引擎。</p><ul><li><code>渲染引擎</code>：其职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 HTML、 XML 文档及图片，它也可以借助一些浏览器扩展插件显示其他类型数据，如：使用PDF阅读器插件可以显示 PDF 格式。</li><li><code>JS引擎</code>：解析和执行 JavaScript 来实现网页的动态效果。</li></ul><p>最开始渲染引擎和JS引擎并没有区分的很明显，后来JS引擎越来越独立，内核就倾向于只指渲染引擎了。</p><h2 id="什么是文档的预解析？"><a href="#什么是文档的预解析？" class="headerlink" title="什么是文档的预解析？"></a>什么是文档的预解析？</h2><p>当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载，从而使整体速度更快。</p><p>需要注意的是，预解析并不改变DOM树，它将这个工作交给主解析过程，自己只解析外部资源的引用，比如：外部脚本、样式及图片。</p><h2 id="浏览器的渲染原理"><a href="#浏览器的渲染原理" class="headerlink" title="浏览器的渲染原理"></a>浏览器的渲染原理</h2><p>简记： 生成DOM树 –&gt; 生成CSS规则树 –&gt; 构建渲染树 –&gt; 布局 –&gt; 绘制</p><ol><li>首先解析收到的文档，根据文档定义构建一颗 <code>DOM 树</code>，DOM 树是由 DOM 元素及属性节点组成的。</li><li>然后对 CSS 进行解析，生成一颗 <code>CSS 规则树</code>。</li><li>根据 DOM 树和 CSS 规则树构建<code>渲染树</code>。渲染树的节点被称为渲染对象，它是一个包含有颜色等属性的矩形。渲染对象和 DOM 元素相对应，但这种关系不是一对一的，不可见的 DOM 元素不会插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行<code>布局</code>（也可以叫做回流）。这一阶段浏览器要做的是计算出各个节点在页面中确切位置和大小。通常这一行为也被称为自动重排。</li><li>布局阶段结束后是<code>绘制</code>阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示到屏幕上。值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎会尽早的将内容呈现到屏幕上，并不会等到所有 HMTL 内容都解析完之后再去构建和布局渲染树，它是解析完一部分内容就显示一部分内容，同时，可能还通过网络下载其余内容。</li></ol><h2 id="什么是回流和重绘？"><a href="#什么是回流和重绘？" class="headerlink" title="什么是回流和重绘？"></a>什么是回流和重绘？</h2><p>1.概念：</p><ul><li><code>回流</code>：当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做回流（也可以叫做重排）。表现为重新生成布局，重新排列元素。</li><li><code>重绘</code>：当一个元素的外观发生改变，重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。</li></ul><p>2.常见引起回流和重绘的属性和方法：</p><p>任何会改变元素几何信息（元素的位置和尺寸大小）的操作都会触发回流。</p><ul><li>添加或删除可见的 DOM 元素</li><li>元素尺寸改变–边距、填充、宽度、高度</li><li>浏览器尺寸改变– resize 事件发生时</li><li>计算 offsetWidth 和 offsetHeight 属性</li><li>设置 style 属性的值</li><li>修改网页默认字体</li></ul><p><strong>回流必定会发生重绘，重绘不一定会引发回流。</strong></p><p><strong>回流所需的成本比重绘高得多</strong></p><p>建议阅读文章：<a href="https://juejin.cn/post/6844903779700047885" title="https://juejin.cn/post/6844903779700047885">你真的了解回流和重绘吗</a></p><h2 id="如何减少回流？"><a href="#如何减少回流？" class="headerlink" title="如何减少回流？"></a>如何减少回流？</h2><ul><li>使用 transform 代替 top</li><li>不要把节点的属性值放在一个循环里，当成循环里的变量</li><li>不要使用 table 布局，可能很小的一个改动会造成整个 table 的重新布局</li><li>把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM</li><li>不要一条一条的修改样式，可以预先定义好 class，然后修改 DOM 的 className</li><li>使用 absolute 或 fixed 使元素脱离文档流</li></ul><h2 id="sessionStorage，localStorage-和-cookie-的区别"><a href="#sessionStorage，localStorage-和-cookie-的区别" class="headerlink" title="sessionStorage，localStorage 和 cookie 的区别"></a>sessionStorage，localStorage 和 cookie 的区别</h2><ol><li>共同点：都是保存在浏览器端，且同源的</li><li>区别:</li></ol><ul><li>cookie 始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器之间来回传递；而 sessionStorage 和 localStorage 不会自动把数据发送到服务器，仅在本地保存。cookie 还有路径（path）的概念，可以限制 cookie 只属于某个路径下。</li><li>存储大小限制不同。cookie 不能超过 4K，因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如：会话标识。sessionStorage 和 localStorage 虽然也有存储大小限制，但比 cookie 大得多，可以达到 5M 或更大。</li><li>数据有效期不同。sessionStorage 仅在当前浏览器窗口关闭之前有效；localStorage 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前有效。</li><li>作用域不同。sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和 cookie 在所有同源窗口中都是共享的。</li></ul><h2 id="iframe-有哪些优缺点？"><a href="#iframe-有哪些优缺点？" class="headerlink" title="iframe 有哪些优缺点？"></a>iframe 有哪些优缺点？</h2><p>优点：</p><ol><li>iframe 能原封不动的把嵌入的网页展现出来。</li><li>如果有多个网页引用 iframe，只需修改 iframe 的内容，就可以实现调用每一个页面的更改，方便快捷。</li></ol><p>缺点：</p><ol><li>iframe 会阻塞主页面的 onload 事件。</li><li>iframe 和主页面共享链接池，而浏览器对相同域的链接有限制，所以会影响页面的并行加载。</li><li>不利于 SEO，代码复杂，无法一下被搜索引擎索引到。</li><li>iframe 框架页面会增加服务器的 http 请求，对于大型网站不可取。</li><li>很多移动设备无法完全显示框架，设备兼容性差。</li></ol><p>注意：通过动态给 iframe 添加 src 属性值，可解决前两个问题。</p><h2 id="什么是-canvas，基本用法是什么？"><a href="#什么是-canvas，基本用法是什么？" class="headerlink" title="什么是 canvas，基本用法是什么？"></a>什么是 canvas，基本用法是什么？</h2><p>canvas 元素是 HTML5 的一部分，允许脚步语言动态渲染位图像。canvas 由一个可控制区域 HTML 代码中的属性定义决定高度和宽度。JavaScript 代码可以访问该区域，通过一套完整的绘图功能类似于其他通用二维的 API，从而生成动态的图形。</p><ol><li>创建 canvas 标签</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;canvas <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;150&quot;</span> <span class="hljs-attribute">height</span>=<span class="hljs-string">&quot;150&quot;</span>&gt;该浏览器不支持canvas&lt;/canvas&gt;<br>复制代码<br></code></pre></td></tr></table></figure><ol start="2"><li>渲染上下文</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);<br><span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);<br>复制代码<br></code></pre></td></tr></table></figure><p>代码第一行通过使用 <code>document.getElementById()</code> 方法获取 <code>&lt;canvas&gt;</code> 元素对应的 DOM 对象，然后可以通过使用它的 <code>getContext()</code> 方法来绘制上下文。 创建 canvas 标签时可以在标签内写上不支持的提示信息；也可以通过 <code>getContext()</code> 方法判读是否支持编程。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);<br><span class="hljs-keyword">if</span> (canvas.getContext) &#123;<br>  <span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);<br>  <span class="hljs-comment">// other code</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 不支持 canvas 的其他代码</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>用途：</p><p>canvas 可用于游戏和图表（echarts.js、heightchart.js 都是基于 canvas 来绘图）制作。</p><ul><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo创建博客</title>
    <link href="/2023/01/22/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/01/22/hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo部署博客的命令"><a href="#hexo部署博客的命令" class="headerlink" title="hexo部署博客的命令"></a>hexo部署博客的命令</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
